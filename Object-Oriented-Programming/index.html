<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>21. 面向对象及特性 - 茶桁.MAMT</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="茶桁.MAMT"><meta name="msapplication-TileImage" content="https://qiniu.hivan.me/picGo/20230601174411.png?imgNote"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="茶桁.MAMT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Hi，大家好。我是茶桁。"><meta property="og:type" content="blog"><meta property="og:title" content="21. 面向对象及特性"><meta property="og:url" content="https://hivan.me/Object-Oriented-Programming/"><meta property="og:site_name" content="茶桁.MAMT"><meta property="og:description" content="Hi，大家好。我是茶桁。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hivan.me/Object-Oriented-Programming/cover.png"><meta property="article:published_time" content="2023-08-16T03:41:18.000Z"><meta property="article:modified_time" content="2023-08-16T18:01:35.602Z"><meta property="article:author" content="Hivan Du"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://hivan.me/Object-Oriented-Programming/cover.png"><meta property="twitter:creator" content="@hivan"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hivan.me/Object-Oriented-Programming/"},"headline":"21. 面向对象及特性","image":["https://hivan.me/Object-Oriented-Programming/cover.png"],"datePublished":"2023-08-16T03:41:18.000Z","dateModified":"2023-08-16T18:01:35.602Z","author":{"@type":"Person","name":"Hivan Du"},"publisher":{"@type":"Organization","name":"茶桁.MAMT","logo":{"@type":"ImageObject","url":"https://hivan.me/img/logo.svg"}},"description":"Hi，大家好。我是茶桁。"}</script><link rel="canonical" href="https://hivan.me/Object-Oriented-Programming/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="茶桁.MAMT" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="茶桁.MAMT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hivandu"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-16T03:41:18.000Z" title="8/16/2023, 11:41:18 AM">2023-08-16</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a><span> / </span><a class="link-muted" href="/categories/AI%E7%A7%98%E7%B1%8D/Python/">Python</a></span></div></div><h1 class="title is-3 is-size-4-mobile">21. 面向对象及特性</h1><div class="content"><img src="/Object-Oriented-Programming/cover.png" class="" title="cover">
<p>Hi，大家好。我是茶桁。</p>
<span id="more"></span>
<p>今天开始，我们要迈向Python的另外一个台阶了，那就是面向对象。</p>
<p>面向对象编程（Object Oriented
Programming)，简称为OOP，是一种<strong>以对象为中心</strong>的程序设计思想。</p>
<p>与之相对的，就是面向过程编程（Procedure Oriented Programming),
简称为POP, 是一种<strong>以过程为中心</strong>的程序设计思想。</p>
<h2 id="面向对象和面向过程">面向对象和面向过程</h2>
<p>接下来，让我们先了解一下这两个编程思想到底有什么不同。还记得咱们之前讲过宋丹丹老师小品里的经典的「把大象装进冰箱分几步」吗？小品给出的答案是三步对吧？</p>
<ol type="1">
<li>第一步：打开冰箱门</li>
<li>第二步：把大象装进去</li>
<li>第三步：关上冰箱门</li>
</ol>
<h3 id="设计思想的不同">设计思想的不同</h3>
<p>那么这个答案，就是一种面向过程的思维，遇到问题之后，分析解决问题的步骤，然后一步步的去实现。</p>
<p>那么如果是面向对象的话，又该如何去做？</p>
<p>面向对象是通过分析问题中需要的抽象模型，然后根据需要的功能分别去创建模型对象，最终由模型对象来完成程序。那这个「把大象装进冰箱分几步」的问题我们该如何去考虑呢？</p>
<p>首先，面向对象要解决这个问题，需要先建立出抽象模型，比如：</p>
<ul>
<li>打开冰箱门和关闭冰箱门，这都属于一个冰箱的功能，</li>
<li>大象走进去，这就是大象的功能。</li>
<li>到此时我们就出现了<strong>两个抽象模型，一个是冰箱，一个是大象</strong>。</li>
</ul>
<p>冰箱具有 打开和关闭的功能，大象具有走路的能力。</p>
<p>分析到这里，就是面向对象的思想，具体完成的话，就是去创建冰箱和大象这两个对象，最终完成这个程序</p>
<p>冰箱对象-开门，大象对象-走进冰箱，冰箱对象-关门</p>
<p>这个问题解决了，我们再来思考一个新的问题：「想吃清蒸鱼怎么办？」</p>
<p>当然是按照做菜的顺序一步一步来对吧？<strong>这就是典型的面向过程思维：</strong></p>
<ol type="1">
<li>买鱼，买料</li>
<li>杀鱼和清理，并且腌制</li>
<li>锅里烧水</li>
<li>把鱼放进去，开始蒸鱼。</li>
<li>十分钟后开盖，把鱼端出来，然后浇汁。</li>
</ol>
<p>这样，一步一步的完成这个愿望，就是面向过程所作的事情。</p>
<p><strong>轮到面向对象，又该如何呢？</strong></p>
<ul>
<li>需要一个对象：大厨。</li>
<li>告诉大厨，我想吃清蒸鱼。</li>
</ul>
<p>那么大厨呢，有可能是我们自己训练的，也有可能是其他五星酒店挖过来的。不管如何，这是一个已经完善建立好的对象，我们直接拿来用就可以了。面向对象呢，就是这样寻找具体的对象去解决问题。对于我们来说，调用了对象，而对象完成了这个过程。</p>
<p>当然，具体大厨这个对象里肯定还是一步一步的去完成过程，也就是说，最终面向对象中是由面向过程的体现的。但是思维方式，也就是设计思想是完全不同的。</p>
<h3 id="优缺点">优缺点</h3>
<p>既然有不同之处，那必然是有优缺点的。因为有对比嘛。面向过程有其优点，当然，面向对象也有其缺点。</p>
<p>面向过程的核心是过程，过程就是指几觉问题的步骤。其优缺点非常明显：</p>
<ul>
<li>优点： 将负责的问题流程化，进而实现简答。</li>
<li>缺点： 扩展性差（更新、维护、迭代）</li>
</ul>
<p>而面向对象的核心是对象，是一个特征和功能的综合体，其优缺点如下：</p>
<ul>
<li>优点：可扩展性高</li>
<li>缺点：编程复杂度相对面向过程高一些，这里的复杂度指的是计算机在执行面向对象的程序时性能表现一般。</li>
</ul>
<p>那总结起来呢，在去完成一些简单的程序时，可以使用面向过程去解决。但是如果有复杂的程序或任务，而且需要不断的进行迭代和维护，那么肯定是优先选择面向对象的编程思想</p>
<h3 id="如何学习面向对象编程">如何学习面向对象编程</h3>
<p>那我们后面<strong>如何去学习面向对象编程</strong>呢？其实就两步：</p>
<ol type="1">
<li>学习面向对象编程的思想</li>
<li>学习面向对象编程的语法</li>
</ol>
<p>这两步中，其实难的是第一步，学习面向对象编程的思想。</p>
<p>不管如何，什么事情都需要有个开头，那我们就从类和对象的基本概念开始好了。</p>
<h3 id="认识类与对象">认识类与对象</h3>
<p>类： 类是对象的一个抽象的概念</p>
<p>对象（实例）：对象就是由类创建的实例</p>
<p>那么这两者的关系其实就是「模具和铸件」之间的关系。</p>
<ol type="1">
<li>类是由对象总结而来的，总结的这个过程叫做抽象。</li>
<li>对象是由类具体实施出来的，这个过程叫做实例化。</li>
</ol>
<p>是不是听着有些迷糊了？这里我们还是用实际例子来解释一下的好，我们思考下面的问题：</p>
<ul>
<li>水果是一个对象还是一个类？</li>
<li>汽车是一个对象还是一个类？</li>
<li>手机是一个对象还是一个类？</li>
</ul>
<p>我们在说水果的时候，你能想到什么？香蕉、苹果、西瓜、榴莲等等。对吧？那我们想了这么多不一样的东西，是不是这些所有的都称为是「水果」？那么我们将这些内容都叫做水果的过程就称为「归类」的过程。这个「水果」就是一个类，刚才我们总结的这个过程就叫做抽象，我们想到的香蕉、苹果...等等，就是对象。</p>
<p>汽车其实是一个概念，你能想到什么？奔驰、野马、奥迪、别摸我？那我们见过的车，就会在我们脑海中浮现，而这些具体的车总结出来一个类的过程就是「抽象的过程」，我们最后总结出来的「汽车」就是一个类。那些在我们脑海里浮现的具体的汽车，就是对象。</p>
<p>单我们去开车上班的时候，那么我们就是应用一个具体的对象去发生特定的功能。</p>
<p>再来想一个问题，我现在给大家写这个教程，用的是Macbook
Pro，那么请问我当前正在使用的这个MBP是对象还是一个类？</p>
<p>MBP的特征：金属外壳，优美的外观。</p>
<p>MBP的功能：给大家写教程，编辑代码，听音乐，作曲，画画....</p>
<p>当我描述了这么多之后，这个MBP到底是一个类还是一个对象？</p>
<h2 id="面向对象的基本实现">面向对象的基本实现</h2>
<p>如果我们需要实例一个对象，那么我们就需要先抽象一个类。</p>
<p>举了栗子：</p>
<p>我们现在需要创建一个汽车，或者千千万万个汽车用于销售。那在这之前我们要做什么？</p>
<p>首先，我们需要抽象一个汽车类，也就是我们要在一个设计图纸上设计处这个汽车。</p>
<p>然后，我们由这个设计图纸去创建（实例）出来的真实汽车就是一个对象。</p>
<p>那么接下来，就让我们具体到代码里去实现看看。</p>
<p>还记得我们之前介绍的怎么去创建一个类嘛？有没有小伙伴还记得？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个汽车的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cart</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>没错，就是使用<code>class</code>关键字来定义一个类。其书写规范如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">类名的书写规范，建议使用驼峰命名法</span><br><span class="hljs-string">    大驼峰：MyCar ChaHeng</span><br><span class="hljs-string">    小驼峰：myCar chaHeng</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>那么我们在类里需要声明些什么内容呢？一个类需要有「特征」和「功能」两个内容组成：</p>
<ul>
<li><p>特征就是一个描述：颜色：黑色， 品牌：野马，排量：2.4...；
特征在编程中就是<strong>一个变量</strong>，在类中称为属性</p></li>
<li><p>功能就是某一项能力： 拉货，代步，上班....；
功能在编程中就是<strong>一个函数</strong>，在类中称为方法</p></li>
</ul>
<p>在类中，属性一般定义在前面，方法定义在后面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个汽车的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>():<br>    <span class="hljs-comment"># 属性 =&gt; 特征 =&gt; 变量</span><br>    color = <span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-comment"># 表示颜色属性</span><br>    brand = <span class="hljs-string">&#x27;mustang&#x27;</span> <span class="hljs-comment">#表示品牌属性</span><br>    displacement = <span class="hljs-number">2.4</span> <span class="hljs-comment"># 表示排量属性</span><br><br>    <span class="hljs-comment"># 方法 =&gt; 功能 =&gt; 函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pulling</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能拉货。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rode</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能代步。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">onDuty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能上班。&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>现在，我们拥有了一个具体的类，里面包含了特征和功能。那么我们如何通过类实例化对象并最终使用它们呢？</p>
<p>很简单，将其赋值给一个具体的变量就可以了，比如，我们现在去4S店实际购买一个野马汽车：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化一个对象</span><br>buyNewCar = Car()<br></code></pre></td></tr></table></figure>
<p>这样，就简单的实例化了一个购买的新车，让我们查看一下它的类别和各项属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(buyNewCar, <span class="hljs-built_in">type</span>(buyNewCar))<br><br><span class="hljs-comment"># 查看对象的品牌</span><br><span class="hljs-built_in">print</span>(buyNewCar.brand)<br><br><span class="hljs-comment"># 调用对象的方法</span><br>buyNewCar.rode()<br><br>---<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105e6fbb0</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Car&#x27;</span>&gt;<br>mustang<br>小汽车能代步。。<br></code></pre></td></tr></table></figure>
<p>这样，我们就能看到这个对象是由类<code>Car</code>实例化得来的。并且查看到了品牌属性，试用了一下其“代步”这个功能。</p>
<h3 id="成员属性和方法的操作">成员属性和方法的操作</h3>
<p>一个对象通过实例化之后，在类中定义的属性和方法，可以使用实例化的对象进行操作。</p>
<p>类中定义的属性也称为成员属性，类中定义的方法，也称为成员方法。</p>
<p>我们直接拿之前定义的类来实例化两个对象观察一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = Car()<br>b = Car()<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><br>---<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105d37190</span>&gt;<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105d36fe0</span>&gt;<br></code></pre></td></tr></table></figure>
<p>我们来看，<code>a,b</code>分别实例化之后，我们将其打印出来。看到两个对象都是通过<code>Car</code>来实例化的，但是后面不同。就是说，这两者在实例化之后，完全就是两个不同的对象。那我们可以这么说，<strong>一个类可以实例化处多个对象。</strong></p>
<h4 id="对象的成员操作">对象的成员操作</h4>
<p>在类的外部，使用对象操作成员，比如，我们可以通过对象访问类中的属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = a.color<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>black<br></code></pre></td></tr></table></figure>
<p>还可以通过对象访问类中的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.rode()<br><br>---<br>小汽车能代步。<br></code></pre></td></tr></table></figure>
<p>那除了访问，我们是否可以对其进行修改呢？来看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a.color = <span class="hljs-string">&#x27;red&#x27;</span><br>res = a.color<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>red<br></code></pre></td></tr></table></figure>
<p>可以看到，我们修改了对象的属性。那么，这个时候我们另外一个实例化对象<code>b</code>里是什么情况？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(b.color)<br><br>---<br>black<br></code></pre></td></tr></table></figure>
<p>依然还是<code>black</code>，并未收到<code>a</code>内属性变化的影响。</p>
<p>也就是说，我们操作单个对象进行属性修改，并不影响最初的类，也不会影响同一个类实例化出来的其他对象。</p>
<p>我们还可以给对象添加本来没有的属性来丰富这个对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a.name = <span class="hljs-string">&#x27;AE86&#x27;</span><br><span class="hljs-built_in">print</span>(a.name)<br><br>---<br>AE86<br></code></pre></td></tr></table></figure>
<p>同样的，我们对单个对象进行的操作，一样不会影响原本的类以及其他实例化对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(b.name)<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>
<p>不出所料的报错了，错误类型为属性错误。告知我们并没有<code>name</code>这个属性。</p>
<p>好，再让我们来看看删除这个动作。我们就直接删除<code>a</code>对象刚创建的<code>name</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.name)<br><span class="hljs-keyword">del</span> a.name<br><span class="hljs-built_in">print</span>(a.name)<br><br>---<br>AE86<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure>
<p>程序显示打印了一次<code>name</code>的值，说明我们能正常获取，然后删除<code>a</code>对象中的这个属性，然后再打印来看，警告我们<code>AttributeError</code>类型错误。说明，这个时候的<code>name</code>已经不存在了。</p>
<p>好，让我们删除<code>a</code>继承下来的属性<code>brand</code>,不过这次为了让后续程序还能正常运行，我们使用<code>try</code>来捕获一下错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">del</span> a.brand<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AttributeError:&#x27;</span>, e)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a.brand: &#x27;</span>, a.brand)<br><br>---<br>AttributeError: brand<br>a.brand:  mustang<br></code></pre></td></tr></table></figure>
<p>可以看到，我们在执行删除<code>a.brand</code>的时候报错了，后面打印的结果也证明了<code>a.brand</code>这个属性还存在，可以被打印出来。</p>
<p>那么问题来了，为什么之前的<code>a.name</code>可以被删除，而<code>a.brand</code>不行？这两个属性到底有什么区别？</p>
<p>其实，单我们执行删除一个对象的属性时，只能删除当前这个对象自己的属性才可以。而我们执行的操作中，<code>brand</code>并不是<code>a</code>自己的属性，而是属于<code>Car</code>这个类的。因为无法进行删除。</p>
<p><code>a.name</code>则不一样，是单独在<code>a</code>对象内创建的属性，因此可以删除。</p>
<p>访问成员属性，会先访问对象自己的属性，如果没有，则去访问这个对象的类的属性。</p>
<p>修改对象的属性值时，实际上等于给这个对象创建了一个对象自己的属性。</p>
<p>添加对象的属性，是给对象创建了自己独有的属性。</p>
<p>删除属性，只能删除这个对象自己的属性，包括给对象添加的和修改的。</p>
<p>接着，我们来看看在类的外部，操作对象的方法。</p>
<p>访问对象的方法：实际上如果这个对象没有自己独立的方法，那么会访问这个对象的类的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.rode()<br><br>---<br>小汽车能代步<br></code></pre></td></tr></table></figure>
<p>我们来进行修改对象的方法：给这个对象的方法重新定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是重新定义的一个方法&#x27;</span>)<br><br>a.rode = func<br>a.rode()<br><br>---<br>这里是重新定义的一个方法<br></code></pre></td></tr></table></figure>
<p>这样，我们就完成了方法的重新定义。</p>
<p>访问、修改之后，我们能不能给对象添加新的方法呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a.func2 = func<br>a.func2()<br><br>---<br>这里是重新定义的一个方法<br></code></pre></td></tr></table></figure>
<p>看来也是可以的，我们现在给这个对象自己新创建了一个方法。</p>
<p>来，删除一下方法试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> a.func2<br></code></pre></td></tr></table></figure>
<p>并未报错，我们继续执行下试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.func2()<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;func2&#x27;</span><br></code></pre></td></tr></table></figure>
<p>看报错，说明我们删除成功了。</p>
<p>方法实际上和属性一样，我们可以删除对象自己的方法，但是无法删除对象的类的方法。</p>
<p>至此，我们可以总结如下：</p>
<p>一个类定义类成员属性和成员方法，那么通过这个类实例化的对象，也具备了这些方法和属性。</p>
<p>实际上，创建对象的时候，并不会把类中的属性的属性和方法复制一份给对象，而是在对象中应用父类的方法。因此在访问对象的属性时，会先去找对象自己的属性，如果没有就去找这个类的属性和方法。</p>
<p>一个对象由类创建以后，是一个独立的对象，会应用父类中的属性和方法。如果在对象创建后，给对象的属性或方法，进行修改或添加，那么此时等于给这个对象创建了一个自己的属性和方法。所以在删除时，只能删除对象呗修改或添加的成员。</p>
<p>除了在类的实例化对象中对类的成员进行操作之外，我们还可以直接在类上进行操作。比如，我们可以执行下列操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Car.brand = <span class="hljs-string">&#x27;BMW&#x27;</span><br></code></pre></td></tr></table></figure>
<p>那现在提一个问题，在原始类的成员修改之后，这个类创建的实例化对象会如何？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.brand) <span class="hljs-comment"># 先执行一次打印，原始属性</span><br>Car.brand = <span class="hljs-string">&#x27;BMW&#x27;</span><br>b = Car() <span class="hljs-comment"># 新创建一个实例化对象</span><br><span class="hljs-built_in">print</span>(b.brand) <span class="hljs-comment"># 打印新创建的对象的属性</span><br><span class="hljs-built_in">print</span>(a.brand) <span class="hljs-comment"># 打印修改之前创建的对象的属性</span><br><br>---<br>mustang<br>BMW<br>BMW<br></code></pre></td></tr></table></figure>
<p>很明显，我们直接在类上进行操作修改成员之后，不管是hi新创建的实例化对象，还是早已存在的实例化对象，其中的成员属性都被修改了。删除和新加都遵循着这样一个特性。</p>
<p>对成员属性和方法的操作，我们也就可以总结成两种，一是「对象操作成员」，
一种是「类操作成员」。当然，由于类修改后会影响具体的实例化对象，所以并不推荐这么去做。</p>
<h4 id="对象操作成员">对象操作成员</h4>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">成员属性：<br>  访问：  对象.成员属性名<br>  修改：  对象.成员属性名法 <span class="hljs-operator">=</span> 新值。（此时等于给这个对象创建了一个自己的属性）<br>  添加：  对象.新成员属性 <span class="hljs-operator">=</span> 值 (此时是给这个对象自己新建了一个属性)<br>  删除：  del 对象.成员属性 (注意：只能删除这个对象自己的属性)<br>  <br>成员方法：<br>  访问：  对象.成员方法名()<br>  修改：  对象.成员方法名 <span class="hljs-operator">=</span> func（此时等于给这个对象创建了一个自己的方法）<br>  添加：  对象.方法名 <span class="hljs-operator">=</span> func (此时是给这个对象自己新建了一个方法)<br>  删除：  del 对象.方法名 (注意：只能删除这个对象自己的方法)<br></code></pre></td></tr></table></figure>
<h4 id="类操作成员不推荐">类操作成员（不推荐）</h4>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">成员属性：<br>  访问：  类名.成员属性名<br>  修改：  类名.成员属性名法 <span class="hljs-operator">=</span> 新值。（此时通过这个类创建的对象都具有这个属性）<br>  添加：  类名.新成员属性 <span class="hljs-operator">=</span> 值 (此时通过这个类创建的对象都具有这个属性)<br>  删除：  del 类名.成员属性 (注意：删除这个类的属性后，这个类创建的对象也没有这几个属性了)<br>  <br>成员方法：<br>  访问：  类名.成员方法名()<br>  修改：  类名.成员方法名 <span class="hljs-operator">=</span> func（此时通过类创建的对象都被修改）<br>  添加：  类名.方法名 <span class="hljs-operator">=</span> func (此时通过类创建的对象都被修改)<br>  删除：  del 类名.方法名 (注意：此时通过类创建的对象都被修改)<br></code></pre></td></tr></table></figure>
<p><strong>最终总结一下如下：</strong></p>
<ul>
<li>一个类可以实例化出多个对象，每个对象在内存中都独立存在的</li>
<li>当通过类实例化对象时，并不会把类中的成员复制一份给对象，而去给对象了一个引用</li>
<li>访问对象成员的时候，如果对象自己没有这个成员，对象会向实例化它的类去查找</li>
<li>对象成员的添加和修改，都只会影响当前对象自己，不会影响类和其它对象</li>
<li>删除对象的成员时，必须是该对象自己具备的成员才可以，不能删除类中引用的成员</li>
<li>对类的成员操作，会影响通过这个类创建的对象，包括之前创建的。</li>
</ul>
<h3 id="成员方法中的self">成员方法中的<code>self</code></h3>
<p><code>self</code>在方法中只是一个形参，并不是关键字。从它本身的意义上来说，是可以用其他的关键字去替换的，但是长久以来的惯例大家都一直在使用<code>self</code>。</p>
<p>其作为英文单词的本意是：自己。那么在类的方法中则代表的是「当前这个对象」。不太明白？让我们来看一个实际的例子：</p>
<p>让我们先定义一个「Person」类，然后实例化一个「张三」：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    sex = <span class="hljs-string">&#x27;sex&#x27;</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会唱歌&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会跳舞&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rap</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会饶舌&#x27;</span>)<br><br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>name<br></code></pre></td></tr></table></figure>
<p>成功打印出了<code>name</code>， 说明我们成功实例化了。</p>
<p>通过实例化的对象，我们可以在类的外部去访问成员属性和成员方法。（对象.成员）。</p>
<p>同样的，我们其实也可以在类的内部去访问成员属性和成员方法。让我们做一个实验，来说明一下<code>self</code>到底是什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    ...<br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-comment"># print(zs.name)</span><br><span class="hljs-built_in">print</span>(zs)<br>zs.func()<br><br>---<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a048c10</span>&gt;<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a048c10</span>&gt;<br></code></pre></td></tr></table></figure>
<p>我们修改了这个类，在内部创建了一个方法<code>func(self)</code>，
然后打印了<code>self</code>这个参数。</p>
<p>然后我们在外面打印了实例化的<code>zs</code>，还通过这个具体的实例化对象执行了类内部的<code>func</code>方法。实际上就是打印了一下此刻的<code>self</code>。可以看到，两个打印结果完全一样，那说明，这两者本身就是一个东西。</p>
<p><code>self</code>代表调用这个方法的对象，谁调用了这个方法，<code>self</code>就代表的是谁。<code>self</code>就可以在类的内部代替对象进行各种操作。</p>
<p>我们通过<code>self</code>来进行的操作，其实完全就是实例化的对象所作的操作。我们在类中修改<code>func</code>这个方法，让其打印<code>name</code>，
修改<code>name</code>， 调用方法<code>rap</code>来试试看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    ...<br><br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(self.name)<br>        self.name = <span class="hljs-string">&#x27;茶桁&#x27;</span><br>        <span class="hljs-built_in">print</span>(self.name)<br>        self.rap()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br>zs.name = <span class="hljs-string">&quot;张三&quot;</span><br>zs.func() <br><br>---<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a06bf40</span>&gt;<br>张三<br>茶桁<br>会饶舌<br></code></pre></td></tr></table></figure>
<p>我们就可以很清晰的看到<code>self</code>代表的含义，谁调用，<code>self</code>就代表谁。也就是说，只要是对象能干的事情，<code>self</code>就可以代表对象去完成，比如成员的添加、删除、更新、访问、调用等等。</p>
<p>我们再来修改一下类里的方法，让其更清晰的显示这个特性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    ...<br><br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rap</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;self.name&#125;</span>, 我会饶舌&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>       ...<br>        self.rap()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br>zs.name = <span class="hljs-string">&quot;张三&quot;</span><br>zs.func() <br><br>---<br>我是张三, 我会饶舌<br></code></pre></td></tr></table></figure>
<p>在类中，我们修改了一下<code>rap</code>方法，让其调用<code>self.name</code>，
在类被定义的时候，这个类中的<code>name</code>是被赋值为<code>name</code>的。然后，我们在<code>func</code>方法中调用了一下<code>self.rap()</code>,
我们对其进行实例化一个对象<code>zs</code>，并且在这个实例中对<code>name</code>进行了重新赋值<code>张三</code>,
接着，调用了实例化对象中的<code>func()</code>方法。</p>
<p>我们清晰的看到，<code>func()</code>调用了<code>self.rap()</code>，然后将<code>张三</code>打印在了屏幕上。充分说明了，这个时候的<code>self</code>代表的就是调用它的<code>zs</code>这个实例化对象。</p>
<p>我们直接调用类中的方法试试看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Person.func()<br><br>---<br>TypeError: Person.func() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">&#x27;self&#x27;</span><br></code></pre></td></tr></table></figure>
<p>我们收到了报错，被告知缺少必须的位置参数<code>self</code>。</p>
<p>好，那让我们再来做两个实验，第一个实验中，我们测试一下如果在类中的方法没有使用<code>self</code>接受参数会怎样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个没有`self`的方法。&#x27;</span>)<br><br>Person.func()<br><br>a = Person()<br>a.func()<br><br>---<br>我是一个没有`self`的方法。<br>TypeError: Person.func() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure>
<p>可以看到，我们可以使用类直接调用这个方法有效，但是我们创建一个实例化对象之后，利用实例化对象去调用则会报错。这个是因为，我们在用实例化对象去调用类中的方法的时候会传入一个参数。但是现在类中的<code>func()</code>方法并没有可以接受的参数，那么必定会报错。</p>
<p>第二个实验，我们试试不用<code>self</code>，而是其他的参数是否可以成功：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"><span class="hljs-built_in">vars</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;<span class="hljs-built_in">vars</span>.name&#125;</span>, 我使用了vars来接受参数。&#x27;</span>)<br><br>a = Person()<br>a.name = <span class="hljs-string">&#x27;admin&#x27;</span><br>a.func()<br><br>---<br>我是admin, 我使用了<span class="hljs-built_in">vars</span>来接受参数。<br></code></pre></td></tr></table></figure>
<p>可以看到，完全没有问题。也就是说，用实例化对象调用类中的方法时，是一定会将自己作为一个参数传给这个方法，需要一个具体的参数去接受。而参数的名称是什么则无所谓，只是大家在习惯上都是用<code>self</code>。区别如下：</p>
<ul>
<li>含有<code>self</code>或者可以接受对象作为参数的方法：
非绑定类方法</li>
<li>不含<code>self</code>或者不能接受对象作为参数的方法：绑定类方法</li>
</ul>
<p>非绑定类方法，可以使用对象去访问, 绑定类方法，只能通过类去访问。</p>
<h3 id="魔术方法">魔术方法</h3>
<p>魔术方法是什么呢？</p>
<p>魔术方法也和普通方法一样都是类中定义的成员方法。这是一种不需要去手动调用的，在某种情况下，自动触发（自动执行）的方法。魔术方法特殊就特殊在定义的时候，多数的魔术方法
前后都有两个连续的下划线。但是切记，这个方法并不是我们自己定义的，而是系统定义好的，我们来使用而已。</p>
<h4 id="init__-初始化方法"><code>__init__</code> 初始化方法</h4>
<p>这个初始化方法是在通过类实例化对象之后，自动触发的一个方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个初始化方法。&#x27;</span>)<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大家好，我是茶桁。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><br>---<br>我是一个初始化方法。<br></code></pre></td></tr></table></figure>
<p>注意到了么？我们仅仅是实例化的对象而已，并没有进行任何调用，初始化方法就执行了一遍。那么，我们可以得到下面这些内容：</p>
<ul>
<li><code>__init__</code> 触发机制：
在通过类实例化对象后，自动触发的一个方法</li>
<li>作用：可以在对象实例化之后完成对象的初始化（属性的复制，方法的调用）。</li>
<li>应用场景：文件的打开，数据的获取。 干活之前，做好一些准备工作。</li>
</ul>
<p>以下，我们改造一下这个类，然后再实例化的时候多做一些动作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个初始化方法。&#x27;</span>)<br>        <span class="hljs-comment"># 完成对象属性的初始化赋值</span><br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大家好，我是茶桁。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">41</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我叫<span class="hljs-subst">&#123;zs.name&#125;</span>, 我今年<span class="hljs-subst">&#123;zs.age&#125;</span>岁，性别:<span class="hljs-subst">&#123;zs.sex&#125;</span>&#x27;</span>)<br><br>---<br>我是一个初始化方法。<br>我叫张三, 我今年<span class="hljs-number">41</span>岁，性别:male<br></code></pre></td></tr></table></figure>
<p>当然，我们还可以再初始化方法中调用<code>say</code>方法，完成自我介绍：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>  ...<br>  self.say()<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;打击好，我是<span class="hljs-subst">&#123;self.name&#125;</span>。&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h4 id="del__-析构方法"><code>__del__</code>： 析构方法</h4>
<p>和初始化方法一样，我们直接来解析一下这个方法的触发机制，作用以及注意点。</p>
<ul>
<li>触发机制： 析构方法方法会在对象被销毁时自动触发。</li>
<li>作用：关闭一些开发的资源</li>
<li>注意：对象被销毁时触发了析构方法，而不是析构方法销毁了对象。</li>
</ul>
<p>我们还是从代码里来观察这个方法。</p>
<p>我们来定义一个类，完成一个日志的记录，调用这个对象的时候，传递一个日志信息。这个对象会创建一个文件，开始写入，并在最后关闭这个文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">writeLog</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    <span class="hljs-comment"># 文件的路径</span><br>    fileurl = <span class="hljs-string">&#x27;./data&#x27;</span><br>    <span class="hljs-comment"># 日志文件的名称</span><br>    filename = <span class="hljs-built_in">str</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>))+<span class="hljs-string">&#x27;.log&#x27;</span><br>    <span class="hljs-comment"># 初始化 打开文件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 完成文件的打开</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;初始化方法触发类，完成文件的打开&#x27;</span>)<br>        self.fileobj = <span class="hljs-built_in">open</span>(self.fileurl+self.filename, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-comment"># 写日志的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self,s</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;把日志<span class="hljs-subst">&#123;s&#125;</span>写入到文件中&#x27;</span>)<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;析构方法触发了，关闭打开的文件&#x27;</span>)<br>        <span class="hljs-comment"># 在对象被销毁时，关闭在初始化方法中打开的文件对象</span><br>        self.fileobj.close()<br><br>l = writeLog()<br>l.log(<span class="hljs-string">&#x27;today is good day.&#x27;</span>)<br><span class="hljs-keyword">del</span> l<br><br>---<br>初始化方法触发类，完成文件的打开<br>把日志today <span class="hljs-keyword">is</span> good day.写入到文件中<br>析构方法触发了，关闭打开的文件<br></code></pre></td></tr></table></figure>
<p>这段代码中，我们实例化了<code>writeLog()</code>类，调用了初始化方法。在方法中我们打开了文件，因为我用的是变量创建，所以不一定是什么文件。当前我操作的文件为<code>2023-08-16.log</code>。</p>
<p>然后我们调用<code>l.log()</code>，
也就是实例化对象中的<code>log</code>方法来对该文件写入一段日志内容：<code>today is good day.</code>，
在执行之后，我们又使用了<code>del l</code>来销毁这个实例。在销毁实例的时候，就会调用<code>__del__</code>方法来执行其中的方法。</p>
<p>那么对象会在什么情况下被销毁呢？</p>
<ol type="1">
<li>当程序执行完毕，内存中所有的资源都会被销毁释放</li>
<li>使用 del 删除时</li>
<li>对象没有被引用时，会自动销毁</li>
</ol>
<h2 id="面向对象的三大特性">面向对象的三大特性</h2>
<p>面向对象有三大特性，分别是「封装、继承、多态」，
那么它们具体都是什么呢？下面让我们分别来解释。</p>
<h3 id="封装">封装</h3>
<p>封装，就是使用特殊的语法，对成员属性和成员方法进行包装，达到保护和隐藏的目的。就像我们送礼的时候，会找东西把礼物包起来一样。</p>
<p>但是一定注意，不能把成员全部封装死，就失去意义了。就好比我们买的笔记本电脑，无论如何都会给你留下一些接口的，比如说电源接口，USB接口等等。只有有了这些接口，我们才能插上鼠标啊，移动硬盘等等来进行使用。</p>
<p>被封装的成员主要是供类的内部使用。被特殊语法封装的成员，会有不同的访问的权限。比如笔记本内的硬盘，内存等等，这些并不是不让你使用，而是提供给笔记本本身使用，我们可以操作笔记本电脑来达到间接使用它们的目的。</p>
<p>封装分为了几个不同的级别，一般情况下有三种：</p>
<p>公有的 public</p>
<p>受保护的 protected</p>
<p>私有的 private</p>
<p>被特殊语法封装的成员，会有不同的访问权限。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;talk about life.&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kiss</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;come on...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><br><span class="hljs-comment"># 查看对象的所有成员</span><br><br><span class="hljs-built_in">print</span>(Person.__dict__) <span class="hljs-comment"># 获取当前类的所有成员信息</span><br><span class="hljs-built_in">print</span>(zs.__dict__) <span class="hljs-comment"># 获取当前对象的所有成员信息</span><br><br><span class="hljs-comment"># 我们也可以直接访问对象所有的方法</span><br><span class="hljs-built_in">print</span>(zs.name)<br>zs.kiss()<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Person.__init__ at <span class="hljs-number">0x111a355a0</span>&gt;, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Person.say at <span class="hljs-number">0x111a35750</span>&gt;, <span class="hljs-string">&#x27;sing&#x27;</span>: &lt;function Person.sing at <span class="hljs-number">0x111a357e0</span>&gt;, <span class="hljs-string">&#x27;kiss&#x27;</span>: &lt;function Person.kiss at <span class="hljs-number">0x111a35870</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>张三<br>come on...<br></code></pre></td></tr></table></figure>
<p>在整段代码中，我们实例化对象的时候，基本可以访问<code>Person</code>类中所有的成员。我们说定义的属性和方法，都可以无障碍访问。那么，我们现在说定义的这些成员，就都是<code>Public</code>级别。</p>
<p>现在想象一个场景，我们走在美国街头上，遇到一个美女，然后我们上前询问人家的年龄，大多数时候我们得不到想要的答案。而如果我们上去询问性别（现在知道为什么我要设定为美国街头了吧？），我估计这个就是保密的了吧，有可能一种情况就是当事人在当时的情况下，自己都不知道自己是什么性别。</p>
<p>那这个时候，我们就需要改写一下这段代码了,
改写之前，我们需要理解一下<code>Python</code>中不同级别成员的定义方式，分别为：</p>
<ul>
<li><code>str</code> =&gt; 公共的</li>
<li><code>_str</code> =&gt;
受保护的（约定俗成，在Python中没有具体实现）</li>
<li><code>__str</code> =&gt; 私有的。</li>
</ul>
<p>在了解了定义方法之后，我们可以着手来做实验了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-literal">None</span><br>    _age = <span class="hljs-literal">None</span> <span class="hljs-comment"># 这是一个protected 成员属性</span><br>    __sex = <span class="hljs-literal">None</span> <span class="hljs-comment"># 这是一个 private 成员属性</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self._age = age<br>        self.__sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;talk about life.&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sing</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 这是一个protected 成员方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__kiss</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 这是一个private 成员方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;come on...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><br><span class="hljs-comment"># 查看对象的所有成员</span><br><br><span class="hljs-built_in">print</span>(Person.__dict__) <span class="hljs-comment"># 获取当前类的所有成员信息</span><br><span class="hljs-built_in">print</span>(zs.__dict__) <span class="hljs-comment"># 获取当前对象的所有成员信息</span><br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_age&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_Person__sex&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Person.__init__ at <span class="hljs-number">0x111f99630</span>&gt;, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Person.say at <span class="hljs-number">0x111f996c0</span>&gt;, <span class="hljs-string">&#x27;sing&#x27;</span>: &lt;function Person.sing at <span class="hljs-number">0x111f99870</span>&gt;, <span class="hljs-string">&#x27;kiss&#x27;</span>: &lt;function Person.kiss at <span class="hljs-number">0x111f99c60</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>: <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;_Person__sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，我们调用实例化方法得到的结果已经和之前有所不同了。最终拿到的<code>__sex</code>成员属性是属于类的。</p>
<p>现在让我们逐一来调用一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(zs._age)<br><span class="hljs-built_in">print</span>(zs.__sex)<br><br>---<br><span class="hljs-number">49</span><br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__sex&#x27;</span><br></code></pre></td></tr></table></figure>
<p>可以看到，<code>_age</code>作为受保护的成员属性可以调用，但是<code>__sex</code>作为私有成员属性则不允许。</p>
<blockquote>
<p>实际上，受保护的成员属性也是不能调用的，但是Python中因为没有具体实现，所以唯独在Python中可以调用。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">zs._sing()<br>zs.__kiss()<br><br>---<br>sing a song.<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__kiss&#x27;</span><br></code></pre></td></tr></table></figure>
<p>那么，作为受保护的成员方法<code>_sing</code>被正常调用了，但是室友的成员方法<code>__kiss</code>调用的时候报错。看来和成员属性是一致的。</p>
<p>那么我们现在就可以总结如下：</p>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 21%" />
<col style="width: 40%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>公有的(Public)</th>
<th>受保护的(Protected)</th>
<th>私有的(Private)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>在类的内部</td>
<td>可以访问</td>
<td>可以访问</td>
<td>可以访问</td>
</tr>
<tr class="even">
<td>在类的外部</td>
<td>可以访问</td>
<td>不可以访问（Python中可以）</td>
<td>不可以访问</td>
</tr>
</tbody>
</table>
<p>在实现上我们总结如下：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 2%" />
<col style="width: 23%" />
<col style="width: 37%" />
<col style="width: 37%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>公有的(Public)</th>
<th>受保护的(Protected)</th>
<th>私有的(Private)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定义</td>
<td>默认定义的成员都属于公有成员</td>
<td>在成员名称前面加一个下划线 <code>_成员名称</code></td>
<td>在成员名称前面加两个下划线 <code>__成员名称</code></td>
</tr>
<tr class="even">
<td>特征</td>
<td>公有的成员可以在任何位置进行访问和操作</td>
<td>受保护的成员和公有成员一样可以在任何位置进行访问，但是一般不要随便访问和操作受保护成员</td>
<td>私有的成员只能在当前类的内部去访问和操作，不能在类的外部进行操作</td>
</tr>
</tbody>
</table>
<p><strong>⚠️ 这里我们需要注意Python特殊的亮点：</strong></p>
<ol type="1">
<li>在python中并没有实现受保护的封装，属于开发者的约定俗成。</li>
<li>python中的私有化封装是通过改名策略实现的，并不是真正的私有化</li>
</ol>
<h3 id="继承">继承</h3>
<p>继承是什么？我们是不是经常听到「文化的继承，技艺的继承，衣钵的继承...」等等这些。</p>
<p>那计算机的继承又是什么？</p>
<p>在面向对象中，一个类去继承父类，那么这个类就拥有了父类中除了私有成员之外的所有成员，包括属性和方法。这个，就叫做继承。</p>
<p>在整个继承过程中，被其他类继承的类就称为「父类」，
也可以称为「基类」或者「超类」。那么继承其他类的类，就被称为「子类」，
也可以称为「派生类」。</p>
<p>那么我们继承又什么意义吗？继承的主要意义，就是为了提高代码的重用性，建立新的类与类的关系，方便其他逻辑的操作。</p>
<p>继承实现起来其实非常方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承的语法格式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父类</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>我们直接看代码来理解，比如，我有如下定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    coatColor = <span class="hljs-string">&#x27; white&#x27;</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>我们看，猫是不是也是属于猫科动物的一种动物？那么在猫科动物中定义的所有成员，其实在猫这边我也会有。不过这样重复定义是不是感觉特别繁琐？其实，我们在<code>Cat</code>中完全不需要再次输入这么多，完全可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    <span class="hljs-keyword">pass</span><br><br>mimi = Cat()<br>mimi.run()<br></code></pre></td></tr></table></figure>
<p>这样，我在定义<code>Cat</code>的时候就完成了对<code>Felidae</code>的继承，然后我们实例化一个<code>Cat</code>,再调用这个实例化对象中的方法<code>run()</code>，
也就输出了原本是属于类<code>Felidae</code>中的<code>run()</code>方法。</p>
<p>我们再继承父类的时候，之类还可以写入自己独有的成员属性或方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    size = <span class="hljs-string">&#x27;small&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃猫粮。&#x27;</span>)<br>    <span class="hljs-keyword">pass</span><br>  <br>mimi = Cat()<br>mimi.run()<br><span class="hljs-built_in">print</span>(mimi.size)<br>mimi.eat()<br>Felidae.eat()<br><br>---<br>轻盈的跳跃<br>small<br>吃猫粮。<br><br>AttributeError: <span class="hljs-built_in">type</span> <span class="hljs-built_in">object</span> <span class="hljs-string">&#x27;Felidae&#x27;</span> has no attribute <span class="hljs-string">&#x27;eat&#x27;</span><br></code></pre></td></tr></table></figure>
<p>我们定义<code>Cat</code>的时候，除了继承<code>Felidae</code>里的成员之外，还定义了一个<code>size</code>成员属性和一个<code>eat</code>成员方法。然后我们在实例化对象中进行调用，都正常运行。</p>
<p>这个时候我们反过来，使用父类<code>Felidae</code>来调用在之类<code>Cat</code>中定义的成员，则会报错。说明这个成员是独属于之类的。</p>
<p>我们不仅可以继承的时候进行扩展，还可以复写父类中的方法，使的它与父类方法产生差异化。其方法是在子类中将父类的方法重新定义一遍就可以了。</p>
<p>那有什么办法在我重写父类方法的时候，仍然可以调用父类方法吗？也是可以的，就是使用<code>super().父类方法名()</code>来进行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    size = <span class="hljs-string">&#x27;small&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().run()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;更加轻盈的跳跃。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃猫粮。&#x27;</span>)<br><br>    <span class="hljs-keyword">pass</span><br><br>mimi = Cat()<br>mimi.run()<br><br>---<br>轻盈的跳跃<br>更加轻盈的跳跃。<br></code></pre></td></tr></table></figure>
<p>我们可以看到，在子类中我们重写了父类中的<code>run</code>方法，但是由于我们在重写的时候在内部使用了<code>super().run()</code>。
所以父类中的方法被完全调用了一遍。</p>
<p>所以，我们目前可以总结<strong>继承的特征</strong>如下：</p>
<ul>
<li>在不指定继承的父类时，所有类都继承自object类（系统提供） 了解</li>
<li>子类继承了父类后，就拥有了父类中的所有成员包括魔术方法（除了私有成员）</li>
<li>子类继承父类后，并不会把父类的成员复制给子类，而去引用</li>
<li>子类继承父类后可以重写父类中的方法，叫做 重写</li>
<li>子类重写父类的方法，依然可以使用<code>super().父类方法名()</code>的方式调用父类的方法</li>
<li>子类中如果定义了父类中不存在的方法，称为对父类的扩展</li>
<li>一个父类可以被多个子类继承，还可以存在 链式继承 。
<ul>
<li>链式继承：A类继承了B类，B类继承了C类，C类继承了D类。。。</li>
</ul></li>
</ul>
<h3 id="单继承和多继承">单继承和多继承</h3>
<p>一个类只能继承一个父类的方式，就叫做单继承。如果一个类继承了多个父类的方式，就称为多继承。直接看例子，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人的样子。&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chusheng</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;畜生的特性。&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Japanese</span>(Person, Chusheng):<br>    <span class="hljs-keyword">pass</span><br><br>c = Japanese()<br>c<br><br>---<br>人的样子。<br>畜生的特性。<br></code></pre></td></tr></table></figure>
<p>像代码中定义的<code>Japanese</code>类，同时继承了<code>Person</code>和<code>Chusheng</code>，
那这个，就属于多继承。我们来区分一下语法特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父类</span>():<br>  	<span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>  	<span class="hljs-keyword">pass</span><br>  <br><span class="hljs-comment"># 多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父</span>():<br>  	<span class="hljs-keyword">pass</span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">母</span>():<br>  	<span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子</span>(父，母):<br>  	<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>
<p>在多继承的关系里，有一个有意思的部分，我们来看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大口撕咬食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小口吞咽食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(Tiger, Cat):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;到底该怎么吃？&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = C()<br>c.eat()<br></code></pre></td></tr></table></figure>
<p>我们现在看到这段代码是一个多继承关系，我在<code>C</code>这个类中继承了<code>Tiger</code>和<code>Cat</code>两个类，并且复写了<code>eat()</code>这个方法。按道理来说，我们实例化<code>C</code>类之后，打印的结果一定是复写的结果。但是我们在<code>C</code>类的<code>eat</code>方法里还调用了<code>super().eat()</code>，
我们知道<code>super()</code>是调用一遍父类的方法。那么这里到底是调用<code>Tiger</code>里的<code>eat</code>方法，还是<code>Cat</code>里的<code>eat</code>方法呢？</p>
<p>让我们看打印结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">---<br>大口撕咬食物...<br>到底该怎么吃？<br></code></pre></td></tr></table></figure>
<p>打印结果有没有出乎你的意料？那么这个原因是什么呢？其实也不复杂，就是因为<code>Tiger</code>的调用在前面，<code>Cat</code>在后面。让我们重新改一下看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大口撕咬食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小口吞咽食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(Cat,Tiger):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;到底该怎么吃？&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = C()<br>c.eat()<br><br>---<br>小口吞咽食物...<br>到底该怎么吃？<br></code></pre></td></tr></table></figure>
<p>这就证实了，谁在前面就调用谁的方法。</p>
<h3 id="菱形继承钻石继承">菱形继承（钻石继承）</h3>
<p>先来看一个图形：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">A</span><br><span class="hljs-selector-tag">B</span>   C<br>  D<br></code></pre></td></tr></table></figure>
<p>那我们先有一个<code>A</code>类，下面有<code>B</code>和<code>C</code>类，再下面还有一个<code>D</code>类。</p>
<p>看图可能还是不太明白，它们之间的关系是这样的：<code>B</code>和<code>C</code>继承了<code>A</code>类，然后<code>D</code>又多继承了<code>B</code>和<code>C</code>。</p>
<p>那么这种继承关系就叫做菱形继承。</p>
<p>那么我们现在面临的一个问题就是：在这种菱形继承关系中，类与类是什么关系？<code>super()</code>调用时的顺序是怎样的？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菱形继承</span><br><br><span class="hljs-comment"># 祖先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    num = <span class="hljs-number">111</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学着凭借本能寻找食物...&#x27;</span>)<br><br><span class="hljs-comment"># 父亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">222</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化了，学会大口吃肉。。。&#x27;</span>)<br><br><span class="hljs-comment"># 母亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">333</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化的另外一个分支，小口吞咽...&#x27;</span>)<br><br><span class="hljs-comment"># 子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<br>    num = <span class="hljs-number">444</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;居然退化了，又忘了怎么吃...&#x27;</span>)<br><br>d = D()<br>d.eat()<br><br>---<br>学着凭借本能寻找食物...<br><span class="hljs-number">111</span><br>进化的另外一个分支，小口吞咽...<br><span class="hljs-number">333</span><br>进化了，学会大口吃肉。。。<br><span class="hljs-number">222</span><br>居然退化了，又忘了怎么吃...<br></code></pre></td></tr></table></figure>
<p>那么我们来看一下，究竟是怎样的一个顺序：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">D.super<span class="hljs-function"><span class="hljs-params">()</span> =&gt; <span class="hljs-title">B</span>.<span class="hljs-title">super</span><span class="hljs-params">()</span> =&gt;<span class="hljs-title">C</span>.<span class="hljs-title">super</span><span class="hljs-params">()</span> =&gt; <span class="hljs-title">A</span>.<span class="hljs-title">print</span><span class="hljs-params">()</span> -&gt;</span> C.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> B.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> D.<span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>
<p>上边这一段中，<code>=&gt;</code>是继承关系，<code>-&gt;</code>是执行顺序。</p>
<p>好，那我们这个时候要清楚一个点是，我们使用的<code>d</code>这个实例化去执行的，那么在这所有的继承类中，<code>self</code>全部都是<code>c</code>这个实例化对象。让我们来看看到底是不是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菱形继承</span><br><br><span class="hljs-comment"># 祖先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    num = <span class="hljs-number">111</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学着凭借本能寻找食物...&#x27;</span>)<br><br><span class="hljs-comment"># 父亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">222</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化了，学会大口吃肉。。。&#x27;</span>)<br><br><span class="hljs-comment"># 母亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">333</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化的另外一个分支，小口吞咽...&#x27;</span>)<br><br><span class="hljs-comment"># 子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<br>    num = <span class="hljs-number">444</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;居然退化了，又忘了怎么吃...&#x27;</span>)<br><br>d = D()<br>d.eat()<br><br>---<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br>学着凭借本能寻找食物...<br><span class="hljs-number">111</span><br>进化的另外一个分支，小口吞咽...<br><span class="hljs-number">333</span><br>进化了，学会大口吃肉。。。<br><span class="hljs-number">222</span><br>居然退化了，又忘了怎么吃...<br></code></pre></td></tr></table></figure>
<p>打印的结果证实了我们刚才的说法。</p>
<p>这个地方可能比较让人意外的是之前那个继承关系上，明明我<code>B</code>继承的是<code>A</code>，
怎么变成<code>C</code>了？我们来看看原因：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">在定义类之后，程序会自动生成一个继承的列表MRO(Method Realtion Order)方法关系列表</span><br><span class="hljs-string">MRO列表生成原则：</span><br><span class="hljs-string">1. 子类永远在父类的前面</span><br><span class="hljs-string">2. 同一等级的类，按照之类中的继承顺序摆放</span><br><span class="hljs-string">3. 先之类，后父类的顺序原则，最终的类是系统提供的obejct类</span><br><span class="hljs-string"></span><br><span class="hljs-string">MRO的调用方法</span><br><span class="hljs-string">类名.mro()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>D.mro()<br><br>---<br>[__main__.D, __main__.B, __main__.C, __main__.A, <span class="hljs-built_in">object</span>]<br></code></pre></td></tr></table></figure>
<p><code>super</code>在调用时，并不是查找父类，而是去MRO列表上找上一个类。</p>
<p><code>super</code>方法在调用时，会自动把当前<code>self</code>传入到上一级的类的方法中。</p>
<p>所以我们之前会呈现出<code>D=&gt;B=&gt;C=&gt;A</code>的顺序。</p>
<p>看着有点晕是吧？别着急，我们接下来介绍一个方法，能很方便的看到类关系。</p>
<h3 id="issubclass类关系检测"><code>issubclass()</code>类关系检测</h3>
<p>这个方法是检测一个类是否是另一个类的之类的方法。用起来也非常简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">issubclass</span>(D, B)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(D, C)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(D, A)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(A, D)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<h3 id="多态">多态</h3>
<p>对于同一个方法，由于调用的对象不同，产生了不同形态的结果。这个就叫做多态。</p>
<p>比如说，我们现在的电脑上有一个USB接口，那么这个接口在接入不同的设备的时候，产生的结果也是不一样的。插入鼠标，我们可以点击。插入键盘我们可以输入，插入U盘呢，我们可以读取。对吧？对于这个USB接口来说。就属于多态。</p>
<p>好的，让我们来实现一下，直接看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>():<br>    <span class="hljs-comment"># 在电脑类中定义一个 sub 的规范的接口 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">usb</span>(<span class="hljs-params">self,obj</span>):<br>        obj.start()<br><br><span class="hljs-comment"># 定义鼠标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标启动成功，可以双击单击嗨起来。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义键盘类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBord</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘启动成功了，赶紧输入666。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义 U盘 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Udisk</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;U盘启动了，赶紧检查一下我的种子还在不在。。。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = Computer()  <span class="hljs-comment"># 电脑对象</span><br>m = Mouse()     <span class="hljs-comment"># 鼠标对象</span><br>k = KeyBord()   <span class="hljs-comment"># 键盘对象</span><br>u = Udisk()     <span class="hljs-comment"># u盘对象</span><br><br><br><span class="hljs-comment"># 把不同的设备插入到电脑的usb的接口中</span><br>c.usb(m)<br>c.usb(k)<br>c.usb(u)<br><br>---<br>鼠标启动成功，可以双击单击嗨起来。。。<br>键盘启动成功了，赶紧输入<span class="hljs-number">666</span>。。。<br>U盘启动了，赶紧检查一下我的种子还在不在。。。<br></code></pre></td></tr></table></figure>
<p>这样，我们就实现了一个多态的程序。</p>
<p>我们在实例化<code>Computer()</code>之后，利用实例化对象<code>c</code>调用类中的方法<code>usb</code>，
将实例化对象传入，并且还传入了不同的<code>obj</code>，
这里的<code>obj</code>是我们之前实例化过的<code>m, k, u</code>。
那这样，我们<code>obj</code>代表了不同的实例化对象，那也就会启动不同的类方法。</p>
<p>那这样呢，属于一个普通的方式来实现，其实对于这段程序，我们还可以使用继承关系来完成。</p>
<p>我们先定义一个接口规范类，其他类都继承这个类，并实现（重写）父类中的方法。由于每个对象实现父类的方式或者过程都不相同，最后的结果是不一样的形态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承关系写多态</span><br><br><span class="hljs-comment"># 定义USB</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USB</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    info:</span><br><span class="hljs-string">        这个类是一个接口规范类，需要子类继承并实现start方法</span><br><span class="hljs-string">        start方法不做任何具体功能的实现</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 在usb类中定义一个规范的接口方法，但是不实现任何功能</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义鼠标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标启动成功，可以双击单击嗨起来。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义键盘类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBord</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘启动成功了，赶紧输入666。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义 U盘 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Udisk</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;U盘启动了，赶紧检查一下我的种子还在不在。。。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>m = Mouse()<br>k = KeyBord()<br>u = Udisk()<br><br>m.start()<br>k.start()<br>u.start()<br><br>---<br>鼠标启动成功，可以双击单击嗨起来。。。<br>键盘启动成功了，赶紧输入<span class="hljs-number">666</span>。。。<br>U盘启动了，赶紧检查一下我的种子还在不在。。。<br></code></pre></td></tr></table></figure>
<p>我们回来看这段代码，实际上，如果抛开<code>USB</code>类，我们单独去写后面的类，并且把继承关系去掉。最后是不是也可以进行打印？可以...</p>
<p>可是这样的话，那这三个方法中的<code>satrt</code>方法之间就毫无关系，继承了<code>USB</code>中的<code>start</code>方法，也就是继承了规范。</p>
<p>而且这个继承的形式，和我们之前实现的普通版本其实并无什么差别，虽然代码实现上有不同，可是逻辑上是完全相同的。</p>
<p>好了，关于面向对象，我们就先介绍到这里。不过别着急，并不是讲完了，我们下节课还要接着讲「面向对象」。讲解一些高级语法和思想。小伙伴们记得关注。</p>
<p>另外，面向对象这个东西，确实蛮难的，并不是看我这一两节课就能学懂的。虽然我尽力，但是我还是有自知之明。</p>
<p>在这里给大家推荐一本好书，有它在，你想不懂都难。 <code>^_^</code></p>
<p><a target="_blank" rel="noopener" href="https://u.jd.com/2zo4Ee3">领取优惠券</a>再<a
target="_blank" rel="noopener" href="https://u.jd.com/2QmKR3j">购买</a>：</p>
<p><img
src="https://img1.doubanio.com/view/subject/l/public/s24550919.jpg"
alt="img" /></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>21. 面向对象及特性</p><p><a href="https://hivan.me/Object-Oriented-Programming/">https://hivan.me/Object-Oriented-Programming/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hivan Du</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-08-16</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-17</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6479444288ae9600196fa98e&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://afdian.net/item/72907364008511ee904852540025c377" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://qiniu.hivan.me/picGo/20230601221633.jpeg" alt="支付宝"></span></a><a class="button donate" href="https://www.buymeacoffee.com/hivandu" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="https://patreon.com/user?u=89473430" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="paypal" onclick="document.getElementById(&#039;paypal-donate-form&#039;).submit()"><span class="icon is-small"><i class="fab fa-paypal"></i></span><span>Paypal</span></a><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" rel="noopener" id="paypal-donate-form"><input type="hidden" name="cmd" value="_donations"><input type="hidden" name="business" value="doo@hivan.me"><input type="hidden" name="currency_code" value="USD"></form><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://qiniu.hivan.me/IMG_4603.JPG" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Object-Oriented-Programming-Higher-Level/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">22. 面向对象 - 高阶</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Get-the-exception/"><span class="level-item">20. 异常处理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://hivan.me/Object-Oriented-Programming/';
            this.page.identifier = 'Object-Oriented-Programming/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'hivan' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/bdff168cf8a71c11d2712a1679a00c54?s=128" alt="茶桁"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">茶桁</p><p class="is-size-6 is-block">AI游民</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shang Hai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">194</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hivandu" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hivandu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/hivan"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/hivan"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com/hivan"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NzE4MDQzMg==&amp;action=getalbum&amp;album_id=2932504849574543360&amp;scene=173&amp;from_msgid=2648747980&amp;from_itemidx=1&amp;count=3&amp;nolastread=1&amp;token=1758883909&amp;lang=zh_CN#wechat_redirect"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/column/c_1424326166602178560" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">塌缩的奇点</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/column/hivandu" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">茶桁-知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI-%E7%A7%98%E7%B1%8D%EF%BC%8CMath/"><span class="level-start"><span class="level-item">AI 秘籍，Math</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/"><span class="level-start"><span class="level-item">AI秘籍</span></span><span class="level-end"><span class="level-item tag">51</span></span></a><ul><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">核心能力基础</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="level-start"><span class="level-item">从零开始接触人工智能大模型</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-21T23:30:00.000Z">2023-11-22</time></p><p class="title"><a href="/23.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20-%20%E5%AE%8C%E6%88%90%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6/">23. 深度学习 - 多维向量自动求导</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-18T23:30:00.000Z">2023-11-19</time></p><p class="title"><a href="/22.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20-%20%E8%87%AA%E5%8A%A8%E6%B1%82%E5%AF%BC%E8%AE%A1%E7%AE%97%E7%9A%84%E5%AE%9E%E7%8E%B0/">22. 深度学习 - 自动求导</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-15T23:30:00.000Z">2023-11-16</time></p><p class="title"><a href="/21.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20-%20%E6%8B%93%E6%9C%B4%E6%8E%92%E5%BA%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/">21. 深度学习 - 拓朴排序的原理和实现</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-12T23:30:00.000Z">2023-11-13</time></p><p class="title"><a href="/20.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20-%20%E5%A4%9A%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">20. 深度学习 - 多层神经网络</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-11-09T23:30:00.000Z">2023-11-10</time></p><p class="title"><a href="/19.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%20-%20%E7%94%A8%E5%87%BD%E6%95%B0%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/">19. 深度学习 - 用函数解决问题</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="茶桁.MAMT" height="28"></a><p class="is-size-7"><span>&copy; 2023 Hivan Du</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hivandu"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>