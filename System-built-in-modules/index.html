<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>15. 系统内置模块 - 茶桁.MAMT</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="茶桁.MAMT"><meta name="msapplication-TileImage" content="https://qiniu.hivan.me/picGo/20230601174411.png?imgNote"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="茶桁.MAMT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content=""><meta property="og:type" content="blog"><meta property="og:title" content="15. 系统内置模块"><meta property="og:url" content="https://hivan.me/System-built-in-modules/"><meta property="og:site_name" content="茶桁.MAMT"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-08-10T15:20:33.000Z"><meta property="article:modified_time" content="2023-11-25T12:02:16.324Z"><meta property="article:author" content="Hivan Du"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:creator" content="@hivan"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hivan.me/System-built-in-modules/"},"headline":"15. 系统内置模块","image":[],"datePublished":"2023-08-10T15:20:33.000Z","dateModified":"2023-11-25T12:02:16.324Z","author":{"@type":"Person","name":"Hivan Du"},"publisher":{"@type":"Organization","name":"茶桁.MAMT","logo":{"@type":"ImageObject","url":"https://hivan.me/img/logo.svg"}},"description":""}</script><link rel="canonical" href="https://hivan.me/System-built-in-modules/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?f91b64734fdc7bfb999e48f9248d44dd";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-ZFB6CVWZFJ" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-ZFB6CVWZFJ');</script><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="茶桁.MAMT" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="茶桁.MAMT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hivandu"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-10T15:20:33.000Z" title="8/10/2023, 11:20:33 PM">2023-08-10</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a><span> / </span><a class="link-muted" href="/categories/AI%E7%A7%98%E7%B1%8D/Python/">Python</a></span></div></div><h1 class="title is-3 is-size-4-mobile">15. 系统内置模块</h1><div class="content"><p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000728.png" /></p>
<span id="more"></span>
<p>Hi，大家好。我是茶桁。</p>
<p>上一节中，在我们的学习到达一个阶段的时候，我们用之前所学过的知识创建了一个简单的注册登录系统。不知道小伙伴们有没有在课后自己实现一遍呢？编程这种事情，还是要多上手多练才行。</p>
<p>那么今天这节课，我们来学习一下Python系统内置模块。</p>
<p>系统内置模块就是安装完Python解释器之后，系统本身所提供的模块。我知道，咱们之前的课程里有学习系统的内置函数，这个模块和函数不是一个东西。模块这种东西，是需要导入后才可以使用的，比如：<code>json, re, os</code>等等。</p>
<p>行，废话不多说，让我们进入正题。</p>
<h2 id="序列化模块">序列化模块</h2>
<p>序列化，就是指可以把Python中的数据，以文本或者二进制的方式进行转换，并且还能反序列化为原来的数据。数据在程序和网络中进行传输和存储的时候，需要以更加方便的形式进行操作，因此需要对数据进行序列化。</p>
<p>对数据进行序列化主要有两种方法，一种呢是Python专用的二进制序列化模块：<code>pickle</code>，
还有一种呢，是互联网通用的文本序列化模块<code>json</code>。</p>
<h3 id="pickle"><code>pickle</code></h3>
<p>按照官方的定义来讲</p>
<blockquote>
<p>pickle实现了对一个Python对象结构的二进制序列化和反序列化</p>
</blockquote>
<p>它提供了一些可供使用的函数，下面让我们来一一介绍一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br>myStr = <span class="hljs-string">&#x27;I love you&#x27;</span><br>res = pickle.dumps(myStr)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br><span class="hljs-string">b&#x27;\x80\x04\x95\x0e\x00\x00\x00\x00\x00\x00\x00\x8c\nI love you\x94.&#x27;</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bytes&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>当前是将一段字符串使用<code>dumps()</code>进行了转化，那其他数据类型是否可以呢？我们来一段列表试试看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>res = pickle.dumps(myList)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br><span class="hljs-string">b&#x27;\x80\x04\x95\x0f\x00\x00\x00\x00\x00\x00\x00]\x94(K\x01K\x02K\x03K\x04K\x05e.&#x27;</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bytes&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>可以看到，依然进行了转化，并且类型还是<code>bytes</code>。其他的诸如字典、元组等都可以进行这样的转化，我们就不一一的在这里展示了。结论为，我们使用<code>pickle.dumps</code>方法可以进行序列化成为一个二进制的数据。</p>
<p>再让我们来看看反序列化的效果，我在源码中还做过一个元组的序列化，并且给<code>res</code>进行了赋值，我们就拿最后一次的结果来做演示（<code>res = b'\x80\x04\x95\x10\x00\x00\x00\x00\x00\x00\x00(K\x01K\x02K\x03K\x04K\x05K\x06t\x94.'</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = pickle.loads(res)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>可以看到, 之前序列化成二进制数据的元组被<code>loads()</code>
反序列化转化回来恢复成了元组，我们打印其类型，为<code>tuple</code>。</p>
<p>除了以上两个方法之外，还有另外两个方法<code>dump()</code>和<code>load()</code>，
这四者的区别如下：</p>
<ul>
<li><code>dumps(obj, protocol=None, *, fix_imports=True, buffer_callback=None)</code>:
序列化，可以把一个Python的任意对象序列化成为一个二进制，返回一个序列化后的二进制数据。</li>
<li><code>dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None)</code>:
序列化，把一个数据对象进行序列化并写入到文件中。注意，<code>demps</code>是返回并不写到文件中，而<code>dump</code>者是写入到文件中。所以多一个必填参数<code>file</code>，
就是写入的文件对象。</li>
<li><code>loads(data, /, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=None)</code>:
反序列化，可以把一个序列化后的二进制数据反序列化为Python的对象。返回一个反序列化后的Python对象。</li>
<li><code>load(file, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=None)</code>:
反序列化，
<strong>在一个文件中</strong>读取序列化的数据，并且完成一个反序列化。和<code>loads</code>最大的不同是加载的是读取的文件对象<code>file</code>，而不是<code>data</code>。</li>
</ul>
<p>可以看到，基本上来说，<code>dump</code>和<code>load</code>是对文件进行操作的方法，那能不能使用<code>dumps</code>和<code>loads</code>来完成呢？让我们来试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义数据</span><br>myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-comment"># 进行序列化</span><br>res = pickle.dumps(myDict)<br><span class="hljs-comment"># 写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.write(res)<br></code></pre></td></tr></table></figure>
<p>然后我们看，文件夹中确实多了一个data.txt文件，当我想要打开的时候，提示我为二进制文件。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000729.png" /></p>
<p>那基本上可以确定，咱们所作的操作确实成功了。</p>
<p>借用其他的支持二进制文件的编辑器打开看看：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000730.png" /></p>
<p>再来，我们把一个反序列的二进制文件读取处理，并完成反序列化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br><br><span class="hljs-comment"># 进行反序列化</span><br>myDict = pickle.loads(res)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>以上两个方式，我们其实完全可以使用<code>pickle</code>模块提供的方法来完成，<code>dump</code>和<code>load</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data2.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    pickle.dump(myDict, fp)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data2.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    newdict = pickle.load(fp)<br>    <span class="hljs-built_in">print</span>(newdict)<br>    <br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>我们又重新创建了一个序列化，保存数据到<code>data2.txt</code>中，然后反序列化再从文件中读取转化。和之前我们用到的方法得到的结果一样，但是方法我们用的却完全不同。</p>
<h3 id="json序列化">JSON序列化</h3>
<p>JSON的全称为: JavaScript Object Notation,
是一个受JS的对象字面量语法启发的轻量级数据交换格式。其在JS语言中是一个对象的表示方法，和Python中的字典的定义规则和语法都很像。</p>
<p>JSON在互联网中又是一种通用的数据交换，传输，定义的一种数据格式。</p>
<p>和之前的<code>pickle</code>序列化方法一样，JSON序列化也有四种函数，其功能基本是一模一样。只是最后转化的数据格式不同：</p>
<ul>
<li><code>json.dumps()</code>: 完成JSON格式数据的序列化</li>
<li><code>json.loads()</code>: 完成JSON格式数据的反序列化</li>
<li><code>json.dump()</code>:
和<code>pickle</code>模块的<code>dump</code>方法一致</li>
<li><code>json.load()</code>:
和<code>pickle</code>模块的<code>load</code>方法一致</li>
</ul>
<p>这里，我们先不着急写代码，我觉得需要对JSON简单了解一下，其实很简单，一说就明白了：</p>
<p>我们之前定义了一个字典：<code>myDict = &#123;'name':'茶桁', 'age':32, 'sex':'male'&#125;</code>，
这个格式的数据在Python中是字典，但是在JS中，这个玩意是一个对象(<code>Object</code>)，如果它放在一个<code>.json</code>文件中，这会是正常的<code>json</code>格式的数据。</p>
<p>我们来做一下操作，上几张图就明白了，为了说明，我们创建一个<code>15_json.html</code>文件和<code>15_json.json</code>，
大家来看：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>		...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> person = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person, <span class="hljs-title function_">typeof</span>(person))</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>我们在脚本中定义了一个<code>person</code>，格式和Python中的字典一模一样，但是在JS中，它被称为对象。我们在浏览器的控制台中打印出来看看：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000731.png" /></p>
<p>那如果在一个JSON文件中呢，它就是一个最普通的JSON数据格式。只是稍微需要注意一下，虽然我们这样写并不会报错，但是总会提示格式问题，JSON最正规的写法，是需要用<code>“"</code>，尽量不要使用<code>‘’</code>。</p>
<p>提前说这么多JSON的知识点，是因为接下来，如果我们没有说清楚，可能正的会分辨不清。好了，让我们转回Python中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(myDict, <span class="hljs-built_in">type</span>(myDict))<br><br><span class="hljs-comment"># 使用JSON模块的dumps方法进行JSON格式的转换</span><br>res = json.dumps(myDict)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br>&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;\u8336\u6841&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>我们在代码中执行了两次打印，第一次是定义完字典之后，第二次是转换为JSON之后。我们可以看到两次打印结果，几乎是一模一样。当然，中文部分转化的比较明显，但是如果我讲<code>name</code>的值设定为英文，比如<code>Hivan</code>，
那么可以说几乎看不出区别。比较明显的，是我们将类型打印了出来，一个是<code>dict</code>,
一个就是<code>str</code>。</p>
<p>当然，和<code>pickle</code>一样，<code>loads</code>方法将会进行反序列化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">newDict = json.loads(res)<br><span class="hljs-built_in">print</span>(newDict, <span class="hljs-built_in">type</span>(newDict))<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>JSON的转化，基本Python中所有的数据类型都可以进行序列化而不会出现报错的情况，但是有些数据是真的转为了JSON格式的数据，但是有的则只是转为了字符串而已。</p>
<p>让我们尝试将一个复杂的结构数据写到一个JSON文件中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">myList = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;female&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;du&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">34</span>,<span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(myList, fp)<br></code></pre></td></tr></table></figure>
<p>我们去查看一下文件的内容：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000732.png" /></p>
<p>读取的话，当然也和<code>pickle</code>中的用法也是一致的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    newList = json.load(fp)<br>    <span class="hljs-built_in">print</span>(newList)<br><br>---<br>[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;du&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure>
<h2 id="数学与数值">数学与数值</h2>
<h3 id="数学模块-math">数学模块 Math</h3>
<p>Python中的内置数学模块Math提供了很多的数学相关运算。整个模块中的方法都非常简单，直接调用就可以了，当然，前提是需要导入数学模块。
下面我们就简单的介绍一下相关方法(当然，其实我们之前已经介绍过一部分了。)：</p>
<ul>
<li>向上取整 <code>math.ceil()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># math.ceil() 向上取整</span><br>res = math.ceil(<span class="hljs-number">3.14</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>这个函数让你想到了什么？不知道小伙伴们还记得前面学习的内容不，是不是特别像我们曾经学过的<code>round()</code>方法？不过这两个方法还有不一样的地方，让我们来看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.14</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.5</span>))<br><br>---<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>
<p>看到区别了吗？<code>round</code>实际上是一个四舍五入的函数，而<code>ceil</code>只是向上取整
，则不管你小数点后面的数字大小。当然，有向上取整:
<code>math.floor()</code>，这肯定有对应的向下取整，为了很清晰的看出来，我选择了一个向上接近整数的小数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.floor(<span class="hljs-number">3.94</span>))<br><br>---<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
<p>接下来是求幂次方:
<code>math:pow(x,y)</code>，这个方法会传入两个数值，前一个数值为底数，后一个则为指数，结果是浮点数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">1.44</span><br></code></pre></td></tr></table></figure>
<p>下面一个是求开平方，结果也是浮点数： <code>math.sqrt()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">4</span>))<br><br>---<br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure>
<p><code>math.fabs()</code>能够计算绝对值,结果是浮点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.fabs(-<span class="hljs-number">3.14</span>))<br><br>---<br><span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure>
<p><code>math.modf()</code>: 把一个数值拆分成小数和整数组成的元组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.modf(<span class="hljs-number">3.1415</span>))<br><br>---<br>(<span class="hljs-number">0.14150000000000018</span>, <span class="hljs-number">3.0</span>)<br></code></pre></td></tr></table></figure>
<p>至于最后的打印结果，不用太纠结。这并不是Python中的BUG，而是与计算机如何处理浮点数有关，因为计算机存储数据实际上都是二进制的，而二进制无法正确处理。</p>
<p>举个栗子：<code>1/3</code>，
在十进制下，这个数是无限循环小数对吧？<code>3.33333333</code>，二进制实际上也有这种问题，比如说<code>1/10</code>,
十进制下是<code>0.1</code>，可是二进制下呢，就成了无限循环小数：<code>0.000111001100110011...</code>。</p>
<p>其实大部分情况之下，这并不影响我们的使用，只是得到的数值需要处理一下四舍五入就可以了，但是也有不适用的情况。实际上，Python中有专门处理精度计算的模块：<code>decimal</code>，这个等我们以后再详细讲。</p>
<p><code>math.copysign(x,y)</code>:
把第二个参数的正负符号拷贝给第一个参数，结果为浮点数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.copysign(-<span class="hljs-number">3</span>, <span class="hljs-number">99</span>))<br><span class="hljs-built_in">print</span>(math.copysign(<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">3.0</span><br>-<span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure>
<p><code>math.fsum()</code> :
将一个容器类型数据中的元素进行一个求和运算，结果为浮点数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.fsum((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))<br><span class="hljs-built_in">print</span>(math.fsum(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))<br><br>---<br><span class="hljs-number">6.0</span><br><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure>
<p>这个方法的参数值需要注意一下，容器中的元素必须是可以运算的<code>number</code>类型。</p>
<p><code>math.factorial(x)</code>: 以一个整数返回x的阶乘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.factorial(<span class="hljs-number">4</span>))<br><br>---<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure>
<p>除了运算函数外，还有一些常量函数。最典型的就是<code>数学常数 π = 3.141592...</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.pi)<br><br>---<br><span class="hljs-number">3.141592653589793</span><br></code></pre></td></tr></table></figure>
<p>基本可以看出来，Python的数学模块基本都属于很简单的工具类函数，
列举几个之后，大家基本上就都能上手了。其官方的文档地址可以看这里：相关文档地址为：<a
target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.10/library/math.html#module-math">https://docs.python.org/zh-cn/3.10/library/math.html#module-math</a>。</p>
<h3 id="随机模块-random">随机模块 <code>random</code></h3>
<p>随机模块也是一个比较简单的模块，大部分时候，我们是使用它来产生随机值使用的。</p>
<p><code>random</code>模块中的<code>random</code>函数直接使用会返回一个0-1之间的随机小数（左闭右开）</p>
<p>什么是左闭右开呢？通俗点说，就是<code>random</code>这个函数，有可能取到<code>0</code>这个值，而无论如何不会取到<code>1</code>这个值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.random())<br><br>---<br><span class="hljs-number">0.7363473107012012</span><br></code></pre></td></tr></table></figure>
<p><code>random.randrange([开始值]，结束值，[步进值])</code>:随机获取指定<strong>范围内的整数</strong>。对于这种需要开始值，结束值和步进值的参数形式的函数我们应该都已经非常熟悉了对吧？</p>
<p>这里有三个值，除了结束值是必选之外，另外两个值都是可选值。当<strong>只有一个参数</strong>时，默认就是从0到整数之间的值，<strong>存在两个参数</strong>时，就从开始值到结束值之间的随机数，而<strong>当有三个参数时</strong>，就会按照步进值从开始值到结束值之间产生一个随机数。需要记住一点，这三种参数取值方式，都是左闭右开的形式。也就是说，结束值是不会被取到的。</p>
<p>随机数大量应用在数字验证码，抽奖以及高并发下生成订单号等应用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p><code>random.randint()</code> 会随机产生指定范围内的随机整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>))<br><br>---<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>
<p>可能有的小伙伴会发出疑问了：茶桁老师，你这个解释是不是写错位置了？将<code>randrange</code>的解释直接复制了下来。其实没有，这两个的功能几乎一模一样，说几乎的意思当然是还是有不同点，唯一一点不相同的是，<code>randint</code>产生的随机整数，是左闭右闭的模式，也就是说，它是可以取到结束值的。</p>
<p>当然我们不能只随机整数对吧？实际应用场景中我们也需要大量的浮点数：</p>
<p><code>random.uniform()</code> 获取指定返回内的随机小数,
实际应用中我们需要注意，这个函数是没有开始值和结束值的，只有<strong>范围值</strong>，也就是说，你最小值和最大值填入的先后顺序无所谓。</p>
<p>那有的小伙伴会想，如果两个值我填入的数值一样会如何？嗯，那就产生一个唯一的浮点值呗。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br><br>---<br><span class="hljs-number">9.540258898738779</span><br><span class="hljs-number">7.343136835899989</span><br><span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure>
<p><code>random.choice()</code>，
随机获取容器类型中的值。这个函数的应用范围就非常广了，我们在做数据分析的时候经常会用得到。因为大部分时候，我们说面对的应该都是容器类数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.choice(<span class="hljs-string">&#x27;123&#x27;</span>))<br><span class="hljs-built_in">print</span>(random.choice([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br><br>---<br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<p><code>random.shuffle()</code>
随机打乱当前列表中的值，没有返回值，仅仅是打乱原数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>res = random.shuffle(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr:<span class="hljs-subst">&#123;arr&#125;</span> \nres:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>arr:[<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <br>res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>当然，我说介绍的函数都只是一部分，目的是打个样，让大家知道这些函数是个怎么回事。大部分时候会用到的函数抽出来讲解一下，更多的内容，还需要参考官方文档：<a
target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.10/library/random.html#module-random">https://docs.python.org/zh-cn/3.10/library/random.html#module-random</a></p>
<h2 id="系统操作相关模块">系统操作相关模块</h2>
<h3 id="os模块">OS模块</h3>
<p>OS模块，就是操作系统接口模块。这个模块提供了一些方便使用操作系统相关功能的函数。我们之前重点学习的<code>open()</code>，就是这个模块中的相关函数。现在让我们来看看除了<code>open</code>之外，还有哪些函数可供我们日常使用：</p>
<p><code>os.getcwd()</code>获取当前的工作目录,注意获取的不是当前脚本的目录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>res = os.getcwd()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>/Users/du/git/AI_Cheats/Python<br></code></pre></td></tr></table></figure>
<p>不过需要注意一点是，这个函数并不是获取现在这个文件的所在目录，而是当前此文件的执行目录。这个怎么理解呢？我给大家举例说明一下：</p>
<p>我们首先需要知道一个，就是我们在Linux中执行<code>cd</code>和<code>pwd</code>的时候，一个是进入某个目录，一个是打印当前目录路径：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000733.png" /></p>
<p>那么这里的<code>pwd</code>所执行的结果，是随着进入目录不同而变化的，比如我们进入我们当前的文件目录：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000734.png" /></p>
<p>也就是说，我在哪个目录下执行<code>pwd</code>，那么返回结果就是当前执行的这个目录，而不是<code>pwd</code>这个执行文件本身所在的目录。</p>
<p><code>gwtcwd()</code>文件，和<code>pwd</code>实际上就是相同的特点，如果在当前目录执行这个脚本文件，那么getcwd获取的就是当前的文件目录。如果这个时候我切换到了其他目录，但是写了<code>getcwd()</code>方法的文件没有挪动位置，那么此时我获取的返回值就是我切换的其他目录，而非文件所在的位置。下面我们可以测试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;/Users/du/git/&#x27;</span>)<br>res = os.getcwd()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>/Users/du/git<br></code></pre></td></tr></table></figure>
<p>可以看到，我们执行了和上main相同的代码，但是这个时候<code>res</code>接收返回值发生了变化，其原因就是我使用了<code>os.chdir</code>来改变了一下当前的工作目录。不知道大家现在是否能理解<code>gwtcwd()</code>的工作原理？还是无法理解的，可以多自己写一下代码，做做尝试。连我这种笨人之前学习的时候都能很快理解，小伙伴们肯定更没有问题。</p>
<p>刚才我们的实验中，引出了另外一个方法：</p>
<p><code>os.chdir()</code>,
如上所见，其功能就是修改<strong>当前工作目录</strong>。</p>
<p>下面我们直接介绍其他的函数：</p>
<p><code>os.listdir()</code>
获取当前或指定目录中的所有项（文件，文件夹，隐藏文件），组成的列表</p>
<p>这个方法和Linux中的<code>list</code>命令就十分像了，让我们先将<strong>当前工作目录</strong>切回我们当前文件本来所在的目录，然后在来执行一下这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/&#x27;</span>)<br>res = os.listdir()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;12.ipynb&#x27;</span>, <span class="hljs-string">&#x27;10.ipynb&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;15_json.html&#x27;</span>, <span class="hljs-string">&#x27;14.ipynb&#x27;</span>, <span class="hljs-string">&#x27;8.ipynb&#x27;</span>, <span class="hljs-string">&#x27;14.py&#x27;</span>, <span class="hljs-string">&#x27;11.ipynb&#x27;</span>, <span class="hljs-string">&#x27;globals.ipynb&#x27;</span>, <span class="hljs-string">&#x27;13.ipynb&#x27;</span>, <span class="hljs-string">&#x27;Kalman.ipynb&#x27;</span>, <span class="hljs-string">&#x27;9.ipynb&#x27;</span>, <span class="hljs-string">&#x27;15.ipynb&#x27;</span>, <span class="hljs-string">&#x27;7.ipynb&#x27;</span>, <span class="hljs-string">&#x27;5.ipynb&#x27;</span>, <span class="hljs-string">&#x27;1.ipynb&#x27;</span>, <span class="hljs-string">&#x27;3.ipynb&#x27;</span>, <span class="hljs-string">&#x27;4.ipynb&#x27;</span>, <span class="hljs-string">&#x27;6.ipynb&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;2.ipynb&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>可以看到，目录内所有的文件，包括隐藏文件<code>.DS_Store</code>和文件夹<code>data</code>都被放进了一个列表当中。</p>
<p>这是在不指定目录的情况下，默认为当前工作目录，当然，我们还可以指定目录来获取那个目录下的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.listdir(<span class="hljs-string">&#x27;/Users/du/AI/&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;AIGC&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;GPT&#x27;</span>, <span class="hljs-string">&#x27;AI_core_competence&#x27;</span>, <span class="hljs-string">&#x27;stable-diffusion-webui&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>这样，我们就获取到了我们希望查找的目录下的所有内容。我们继续：</p>
<p><code>os.mkdir(文件夹路径, 权限)</code>
这个函数用来创建文件夹，其命令 和Linux中是一模一样，功能也是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.listdir(<span class="hljs-string">&#x27;./data/&#x27;</span>))<br>os.mkdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>, <span class="hljs-number">0o777</span>)<br><span class="hljs-built_in">print</span>(os.listdir(<span class="hljs-string">&#x27;./data/&#x27;</span>))<br><br>---<br>[<span class="hljs-string">&#x27;black.txt&#x27;</span>, <span class="hljs-string">&#x27;user.txt&#x27;</span>, <span class="hljs-string">&#x27;13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;data2.txt&#x27;</span>, <span class="hljs-string">&#x27;data3.json&#x27;</span>, <span class="hljs-string">&#x27;13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;15_data.json&#x27;</span>, <span class="hljs-string">&#x27;data.txt&#x27;</span>]<br>[<span class="hljs-string">&#x27;black.txt&#x27;</span>, <span class="hljs-string">&#x27;user.txt&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;data2.txt&#x27;</span>, <span class="hljs-string">&#x27;data3.json&#x27;</span>, <span class="hljs-string">&#x27;13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;15_data.json&#x27;</span>, <span class="hljs-string">&#x27;data.txt&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>可以看到我们两次打印结果的对比，确实多了一个<code>test</code>的目录。前一个参数很好理解，重点是后一个参数，什么是权限？</p>
<p>关于系统中的文件权限，我下面所讲的仅限<code>Linux</code>系统，确切的说是<code>unix</code>，因为包括Mac一样通用：</p>
<p>来，我们先进入目录打印出来看看：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000735.png" /></p>
<p>我们主要来看一下<code>data</code>目录的<code>drwxr-xr-x</code>，分别来介绍一下：</p>
<ul>
<li>第一个字母<code>d</code>代表的是一个目录，如果是<code>-</code>呢，这表示这是一个文件</li>
<li>前三位的<code>rwx</code>代表当前目录（文件）对所有人(u)的权限</li>
<li>中间位置的<code>r-x</code>代表的所属组(g)的权限</li>
<li>末尾的三位<code>r-x</code>代表的是其他人(o)的权限</li>
<li>三个位置介绍完了我们来看字母所代表的意义：</li>
</ul>
<p><code>r,w,x</code>代表不同的操作权限，其中:</p>
<ul>
<li><code>r</code>就是可读，权限针对文件，表示可以查看文件内容，针对目录，表示可以<code>ls</code>查看目录中存在的文件名称。</li>
<li><code>w</code>就是可写，针对文件，表示可以更改文件的内容，针对目录，表示是否可以删除目录中的子文件或者子目录。</li>
<li><code>x</code>是访问权限，针对文件，表示是否可以开启文件当中记录的程序，针对目录，这表示是否可以进入该目录。</li>
</ul>
<p>那为什么是<code>777</code>呢？那是因为<code>r</code>代表是<code>4</code>,
<code>w</code>代表是<code>2</code>,
<code>x</code>代表的是<code>1</code>,
那么<code>7</code>就可以理解了，就是所有数值相加的结果。那么为什么是三个<code>7</code>呢？因为这是在设置三个不同目标的权限，三个位数分别是<strong>所有人，所有组，其他</strong>。</p>
<p>不过，大家还要注意的一点是，无法使用Python去创建一个比自己这个进程权限还要高的文件。</p>
<p><code>mkdir()</code>方法是只能创建一个文件夹，无法递归创建文件夹，而当我们需要进行递归创建该怎么办呢？也就是说，我们不仅仅是想要创建<code>test</code>文件夹，而是想创建<code>/test/a/b/c/d/e</code>该怎么办？</p>
<p><code>os.makedirs()</code>可是进行递归创建文件夹。我们先看一下当前目录结构，直接Finder来看吧：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000736.png" /></p>
<p>好，让我们执行一下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.makedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>再来看看目录结构：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000737.png" /></p>
<p>这样就能最直观的看到执行这个函数之后的结果了。</p>
<p>在创建完一些无用目录之后，我当然想着是怎么删除它们。</p>
<p><code>os.rmdir*()</code>
删除<strong>空文件夹</strong>，比如我们尝试着删除一下刚才我们创建的目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><br>---<br>OSError: [Errno <span class="hljs-number">66</span>] Directory <span class="hljs-keyword">not</span> empty: <span class="hljs-string">&#x27;./data/test&#x27;</span><br></code></pre></td></tr></table></figure>
<p>报错了，告知我们无法删除一个空目录，原因就是我们在<code>test</code>里创建了好几层文件夹，那现在<code>test</code>肯定不是空目录，那让我们从内层开始试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>没有报错，应该是成功了，我们来看看：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000738.png" /></p>
<p>确实，<code>f</code>文件夹被删除了。不过太烦了，一个个删除到什么时候去了，还不如我到<code>Finder</code>中直接手动删除呢。</p>
<p><code>os.removedirs()</code>就是一个递归删除空文件夹的函数，我们来试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.removedirs(<span class="hljs-string">&#x27;./data/test/&#x27;</span>)<br><br>---<br>OSError: [Errno <span class="hljs-number">66</span>] Directory <span class="hljs-keyword">not</span> empty: <span class="hljs-string">&#x27;./data/test/&#x27;</span><br></code></pre></td></tr></table></figure>
<p>居然又报错，告诉我们非空目录，这...</p>
<p>原来，<code>removedirs</code>方法使用必须是从后往前递归的，也就是说，我们需要将需要删除的所有目录的层级关系给到这个方法，在执行过程中，向上递归，路径中的所有空目录都会被删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.removedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>再执行一次，这回没问题了。从<code>test</code>开始，下层的所有空目录都被删除了。</p>
<p>然后就是删除文件了</p>
<p><code>os.remove()</code>就是删除文件，为了测试这个方法，我在<code>data</code>目录下创建了一个空文件<code>test.txt</code></p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000739.png" /></p>
<p>不过在删除之前，我们还是要先用一下这个文件，来看看如何改名：</p>
<p><code>os.rename()</code>: 用于修改文件或者文件夹的名字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rename(<span class="hljs-string">&#x27;./data/test.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000740.png" /></p>
<p>好了，文件用完了，现在让我们删除吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.remove(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>顺利删掉了刚才创建的文件。</p>
<p><code>os.system()</code> 执行操作系统中的命令</p>
<p>比如，我们刚才在命令行里执行过<code>ls -al</code>的命令用于查看当前目录下的所有文件及目录，包括其相关权限，那么我们在Python里可以执行吗？来试试看就知道了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;ls -al&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>执行效果如图：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000741.png" /></p>
<p>这个方法实际上不止是让你在Python中执行系统命令用的，可以用于执行其他<code>.py</code>，
也就是Python文件。比如我们创建了一个<code>hello.py</code>文件，里面写了如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello Python。&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>那么，我在其他Python文件中使用<code>os.system</code>方法就可以执行这段代码，当然，前提是你得写对路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;/file_path/hello.py&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>这样，你在其他文件内写的一个方法就被当前文件执行了。</p>
<h3 id="os.path-路径模块"><code>os.path</code> 路径模块</h3>
<p>在Python创建的整个工程或者某一个函数里，路径操作也是经常要做的事情。比如：</p>
<p><code>os.path.abspath()</code>
就是将相对路径转化为绝对路径吗，多数时候，我们是需要获取文件的绝对路径的，更多的是为了获取当前工作目录的绝对路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&#x27;./15.ipynb&#x27;</span>))<br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&#x27;./&#x27;</span>))<br><br>---<br>/Users/du/git/AI_Cheats/Python/<span class="hljs-number">15.</span>ipynb<br>/Users/du/git/AI_Cheats/Python<br></code></pre></td></tr></table></figure>
<p><code>os.path.basename()</code>，
这个方法可以获取到路径后截取返回主体部分，来看代码，一看就明白了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.abspath(<span class="hljs-string">&#x27;./15.ipynb&#x27;</span>)<br><span class="hljs-built_in">print</span>(os.path.basename(res))<br><br>---<br><span class="hljs-number">15.</span>ipynb<br></code></pre></td></tr></table></figure>
<p>截取了路径中最末尾的文件名和扩展名，如果路径上最末尾的是一个文件夹不包含文件，那获取的就是那最后一个文件夹名称。</p>
<p><code>os.path.dirname()</code>， 返回路径中主体部分之前的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.dirname(<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/data/data.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>
<p>不过使用这个方法的时候需要注意，如果你填入的是一个相对路径，它并不能打印出绝对路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.dirname(<span class="hljs-string">&#x27;./1.ipynb&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>.<br></code></pre></td></tr></table></figure>
<p><code>join()</code> 链接多个路径，组成一个新的路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.join(<span class="hljs-string">&#x27;./data/test/&#x27;</span>, <span class="hljs-string">&#x27;2.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>./data/test/<span class="hljs-number">2.</span>txt<br></code></pre></td></tr></table></figure>
<p>实际上，它更像是一个字符串拼接，因为这个方法并不会去验证路径的有效性。</p>
<p><code>split()</code>
这个方法和<code>join()</code>正好相反，用于拆分路径，把路径拆分为路径和主体部分。然后返回一个元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.split(<span class="hljs-string">&#x27;./data/test/2.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;./data/test&#x27;</span>, <span class="hljs-string">&#x27;2.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><code>splitext()</code>拆分路径，可以拆分文件后缀名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.splitext(<span class="hljs-string">&#x27;./data/test/2.jpg&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;./data/test/2&#x27;</span>, <span class="hljs-string">&#x27;.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><code>os.path.getsize()</code>获取文件的大小 , 单位是字节数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.getsize(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">91</span><br></code></pre></td></tr></table></figure>
<p><code>os.path.isdir()</code>会检测是否是一个文件夹，检测其是否存在，返回<code>True</code>或者<code>False</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.isdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p><code>os.path.isfile()</code>会检测文件是否存在，一样是返回<code>True</code>或者<code>False</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.isfile(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p><code>exists()</code>
是一个通用函数，检测路径是否存在。和以上两个不同的是，也可以检测文件，也可以检测路径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.exists(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br>res = os.path.exists(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>当我们有一个相对路径和一个绝对路径，而我们想看看两个路径是否指向一个目标位置的时候，是不是要先获取相对路径的绝对路径之后，再去对比呢？</p>
<p>其实没有那么麻烦,
只需要<code>os.path.samefile(a, b)</code>就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;./data/data.txt&#x27;</span><br>b = <span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/data/data.txt&#x27;</span><br>res = os.path.samefile(a, b)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>使用这个方法，我们需要填入的两个值是真实存在的路径。</p>
<p>当然，官方的文档内还有更多的函数，我这里仅仅是列出了一些常用的。大家可以去官方文档内去看看。</p>
<h3 id="shutil高级操作模块"><code>shutil</code>高级操作模块</h3>
<p><code>shutil</code>模块对文件和文件集合提供了许多的高级操作。其中就有支持文件复制和删除的一些功能。</p>
<p>要说，其实<code>shutil</code>这个模块的很多方法和<code>Unix</code>里的<code>shell util</code>都一样，所以会用命令行的小伙伴，对这个模块应该是极其容易上手：</p>
<p><code>shutil.copy()</code>，
一看就明白是干什么的是吧？就是将文件拷贝到指定目录的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br><br>---<br>FileNotFoundError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span><br></code></pre></td></tr></table></figure>
<p>报错了，咋回事？看提示，应该目录或文件不存在。嗯，这个方法要操作之前，目标路径中的目录是必须存在的，它无法自动创建目录。</p>
<p>让我们手动创建目录之后再试试，
还记得我们之前创建目录的命令怎么做吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">os.mkdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br>shutil.copy(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span><br></code></pre></td></tr></table></figure>
<p>有返回值了，那我们操作应该完成了。走，去目录里看看：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000742.png" /></p>
<p>确实，目录和文件都存在了，这里注意我标注的两个文件，<code>copy</code>这个命令指示拷贝了一个副本到目标目录中，原文件还是存在于原来的位置。但是注意到时间了吗？修改时间被更改了，改为了我们执行当前操作的时间。</p>
<p><code>copy2</code>是另外一个拷贝方法，它所有功能和<code>copy</code>都一样，但是如果真是一模一样的方法，也就没必要多创建一个了对吧？这个方法最大的不同，就是保留了原文件的信息，包括操作时间和权限等。</p>
<p>再让我们操作一下试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy2(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000743.png" /></p>
<p>除了这两个拷贝方法外，还有一个拷贝方法<code>copyfile()</code>，
专门用于拷贝文件中的内容，写入到新的文件中去。让我们在<code>./data/test/</code>中新建一个<code>data2.txt</code>文件来接收写入内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copyfile(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data2.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>我们来打开<code>data2.txt</code>之后查看一下内容，确实写入了：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000744.png" /></p>
<p><code>shutil.copytree('./a', './b')</code>方法看名字应该就猜到是干什么的，是将整个目录结构全部拷贝到指定目录中。使用的时候要多注意，指定的目标目录必须不存在同名目录。</p>
<p><code>shutil.rmtree()</code>，我们之前有用到带<code>rm</code>的方法，那么看名字也就知道了，这个方法是删除整个文件夹，包括文件夹下的所有目录和文件，和之前我们使用的<code>removedirs</code>不同，这个方法并不是从下往上递归，而是直接全部删除。让我再创建一次多级目录才测试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.makedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>目录创建完成后，来让我们将整个<code>test</code>文件夹全部删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.rmtree(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>执行成功，<code>test</code>整个目录及其内部文件全部删除了。</p>
<p>我们最后再来看一个用的非常多的方法<code>shutil.move()</code>，
我们都知道，<code>windows</code>中有剪切和复制两种菜单命令，然后到新的目标目录后进行粘贴，如果是剪切命令，这原目录中文件会在粘贴完成后删除，而如果是复制，不会执行删除。<code>Linux</code>的逻辑稍微有些不同，是先进行拷贝，然后在目标目录之后决定是粘贴还是移动，如果是粘贴的话就保留原目录的文件，如果是移动，则会在粘贴完成之后在原位置删除文件。</p>
<p>虽然逻辑上有些许不同，但是不管是<code>Windows</code>还是<code>Linux</code>(包括Mac)，如果是移动某个文件的时候都遵循的是先复制一份到目标目录之后，再把原文件删除的先后顺序。</p>
<p>其实<code>move()</code>命令也是一样的逻辑，
基于这个逻辑，<code>move</code>实际上也可以用于修改文件夹或文件的名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.move(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/data_copy.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>然后我们去看一下：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000745.png" /></p>
<p>可以看到，执行成功了。我们多注意一下就会发现，<code>move</code>命令也有和<code>copy2</code>相同的特性，将原文件的信息保留了下来。</p>
<h2 id="zipfile压缩模块"><code>zipfile</code>压缩模块</h2>
<p>ZIP文件格式基本是互联网上最通用的一种压缩格式，常见的存档和压缩标准。该模块提供了用于创建，读取，写入，附加和列出ZIP文件的工具。</p>
<p>在日常使用中，我们也会经常用到这个模块的相关功能。和之前介绍方法不同，我们这一部分按需求来介绍：</p>
<h3 id="压缩文件">压缩文件</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile, os<br><br><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> myzip:<br>    myzip.write(<span class="hljs-string">&#x27;./data/data_copy.txt&#x27;</span>)<br>    myzip.write(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>)<br>    myzip.write(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>有没有发现，其方法和我们在对文件进行读写操作的时候很像，逻辑就是先创建一个压缩包文件，然后往里面扔入对应的文件。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000746.png" /></p>
<h3 id="解压缩文件">解压缩文件</h3>
<p>压缩之后，我们这次解压缩来看看压缩包内的文件是不是我们刚才扔进去的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> myzip:<br>    myzip.extractall(<span class="hljs-string">&#x27;./data2&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>执行之后结果：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000747.png" /></p>
<p>文件的确都是原来的文件。</p>
<h3 id="批量压缩">批量压缩</h3>
<p>不过之前压缩文件的时候也太麻烦了，文件一个一个的列出来扔进压缩包，那有没有办法将指定文件夹中的文件全部打包呢？</p>
<p>当然没问题，既然我们嫌弃手动一个个添加文件名太麻烦，那我们直接用机器添加不就好了，怎么做呢？</p>
<p>首先第一步当然是获取文件夹下所有的文件，应该还记得<code>listdir()</code>这个方法吧？才学的。</p>
<p>获取列表之后，我们直接用代码一个个的扔到压缩包内就可以了，用<code>for</code>循环吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED) <span class="hljs-keyword">as</span> myzip:<br>    <span class="hljs-comment"># 获取当前目录中的所有的项</span><br>    arr = os.listdir(<span class="hljs-string">&#x27;./&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>        myzip.write(i)<br>        <br>---<br>[<span class="hljs-string">&#x27;12.ipynb&#x27;</span>, <span class="hljs-string">&#x27;10.ipynb&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;15_json.html&#x27;</span>, <span class="hljs-string">&#x27;14.ipynb&#x27;</span>, <span class="hljs-string">&#x27;8.ipynb&#x27;</span>, <span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;14.py&#x27;</span>, <span class="hljs-string">&#x27;11.ipynb&#x27;</span>, <span class="hljs-string">&#x27;globals.ipynb&#x27;</span>, <span class="hljs-string">&#x27;13.ipynb&#x27;</span>, <span class="hljs-string">&#x27;Kalman.ipynb&#x27;</span>, <span class="hljs-string">&#x27;9.ipynb&#x27;</span>, <span class="hljs-string">&#x27;15.ipynb&#x27;</span>, <span class="hljs-string">&#x27;7.ipynb&#x27;</span>, <span class="hljs-string">&#x27;5.ipynb&#x27;</span>, <span class="hljs-string">&#x27;1.ipynb&#x27;</span>, <span class="hljs-string">&#x27;3.ipynb&#x27;</span>, <span class="hljs-string">&#x27;4.ipynb&#x27;</span>, <span class="hljs-string">&#x27;6.ipynb&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;2.ipynb&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>通过将打印出来的<code>arr</code>我们可以看到所有被成功扔进压缩包的内容。</p>
<h3 id="其他压缩方法">其他压缩方法</h3>
<p><code>zipfile</code>是Python中内置的专门用于压缩<code>zip</code>格式压缩包的方法，但是其实，我们并不限于压缩成<code>zip</code>格式。那是不是还有<code>rarfile</code>,
<code>7zfile</code>等模块呢？那真是想多了，我们刚才学过的<code>shutil</code>方法，就可以进行压缩操作。不过不一样的是，虽然效果是一样的，但是我们这个方法是<strong>创建归档</strong>:</p>
<p><code>shutil.make_archive()</code>，
用于创建一个压缩文档。这个方法中有三个比较重要的参数，一个是创建的归档文件名称，第二个是指定的归档格式，第三个则是要归档的文件或文件夹路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.make_archive(<span class="hljs-string">&#x27;temp&#x27;</span>, <span class="hljs-string">&#x27;tar&#x27;</span>, <span class="hljs-string">&#x27;./data&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311252000748.png" /></p>
<p>成功完成<code>tar</code>格式的归档。</p>
<p>除了以上的这些介绍的内置模块之外，我们平时应用中还会用到许多其他的模块，比如日历模块<code>calendar</code>，时间模块<code>time</code>等等。我上方讲解模块使用的同时，更多的是想向大家传递一个思想就是内置模块基本都很易上手，并且就算一时之间不太明白，可以多看看官方文档。从官方文档上学习是一个很好的习惯。我们可以从官方<a
target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/py-modindex.html">Python模块索引</a>中去找到自己需要的模块。</p>
<p>好了，那这节课就先到这里了，下一节课中，我们利用日历和时间模块来做一个练习：万年历。大家要提前做预习，去官方文档好好学习一下其相关模块，包括<code>calendar</code>、<code>datetime</code>、<code>time</code>等.</p>
<p>那小伙伴们，让我们下节课练习再见吧。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>15. 系统内置模块</p><p><a href="https://hivan.me/System-built-in-modules/">https://hivan.me/System-built-in-modules/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hivan Du</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-08-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6479444288ae9600196fa98e&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://afdian.net/item/72907364008511ee904852540025c377" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://qiniu.hivan.me/picGo/20230601221633.jpeg" alt="支付宝"></span></a><a class="button donate" href="https://www.buymeacoffee.com/hivandu" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="https://patreon.com/user?u=89473430" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="paypal" onclick="document.getElementById(&#039;paypal-donate-form&#039;).submit()"><span class="icon is-small"><i class="fab fa-paypal"></i></span><span>Paypal</span></a><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" rel="noopener" id="paypal-donate-form"><input type="hidden" name="cmd" value="_donations"><input type="hidden" name="business" value="doo@hivan.me"><input type="hidden" name="currency_code" value="USD"></form><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://qiniu.hivan.me/IMG_4603.JPG" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Exercise-perpetual-calendar/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">16. 练习：万年历</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Exercise-register-system/"><span class="level-item">14. 练习：登录注册系统</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://hivan.me/System-built-in-modules/';
            this.page.identifier = 'System-built-in-modules/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'hivan' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/bdff168cf8a71c11d2712a1679a00c54?s=128" alt="茶桁"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">茶桁</p><p class="is-size-6 is-block">AI游民</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shang Hai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">210</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hivandu" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hivandu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/hivan"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/hivan"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com/hivan"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NzE4MDQzMg==&amp;action=getalbum&amp;album_id=2932504849574543360&amp;scene=173&amp;from_msgid=2648747980&amp;from_itemidx=1&amp;count=3&amp;nolastread=1&amp;token=1758883909&amp;lang=zh_CN#wechat_redirect"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/column/c_1424326166602178560" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">塌缩的奇点</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/column/hivandu" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">茶桁-知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/"><span class="level-start"><span class="level-item">AI秘籍</span></span><span class="level-end"><span class="level-item tag">68</span></span></a><ul><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/BI/"><span class="level-start"><span class="level-item">BI</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">核心能力基础</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="level-start"><span class="level-item">从零开始接触人工智能大模型</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-09T23:30:00.000Z">2024-01-10</time></p><p class="title"><a href="/04.%20BI%20-%20LightGBM%20vs%20CatBoost%EF%BC%8C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"> </a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/BI/">BI</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-06T23:30:00.000Z">2024-01-07</time></p><p class="title"><a href="/03.%20BI%20-%20XGBoost/">03. BI - XGBoost</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/BI/">BI</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-02T23:30:00.000Z">2024-01-03</time></p><p class="title"><a href="/02.%20BI%20-%20%E7%94%B7%E5%A5%B3%E5%A3%B0%E9%9F%B3%E8%AF%86%E5%88%AB/">02. BI - Project Two, 男女声音识别</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/BI/">BI</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-02T11:00:00.000Z">2024-01-02</time></p><p class="title"><a href="/Tea%20Truss&#039;s%20AI%20cheats%20math%20PDF%20release%20download/">茶桁的AI秘籍 - 数学篇 PDF发布下载</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/Math/">Math</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-30T23:30:00.000Z">2023-12-31</time></p><p class="title"><a href="/01.%20BI%20-%20%E5%91%98%E5%B7%A5%E7%A6%BB%E8%81%8C%E9%A2%84%E6%B5%8B/">01. BI - Project one, 员工离职预测</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/BI/">BI</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="茶桁.MAMT" height="28"></a><p class="is-size-7"><span>&copy; 2024 Hivan Du</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hivandu"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>