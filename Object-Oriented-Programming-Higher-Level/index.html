<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>22. 面向对象 - 高阶 - 茶桁.MAMT</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="茶桁.MAMT"><meta name="msapplication-TileImage" content="https://qiniu.hivan.me/picGo/20230601174411.png?imgNote"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="茶桁.MAMT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Hi，大家好。我是茶桁。"><meta property="og:type" content="blog"><meta property="og:title" content="22. 面向对象 - 高阶"><meta property="og:url" content="https://hivan.me/Object-Oriented-Programming-Higher-Level/"><meta property="og:site_name" content="茶桁.MAMT"><meta property="og:description" content="Hi，大家好。我是茶桁。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-08-17T03:38:54.000Z"><meta property="article:modified_time" content="2023-11-25T11:57:38.431Z"><meta property="article:author" content="Hivan Du"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:creator" content="@hivan"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hivan.me/Object-Oriented-Programming-Higher-Level/"},"headline":"22. 面向对象 - 高阶","image":[],"datePublished":"2023-08-17T03:38:54.000Z","dateModified":"2023-11-25T11:57:38.431Z","author":{"@type":"Person","name":"Hivan Du"},"publisher":{"@type":"Organization","name":"茶桁.MAMT","logo":{"@type":"ImageObject","url":"https://hivan.me/img/logo.svg"}},"description":"Hi，大家好。我是茶桁。"}</script><link rel="canonical" href="https://hivan.me/Object-Oriented-Programming-Higher-Level/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="茶桁.MAMT" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="茶桁.MAMT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hivandu"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-08-17T03:38:54.000Z" title="8/17/2023, 11:38:54 AM">2023-08-17</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a><span> / </span><a class="link-muted" href="/categories/AI%E7%A7%98%E7%B1%8D/Python/">Python</a></span></div></div><h1 class="title is-3 is-size-4-mobile">22. 面向对象 - 高阶</h1><div class="content"><p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311251957534.png" /></p>
<p>Hi，大家好。我是茶桁。</p>
<span id="more"></span>
<p>之前的课程里面，我们简单的接触了面向对象编程，也和大家讲解了其思想，优缺点。相信上节课程结束之后，大家对面向对象都有了一定的理解。</p>
<p>那么我们这节课，就进入面向对象的一些高阶部分，让我们继续来学习一些魔术方法以及Python的内置成员，然后再来学习一下描述符与设计模式。</p>
<ol type="1">
<li>内置成员</li>
<li>魔术方法</li>
<li>描述符</li>
<li>设计模式</li>
</ol>
<p>好，正课走起。让我们开始。</p>
<h2 id="内置成员">内置成员</h2>
<p>当我们创建一个类之后，即便我们还什么都没做，这个类里面就已经有内容了，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 获取类/对象的所属成员</span><br>res = Demo.__dict__<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure>
<p>上节课我们学过了<code>__dict__</code>，
这个是获取类或者对象的成员的方法。打印结果我们看到其中的成员。</p>
<p>让我们添加些内容再来观察一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    name = <span class="hljs-string">&#x27;a&#x27;</span><br>    age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;say something&#x27;</span>)<br><br><span class="hljs-comment"># 获取类/对象的所属成员</span><br>res = Demo.__dict__<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Demo.say at <span class="hljs-number">0x1117a3e20</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure>
<p>看到我们刚才定义的成员属性和成员方法也都在列了。我们还可以实例化之后获取对象的成员：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = Demo()<br><span class="hljs-built_in">print</span>(obj.__dict__)<br><br>---<br>&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>当我们实例化一个对象<code>obj</code>之后，打印发现其成员是空的。这是为什么？</p>
<p>原因就在于，这个方法用处其实是打印其对象的专有成员。我们再来为这个实例化对象创建一些成员再来看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.sex = <span class="hljs-string">&#x27;female&#x27;</span><br><span class="hljs-built_in">print</span>(obj.__dict__)<br><br>---<br>&#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;<br></code></pre></td></tr></table></figure>
<p>可以看到，我们获取了刚才创建的成员属性。</p>
<p>以上，就是我们使用<code>__dict__</code>获取了类和对象的所属成员，方法为：<code>类/对象.__dict__</code>。</p>
<p>除了获取所属成员，我们还有其他方法，比如获取「文档信息」，
获取「类名称」，
获取「所在文件名称」，获取「当前类的父类列表」以及获取「当前类的『继承链』。来让我们依次看一下：</p>
<p>还记得我们之前在创建函数的时候可以添加文档吗？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">obj</span>():<br>  <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">  这里是文档内容</span><br><span class="hljs-string">  &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure>
<p>同样的，类当中我们一样可以添加文档内容。然后我们可以通过<code>__doc__</code>来获取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    这里是一个Demo类，主要用于测试</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(Demo.__doc__)<br><br>---<br>这里是一个Demo类，主要用于测试<br></code></pre></td></tr></table></figure>
<p>同样的，<code>__doc__</code>不仅可以获取类的文档信息，同样可以获取到对象的。</p>
<p>我们使用<code>__name__</code>来获取类名称「组成的字符串」,
<strong>这个方法无法对对象使用。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Demo.__name__)<br><br>---<br>Demo<br></code></pre></td></tr></table></figure>
<p><code>__module__</code>可以用来获取类/对象所在的文件名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Demo.__module__)<br><span class="hljs-built_in">print</span>(obj.__module__)<br><br>---<br>__main__<br>__main__<br></code></pre></td></tr></table></figure>
<p>如果其所在文件为当前文件，那么这里就会显示为<code>__main__</code>。</p>
<p>然后是<code>__base__</code>，
这个方法是用来获取当前类的父类列表。这个方法有两个版本，一个是<code>__base__</code>,
一个是<code>__bases__</code>。这两个方法的区别在于一个是获取继承的第一个父类，一个是继承所有的父类的列表，为了呈现的更明显，我们建立一个继承类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Demo</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(A, Demo):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(B.__base__)<br><span class="hljs-built_in">print</span>(B.__bases__)<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure>
<p>还有一个就是我们上节课讲过的，MRO列表，也就是<code>__mro__</code>方法，用于获取当前类的继承链。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(B.__mro__)<br><br>---<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure>
<p>到此为止，我们介绍的就是常用的一些内置成员获取的一些方法。当然，这里不是全部，除此之外还有很多，因为并不是常用，所以这里我们就不多介绍了。</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311251957535.png" /></p>
<h2 id="方法的分类">方法的分类</h2>
<p>接下来呢，我们来看下面向对象的分类，包括：</p>
<ol type="1">
<li>对象方法</li>
<li>类方法</li>
<li>绑定类方法</li>
<li>静态方法</li>
</ol>
<p><strong>对象方法</strong></p>
<p>其特征为： 1. 在类中定义方法，含有<code>self</code>参数 2.
含有<code>self</code>的方法，只能使用对象进行调用。 3.
该方法会把调用的对象传给进来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-comment"># 对象方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">objFunc</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is objFunc&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.objFunc()<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1171460e0</span>&gt;<br>this <span class="hljs-keyword">is</span> objFunc<br></code></pre></td></tr></table></figure>
<p>这个方法不能直接使用类直接调用，但是其实也不是绝对的。当我们使用类直接调用的时候，需要传递一个参数，也就是必须要<code>self</code>有参数可接收。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Demo.objFunc(<span class="hljs-string">&#x27;a&#x27;</span>)<br><br>---<br>a<br>this <span class="hljs-keyword">is</span> objFunc<br></code></pre></td></tr></table></figure>
<p><strong>类方法</strong></p>
<p>类方法呢，和对象方法有不一样的地方，也有相同的地方。两者定义十分相似，不同之处是使用装饰器材：</p>
<p>其特征为：</p>
<ol type="1">
<li>在类中定义的方法，使用了<code>@classmethod</code>进行了装饰</li>
<li>方法中有形参<code>cls</code></li>
<li>可以不用实例化对象，直接使用类进行调用</li>
<li>会把调用这个方法的类或对象传递进来</li>
</ol>
<p>来直接看代码理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 类方法</span><br><span class="hljs-meta">    @classmethod </span><span class="hljs-comment"># 装饰器</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clsFunc</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(cls)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is cls function: clsFunc&#x27;</span>)<br><br>Demo.clsFunc()<br>obj.clsFunc()<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;<br>this <span class="hljs-keyword">is</span> cls function: clsFunc<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;<br>this <span class="hljs-keyword">is</span> cls function: clsFunc<br></code></pre></td></tr></table></figure>
<p>看结果可以看到，我们用类进行调用的时候并没有像对象方法一样传递一个参数进去，这是因为调用的时候会直接传递调用的类给到<code>cls</code>参数。
而我们说不需要实例化对象，并不是实例化对象不可调用。对象调用也是可以的。</p>
<p>至于什么是「装饰器」，我们以后会详细讲到，这里先记住这种形式就可以了。</p>
<p><strong>绑定类方法</strong></p>
<p>这个方法不传递任何对象和类。在定义的时候，不设定任何的形参：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># 绑定类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bindClassFunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is bind Class function: bindClassFunc&#x27;</span>)<br><br><span class="hljs-comment"># 调用</span><br>Demo.bindClassFunc()<br><br>---<br>this <span class="hljs-keyword">is</span> bind Class function: bindClassFunc<br></code></pre></td></tr></table></figure>
<p>那么绑定类方法既然没有定义形参，那么这个方法是无法使用实例化对象来调用的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.bindClassFunc()<br><br>---<br>TypeError: Demo.bindClassFunc() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure>
<p>其特征如下： 1. 在类中定义的方法，不必须设置形参。 2.
只能使用类进行调用。 3.
可以传递任意参数，但是不会将类作为参数传递进来。</p>
<p><strong>静态方法</strong></p>
<p>「静态类方法」和「类方法」相似，也需要一个装饰器。并且，静态类方法也是不需要设置形参的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-comment"># 静态类方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">staticFunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is static method func&#x27;</span>)<br><br>Demo.staticFunc()<br>obj.staticFunc()<br><br>---<br>this <span class="hljs-keyword">is</span> static method func<br>this <span class="hljs-keyword">is</span> static method func<br></code></pre></td></tr></table></figure>
<p>那从结果中我们可以看到，「静态类方法」可以使用类和对象进行调用，并且调用的时候不需要传递任何参数。</p>
<p>其特征如下： 1. 在类中定义的方法，使用装饰器
<code>@staticmethod</code> 进行了装饰 2. 可以使用对象或者类进行调用 3.
不会将对象或者类作为参数传递进来</p>
<blockquote>
<p>⚠️
注意：这里我们需要注意的，「静态类方法」只是可以不设置参数，并不是不能设置参数，并且，就算是设置了参数之后，也是不接受类和对象作为参数传递的。比如：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">staticFunc</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a:<span class="hljs-subst">&#123;a&#125;</span>, b:<span class="hljs-subst">&#123;b&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is static method func&#x27;</span>)<br><br><span class="hljs-comment"># 调用</span><br>Demo.staticFunc(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>)<br>obj.staticFunc(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;obj&#x27;</span>)<br><br>---<br>a:static, b:<span class="hljs-keyword">class</span><br><span class="hljs-title class_">this</span> <span class="hljs-keyword">is</span> static method func<br>a:static, b:obj<br>this <span class="hljs-keyword">is</span> static method func<br></code></pre></td></tr></table></figure>
<p>我们分别用类和对象进行了调用并传递了两个参数进行打印，而打印结果正常，并且没有对象或者类被传递。</p>
<p>相应的，「绑定类方法」也是这种特性，只是「绑定类方法」只支持类调用，不支持对象调用。</p>
<h2 id="常用函数">常用函数</h2>
<p>其实在之前，关于「常用函数」我们已经接触过了一些，比如：<code>issubclass(子类，父类)</code>。有些小伙伴可能还记得，这个函数是用于检测一个类是否为另一个类的子类。</p>
<p>那除了这个之外，Python中还有很多其他的一些针对类和对象的常用函数，下面让我们来详细看一下。</p>
<p><code>isinstance(对象，类)</code>，
用于检测一个对象是否是该类或者该类的子类的实例化结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = D()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, D))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>这个结果显而易见，那么我们思考一下，既然<code>D</code>类继承了<code>B</code>类和<code>C</code>类，那么<code>obj</code>对象是否也是<code>B</code>或者<code>C</code>的实例化结果呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, B))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>可见，对于继承了父类的子类，其实例化对象和父类之间也会被检测为<code>True</code>。</p>
<p><code>hasattr(对象/类,'成员名称')</code>，
这个函数是用于检测类/对象是否包含指定名称的成员。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">B.name = <span class="hljs-string">&#x27;张三&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>在这段代码中，我们给父类<code>B</code>添加了一个成员属性<code>name</code>，因为<code>obj</code>是<code>D</code>的实例化对象（之前的代码中）。而<code>D</code>类是继承自<code>B</code>类的，所以自然<code>obj</code>中也是包含了<code>name</code>这个成员属性的。所以我们的检测结果必然为<code>True</code>。</p>
<p>来，我们做另外一个实验：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">objB = B()<br>D.age = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(D.age)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(objB, <span class="hljs-string">&#x27;age&#x27;</span>))<br><br>---<br><span class="hljs-number">20</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>我们重新用<code>B</code>类实例化了一个对象<code>objB</code>，
然后我们给<code>D</code>类添加了一个成员属性<code>age</code>，并且打印了一遍证实其存在。这个时候我们检测了一下<code>objB</code>中是否含有<code>age</code>，
因为<code>D</code>为<code>B</code>的子类，它说添加的成员属性为独有属性，并不会更改到<code>B</code>类里，那自然<code>B</code>的实例化对象<code>objB</code>中是不可能存在这个成员属性的，结果自然为<code>False</code>。</p>
<p>``</p>
<p><code>getattr(对象/类,'成员名称')</code>,
用于获取类/对象的成员的值</p>
<p>那这个函数就好理解了，我们可以用之前建立好的实例化对象<code>objB</code>和<code>obj</code>来获取一下试试看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;age&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(objB, <span class="hljs-string">&#x27;name&#x27;</span>))<br><br>---<br><span class="hljs-number">20</span><br>张三<br></code></pre></td></tr></table></figure>
<p>没问题，结果如我们所料一般。那如果是获取<code>objB</code>中的<code>age</code>的值会如何？我们前面已经知道，<code>objB</code>中并未存在<code>age</code>这个成员属性，所以必然会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(objB, <span class="hljs-string">&#x27;age&#x27;</span>))<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure>
<p><code>setattr(对象/类,'成员名称','成员的值')</code>,
这个函数用于设置类/对象的成员的属性值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>))<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br>du<br></code></pre></td></tr></table></figure>
<p>如结果所见，这个方法的返回值为<code>None</code>，但是我们通过打印<code>obj.name</code>可知，方法确实更改了<code>obj</code>中<code>name</code>的值。</p>
<p><code>delattr(类/对象,'成员名称')</code>
这个函数可以删除类/对象的成员属性，和<code>del</code>直接删除对象的成员是一样的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">delattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>))<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br>张三<br></code></pre></td></tr></table></figure>
<p>可见，这个方法也是没有返回值的，返回了<code>None</code>。
不过，既然我们已经删除了<code>obj</code>中的<code>name</code>，
为啥还能打印出<code>张三</code>呢？有没有小伙伴知道为什么？
其实，我们删除的<code>name</code>是之前使用<code>setattr</code>为<code>obj</code>设定的专有成员，当它被删除之后，我们的<code>obj</code>的继承类<code>D</code>中还存在着<code>name</code>这个成员属性，所以现在打印出来的<code>张三</code>是从<code>D</code>类中继承过来的。</p>
<p>那如果是我们新添加的但是其他类中没有的属性就会直接报错了，来看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.size)<br><span class="hljs-built_in">delattr</span>(obj, <span class="hljs-string">&#x27;size&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.size)<br><br>---<br>small<br>AttributeError: <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;size&#x27;</span><br></code></pre></td></tr></table></figure>
<p>我们分别打印了两次，第一次<code>setattr</code>了一个成员属性<code>size</code>，并且打印验证了。然后我们执行<code>delattr</code>，删除了刚才设置的成员属性<code>size</code>，这次再打印来看，报错了。</p>
<p><code>dir()</code>这个函数可以获取当前对象所有可以访问的成员的列表。正好，让我们来看看是否从还存在从<code>B</code>类中继承的成员属性<code>name</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">dir</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>可以看到打印结果的最后面，确实还存在着<code>name</code>这个成员属性。</p>
<p>以上函数在讲解的过程中，我们使用的都是成员属性，而成员方法其实是一样的。因为这几个函数说针对的对象都是「成员」。</p>
<p>另外需要注意的一点是，以上所有这些常用函数，都是在可访问的情况下才可执行。我们还有一些不可访问的情况，比如说「私有成员属性」，这种成员是无法被访问或者操作的，我们随便拿个函数来举一个例子看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>():<br>    name = <span class="hljs-string">&#x27;张三&#x27;</span><br>    _age = <span class="hljs-number">25</span><br>    __sex = <span class="hljs-string">&#x27;female&#x27;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Sex:<span class="hljs-subst">&#123;__sex&#125;</span>&#x27;</span>)<br><br>obj = D()<br><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;__sex&#x27;</span>)<br><br>---<br>Sex:female<br>AttributeError: <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__sex&#x27;</span><br></code></pre></td></tr></table></figure>
<p>可以看到，当我们意图用<code>getattr</code>来获取实例化对象<code>obj</code>中的<code>__sex</code>属性时报错了。无法正确访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">dir</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_D__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure>
<p>当我们使用<code>dir()</code>来查看的时候，其中也并没有<code>__sex</code>这个成员属性，有的只是类的私有成员属性:<code>_D__sex</code>，
我们需要借助类从内部才可访问到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;_D__sex&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;female&#x27;</span><br></code></pre></td></tr></table></figure>
<p>这样是可以的。</p>
<h2 id="魔术方法">魔术方法</h2>
<p>我们在这节课之前，讲到过「魔术方法」，
那我们已经了解，魔术方法是不需要手动调用就可以自动执行的方法。</p>
<p>那我们之前已经讲解过<code>__init__</code>，这是一个初始化方法。然后还有一个<code>__del__</code>方法，是一个销毁方法。</p>
<p>这两个方法除了功能上的不同之外，还有一个最大的不同点就是被触发的机制是不一样的。其实，魔术方法中，最重要的一点就是要了解方法的触发机制是什么。</p>
<p>让我们先列出来常用的魔术方法，包括其触发机制，作用以及参数等等...</p>
<ol type="1">
<li><code>__init__</code>， 初始化方法, <code>*****</code></li>
</ol>
<p><strong>触发机制：</strong>当实例化对象之后就会立即触发的方法
<strong>作用：</strong>为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，
方法的调用， 打开或者创建一些资源等等。
<strong>参数：</strong>一个<code>self</code>，
接收当前对象，其他参数根据需求进行定义即可。 <strong>返回值：</strong>无
<strong>注意事项：</strong>无</p>
<ol start="2" type="1">
<li><code>__new__</code>，构造方法, <code>****</code></li>
</ol>
<p><strong>触发机制：</strong>实例化对象时自动触发（在<code>__init__</code>之前触发）
<strong>作用：</strong>管理控制对象创建的过程
<strong>参数：</strong>一个<code>cls</code>接收当前类，其它参数根据初始化方法的参数进行决定
<strong>返回值：</strong>必须返回<code>object.__new__(cls)</code>进行对象的创建，如果没有返回值，则实例化对象的结果为<code>None</code>
<strong>注意事项：</strong>
<code>__new__</code>方法的参数和<code>__init__</code>方法的参数要保持一致，除了第一个参数。必须返回<code>object.__new__(cls)</code>进行对象的创建，如果没有返回值，则实例化对象的结果为<code>None</code>
<strong>应用场景：</strong>设计模式中的单例设计模式。</p>
<ol start="3" type="1">
<li><code>__del__</code>，析构方法, <code>*****</code></li>
</ol>
<p><strong>触发机制：</strong>当该类对象被销毁时，自动触发
<strong>作用：</strong> 关闭或释放对象创建时打开或创建的一些资源
<strong>参数：</strong> 一个<code>self</code>，接受当前的对象
<strong>返回值：</strong>无 <strong>注意事项：</strong> 无</p>
<ol start="4" type="1">
<li><code>__call__</code> , <code>***</code></li>
</ol>
<p><strong>触发机制:</strong> 把对象当作函数直接调用时自动触发
<strong>作用:</strong> 一般用于归纳类或对象的操作步骤，方便调用
<strong>参数</strong>：一个<code>self</code>接收当前对象，其它参数根据调用需求缺点
<strong>返回值</strong>：可有可无</p>
<p>5.<code>__len__</code></p>
<p><strong>触发机制:</strong>
当使用<code>len</code>函数去检测当前对象的时候自动触发
<strong>作用:</strong>
可以使用<code>len</code>函数检测当前对象中某个数据的信息
<strong>参数</strong>: 一个<code>self</code>接收当前对象
<strong>返回值</strong>：必须有，并且必须是一个整型
<strong>注意事项</strong>：<code>len</code>要获取什么属性的值，就在返回值中返回哪个属性的长度即可</p>
<p>6.<code>__str__</code></p>
<p><strong>触发机制:</strong>
当使用<code>str</code>或者<code>print</code>函数对对象进行操作时自动触发
<strong>作用:</strong> 代码对象进行字符串的返回，可以自定义打印的信息
<strong>参数</strong>：一个<code>self</code>，接收当前对象
<strong>返回值</strong>：必须有，而去必须是字符串类型的值</p>
<p>7.<code>__repr__</code></p>
<p><strong>触发机制:</strong>
在使用<code>repr</code>方法对当前对象进行转换时自动触发
<strong>作用:</strong> 可以设置<code>repr</code>函数操作对象的结果
<strong>参数</strong>： 一个<code>self</code>，接收当前对象
<strong>返回值</strong>： 必须有，而去必须是字符串类型的值
<strong>注意</strong>：正常情况下，如果没有<code>__str__</code>这个魔术方法，<code>__repr__</code>方法就会代替<code>__str__</code>魔术方法</p>
<p>8.<code>__bool__</code></p>
<p><strong>触发机制:</strong>
当前使用<code>bool</code>函数转换当前对象时，自动触发.默认情况下，对象会转为<code>True</code>
<strong>作用:</strong>
可以代替对象进行<code>bool</code>类型的转换，可以转换任何数据
<strong>参数</strong>: 一个<code>self</code>接收对象
<strong>返回值</strong>： 必须是一个布尔类型的返回值</p>
<p>以上，我们把常用魔术方法都列出来之后，然后我们来些代码进行讲解。让我们先创建一个<code>Person</code>类，然后在其中协商构造方法，初始化方法和析构方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-built_in">print</span>(kwargs)<br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发初始化方法:__init__&#x27;</span>)<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发了析构方法:__del__&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>&#123;&#125;<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>当我们完成实例化的时候，「构造方法」先是用<code>*args</code>接收了所有传递的参数，并且使用存储了元组。我们可以看到，<code>**kwargs</code>什么都没接收到，所以打印为空。</p>
<p>当「构造方法」执行完之后，也并没有去执行「初始化方法」和「析构方法」，这又是为什么呢？这是因为如果在「构造方法」中没有返回对象，这对象无法创建。要想对象进行创建，这我们必须返回<code>object.__new__(cls)</code>进行对象的创建。这在之前「构造方法」的说明里有说明。这个<code>cls</code>参数是什么呢？我们直接来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-comment"># print(kwargs)</span><br>        <span class="hljs-built_in">print</span>(cls)<br>        <span class="hljs-comment"># 如果该方法中没有返回对象，则无法创建对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__new__(cls)<br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发初始化方法:__init__&#x27;</span>)<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发了析构方法:__del__&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Person&#x27;</span>&gt;<br>触发初始化方法:__init__<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107f3c070</span>&gt;<br></code></pre></td></tr></table></figure>
<p>现在可以看到，我们打印了<code>cls</code>，
实际上就是<code>Person</code>这个类。当我们返回<code>object.__new__(cls)</code>之后，可以看到<code>__init__</code>初始化方法正确运行了，执行了方法内的打印方法。然后最后，我们打印了<code>zs</code>这个实例化对象。那为什么<code>__del__</code>析构方法没有触发？因为我们是在<code>Jupyter</code>中执行，并未执行释放，此时我们如果<code>del zs</code>，则会触发析构方法，或者，我们讲上述代码保存为一个<code>22.py</code>文件，然后单独执行，这个时候Python的垃圾回收机制会执行，就会进行释放，从而触发析构方法。如下图：</p>
<p><img
src="https://cdn.jsdelivr.net/gh/hivandu/notes/img/202311251957536.png" /></p>
<p>我们接着上面写的代码在<code>22.py</code>中继续写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">zs()<br><br>---<br>TypeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span><br></code></pre></td></tr></table></figure>
<p>报警，告知我们这个类当中没有cllable。那如果我们讲这个类改造下，加上<code>__call__</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 魔术方法</span><br><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        ...<br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">slef, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你把对象当成了函数进行调用。&#x27;</span>)<br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        ...<br><br><span class="hljs-comment"># 实例化对象</span><br>...<br>zs()<br><br>---<br>...<br>你把对象当成了函数进行调用。<br>触发了析构方法:__del__<br></code></pre></td></tr></table></figure>
<p>这样，我们直接执行<code>zs()</code>就没问题了，可以把对象当作函数直接调用时自动触发。</p>
<p>让我们继续，返回到<code>22.ipynb</code>笔记本文件中，让我们重新定义一个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">len</span>(obj)<br><br>---<br>TypeError: <span class="hljs-built_in">object</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;Demo&#x27;</span> has no <span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure>
<p>报错信息中可以看出，这个实例化对象是没有<code>len()</code>方法的。我们如果给它加上<code>__len__</code>之后就会让其拥有<code>len()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>因为当前我们在类中定义的<code>items</code>里面没有数据，所以返回的长度必然也是<code>0</code>。但是这个返回值是必须要有的，需要返回一个整型才行。</p>
<p>来，我们看看如果这个方法的返回值写死会如何：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>很明显，我们重新给<code>obj.items</code>进行了赋值，目前其长度是<code>7</code>,
可是返回值依然是<code>1</code>。说明<code>__len__</code>的返回值只要四个整型就行。那我们就需要注意了，<code>len</code>需要获取什么属性的值，就在返回值中返回哪个属性的长度即可。当我们用正确的方式返回的时候就会是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>
<p>让我们继续接着这段代码来玩：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>res = <span class="hljs-built_in">str</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x110631270</span>&gt;<br></code></pre></td></tr></table></figure>
<p>发现没有，虽然我们使用了<code>str()</code>方法，可是最后返回的结果，和直接打印<code>obj</code>的结果是一样的。那为什么会这样呢？这是因为我们这个当前的方法其实是对<code>obj</code>对象进行了一个转化字符串操作，而其本身就返回了一个<code>&lt;__main__.Demo object at 0x110631270&gt;</code>的字符串。</p>
<p>其实这个返回的字符串我们也是可以自定义的,
使用<code>__str__</code>方法给一个返回值就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;__Demo__, 此字符串返回的是茶桁自定义的结果。&gt;&#x27;</span><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>...<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;__Demo__, 此字符串返回的是茶桁自定义的结果。&gt;<br></code></pre></td></tr></table></figure>
<p>我们直接打印了<code>obj</code>对象，因为<code>__str__</code>方法的存在，所以现在直接打印了返回的字符串。也就是说，该方法可以代替对象进行<code>str</code>或者<code>print</code>的字符串信息返回。</p>
<p>继续来看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># def __str__(self):</span><br>        <span class="hljs-comment"># ...</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是一个repr返回的内容&#x27;</span><br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>这是一个<span class="hljs-built_in">repr</span>返回的内容<br></code></pre></td></tr></table></figure>
<p>可以看到我在类中注释了<code>__str__</code>方法，这是因为只有其不存在的情况下，<code>__repr__</code>
方法才会起作用，可以替代<code>__str__</code>方法。</p>
<p>那么到底<code>__str__</code>和<code>__repr__</code>两个到底有什么区别呢？让我们直接在代码里找答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">521</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(num))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(num))<br><br>---<br><span class="hljs-number">521</span><br><span class="hljs-number">521</span><br></code></pre></td></tr></table></figure>
<p>这个时候两个的结果都是一样的，似乎并看不出两者到底有什么区别。别急，让我们继续往后做这个实验：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">521</span><br>r1 = <span class="hljs-built_in">str</span>(num)<br>r2 = <span class="hljs-built_in">repr</span>(num)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r1: <span class="hljs-subst">&#123;r1&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r1)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r2: <span class="hljs-subst">&#123;r2&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r2)&#125;</span>&#x27;</span>)<br><br>---<br>r1: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>r2: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>两者的类型都是一样的，返回了一个字符串类。难道这两者就正的毫无区别吗？Python得创建者吃饱了撑的没事做两个功能一模一样但是名字不同的方法？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;521&#x27;</span><br>r1 = <span class="hljs-built_in">str</span>(s)<br>r2 = <span class="hljs-built_in">repr</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r1: <span class="hljs-subst">&#123;r1&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r1)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r2: <span class="hljs-subst">&#123;r2&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r2)&#125;</span>&#x27;</span>)<br><br>---<br>r1: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>r2: <span class="hljs-string">&#x27;521&#x27;</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure>
<p>仔细看，两者似乎有了细微的差别。<code>repr</code>解析的结果带着引号。</p>
<p>那么，<code>str</code>和<code>repr</code>函数都可以把其他类型的数据转为字符串类型。
<code>str</code>函数会把对象转为更适合人阅读的形式，<code>repr</code>函数会把对象转为解释器读取的形式。</p>
<p>如果数据对象并没有更明显的区别的话，<code>str</code>和<code>repr</code>的转化结果还真没什么区别。</p>
<p>这两者的区别，其实只要了解一下就可以了。大部分时候，并不需要那么较真。</p>
<p>接着让我继续来看看<code>__bool__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">bool</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<p>当我们对<code>obj</code>使用<code>bool()</code>方法的时候，返回值为<code>True</code>。
那说明其中包含了一个<code>bool</code>机制，并且默认返回值为<code>True</code>。</p>
<p>这个时候让我们来定义一下看看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(self.items)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>res = <span class="hljs-built_in">bool</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>
<p>由于我们的<code>items</code>中设置为空值，而我们将前面定义<code>obj</code>的<code>items</code>的那段代码删掉了，所以这个时候，传入方法的<code>self.items</code>的值也为空，必然返回值就是<code>False</code>。也证明了，<code>bool(obj)</code>拿到的返回值就是类里定义的的<code>__bool__</code>中返回的对象。</p>
<p>介绍完常用的一些魔术方法之后，我们再来看一些其他的魔术方法。同样是魔术方法，为什么我要明显的区别开来讲呢？那是因为现在开始说讲的魔术方法都是针对成员的，是一些成员相关魔术方法。</p>
<ol type="1">
<li><code>__getattribute__</code>: 优先级最高</li>
</ol>
<p><strong>触发机制</strong>:
当访问对象成员时，自动触发，无论当前成员是否存在 <strong>作用</strong>:
可以在获取对象成员时，对数据进行一些处理 <strong>参数</strong>: 1.
<code>self</code>接收对象，2. <code>item</code>接收当前访问的成员名称
<strong>返回值</strong>: 可有可无，返回的值就是访问的结果
<strong>注意事项</strong>:
在当前的魔术方法中，禁止对当前对象的成员进行访问，会触发递归。如果想要在当前魔术方法中访问对象的成员必须使用<code>object</code>来进行访问。格式：
<code>object.__getattribute__(self,item)</code></p>
<ol start="2" type="1">
<li><code>__getattr__</code></li>
</ol>
<p><strong>触发机制</strong>：当访问对象中不存在的成员时，自动触发
<strong>作用</strong>：防止访问不存在的成员时报错，也可以为不存在的成员进行赋值操作
<strong>参数</strong>: 1. <code>self</code>接收当前对象，2.
<code>item</code>接收当前访问的成员名称
<strong>返回值</strong>：可有可无 <strong>注意事项</strong>：当存在
<strong>getattribute</strong> 方法时，会去执行
<strong>getattribute</strong>
方法。也要注意，不要在当前的方法中再次去访问这个不存在的成员，会触发递归操作</p>
<ol start="3" type="1">
<li><code>__setattr__</code></li>
</ol>
<p><strong>触发机制</strong>：
当给对象的成员进行赋值操作时会自动触发（包括添加，修改）
<strong>作用</strong>： 可以限制或管理对象成员的添加和修改操作
<strong>参数</strong>： 1. <code>self</code>接收当前对象 2.
<code>key</code>设置的成员名 3. <code>val</code>设置的成员值
<strong>返回值</strong>： 无
<strong>注意事项</strong>：在当前的魔术方法中禁止给当前对象的成员直接进行赋值操作，会触发递归操作。如果想要给当前对象的成员进行赋值，需要借助
<code>object</code> <strong>格式</strong>：
<code>object.__setattr__(self,key,value)</code></p>
<ol start="4" type="1">
<li><code>__delattr__</code></li>
</ol>
<p><strong>触发机制</strong>： 当删除对象成员时自动触发
<strong>作用</strong>：
可以去限制对象成员的删除，还可以删除不存在成员时防止报错
<strong>参数</strong>：1. <code>self</code>接收当前对象 2.
<code>item</code>删除的成员名称 <strong>返回值</strong>： 无
<strong>注意事项</strong>：
在当前魔术方法中禁止直接删除对象的成员，会触发递归操作。如果想要删除当前对象的成员，那么需要借助
<code>object</code>。 <strong>格式</strong>：
<code>object.__delattr__(self,item)</code></p>
<p>好了，按照惯例，让我们上代码,
先让我们来定义一个最正常的类，并且实例化它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    sex = <span class="hljs-string">&#x27;male&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;say something...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br>张三丰<br></code></pre></td></tr></table></figure>
<p>这个时候，让我们在类中定义一个方法：<code>__getattrbute__()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>
<p>可以看到，虽然我们在实例化对象的时候传入了成员值，但是当我们打印的时候返回值为<code>None</code>。如果我们这个时候修改一下这个魔术方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;abc&#x27;</span><br><br>...<br><span class="hljs-built_in">print</span>(obj.name)<br><span class="hljs-built_in">print</span>(obj.sex)<br>---<br>abc<br>abc<br></code></pre></td></tr></table></figure>
<p>那我们拿到的就是得到的内容。不仅是<code>name</code>，
任意我们传入的成员，返回的值都为<code>__getattribute__</code>返回的值。当获取对象成员时，这个方法进行处罚，其中的<code>item</code>形参就是我们想要获取的成员属性。第一次是<code>obj.name</code>,
第二次是<code>obj.sex</code>，但是无论你调用的是什么成员，拿到的都是这个方法的返回值<code>abc</code>。</p>
<p>那既然这样，是不是我们返回对象的成员属性就可以了？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.name<br><br></code></pre></td></tr></table></figure>
<p>千万不要这么做，这样会引起方法的无限递归调用，最终导致栈溢出。那么是不是我们就没办法了？也不是，我们需要使用<code>object.__getattribute__(self, item)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <br>    <span class="hljs-comment"># 获取对象成员的时候触发</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__getattribute__(self, item)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><span class="hljs-built_in">print</span>(obj.sex)<br><br>---<br>张三丰<br>男<br></code></pre></td></tr></table></figure>
<p>这样，我们就获取到了正确的返回值。我们这里讲解一个<code>__getattribute__</code>方法，限于篇幅的原因，我们其他的几个方法就不细致讲了。在我们先前的列表内，每一个方法的触发机制，作用，参数和注意事项我们都有写清楚。大家可以执行去看看，并做一些测试。让我们赶紧进入下一个阶段，不过在这之前呢，我们还是需要讲访问成员的顺序给大家强调一下，这个还是比较重要：</p>
<ol type="1">
<li>调用 <code>__getattribute__</code>魔术方法</li>
<li>调用数据描述符</li>
<li>调用当前对象的成员</li>
<li>调用当前类的成员</li>
<li>调用非数据描述符</li>
<li>调用父类的成员</li>
<li>调用<code>__getattr__</code>魔术方法</li>
</ol>
<blockquote>
<p>以上步骤是调用某个成员时的顺序，前面的能够调用成功，后面则不再执行。至于描述符，咱们下节课来详细讲。</p>
</blockquote>
<p>好了，本节课到这里就结束了，让我们先预告一下，下节课呢，我们来讲讲面向对象中的「描述符和设计模式」。大家期待一下吧。</p>
<p>记得课后好好做练习，目前我们的课程稍微有些难度了，只有保持一定的练习量，才能理解并记住。</p>
<p>小伙伴们，下节课再见了。下课。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>22. 面向对象 - 高阶</p><p><a href="https://hivan.me/Object-Oriented-Programming-Higher-Level/">https://hivan.me/Object-Oriented-Programming-Higher-Level/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hivan Du</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-08-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-25</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="sharethis-inline-share-buttons"></div><script src="https://platform-api.sharethis.com/js/sharethis.js#property=6479444288ae9600196fa98e&amp;product=inline-share-buttons" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="https://afdian.net/item/72907364008511ee904852540025c377" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://qiniu.hivan.me/picGo/20230601221633.jpeg" alt="支付宝"></span></a><a class="button donate" href="https://www.buymeacoffee.com/hivandu" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="https://patreon.com/user?u=89473430" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><a class="button donate" data-type="paypal" onclick="document.getElementById(&#039;paypal-donate-form&#039;).submit()"><span class="icon is-small"><i class="fab fa-paypal"></i></span><span>Paypal</span></a><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank" rel="noopener" id="paypal-donate-form"><input type="hidden" name="cmd" value="_donations"><input type="hidden" name="business" value="doo@hivan.me"><input type="hidden" name="currency_code" value="USD"></form><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://qiniu.hivan.me/IMG_4603.JPG" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/OOP-Descriptor-and-design-patterns/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">23. 描述符和设计模式</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Object-Oriented-Programming/"><span class="level-item">21. 面向对象及特性</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://hivan.me/Object-Oriented-Programming-Higher-Level/';
            this.page.identifier = 'Object-Oriented-Programming-Higher-Level/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'hivan' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://www.gravatar.com/avatar/bdff168cf8a71c11d2712a1679a00c54?s=128" alt="茶桁"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">茶桁</p><p class="is-size-6 is-block">AI游民</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Shang Hai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">203</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">22</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/hivandu" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/hivandu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com/hivan"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/hivan"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com/hivan"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4NzE4MDQzMg==&amp;action=getalbum&amp;album_id=2932504849574543360&amp;scene=173&amp;from_msgid=2648747980&amp;from_itemidx=1&amp;count=3&amp;nolastread=1&amp;token=1758883909&amp;lang=zh_CN#wechat_redirect"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.zhihu.com/column/c_1424326166602178560" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">塌缩的奇点</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li><li><a class="level is-mobile" href="https://www.zhihu.com/column/hivandu" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">茶桁-知乎</span></span><span class="level-right"><span class="level-item tag">www.zhihu.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/"><span class="level-start"><span class="level-item">AI秘籍</span></span><span class="level-end"><span class="level-item tag">61</span></span></a><ul><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/Math/"><span class="level-start"><span class="level-item">Math</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">27</span></span></a></li><li><a class="level is-mobile" href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">核心能力基础</span></span><span class="level-end"><span class="level-item tag">32</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"><span class="level-start"><span class="level-item">从零开始接触人工智能大模型</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-23T23:30:00.000Z">2023-12-24</time></p><p class="title"><a href="/32.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%20-%20Transfer%20Learning/">32. 深度学习进阶 - Transfer Learning</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-19T23:30:00.000Z">2023-12-20</time></p><p class="title"><a href="/31.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%20-%20%E5%85%A8%E8%BF%9E%E6%8E%A5%E5%B1%82%E5%8F%8A%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84/">31. 深度学习进阶 - 全连接层及网络结构</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-16T23:30:00.000Z">2023-12-17</time></p><p class="title"><a href="/30.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%20-%20%E6%B1%A0%E5%8C%96/">30. 深度学习进阶 - 池化</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-12T23:30:00.000Z">2023-12-13</time></p><p class="title"><a href="/29.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%20-%20%E5%8D%B7%E7%A7%AF%E7%9A%84%E5%8E%9F%E7%90%86/">29. 深度学习进阶 - 卷积的原理</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-09T23:30:00.000Z">2023-12-10</time></p><p class="title"><a href="/28.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%BF%9B%E9%98%B6%20-%20LSTM/">28. 深度学习进阶 - LSTM</a></p><p class="categories"><a href="/categories/AI%E7%A7%98%E7%B1%8D/">AI秘籍</a> / <a href="/categories/AI%E7%A7%98%E7%B1%8D/%E6%A0%B8%E5%BF%83%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80/">核心能力基础</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="茶桁.MAMT" height="28"></a><p class="is-size-7"><span>&copy; 2023 Hivan Du</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/hivandu"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>