<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶桁.MAMT</title>
  
  <subtitle>ChaHeng Notes，codding and writting ~</subtitle>
  <link href="https://hivan.me/atom.xml" rel="self"/>
  
  <link href="https://hivan.me/"/>
  <updated>2023-08-18T16:04:17.329Z</updated>
  <id>https://hivan.me/</id>
  
  <author>
    <name>Hivan Du</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我不能将iPhone换成Android手机的三个主要原因</title>
    <link href="https://hivan.me/I-can-t-swap-my-iphone/"/>
    <id>https://hivan.me/I-can-t-swap-my-iphone/</id>
    <published>2023-08-18T15:48:20.000Z</published>
    <updated>2023-08-18T16:04:17.329Z</updated>
    
    <content type="html"><![CDATA[<img src="/I-can-t-swap-my-iphone/image-20230818235423846.png" class="" title="iPhone"><p>超过十年来，我始终忠实于苹果的iPhone。虽然并不是从2008年的首款iPhone开始，但是从我第一个苹果产品，我每年都会升级到最新型号。</p><span id="more"></span><p>然而，也并不是说我从未用过Android，我尝试过很多Android的手机，从第一台Android手机HTCG1开始，到现在的PixelFold。尽管并非所有Android手机都令人满意，但也有一些我真正喜欢的手机，HTCG1是我印象最深刻的，我非常喜欢它的滑屏和物理键盘。还有华为、小米、GooglePixel 7、Google PixelFold等等。我亲身体验了Android在一些方面的优势，比如定制性和通知，而且硬件设计也可以更加有趣。</p><p>然而，我仍然有几个重要的理由，使我继续将iPhone 14Pro作为我的主力智能手机。</p><h2 id="imessage真的很好用">iMessage真的很好用</h2><img src="/I-can-t-swap-my-iphone/image-20230818234925243.png" class="" title="imessage"><p>自从开始使用iPhone以来，我几乎将所有的个人和工作设备都换成了苹果的产品。所以我不仅有一部iPhone14 Pro，还有一台多款MacBook（包括Air和Pro），一部12.9英寸的iPadPro和一只Apple WatchUltra。尽管我通常不会像iPhone那样每年升级电脑、iPad和AppleWatch，但我仍然会每隔几年换一次。</p><p>尽管如此，我仍然认为我的iPhone是我使用的其他一切设备的基础。我从很久前开始就使用同一个电话号码，这是我主要用于iMessage（以及一些电子邮件地址）的工具。</p><p>我使用iMessage与朋友和家人保持联系，我知道我不是唯一一个这样做的人。我喜欢使用iMessage的一个原因是，无论我使用什么设备，所有的消息，甚至是与Android用户的短信，都会显示在我的iPad和Mac上。无论我使用哪个设备，我都可以轻松地访问所有的消息和文本，即使我的iPhone在房间的另一边。</p><p>如果你同时使用Android手机和Mac电脑，你仍然可以通过第三方应用程序访问你的消息。但问题是，你需要找到一个好的第三方应用程序来实现这一点。这就是我喜欢iMessage的地方：它已经安装在我所有的苹果设备上，用苹果的著名话语来说，“它就是这样”。只要我登录我的AppleID，我的消息就会同步，我可以在任何设备上发送和接收消息，无需额外的工作。</p><p>此外，我发消息的大部分人也都使用iPhone。这意味着我可以发送照片和视频，而不会被压缩和像素化。我喜欢能够编辑和撤回消息，看到人们正在回复的过程中，消息的反应能正常工作，等等。此外，能够从短信中自动填写安全码是苹果添加的最棒的功能之一。iMessage有很多出色的功能，如果我完全切换到Android，我将错过这些功能。虽然这种封闭性可能不是最友好的，但这无疑是我坚持使用iPhone的一个巨大原因。</p><h2 id="airdrop使照片传输变得轻松">AirDrop使照片传输变得轻松</h2><img src="/I-can-t-swap-my-iphone/image-20230818235007201.png" class="" title="AirDrop"><p>我的工作中需要拍摄很多照片，并将它们传输到我的电脑上，然后变成视频再传回手机。为此，AirDrop的便捷性是其他方式所无法比拟的，可以轻松连接我的iPhone、iPad和Mac。</p><p>由于没有专用的数码相机，我完全依靠智能手机进行摄影和视频录制。鉴于如今主流智能手机的相机功能强大，这是个实用的选择。在对照片进行快速编辑以确保其符合网络标准后，我将它们移动到电脑中，以上传到博客或其它地方。</p><p>在我的iPhone 14Pro上，我可以在“照片”应用中完成所有这些任务，然后选择需要的图片，通过AirDrop快速将它们发送到我的MBP上。这些照片会方便地出现在我的“下载”文件夹中，待命名后即可上传。</p><p>相比之下，在使用Android手机时需要额外的步骤。在编辑照片后，将它们从Android设备传输到Mac变得复杂。我必须在浏览器中打开GooglePhotos，找到所需的图像，然后将它们下载到我的电脑上。额外的复杂性让我渴望AirDrop的简单流程。尽管Android有“附近共享”功能，但这与AirDrop在与Mac的无缝集成上存在差距，至少在没有第三方应用的情况下是如此。</p><p>尽管我喜欢我的Android拍摄出的质量更高的照片，但我主要仍然使用iPhone进行摄影。通过AirDrop将照片传输到电脑上的轻松过程极大地提升了我的工作效率，这对于我经常进行的任务而言，意义重大。</p><h2 id="生态系统的和谐至上">生态系统的和谐至上</h2><img src="/I-can-t-swap-my-iphone/image-20230818235043496.png" class="" title="AppStore"><p>如前所述，我几乎从首款iPhone问世开始就拥抱了它。自从2008年AppStore发布以来，我购买过大量的应用和游戏下载，尤其是在我早期的职业生涯中，我经常评测软件。</p><p>尽管一些应用可能已经不再存在于AppStore，但我对这个生态系统的忠诚仍然不变。一些仅适用于苹果设备的应用，比如Ulysses作为我的主要写作应用程序、OmniFocus作为我主要的GTD工具、MindNode作为我主要的脑图生产工具、MarginNote作为我主要的学习工具、Fantastical作为日历应用、Overcast作为播客应用、Pixelmator和Affinity套件作为照片编辑工具，DEVONThink作为我的数据中心，都构成了我日常工作流程的支柱。游戏作为我首选的休闲娱乐，也加深了我与这个生态系统的联系；我不愿意因为在不同设备间切换而失去我的游戏进度。</p><p>苹果设备之间的无缝协同提升了我的使用体验，确保一切（大部分时间）都可以正常工作。</p><p>近年来，我还采用了一些苹果的原生应用，比如“备忘录”。许多重要的笔记保存在我的“备忘录”应用中，我不愿意将它们导出到其他平台。更何况，DEVONThink和苹果的备忘录协作是如此顺畅。</p><img src="/I-can-t-swap-my-iphone/image-20230818235122899.png" class="" title="dt-import-applenotes"><p>还有，我们别忘了我从第一代AppleWatch开始积累的多年健康数据。我不太愿意在不同的平台上重新开始，并且失去我这么多年的运动记录。</p><p>也许在我不断抱怨iPhone的同时还继续使用它，看起来似乎有些矛盾。但我之前的批评更多是出于对改进的渴望，因为没有任何公司或产品是完美的，苹果也不例外。然而，将苹果设备无缝集成到我的生活中，却是我继续忠于iPhone的一个重要原因。苹果设备之间的无缝协同提升了我的使用体验，确保一切（大部分时间）都可以正常工作。</p><h2 id="结语">结语</h2><img src="/I-can-t-swap-my-iphone/image-20230818234516353.png" class="" title="屏幕时间"><p>最后要说的就是最后一点，虽然我不知道Android上有没有相同的解决方案，但是苹果的「屏幕时间共享」和时间限制让我对孩子的屏幕时间管理非常的得心应手。我可以和孩子共同探讨他需要的时间段和长度，并且都有数据可查。很重要的一点是，一旦进行管理之后，是他的所有设备都将遵循这个规则，我只需要设定规则，而不必烦恼具体是什么设备。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/I-can-t-swap-my-iphone/image-20230818235423846.png&quot; class=&quot;&quot; title=&quot;iPhone&quot;&gt;
&lt;p&gt;超过十年来，我始终忠实于苹果的iPhone。虽然并不是从2008年的首款iPhone开始，但是从我第一个苹果产品，我每年都会升级到最新型号。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Apple" scheme="https://hivan.me/tags/Apple/"/>
    
    <category term="Android" scheme="https://hivan.me/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>23. 描述符和设计模式</title>
    <link href="https://hivan.me/OOP-Descriptor-and-design-patterns/"/>
    <id>https://hivan.me/OOP-Descriptor-and-design-patterns/</id>
    <published>2023-08-17T16:54:10.000Z</published>
    <updated>2023-08-18T09:53:33.330Z</updated>
    
    <content type="html"><![CDATA[<img src="/OOP-Descriptor-and-design-patterns/cover.png" class="" title="cover"><p>Hi， 大家好，我是茶桁。</p><span id="more"></span><p>上一节课中，我们讲解了面向对象中的一些高阶应用，给大家介绍了一些魔术方法。并在最后，我们预告这节课内容会讲解描述符和设计模式。</p><p>好了，让我们开始吧。</p><h2 id="描述符">描述符</h2><p>这个玩意，怎么讲合适呢？这么说吧，当某一个类中，包含了三个魔术方法（<code>__get__, __set__, __delete__</code>)中的任意一个，或者全部都有时，那么这个类就被称为是「描述符类」。</p><p>描述符的作用就是对一个类中的某一个成员进行一个详细的惯例操作，包括获取、赋值以及删除。也就是，描述符代理了一个类中的成员的操作，描述符属于类，只能定义为类的属性。</p><p>魔术方法咱们前面有提到，这里让咱们先来看看三个特殊的魔术方法，：</p><ol type="1"><li><code>__get__(self, instance, owner)</code></li></ol><p><strong>触发机制</strong>：在访问对象成员属性时自动触发(当该成员已经交给描述符管理时)<strong>作用</strong>：设置当前属性获取的值 <strong>参数</strong>：1.<code>self</code> 描述符对象 2.被管理成员的类的对象。3.被管理成员的类<strong>返回值</strong>：返回值作为成员属性获取的值<strong>注意事项</strong>：无</p><ol start="2" type="1"><li><code>__set__(self, instance, value)</code></li></ol><p><strong>触发机制</strong>：在设置对象成员属性时自动触发(当该成员已经交给描述符管理时)<strong>作用</strong>：对成员的赋值进行管理 <strong>参数</strong>：1.<code>self</code> 描述符对象 2.被管理成员的类的对象。3.要设置的值<strong>返回值：</strong>无 <strong>注意事项</strong>：无</p><ol start="3" type="1"><li><code>__delete__(self, instance)</code></li></ol><p><strong>触发机制</strong>：在删除对象成员属性时自动触发(当该成员已经交给描述符管理时)<strong>作用</strong>：对成员属性的删除进行管理<strong>参数</strong>：1. <code>self</code> 描述符对象2.被管理成员的类的对象。 <strong>返回值</strong>：无<strong>注意事项</strong>：无</p><p>让我们先来看一个基本的类和实例化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>name<br></code></pre></td></tr></table></figure><p>然后我们定义一个「描述符类」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>():<br>    __name = <span class="hljs-string">&#x27;abc&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>接着我们重新更改一下刚才定义的普通类，将其中的<code>name</code>成员属性交给刚定义的描述符类来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义的普通类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 把类中的一个成员属性交给一个描述符类来实现</span><br>    name = PersonName()<br></code></pre></td></tr></table></figure><p>这个时候我们实例化之后打印其中的成员属性会如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>我们可以看到，结果为<code>None</code>。</p><p>现在让我们依次将类中的<code>__get__</code>方法的参数都打印出来观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改其中的`__get__`方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>    <span class="hljs-built_in">print</span>(self)<br>    <span class="hljs-built_in">print</span>(instance)<br>    <span class="hljs-built_in">print</span>(owner)<br>     <br><span class="hljs-comment"># 实例化后打印</span><br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>&lt;__main__.PersonName <span class="hljs-built_in">object</span> at <span class="hljs-number">0x108931d20</span>&gt;<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x108930250</span>&gt;<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Person&#x27;</span>&gt;<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>现在，具体<code>self, instance, owner</code>各自分别是什么，就非常清楚了。</p><p>那，既然<code>self</code>是<code>PersonName</code>类本身，那我们在其中定义的<code>name</code>成员属性是不是就可以拿到了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>():<br>    __name = <span class="hljs-string">&#x27;abc&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义的普通类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 把类中的一个成员属性交给一个描述符类来实现</span><br>    name = PersonName()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>abc<br></code></pre></td></tr></table></figure><p>没错，我们确实拿到了<code>PersonName</code>中的<code>__name</code>。</p><p>我们现在可以这么理解，普通类中的一个成员属性交给了一个描述符类来实现，类中的成员的值是另一个描述符类的对象，那么当对这个类中的成员进行操作时，可以理解为就是对另一个对象的操作。现在的<code>PersonName</code>这个描述符类，相对于一个代理人的角色。把当前的描述符类赋值给了一个需要代理的类中的成员属性。</p><p>既然我们看到了<code>get</code>方法的结果之后，那么剩下两个魔术方法的作用也就很容易想到了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>():<br>  ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        self.__name = value<br>    ...<br><span class="hljs-comment"># 定义的普通类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>  ...<br>    <br><span class="hljs-comment"># 实例化对象</span><br>...<br>zs.name = <span class="hljs-string">&#x27;张三丰&#x27;</span><br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>abc<br>张三丰<br></code></pre></td></tr></table></figure><p>这里容易理解吧？当我们执行<code>zs.name = ‘张三丰’</code>这个赋值操作的时候，其就是走到了<code>__set__</code>方法内。其中的<code>self</code>不言而喻，就是<code>PersonName</code>，而<code>value</code>就是刚才我们进行赋值操作的那个值。这个时候，我们可以设置<code>self.__name = value</code>，那就是满足了这个赋值操作。当然，我们也可以不这样给，来让我们调戏一下这个赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只改动`__set__`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-comment"># self.__name = value</span><br>        self.__name = <span class="hljs-string">&#x27;茶桁&#x27;</span><br><br>zs.name = <span class="hljs-string">&#x27;张三丰&#x27;</span><br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>茶桁<br></code></pre></td></tr></table></figure><p>当我们这样去改的时候，那么无论我们怎样去赋值，最终的结果都是打印出<code>茶桁</code>。</p><p>那么<code>__del__</code>怎么用呢？我们接着看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前面的代码都不做改动</span><br><br><span class="hljs-keyword">del</span> zs.name<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>茶桁<br>茶桁<br></code></pre></td></tr></table></figure><p>那么第一个茶桁是刚才我们赋值后的打印结果，第二个茶桁呢？就是我们在执行<code>del zs.name</code>之后的打印结果。按道理来说，我们执行了<code>del</code>命令之后。<code>zs</code>这个对象的<code>name</code>成员已经被删除了，现在应该是打印出类中的原始值，也就是<code>abc</code>,那为什么这里打印出来的还是<code>茶桁</code>呢？</p><p>原因就在于我们的<code>__del__</code>方法内没有任何操作。我们来改一下<code>__del__</code>内部：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只改动`__del__`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-comment"># print(&#x27;我就是不行删除，气死你&#x27;)</span><br>        <span class="hljs-keyword">del</span> self.__name<br><br><span class="hljs-keyword">del</span> zs.name<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>abc<br></code></pre></td></tr></table></figure><p>这样我们就执行了<code>del</code>本该有的操作。不过大家也看到了，我中间有一段代码注释了，现在让我们替换一下注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只改动`__del__`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我就是不行删除，气死你&#x27;</span>)<br>        <span class="hljs-comment"># del self.__name</span><br><br><span class="hljs-keyword">del</span> zs.name<br><br>---<br>我就是不行删除，气死你<br></code></pre></td></tr></table></figure><p>当我们执行<code>del zs.name</code>的时候，触发方法内的打印命令。那么，这个时候再让我们打印一下<code>zs.name</code>来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>茶桁<br></code></pre></td></tr></table></figure><p>毫无意外的，茶桁还在，并没有变成<code>abc</code>。</p><p>需要注意的是，同时具备三个魔术方法的类才是「数据描述符类」，没有同时具备三个魔术方法的类呢？很简单，就是「非数据描述符类」。两者的区别就是一个是完整的，一个是不完整的。可以不可以应用呢？部分可以，但是不完整，<code>__get__</code>,<code>__set__</code>,<code>__delete__</code>中总有某些功能无法实现。</p><h3 id="一个描述符应用">一个描述符应用</h3><p>了解了描述符的概念以及怎么使用之后，我们来试试实现一个应用：<code>定义一个学生类，需要记录学员的id, 名字和分数。</code></p><p>让我们先来起一个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self.score = score<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>    <br><span class="hljs-comment"># 实例化对象</span><br>zs = Student(<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">98</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>学员编号:<span class="hljs-number">37</span><br>学员姓名:张三丰<br>学员分数:<span class="hljs-number">98</span><br></code></pre></td></tr></table></figure><p>这里，我们对这个方法有一个要求，就是学员的分数只能在0-100范围中,那其实很简单了对吧？</p><p>我们先来看看第一种最普通的实现方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        <span class="hljs-comment"># 检测分数范围</span><br>        <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> score &lt;= <span class="hljs-number">100</span>:<br>            self.score = score<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前分数不符号要求。&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>    <br><span class="hljs-comment"># 实例化对象</span><br>zs = Student(<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">101</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>当前分数不符号要求。<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;score&#x27;</span><br></code></pre></td></tr></table></figure><p>尝试一下，确实打印了“分数不符合要求”，同时报错。</p><p>先不说怎么解决报错的问题，这简单的解决方案只能适用于对象初始化的时候有效。如果我们是中间单独对成员属性进行赋值，那么就会失效了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>zs.score = -<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>学员编号:<span class="hljs-number">37</span><br>学员姓名:张三丰<br>学员分数:-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>那这个时候，大家还记不记得咱们之前学过的一个魔术方法<code>setattr</code>?我们来给中间加一个<code>__setattr__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>    <span class="hljs-comment"># 检测是否给score进行赋值操作</span><br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&#x27;score&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(key, value)<br>        <span class="hljs-comment"># 检测分数范围</span><br>        <span class="hljs-keyword">if</span> value &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> value &lt;= <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">object</span>.__setattr__(self, key, value)    <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前分数不符号要求。&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">object</span>.__setattr__(self, key, value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    info = <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>    <span class="hljs-keyword">return</span> info<br><br>...<br>zs.score = -<span class="hljs-number">1</span><br><br>---<br>score -<span class="hljs-number">1</span><br>当前分数不符合要求<br></code></pre></td></tr></table></figure><p>我们这样就使用<code>__setattr__</code>方法，检测如果<code>score</code>分数进行赋值时候，进行了分数的检测判断。</p><p>那我们在看，现在的一个问题是，假如学员的分数不止一个，我需要赋值多个分数怎么办？当前学员有：语文，数学，英语分数。</p><p>另外就是当前这个类中的代码是否比较繁杂？</p><p>现在，我们再来看，思考一下使用描述符来代理我们的分数这个成员属性。让我们先来实现一下框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>():<br>    __score = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">del</span> self.__score<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    score = Score()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">returnSelf</span>(<span class="hljs-params">self</span>):<br>        info = <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>        <span class="hljs-keyword">return</span> info<br></code></pre></td></tr></table></figure><p>框架就实现好了，我们将原始的普通类中的<code>score</code>代理给了描述符类<code>Score()</code>。</p><p>那现在让我们来完善一下整个类中的方法。</p><p>首先，当我们进行获取的时候，直接<code>return</code>现有的值就可以了，当我们进行设置的时候，就需要进行判断，如果不符合要求就打印一个不符合要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类，代理分数的管理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>():<br>    __score = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self.__score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> value &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> value &lt;= <span class="hljs-number">100</span>:<br>            self.__score = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;分数不符合要求&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">del</span> self.__score<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    score = Score()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">returnSelf</span>(<span class="hljs-params">self</span>):<br>        info = <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>        <span class="hljs-keyword">return</span> info<br></code></pre></td></tr></table></figure><p>让我们对其进行一下检测，看看是不是符合要求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化对象</span><br>zs = Student(<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">132</span>)<br>zs.returnSelf()<br><br>---<br>分数不符合要求<br><span class="hljs-string">&#x27;学员编号:37\n学员姓名:张三丰\n学员分数:None&#x27;</span><br></code></pre></td></tr></table></figure><p>没毛病，被告知了当前赋值不符合要求，并且最后分数上也为<code>None</code>，并未进行赋值。</p><p>在看看单独赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">zs.score = -<span class="hljs-number">1</span><br>zs.score = <span class="hljs-number">88</span><br>zs.returnSelf()<br><br>---<br>分数不符合要求<br><br><span class="hljs-string">&#x27;学员编号:37\n学员姓名:张三丰\n学员分数:88&#x27;</span><br></code></pre></td></tr></table></figure><p>当赋值为<code>-1</code>的时候也是提示不符合要求，再次赋值<code>88</code>之后，正确赋值。然后我们打印出来的结果也正确。</p><p>那么我们的代理就正确的完成了它的工作。基本工作流程如下：</p><ol type="1"><li>定义<code>Score</code>描述符类</li><li>把学生类中的<code>score</code>这个成员交给描述符类进行代理</li><li>只要在代理的描述符中对分数进行判断和赋值就可以了。</li></ol><p>那么现在，我们就完成了一个描述符的应用案例。不知道大家是否都理解了？那么在下面，我给大家介绍一下描述符的三种定义格式：</p><ul><li><strong>格式一： 通过定义描述符来实现（推荐）</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScoreManage</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    score = ScoreManage()<br></code></pre></td></tr></table></figure><ul><li>格式二： 使用<code>property</code>函数来实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self._score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getScore</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._score<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setScore</span>(<span class="hljs-params">self, score</span>):<br>        self._score = score<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delScore</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">del</span> self._score<br><br>    <span class="hljs-comment"># 在 property 函数中指定对应的三个方法</span><br>    <span class="hljs-comment"># 对应的方法 1. `__get__`，2. `__set__`, 3. `__delete__`</span><br>    <span class="hljs-comment"># 当然，名称不是固定的，也可以定义成其他的方法名</span><br>    <span class="hljs-comment"># 不管定义成什么，`property`中的方法名必须一致。</span><br>    <span class="hljs-comment"># 注意在类中将成员属性重新定义，可以为受保护的或者私有属性，避免递归调用。</span><br>    score = <span class="hljs-built_in">property</span>(getscore,setscore,delscore)<br><br></code></pre></td></tr></table></figure><ul><li>格式三：使用<code>@property</code>装饰器语法来实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    __score = <span class="hljs-literal">None</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.__score<br><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self,value</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;set&#x27;</span>)<br>        self.__score = value<br><br><span class="hljs-meta">    @score.deleter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;delete&#x27;</span>)<br>        <span class="hljs-keyword">del</span> self.__score<br></code></pre></td></tr></table></figure><h2 id="设计模式">设计模式</h2><p>我们谈设计模式的时候，实际上是一个比较抽象的东西。</p><blockquote><p>设计模式，就是前人完成某个功能或者需求，根据经验和总结，对实现的代码步骤和代码设计进行了总结及归纳。成为了实现某个需求的经典模式。</p></blockquote><p>设计模式可以说并不是什么固定的代码格式，而是一种面向对象编程的设计。</p><p>让我们先从单例开始。</p><h3 id="单例单态设计模式">单例（单态）设计模式</h3><p>在当前脚本中，同一个类只能创建一个对象去使用，这种情况就称为单例（单态）。</p><p>我们以一个实际的思考案例来进行讲解，现在让我们来想：</p><p>单例和婚姻法的关系，特别像，就是一个人只能有一个结婚对象。在社会中是如何完成一夫一妻制的？如果想要结婚，必须要到民政局登记，民政局需要检测两个人的户口本，看看上面是否属于已婚的状态。如果是已婚，肯定就被撵出去了对吧。如果没有结婚，就可以盖章登记了。</p><p>那么按照这样的思路，我们又该如何去实现Python中的单例设计模式呢？来看哈：</p><ol type="1"><li><p>需要一个方法，可以去控制当前对象的创建过程：构建方法<code>__new__</code></p></li><li><p>需要有一个标识来存储和表示是否有对象：创建一个私有属性进行存储，默认为<code>None</code>；</p></li><li><p>在创建对象的方法中去检测和判断是否有对象：如果没有对象，则创建对象，并且将对象存储起来，返回对象。那如果存储的是对象，则直接返回对象，就不需要创建新的对象了。</p></li></ol><p>让我们依照这样一个思路来完成代码，让我们还是从框架开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> cls.obj<br></code></pre></td></tr></table></figure><p>第一步我们完成了，现在让我们来看第二部，我们需要定义一个私有属性用于存储对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 定义私有属性存储对象</span><br>    __obj = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> cls.__obj<br></code></pre></td></tr></table></figure><p>接着，就要进入判断了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 定义私有属性存储对象</span><br>    __obj = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 创建对象的过程中，判断是否有对象</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__obj:<br>            <span class="hljs-comment"># 如果没有，则创建，并且存储起来</span><br>            cls.__obj = <span class="hljs-built_in">object</span>.__new__(cls)<br>        <span class="hljs-keyword">return</span> cls.__obj<br></code></pre></td></tr></table></figure><p>类完成了，让我们来证实一下看看，是否只会创建一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化对象</span><br>a = Demo()<br>b = Demo()<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10434e950</span>&gt;<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10434e950</span>&gt;<br></code></pre></td></tr></table></figure><p>看到打印结果中，两次实例化对象不同，但是地址相同。可以证明确实为一个对象。</p><h3 id="mixin类">Mixin类</h3><ul><li><code>Mixin</code> 必须是表示一种功能，而不是一个对象。</li><li><code>Mixin</code>的功能必须单一，如果有多个功能，那就多定义<code>Mixin</code>类</li><li>python 中的<code>Mixin</code>是通过多继承实现的</li><li><code>Mixin</code>这个类通常不单独使用，而是混合到其它类中，去增加功能的</li><li><code>Mixin</code>类不依赖子类的实现，即便子类没有继承这个<code>Mixin</code>,子类也能正常运行，可能就是缺少了一些功能。。</li></ul><p>那使用<code>Mixin</code>混入类有什么好处呢？</p><p>这个混入类的设计模式，在不对类的内容修改的前提下，扩展了类的功能。也提高代码的重用性，使的代码结构更加的简单清晰。可以根据开发需要任意调整功能（也就是创建新的<code>Mixin</code>混入类），避免设计多层次的复杂的继承关系。</p><p>我们之前学习继承，知道继承需要有一个必要的前提，就是继承应该是一个<code>is-a</code>的关系。</p><p>比如，苹果可以去继承水果，因为苹果<code>is a</code>水果，那苹果是不能继承午饭的，因为午饭可以有苹果，也可以没有。</p><p>再比如，汽车可以继承交通工具，又是因为汽车本身<code>is a</code>交通工具。</p><p>遵循这样的一个规律，我们来思考，交通工具都有哪些呢？</p><p>汽车、飞机、直升飞机，这些都属于交通工具对吧？当然，高铁什么的也是，我们无法穷举出来，那样就太多了。</p><p>那么如何去设计这些类的关系呢？我们可以创建一个交通工具类，然后属于交通工具的都来继承，再去实现...等等，我们再来思考一个问题：飞机、直升飞机都可以飞，可是汽车呢？汽车并不能飞行。那么交通工具中如果去定义飞行这个功能，是不是就不合适了？</p><p>你们现在是不是在想：那就在飞机和直升飞机类中分别实现飞行这个功能。可以是可以，但是重复代码是不是过多了？代码无法重用。</p><p>那该怎么办？其实，让我们分别去定义交通工具和飞行器这两个父类，这样飞机和直升飞机就可以去继承这两个类。对吧？</p><p>来，让我们开始实现，一样的，先来个框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义交通工具</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vehicle</span>():<br>    <span class="hljs-comment"># 运输货物</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cargo</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;货物&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 搭载乘客</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人&#x27;</span>)<br><br><span class="hljs-comment"># 定义飞行器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">flying</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;可以飞&#x27;</span>)<br></code></pre></td></tr></table></figure><p>现在刚才的思考得以实现，我们定义了两个父类。接着是不是就要考虑继承了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义飞机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">airplane</span>(vehicle, flying):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义直升机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">helicopter</span>(vehicle, flying):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义汽车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>(<span class="hljs-title class_ inherited__">vehicle</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>根据我们之前学习的继承关系，这样就完成了子类对父类的继承关系。来让我们分析下：</p><p>此时去定义一个飞行器的类Flying,让需要飞行的交通工具直接继承这个类，可以解决问题。但是又两个问题，出现的类多继承，就违背了<code>is-a</code>，飞行器这个类很容易被误解。那怎么办？</p><p>其实解决方案还是使用多继承，但是给飞行器这个类定义为一个<code>Mixin</code>混合类，此时就是等于把飞行器这个类，作为一个扩展的功能，来扩展其他类。</p><p>让我们来改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义交通工具</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vehicle</span>():<br>    <span class="hljs-comment"># 运输货物</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cargo</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;货物&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 搭载乘客</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人&#x27;</span>)<br><br><span class="hljs-comment"># 定义飞行器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">flyingMixin</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;可以飞&#x27;</span>)<br><br><span class="hljs-comment"># 定义飞机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">airplane</span>(vehicle, flyingMixin):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义直升机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">helicopter</span>(vehicle, flyingMixin):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义汽车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>(<span class="hljs-title class_ inherited__">vehicle</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>嗯，你没看错，就是这么简单，改一下名称。</p><p>那么在这段代码中，虽然直升机和飞机都是用了多继承，也就是继承了<code>flyingMixin</code>，但是由于<code>flyingMixin</code>类加了<code>Mixin</code>这个名，就告诉了后面阅读代码的人，这个类是一个<code>Mixin</code>类。</p><p>我知道你们在想什么，这个是不是太随便了？其实并不是，我们目前在谈论的是「设计模式」，这个<code>flyingMixin</code>类中除了名称之外，还要遵循一些特定的惯例规则，就是这个类中的功能必须是单一的。</p><p>在名称的含义上，<code>Mixin</code>表示混入(mix-in)，<code>Mixin</code>必须是表示一种功能，而不是一个对象。<code>Mixin</code>的功能必须单一，如果有多个功能，那就需要多定义几个<code>Mixin</code>类。在Python中的<code>Mixin</code>是通过多继承实现的。<code>Mixin</code>类通常不单独使用，而是混合到其他类中，去增加功能的。<code>Mixin</code>类不依赖子类的实现，即便子类没有继承这个<code>Mixin</code>类，子类也能正常运行，只是可能缺少一些功能。</p><h3 id="抽象类">抽象类</h3><p>首先我们要明白，抽象类也是一个类。但是，这又是一个特殊的类，抽象类不能用，不能直接实例化称为一个对象。抽象类包含了抽象方法，抽象方法就是没有实现代码的方法。抽象类需要子类继承，并重写父类的抽象方法，才可以使用。</p><p>抽象类，一般应用在程序设计，程序设计中一般是要对功能和需求进行规划，其中有一些需求是明确的并且可以完成的，但是也可能会有一些需求是不明确的，或者不确定具体需要怎么实现，此时就可以把这个不确定怎么实现或者需要后面再去实现的方法，定义为抽象方法（只定义方法名，不写具体代码）。</p><p>我们还是拿一个实例来讲解：</p><p>比如公司有一项新的产品需要开发，交给了开发部门的大拿，也就是你。那么你就开始去规划设计怎么去完成这个产品的开发。比如项目需要用到不同的技术，不同的人来完成。这样，你作为老大，自己完成了一部分功能，但是依然有一部分定义了需求，但是还没有具体实现，需要其他人来进行实现。</p><p>那么此时，你已经写完的部分就是普通方法，定义了需求但是未完成的就可以理解为是抽象方法。</p><p>还是来直接看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> abc<br><br><span class="hljs-comment"># 必须使用metaclass, 属性必须是abc.ABCMeta</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteCode</span>(metaclass=abc.ABCMeta):<br><br>    <span class="hljs-comment"># 需要抽象方法，使用装饰器进行装饰</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_swift</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_java</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实现了Java代码的开发&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_python</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实现了Python代码的开发&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样我们就在一个抽象类中定义好了一个抽象方法，和几个普通方法。至于为什么必须<code>metaclass=abc.ABCMeta</code>，那就又要扩展着去讲了。这里先记住，就跟背单词一样，到这里了就这么用就可以了。</p><p>前面我们讲了，抽象类是不能直接实例化的，让我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 抽象类不能直接实例化对象</span><br>obj = WriteCode()<br><br>---<br>TypeError: Can<span class="hljs-string">&#x27;t instantiate abstract class WriteCode with abstract method write_swift</span><br></code></pre></td></tr></table></figure><p>报错了，直接告诉我们无法实例化抽象类。</p><p>那么我们到底要怎么用呢？</p><p>我们可以定义一个子类来继承，并实现抽象类中的抽象方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义子类，继承抽象类，并实现抽象类中的抽象方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-title class_ inherited__">WriteCode</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_swift</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实现了swift代码的开发&#x27;</span>)<br></code></pre></td></tr></table></figure><p>好了，现在让我们实例化子类试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = Demo()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x104ade8c0</span>&gt;<br></code></pre></td></tr></table></figure><p>没有报错，似乎是完成了继承和实现。接着当然是一次执行子类中的方法来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.write_java()<br>obj.write_python()<br>obj.write_swift()<br><br>---<br>实现了Java代码的开发<br>实现了Python代码的开发<br>实现了swift代码的开发<br></code></pre></td></tr></table></figure><p>没毛病，现在我们完成了整个代码。</p><p>那小伙伴们现在估计最大的疑问是：抽象类我要应用在什么地方呢？</p><p>比如说，我们现在要开发一个框架，这个框架要有一大堆的功能，包括<code>a,b,c</code>（哎，我忽然理解导入的为什么是<code>abc</code>这样起名了）。但是呢，具体用这个框架开发什么样的产品我们并不清楚，因此这个框架中能否知道你要做什么样的开发吗？肯定不知道。</p><p>框架具备了一定的功能即可，剩下的，需要具体开发项目的人来实现自己的业务逻辑。</p><p>那这个时候，我们就要用到抽象类了。</p><p>好了，到目前为止，我们关于面向对象编程也就介绍的差不多了。而我们的Python课程基本上也到了尾声，在后面的课程中，我们会介绍一下Python中的装饰器。然后去学习一下几个用的特别广的库，包括<code>matplotlib</code>,<code>numpy</code>以及<code>pandas</code>。</p><p>小伙伴们，大家对于此前的Python基础一定要好好的理解，好好练习。这样，越往后我们才能越轻松的开展后面的学习。</p><p>行，本节课到这里就结束了，下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/OOP-Descriptor-and-design-patterns/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi， 大家好，我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>22. 面向对象 - 高阶</title>
    <link href="https://hivan.me/Object-Oriented-Programming-Higher-Level/"/>
    <id>https://hivan.me/Object-Oriented-Programming-Higher-Level/</id>
    <published>2023-08-17T03:38:54.000Z</published>
    <updated>2023-08-17T17:59:14.124Z</updated>
    
    <content type="html"><![CDATA[<img src="/Object-Oriented-Programming-Higher-Level/cover.png" class="" title="img"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>之前的课程里面，我们简单的接触了面向对象编程，也和大家讲解了其思想，优缺点。相信上节课程结束之后，大家对面向对象都有了一定的理解。</p><p>那么我们这节课，就进入面向对象的一些高阶部分，让我们继续来学习一些魔术方法以及Python的内置成员，然后再来学习一下描述符与设计模式。</p><ol type="1"><li>内置成员</li><li>魔术方法</li><li>描述符</li><li>设计模式</li></ol><p>好，正课走起。让我们开始。</p><h2 id="内置成员">内置成员</h2><p>当我们创建一个类之后，即便我们还什么都没做，这个类里面就已经有内容了，我们来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 获取类/对象的所属成员</span><br>res = Demo.__dict__<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><p>上节课我们学过了<code>__dict__</code>，这个是获取类或者对象的成员的方法。打印结果我们看到其中的成员。</p><p>让我们添加些内容再来观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    name = <span class="hljs-string">&#x27;a&#x27;</span><br>    age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;say something&#x27;</span>)<br><br><span class="hljs-comment"># 获取类/对象的所属成员</span><br>res = Demo.__dict__<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Demo.say at <span class="hljs-number">0x1117a3e20</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><p>看到我们刚才定义的成员属性和成员方法也都在列了。我们还可以实例化之后获取对象的成员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = Demo()<br><span class="hljs-built_in">print</span>(obj.__dict__)<br><br>---<br>&#123;&#125;<br></code></pre></td></tr></table></figure><p>当我们实例化一个对象<code>obj</code>之后，打印发现其成员是空的。这是为什么？</p><p>原因就在于，这个方法用处其实是打印其对象的专有成员。我们再来为这个实例化对象创建一些成员再来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.sex = <span class="hljs-string">&#x27;female&#x27;</span><br><span class="hljs-built_in">print</span>(obj.__dict__)<br><br>---<br>&#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们获取了刚才创建的成员属性。</p><p>以上，就是我们使用<code>__dict__</code>获取了类和对象的所属成员，方法为：<code>类/对象.__dict__</code>。</p><p>除了获取所属成员，我们还有其他方法，比如获取「文档信息」，获取「类名称」，获取「所在文件名称」，获取「当前类的父类列表」以及获取「当前类的『继承链』。来让我们依次看一下：</p><p>还记得我们之前在创建函数的时候可以添加文档吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">obj</span>():<br>  <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">  这里是文档内容</span><br><span class="hljs-string">  &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的，类当中我们一样可以添加文档内容。然后我们可以通过<code>__doc__</code>来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    这里是一个Demo类，主要用于测试</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(Demo.__doc__)<br><br>---<br>这里是一个Demo类，主要用于测试<br></code></pre></td></tr></table></figure><p>同样的，<code>__doc__</code>不仅可以获取类的文档信息，同样可以获取到对象的。</p><p>我们使用<code>__name__</code>来获取类名称「组成的字符串」,<strong>这个方法无法对对象使用。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Demo.__name__)<br><br>---<br>Demo<br></code></pre></td></tr></table></figure><p><code>__module__</code>可以用来获取类/对象所在的文件名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Demo.__module__)<br><span class="hljs-built_in">print</span>(obj.__module__)<br><br>---<br>__main__<br>__main__<br></code></pre></td></tr></table></figure><p>如果其所在文件为当前文件，那么这里就会显示为<code>__main__</code>。</p><p>然后是<code>__base__</code>，这个方法是用来获取当前类的父类列表。这个方法有两个版本，一个是<code>__base__</code>,一个是<code>__bases__</code>。这两个方法的区别在于一个是获取继承的第一个父类，一个是继承所有的父类的列表，为了呈现的更明显，我们建立一个继承类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Demo</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(A, Demo):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(B.__base__)<br><span class="hljs-built_in">print</span>(B.__bases__)<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>还有一个就是我们上节课讲过的，MRO列表，也就是<code>__mro__</code>方法，用于获取当前类的继承链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(B.__mro__)<br><br>---<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>到此为止，我们介绍的就是常用的一些内置成员获取的一些方法。当然，这里不是全部，除此之外还有很多，因为并不是常用，所以这里我们就不多介绍了。</p><img src="/Object-Oriented-Programming-Higher-Level/image-20230817144318246.png" class="" title="img"><h2 id="方法的分类">方法的分类</h2><p>接下来呢，我们来看下面向对象的分类，包括：</p><ol type="1"><li>对象方法</li><li>类方法</li><li>绑定类方法</li><li>静态方法</li></ol><p><strong>对象方法</strong></p><p>其特征为： 1. 在类中定义方法，含有<code>self</code>参数 2.含有<code>self</code>的方法，只能使用对象进行调用。 3.该方法会把调用的对象传给进来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-comment"># 对象方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">objFunc</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is objFunc&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.objFunc()<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1171460e0</span>&gt;<br>this <span class="hljs-keyword">is</span> objFunc<br></code></pre></td></tr></table></figure><p>这个方法不能直接使用类直接调用，但是其实也不是绝对的。当我们使用类直接调用的时候，需要传递一个参数，也就是必须要<code>self</code>有参数可接收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Demo.objFunc(<span class="hljs-string">&#x27;a&#x27;</span>)<br><br>---<br>a<br>this <span class="hljs-keyword">is</span> objFunc<br></code></pre></td></tr></table></figure><p><strong>类方法</strong></p><p>类方法呢，和对象方法有不一样的地方，也有相同的地方。两者定义十分相似，不同之处是使用装饰器材：</p><p>其特征为：</p><ol type="1"><li>在类中定义的方法，使用了<code>@classmethod</code>进行了装饰</li><li>方法中有形参<code>cls</code></li><li>可以不用实例化对象，直接使用类进行调用</li><li>会把调用这个方法的类或对象传递进来</li></ol><p>来直接看代码理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 类方法</span><br><span class="hljs-meta">    @classmethod </span><span class="hljs-comment"># 装饰器</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clsFunc</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(cls)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is cls function: clsFunc&#x27;</span>)<br><br>Demo.clsFunc()<br>obj.clsFunc()<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;<br>this <span class="hljs-keyword">is</span> cls function: clsFunc<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;<br>this <span class="hljs-keyword">is</span> cls function: clsFunc<br></code></pre></td></tr></table></figure><p>看结果可以看到，我们用类进行调用的时候并没有像对象方法一样传递一个参数进去，这是因为调用的时候会直接传递调用的类给到<code>cls</code>参数。而我们说不需要实例化对象，并不是实例化对象不可调用。对象调用也是可以的。</p><p>至于什么是「装饰器」，我们以后会详细讲到，这里先记住这种形式就可以了。</p><p><strong>绑定类方法</strong></p><p>这个方法不传递任何对象和类。在定义的时候，不设定任何的形参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># 绑定类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bindClassFunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is bind Class function: bindClassFunc&#x27;</span>)<br><br><span class="hljs-comment"># 调用</span><br>Demo.bindClassFunc()<br><br>---<br>this <span class="hljs-keyword">is</span> bind Class function: bindClassFunc<br></code></pre></td></tr></table></figure><p>那么绑定类方法既然没有定义形参，那么这个方法是无法使用实例化对象来调用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.bindClassFunc()<br><br>---<br>TypeError: Demo.bindClassFunc() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p>其特征如下： 1. 在类中定义的方法，不必须设置形参。 2.只能使用类进行调用。 3.可以传递任意参数，但是不会将类作为参数传递进来。</p><p><strong>静态方法</strong></p><p>「静态类方法」和「类方法」相似，也需要一个装饰器。并且，静态类方法也是不需要设置形参的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-comment"># 静态类方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">staticFunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is static method func&#x27;</span>)<br><br>Demo.staticFunc()<br>obj.staticFunc()<br><br>---<br>this <span class="hljs-keyword">is</span> static method func<br>this <span class="hljs-keyword">is</span> static method func<br></code></pre></td></tr></table></figure><p>那从结果中我们可以看到，「静态类方法」可以使用类和对象进行调用，并且调用的时候不需要传递任何参数。</p><p>其特征如下： 1. 在类中定义的方法，使用装饰器<code>@staticmethod</code> 进行了装饰 2. 可以使用对象或者类进行调用 3.不会将对象或者类作为参数传递进来</p><blockquote><p>⚠️注意：这里我们需要注意的，「静态类方法」只是可以不设置参数，并不是不能设置参数，并且，就算是设置了参数之后，也是不接受类和对象作为参数传递的。比如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">staticFunc</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a:<span class="hljs-subst">&#123;a&#125;</span>, b:<span class="hljs-subst">&#123;b&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is static method func&#x27;</span>)<br><br><span class="hljs-comment"># 调用</span><br>Demo.staticFunc(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>)<br>obj.staticFunc(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;obj&#x27;</span>)<br><br>---<br>a:static, b:<span class="hljs-keyword">class</span><br><span class="hljs-title class_">this</span> <span class="hljs-keyword">is</span> static method func<br>a:static, b:obj<br>this <span class="hljs-keyword">is</span> static method func<br></code></pre></td></tr></table></figure><p>我们分别用类和对象进行了调用并传递了两个参数进行打印，而打印结果正常，并且没有对象或者类被传递。</p><p>相应的，「绑定类方法」也是这种特性，只是「绑定类方法」只支持类调用，不支持对象调用。</p><h2 id="常用函数">常用函数</h2><p>其实在之前，关于「常用函数」我们已经接触过了一些，比如：<code>issubclass(子类，父类)</code>。有些小伙伴可能还记得，这个函数是用于检测一个类是否为另一个类的子类。</p><p>那除了这个之外，Python中还有很多其他的一些针对类和对象的常用函数，下面让我们来详细看一下。</p><p><code>isinstance(对象，类)</code>，用于检测一个对象是否是该类或者该类的子类的实例化结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = D()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, D))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这个结果显而易见，那么我们思考一下，既然<code>D</code>类继承了<code>B</code>类和<code>C</code>类，那么<code>obj</code>对象是否也是<code>B</code>或者<code>C</code>的实例化结果呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, B))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>可见，对于继承了父类的子类，其实例化对象和父类之间也会被检测为<code>True</code>。</p><p><code>hasattr(对象/类,'成员名称')</code>，这个函数是用于检测类/对象是否包含指定名称的成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">B.name = <span class="hljs-string">&#x27;张三&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在这段代码中，我们给父类<code>B</code>添加了一个成员属性<code>name</code>，因为<code>obj</code>是<code>D</code>的实例化对象（之前的代码中）。而<code>D</code>类是继承自<code>B</code>类的，所以自然<code>obj</code>中也是包含了<code>name</code>这个成员属性的。所以我们的检测结果必然为<code>True</code>。</p><p>来，我们做另外一个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">objB = B()<br>D.age = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(D.age)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(objB, <span class="hljs-string">&#x27;age&#x27;</span>))<br><br>---<br><span class="hljs-number">20</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>我们重新用<code>B</code>类实例化了一个对象<code>objB</code>，然后我们给<code>D</code>类添加了一个成员属性<code>age</code>，并且打印了一遍证实其存在。这个时候我们检测了一下<code>objB</code>中是否含有<code>age</code>，因为<code>D</code>为<code>B</code>的子类，它说添加的成员属性为独有属性，并不会更改到<code>B</code>类里，那自然<code>B</code>的实例化对象<code>objB</code>中是不可能存在这个成员属性的，结果自然为<code>False</code>。</p><p>``</p><p><code>getattr(对象/类,'成员名称')</code>,用于获取类/对象的成员的值</p><p>那这个函数就好理解了，我们可以用之前建立好的实例化对象<code>objB</code>和<code>obj</code>来获取一下试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;age&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(objB, <span class="hljs-string">&#x27;name&#x27;</span>))<br><br>---<br><span class="hljs-number">20</span><br>张三<br></code></pre></td></tr></table></figure><p>没问题，结果如我们所料一般。那如果是获取<code>objB</code>中的<code>age</code>的值会如何？我们前面已经知道，<code>objB</code>中并未存在<code>age</code>这个成员属性，所以必然会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(objB, <span class="hljs-string">&#x27;age&#x27;</span>))<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><p><code>setattr(对象/类,'成员名称','成员的值')</code>,这个函数用于设置类/对象的成员的属性值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>))<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br>du<br></code></pre></td></tr></table></figure><p>如结果所见，这个方法的返回值为<code>None</code>，但是我们通过打印<code>obj.name</code>可知，方法确实更改了<code>obj</code>中<code>name</code>的值。</p><p><code>delattr(类/对象,'成员名称')</code>这个函数可以删除类/对象的成员属性，和<code>del</code>直接删除对象的成员是一样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">delattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>))<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br>张三<br></code></pre></td></tr></table></figure><p>可见，这个方法也是没有返回值的，返回了<code>None</code>。不过，既然我们已经删除了<code>obj</code>中的<code>name</code>，为啥还能打印出<code>张三</code>呢？有没有小伙伴知道为什么？其实，我们删除的<code>name</code>是之前使用<code>setattr</code>为<code>obj</code>设定的专有成员，当它被删除之后，我们的<code>obj</code>的继承类<code>D</code>中还存在着<code>name</code>这个成员属性，所以现在打印出来的<code>张三</code>是从<code>D</code>类中继承过来的。</p><p>那如果是我们新添加的但是其他类中没有的属性就会直接报错了，来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.size)<br><span class="hljs-built_in">delattr</span>(obj, <span class="hljs-string">&#x27;size&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.size)<br><br>---<br>small<br>AttributeError: <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;size&#x27;</span><br></code></pre></td></tr></table></figure><p>我们分别打印了两次，第一次<code>setattr</code>了一个成员属性<code>size</code>，并且打印验证了。然后我们执行<code>delattr</code>，删除了刚才设置的成员属性<code>size</code>，这次再打印来看，报错了。</p><p><code>dir()</code>这个函数可以获取当前对象所有可以访问的成员的列表。正好，让我们来看看是否从还存在从<code>B</code>类中继承的成员属性<code>name</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">dir</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到打印结果的最后面，确实还存在着<code>name</code>这个成员属性。</p><p>以上函数在讲解的过程中，我们使用的都是成员属性，而成员方法其实是一样的。因为这几个函数说针对的对象都是「成员」。</p><p>另外需要注意的一点是，以上所有这些常用函数，都是在可访问的情况下才可执行。我们还有一些不可访问的情况，比如说「私有成员属性」，这种成员是无法被访问或者操作的，我们随便拿个函数来举一个例子看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>():<br>    name = <span class="hljs-string">&#x27;张三&#x27;</span><br>    _age = <span class="hljs-number">25</span><br>    __sex = <span class="hljs-string">&#x27;female&#x27;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Sex:<span class="hljs-subst">&#123;__sex&#125;</span>&#x27;</span>)<br><br>obj = D()<br><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;__sex&#x27;</span>)<br><br>---<br>Sex:female<br>AttributeError: <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__sex&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，当我们意图用<code>getattr</code>来获取实例化对象<code>obj</code>中的<code>__sex</code>属性时报错了。无法正确访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">dir</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_D__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><p>当我们使用<code>dir()</code>来查看的时候，其中也并没有<code>__sex</code>这个成员属性，有的只是类的私有成员属性:<code>_D__sex</code>，我们需要借助类从内部才可访问到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;_D__sex&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;female&#x27;</span><br></code></pre></td></tr></table></figure><p>这样是可以的。</p><h2 id="魔术方法">魔术方法</h2><p>我们在这节课之前，讲到过「魔术方法」，那我们已经了解，魔术方法是不需要手动调用就可以自动执行的方法。</p><p>那我们之前已经讲解过<code>__init__</code>，这是一个初始化方法。然后还有一个<code>__del__</code>方法，是一个销毁方法。</p><p>这两个方法除了功能上的不同之外，还有一个最大的不同点就是被触发的机制是不一样的。其实，魔术方法中，最重要的一点就是要了解方法的触发机制是什么。</p><p>让我们先列出来常用的魔术方法，包括其触发机制，作用以及参数等等...</p><ol type="1"><li><code>__init__</code>， 初始化方法, <code>*****</code></li></ol><p><strong>触发机制：</strong>当实例化对象之后就会立即触发的方法<strong>作用：</strong>为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，方法的调用， 打开或者创建一些资源等等。<strong>参数：</strong>一个<code>self</code>，接收当前对象，其他参数根据需求进行定义即可。 <strong>返回值：</strong>无<strong>注意事项：</strong>无</p><ol start="2" type="1"><li><code>__new__</code>，构造方法, <code>****</code></li></ol><p><strong>触发机制：</strong>实例化对象时自动触发（在<code>__init__</code>之前触发）<strong>作用：</strong>管理控制对象创建的过程<strong>参数：</strong>一个<code>cls</code>接收当前类，其它参数根据初始化方法的参数进行决定<strong>返回值：</strong>必须返回<code>object.__new__(cls)</code>进行对象的创建，如果没有返回值，则实例化对象的结果为<code>None</code><strong>注意事项：</strong><code>__new__</code>方法的参数和<code>__init__</code>方法的参数要保持一致，除了第一个参数。必须返回<code>object.__new__(cls)</code>进行对象的创建，如果没有返回值，则实例化对象的结果为<code>None</code><strong>应用场景：</strong>设计模式中的单例设计模式。</p><ol start="3" type="1"><li><code>__del__</code>，析构方法, <code>*****</code></li></ol><p><strong>触发机制：</strong>当该类对象被销毁时，自动触发<strong>作用：</strong> 关闭或释放对象创建时打开或创建的一些资源<strong>参数：</strong> 一个<code>self</code>，接受当前的对象<strong>返回值：</strong>无 <strong>注意事项：</strong> 无</p><ol start="4" type="1"><li><code>__call__</code> , <code>***</code></li></ol><p><strong>触发机制:</strong> 把对象当作函数直接调用时自动触发<strong>作用:</strong> 一般用于归纳类或对象的操作步骤，方便调用<strong>参数</strong>：一个<code>self</code>接收当前对象，其它参数根据调用需求缺点<strong>返回值</strong>：可有可无</p><p>5.<code>__len__</code></p><p><strong>触发机制:</strong>当使用<code>len</code>函数去检测当前对象的时候自动触发<strong>作用:</strong>可以使用<code>len</code>函数检测当前对象中某个数据的信息<strong>参数</strong>: 一个<code>self</code>接收当前对象<strong>返回值</strong>：必须有，并且必须是一个整型<strong>注意事项</strong>：<code>len</code>要获取什么属性的值，就在返回值中返回哪个属性的长度即可</p><p>6.<code>__str__</code></p><p><strong>触发机制:</strong>当使用<code>str</code>或者<code>print</code>函数对对象进行操作时自动触发<strong>作用:</strong> 代码对象进行字符串的返回，可以自定义打印的信息<strong>参数</strong>：一个<code>self</code>，接收当前对象<strong>返回值</strong>：必须有，而去必须是字符串类型的值</p><p>7.<code>__repr__</code></p><p><strong>触发机制:</strong>在使用<code>repr</code>方法对当前对象进行转换时自动触发<strong>作用:</strong> 可以设置<code>repr</code>函数操作对象的结果<strong>参数</strong>： 一个<code>self</code>，接收当前对象<strong>返回值</strong>： 必须有，而去必须是字符串类型的值<strong>注意</strong>：正常情况下，如果没有<code>__str__</code>这个魔术方法，<code>__repr__</code>方法就会代替<code>__str__</code>魔术方法</p><p>8.<code>__bool__</code></p><p><strong>触发机制:</strong>当前使用<code>bool</code>函数转换当前对象时，自动触发.默认情况下，对象会转为<code>True</code><strong>作用:</strong>可以代替对象进行<code>bool</code>类型的转换，可以转换任何数据<strong>参数</strong>: 一个<code>self</code>接收对象<strong>返回值</strong>： 必须是一个布尔类型的返回值</p><p>以上，我们把常用魔术方法都列出来之后，然后我们来些代码进行讲解。让我们先创建一个<code>Person</code>类，然后在其中协商构造方法，初始化方法和析构方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-built_in">print</span>(kwargs)<br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发初始化方法:__init__&#x27;</span>)<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发了析构方法:__del__&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>&#123;&#125;<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>当我们完成实例化的时候，「构造方法」先是用<code>*args</code>接收了所有传递的参数，并且使用存储了元组。我们可以看到，<code>**kwargs</code>什么都没接收到，所以打印为空。</p><p>当「构造方法」执行完之后，也并没有去执行「初始化方法」和「析构方法」，这又是为什么呢？这是因为如果在「构造方法」中没有返回对象，这对象无法创建。要想对象进行创建，这我们必须返回<code>object.__new__(cls)</code>进行对象的创建。这在之前「构造方法」的说明里有说明。这个<code>cls</code>参数是什么呢？我们直接来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-comment"># print(kwargs)</span><br>        <span class="hljs-built_in">print</span>(cls)<br>        <span class="hljs-comment"># 如果该方法中没有返回对象，则无法创建对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__new__(cls)<br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发初始化方法:__init__&#x27;</span>)<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发了析构方法:__del__&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Person&#x27;</span>&gt;<br>触发初始化方法:__init__<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107f3c070</span>&gt;<br></code></pre></td></tr></table></figure><p>现在可以看到，我们打印了<code>cls</code>，实际上就是<code>Person</code>这个类。当我们返回<code>object.__new__(cls)</code>之后，可以看到<code>__init__</code>初始化方法正确运行了，执行了方法内的打印方法。然后最后，我们打印了<code>zs</code>这个实例化对象。那为什么<code>__del__</code>析构方法没有触发？因为我们是在<code>Jupyter</code>中执行，并未执行释放，此时我们如果<code>del zs</code>，则会触发析构方法，或者，我们讲上述代码保存为一个<code>22.py</code>文件，然后单独执行，这个时候Python的垃圾回收机制会执行，就会进行释放，从而触发析构方法。如下图：</p><img src="/Object-Oriented-Programming-Higher-Level/image-20230817210119680.png" class="" title="img"><p>我们接着上面写的代码在<code>22.py</code>中继续写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">zs()<br><br>---<br>TypeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span><br></code></pre></td></tr></table></figure><p>报警，告知我们这个类当中没有cllable。那如果我们讲这个类改造下，加上<code>__call__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 魔术方法</span><br><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        ...<br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">slef, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你把对象当成了函数进行调用。&#x27;</span>)<br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        ...<br><br><span class="hljs-comment"># 实例化对象</span><br>...<br>zs()<br><br>---<br>...<br>你把对象当成了函数进行调用。<br>触发了析构方法:__del__<br></code></pre></td></tr></table></figure><p>这样，我们直接执行<code>zs()</code>就没问题了，可以把对象当作函数直接调用时自动触发。</p><p>让我们继续，返回到<code>22.ipynb</code>笔记本文件中，让我们重新定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">len</span>(obj)<br><br>---<br>TypeError: <span class="hljs-built_in">object</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;Demo&#x27;</span> has no <span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><p>报错信息中可以看出，这个实例化对象是没有<code>len()</code>方法的。我们如果给它加上<code>__len__</code>之后就会让其拥有<code>len()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>因为当前我们在类中定义的<code>items</code>里面没有数据，所以返回的长度必然也是<code>0</code>。但是这个返回值是必须要有的，需要返回一个整型才行。</p><p>来，我们看看如果这个方法的返回值写死会如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>很明显，我们重新给<code>obj.items</code>进行了赋值，目前其长度是<code>7</code>,可是返回值依然是<code>1</code>。说明<code>__len__</code>的返回值只要四个整型就行。那我们就需要注意了，<code>len</code>需要获取什么属性的值，就在返回值中返回哪个属性的长度即可。当我们用正确的方式返回的时候就会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>让我们继续接着这段代码来玩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>res = <span class="hljs-built_in">str</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x110631270</span>&gt;<br></code></pre></td></tr></table></figure><p>发现没有，虽然我们使用了<code>str()</code>方法，可是最后返回的结果，和直接打印<code>obj</code>的结果是一样的。那为什么会这样呢？这是因为我们这个当前的方法其实是对<code>obj</code>对象进行了一个转化字符串操作，而其本身就返回了一个<code>&lt;__main__.Demo object at 0x110631270&gt;</code>的字符串。</p><p>其实这个返回的字符串我们也是可以自定义的,使用<code>__str__</code>方法给一个返回值就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;__Demo__, 此字符串返回的是茶桁自定义的结果。&gt;&#x27;</span><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>...<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;__Demo__, 此字符串返回的是茶桁自定义的结果。&gt;<br></code></pre></td></tr></table></figure><p>我们直接打印了<code>obj</code>对象，因为<code>__str__</code>方法的存在，所以现在直接打印了返回的字符串。也就是说，该方法可以代替对象进行<code>str</code>或者<code>print</code>的字符串信息返回。</p><p>继续来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># def __str__(self):</span><br>        <span class="hljs-comment"># ...</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是一个repr返回的内容&#x27;</span><br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>这是一个<span class="hljs-built_in">repr</span>返回的内容<br></code></pre></td></tr></table></figure><p>可以看到我在类中注释了<code>__str__</code>方法，这是因为只有其不存在的情况下，<code>__repr__</code>方法才会起作用，可以替代<code>__str__</code>方法。</p><p>那么到底<code>__str__</code>和<code>__repr__</code>两个到底有什么区别呢？让我们直接在代码里找答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">521</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(num))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(num))<br><br>---<br><span class="hljs-number">521</span><br><span class="hljs-number">521</span><br></code></pre></td></tr></table></figure><p>这个时候两个的结果都是一样的，似乎并看不出两者到底有什么区别。别急，让我们继续往后做这个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">521</span><br>r1 = <span class="hljs-built_in">str</span>(num)<br>r2 = <span class="hljs-built_in">repr</span>(num)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r1: <span class="hljs-subst">&#123;r1&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r1)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r2: <span class="hljs-subst">&#123;r2&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r2)&#125;</span>&#x27;</span>)<br><br>---<br>r1: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>r2: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>两者的类型都是一样的，返回了一个字符串类。难道这两者就正的毫无区别吗？Python得创建者吃饱了撑的没事做两个功能一模一样但是名字不同的方法？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;521&#x27;</span><br>r1 = <span class="hljs-built_in">str</span>(s)<br>r2 = <span class="hljs-built_in">repr</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r1: <span class="hljs-subst">&#123;r1&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r1)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r2: <span class="hljs-subst">&#123;r2&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r2)&#125;</span>&#x27;</span>)<br><br>---<br>r1: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>r2: <span class="hljs-string">&#x27;521&#x27;</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>仔细看，两者似乎有了细微的差别。<code>repr</code>解析的结果带着引号。</p><p>那么，<code>str</code>和<code>repr</code>函数都可以把其他类型的数据转为字符串类型。<code>str</code>函数会把对象转为更适合人阅读的形式，<code>repr</code>函数会把对象转为解释器读取的形式。</p><p>如果数据对象并没有更明显的区别的话，<code>str</code>和<code>repr</code>的转化结果还真没什么区别。</p><p>这两者的区别，其实只要了解一下就可以了。大部分时候，并不需要那么较真。</p><p>接着让我继续来看看<code>__bool__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">bool</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>当我们对<code>obj</code>使用<code>bool()</code>方法的时候，返回值为<code>True</code>。那说明其中包含了一个<code>bool</code>机制，并且默认返回值为<code>True</code>。</p><p>这个时候让我们来定义一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(self.items)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>res = <span class="hljs-built_in">bool</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>由于我们的<code>items</code>中设置为空值，而我们将前面定义<code>obj</code>的<code>items</code>的那段代码删掉了，所以这个时候，传入方法的<code>self.items</code>的值也为空，必然返回值就是<code>False</code>。也证明了，<code>bool(obj)</code>拿到的返回值就是类里定义的的<code>__bool__</code>中返回的对象。</p><p>介绍完常用的一些魔术方法之后，我们再来看一些其他的魔术方法。同样是魔术方法，为什么我要明显的区别开来讲呢？那是因为现在开始说讲的魔术方法都是针对成员的，是一些成员相关魔术方法。</p><ol type="1"><li><code>__getattribute__</code>: 优先级最高</li></ol><p><strong>触发机制</strong>:当访问对象成员时，自动触发，无论当前成员是否存在 <strong>作用</strong>:可以在获取对象成员时，对数据进行一些处理 <strong>参数</strong>: 1.<code>self</code>接收对象，2. <code>item</code>接收当前访问的成员名称<strong>返回值</strong>: 可有可无，返回的值就是访问的结果<strong>注意事项</strong>:在当前的魔术方法中，禁止对当前对象的成员进行访问，会触发递归。如果想要在当前魔术方法中访问对象的成员必须使用<code>object</code>来进行访问。格式：<code>object.__getattribute__(self,item)</code></p><ol start="2" type="1"><li><code>__getattr__</code></li></ol><p><strong>触发机制</strong>：当访问对象中不存在的成员时，自动触发<strong>作用</strong>：防止访问不存在的成员时报错，也可以为不存在的成员进行赋值操作<strong>参数</strong>: 1. <code>self</code>接收当前对象，2.<code>item</code>接收当前访问的成员名称<strong>返回值</strong>：可有可无 <strong>注意事项</strong>：当存在<strong>getattribute</strong> 方法时，会去执行<strong>getattribute</strong>方法。也要注意，不要在当前的方法中再次去访问这个不存在的成员，会触发递归操作</p><ol start="3" type="1"><li><code>__setattr__</code></li></ol><p><strong>触发机制</strong>：当给对象的成员进行赋值操作时会自动触发（包括添加，修改）<strong>作用</strong>： 可以限制或管理对象成员的添加和修改操作<strong>参数</strong>： 1. <code>self</code>接收当前对象 2.<code>key</code>设置的成员名 3. <code>val</code>设置的成员值<strong>返回值</strong>： 无<strong>注意事项</strong>：在当前的魔术方法中禁止给当前对象的成员直接进行赋值操作，会触发递归操作。如果想要给当前对象的成员进行赋值，需要借助<code>object</code> <strong>格式</strong>：<code>object.__setattr__(self,key,value)</code></p><ol start="4" type="1"><li><code>__delattr__</code></li></ol><p><strong>触发机制</strong>： 当删除对象成员时自动触发<strong>作用</strong>：可以去限制对象成员的删除，还可以删除不存在成员时防止报错<strong>参数</strong>：1. <code>self</code>接收当前对象 2.<code>item</code>删除的成员名称 <strong>返回值</strong>： 无<strong>注意事项</strong>：在当前魔术方法中禁止直接删除对象的成员，会触发递归操作。如果想要删除当前对象的成员，那么需要借助<code>object</code>。 <strong>格式</strong>：<code>object.__delattr__(self,item)</code></p><p>好了，按照惯例，让我们上代码,先让我们来定义一个最正常的类，并且实例化它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    sex = <span class="hljs-string">&#x27;male&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;say something...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br>张三丰<br></code></pre></td></tr></table></figure><p>这个时候，让我们在类中定义一个方法：<code>__getattrbute__()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>可以看到，虽然我们在实例化对象的时候传入了成员值，但是当我们打印的时候返回值为<code>None</code>。如果我们这个时候修改一下这个魔术方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;abc&#x27;</span><br><br>...<br><span class="hljs-built_in">print</span>(obj.name)<br><span class="hljs-built_in">print</span>(obj.sex)<br>---<br>abc<br>abc<br></code></pre></td></tr></table></figure><p>那我们拿到的就是得到的内容。不仅是<code>name</code>，任意我们传入的成员，返回的值都为<code>__getattribute__</code>返回的值。当获取对象成员时，这个方法进行处罚，其中的<code>item</code>形参就是我们想要获取的成员属性。第一次是<code>obj.name</code>,第二次是<code>obj.sex</code>，但是无论你调用的是什么成员，拿到的都是这个方法的返回值<code>abc</code>。</p><p>那既然这样，是不是我们返回对象的成员属性就可以了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.name<br><br></code></pre></td></tr></table></figure><p>千万不要这么做，这样会引起方法的无限递归调用，最终导致栈溢出。那么是不是我们就没办法了？也不是，我们需要使用<code>object.__getattribute__(self, item)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <br>    <span class="hljs-comment"># 获取对象成员的时候触发</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__getattribute__(self, item)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><span class="hljs-built_in">print</span>(obj.sex)<br><br>---<br>张三丰<br>男<br></code></pre></td></tr></table></figure><p>这样，我们就获取到了正确的返回值。我们这里讲解一个<code>__getattribute__</code>方法，限于篇幅的原因，我们其他的几个方法就不细致讲了。在我们先前的列表内，每一个方法的触发机制，作用，参数和注意事项我们都有写清楚。大家可以执行去看看，并做一些测试。让我们赶紧进入下一个阶段，不过在这之前呢，我们还是需要讲访问成员的顺序给大家强调一下，这个还是比较重要：</p><ol type="1"><li>调用 <code>__getattribute__</code>魔术方法</li><li>调用数据描述符</li><li>调用当前对象的成员</li><li>调用当前类的成员</li><li>调用非数据描述符</li><li>调用父类的成员</li><li>调用<code>__getattr__</code>魔术方法</li></ol><blockquote><p>以上步骤是调用某个成员时的顺序，前面的能够调用成功，后面则不再执行。至于描述符，咱们下节课来详细讲。</p></blockquote><p>好了，本节课到这里就结束了，让我们先预告一下，下节课呢，我们来讲讲面向对象中的「描述符和设计模式」。大家期待一下吧。</p><p>记得课后好好做练习，目前我们的课程稍微有些难度了，只有保持一定的练习量，才能理解并记住。</p><p>小伙伴们，下节课再见了。下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Object-Oriented-Programming-Higher-Level/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>21. 面向对象及特性</title>
    <link href="https://hivan.me/Object-Oriented-Programming/"/>
    <id>https://hivan.me/Object-Oriented-Programming/</id>
    <published>2023-08-16T03:41:18.000Z</published>
    <updated>2023-08-16T18:01:35.602Z</updated>
    
    <content type="html"><![CDATA[<img src="/Object-Oriented-Programming/cover.png" class="" title="cover"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>今天开始，我们要迈向Python的另外一个台阶了，那就是面向对象。</p><p>面向对象编程（Object OrientedProgramming)，简称为OOP，是一种<strong>以对象为中心</strong>的程序设计思想。</p><p>与之相对的，就是面向过程编程（Procedure Oriented Programming),简称为POP, 是一种<strong>以过程为中心</strong>的程序设计思想。</p><h2 id="面向对象和面向过程">面向对象和面向过程</h2><p>接下来，让我们先了解一下这两个编程思想到底有什么不同。还记得咱们之前讲过宋丹丹老师小品里的经典的「把大象装进冰箱分几步」吗？小品给出的答案是三步对吧？</p><ol type="1"><li>第一步：打开冰箱门</li><li>第二步：把大象装进去</li><li>第三步：关上冰箱门</li></ol><h3 id="设计思想的不同">设计思想的不同</h3><p>那么这个答案，就是一种面向过程的思维，遇到问题之后，分析解决问题的步骤，然后一步步的去实现。</p><p>那么如果是面向对象的话，又该如何去做？</p><p>面向对象是通过分析问题中需要的抽象模型，然后根据需要的功能分别去创建模型对象，最终由模型对象来完成程序。那这个「把大象装进冰箱分几步」的问题我们该如何去考虑呢？</p><p>首先，面向对象要解决这个问题，需要先建立出抽象模型，比如：</p><ul><li>打开冰箱门和关闭冰箱门，这都属于一个冰箱的功能，</li><li>大象走进去，这就是大象的功能。</li><li>到此时我们就出现了<strong>两个抽象模型，一个是冰箱，一个是大象</strong>。</li></ul><p>冰箱具有 打开和关闭的功能，大象具有走路的能力。</p><p>分析到这里，就是面向对象的思想，具体完成的话，就是去创建冰箱和大象这两个对象，最终完成这个程序</p><p>冰箱对象-开门，大象对象-走进冰箱，冰箱对象-关门</p><p>这个问题解决了，我们再来思考一个新的问题：「想吃清蒸鱼怎么办？」</p><p>当然是按照做菜的顺序一步一步来对吧？<strong>这就是典型的面向过程思维：</strong></p><ol type="1"><li>买鱼，买料</li><li>杀鱼和清理，并且腌制</li><li>锅里烧水</li><li>把鱼放进去，开始蒸鱼。</li><li>十分钟后开盖，把鱼端出来，然后浇汁。</li></ol><p>这样，一步一步的完成这个愿望，就是面向过程所作的事情。</p><p><strong>轮到面向对象，又该如何呢？</strong></p><ul><li>需要一个对象：大厨。</li><li>告诉大厨，我想吃清蒸鱼。</li></ul><p>那么大厨呢，有可能是我们自己训练的，也有可能是其他五星酒店挖过来的。不管如何，这是一个已经完善建立好的对象，我们直接拿来用就可以了。面向对象呢，就是这样寻找具体的对象去解决问题。对于我们来说，调用了对象，而对象完成了这个过程。</p><p>当然，具体大厨这个对象里肯定还是一步一步的去完成过程，也就是说，最终面向对象中是由面向过程的体现的。但是思维方式，也就是设计思想是完全不同的。</p><h3 id="优缺点">优缺点</h3><p>既然有不同之处，那必然是有优缺点的。因为有对比嘛。面向过程有其优点，当然，面向对象也有其缺点。</p><p>面向过程的核心是过程，过程就是指几觉问题的步骤。其优缺点非常明显：</p><ul><li>优点： 将负责的问题流程化，进而实现简答。</li><li>缺点： 扩展性差（更新、维护、迭代）</li></ul><p>而面向对象的核心是对象，是一个特征和功能的综合体，其优缺点如下：</p><ul><li>优点：可扩展性高</li><li>缺点：编程复杂度相对面向过程高一些，这里的复杂度指的是计算机在执行面向对象的程序时性能表现一般。</li></ul><p>那总结起来呢，在去完成一些简单的程序时，可以使用面向过程去解决。但是如果有复杂的程序或任务，而且需要不断的进行迭代和维护，那么肯定是优先选择面向对象的编程思想</p><h3 id="如何学习面向对象编程">如何学习面向对象编程</h3><p>那我们后面<strong>如何去学习面向对象编程</strong>呢？其实就两步：</p><ol type="1"><li>学习面向对象编程的思想</li><li>学习面向对象编程的语法</li></ol><p>这两步中，其实难的是第一步，学习面向对象编程的思想。</p><p>不管如何，什么事情都需要有个开头，那我们就从类和对象的基本概念开始好了。</p><h3 id="认识类与对象">认识类与对象</h3><p>类： 类是对象的一个抽象的概念</p><p>对象（实例）：对象就是由类创建的实例</p><p>那么这两者的关系其实就是「模具和铸件」之间的关系。</p><ol type="1"><li>类是由对象总结而来的，总结的这个过程叫做抽象。</li><li>对象是由类具体实施出来的，这个过程叫做实例化。</li></ol><p>是不是听着有些迷糊了？这里我们还是用实际例子来解释一下的好，我们思考下面的问题：</p><ul><li>水果是一个对象还是一个类？</li><li>汽车是一个对象还是一个类？</li><li>手机是一个对象还是一个类？</li></ul><p>我们在说水果的时候，你能想到什么？香蕉、苹果、西瓜、榴莲等等。对吧？那我们想了这么多不一样的东西，是不是这些所有的都称为是「水果」？那么我们将这些内容都叫做水果的过程就称为「归类」的过程。这个「水果」就是一个类，刚才我们总结的这个过程就叫做抽象，我们想到的香蕉、苹果...等等，就是对象。</p><p>汽车其实是一个概念，你能想到什么？奔驰、野马、奥迪、别摸我？那我们见过的车，就会在我们脑海中浮现，而这些具体的车总结出来一个类的过程就是「抽象的过程」，我们最后总结出来的「汽车」就是一个类。那些在我们脑海里浮现的具体的汽车，就是对象。</p><p>单我们去开车上班的时候，那么我们就是应用一个具体的对象去发生特定的功能。</p><p>再来想一个问题，我现在给大家写这个教程，用的是MacbookPro，那么请问我当前正在使用的这个MBP是对象还是一个类？</p><p>MBP的特征：金属外壳，优美的外观。</p><p>MBP的功能：给大家写教程，编辑代码，听音乐，作曲，画画....</p><p>当我描述了这么多之后，这个MBP到底是一个类还是一个对象？</p><h2 id="面向对象的基本实现">面向对象的基本实现</h2><p>如果我们需要实例一个对象，那么我们就需要先抽象一个类。</p><p>举了栗子：</p><p>我们现在需要创建一个汽车，或者千千万万个汽车用于销售。那在这之前我们要做什么？</p><p>首先，我们需要抽象一个汽车类，也就是我们要在一个设计图纸上设计处这个汽车。</p><p>然后，我们由这个设计图纸去创建（实例）出来的真实汽车就是一个对象。</p><p>那么接下来，就让我们具体到代码里去实现看看。</p><p>还记得我们之前介绍的怎么去创建一个类嘛？有没有小伙伴还记得？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个汽车的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cart</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>没错，就是使用<code>class</code>关键字来定义一个类。其书写规范如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">类名的书写规范，建议使用驼峰命名法</span><br><span class="hljs-string">    大驼峰：MyCar ChaHeng</span><br><span class="hljs-string">    小驼峰：myCar chaHeng</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>那么我们在类里需要声明些什么内容呢？一个类需要有「特征」和「功能」两个内容组成：</p><ul><li><p>特征就是一个描述：颜色：黑色， 品牌：野马，排量：2.4...；特征在编程中就是<strong>一个变量</strong>，在类中称为属性</p></li><li><p>功能就是某一项能力： 拉货，代步，上班....；功能在编程中就是<strong>一个函数</strong>，在类中称为方法</p></li></ul><p>在类中，属性一般定义在前面，方法定义在后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个汽车的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>():<br>    <span class="hljs-comment"># 属性 =&gt; 特征 =&gt; 变量</span><br>    color = <span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-comment"># 表示颜色属性</span><br>    brand = <span class="hljs-string">&#x27;mustang&#x27;</span> <span class="hljs-comment">#表示品牌属性</span><br>    displacement = <span class="hljs-number">2.4</span> <span class="hljs-comment"># 表示排量属性</span><br><br>    <span class="hljs-comment"># 方法 =&gt; 功能 =&gt; 函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pulling</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能拉货。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rode</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能代步。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">onDuty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能上班。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>现在，我们拥有了一个具体的类，里面包含了特征和功能。那么我们如何通过类实例化对象并最终使用它们呢？</p><p>很简单，将其赋值给一个具体的变量就可以了，比如，我们现在去4S店实际购买一个野马汽车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化一个对象</span><br>buyNewCar = Car()<br></code></pre></td></tr></table></figure><p>这样，就简单的实例化了一个购买的新车，让我们查看一下它的类别和各项属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(buyNewCar, <span class="hljs-built_in">type</span>(buyNewCar))<br><br><span class="hljs-comment"># 查看对象的品牌</span><br><span class="hljs-built_in">print</span>(buyNewCar.brand)<br><br><span class="hljs-comment"># 调用对象的方法</span><br>buyNewCar.rode()<br><br>---<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105e6fbb0</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Car&#x27;</span>&gt;<br>mustang<br>小汽车能代步。。<br></code></pre></td></tr></table></figure><p>这样，我们就能看到这个对象是由类<code>Car</code>实例化得来的。并且查看到了品牌属性，试用了一下其“代步”这个功能。</p><h3 id="成员属性和方法的操作">成员属性和方法的操作</h3><p>一个对象通过实例化之后，在类中定义的属性和方法，可以使用实例化的对象进行操作。</p><p>类中定义的属性也称为成员属性，类中定义的方法，也称为成员方法。</p><p>我们直接拿之前定义的类来实例化两个对象观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = Car()<br>b = Car()<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><br>---<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105d37190</span>&gt;<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105d36fe0</span>&gt;<br></code></pre></td></tr></table></figure><p>我们来看，<code>a,b</code>分别实例化之后，我们将其打印出来。看到两个对象都是通过<code>Car</code>来实例化的，但是后面不同。就是说，这两者在实例化之后，完全就是两个不同的对象。那我们可以这么说，<strong>一个类可以实例化处多个对象。</strong></p><h4 id="对象的成员操作">对象的成员操作</h4><p>在类的外部，使用对象操作成员，比如，我们可以通过对象访问类中的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = a.color<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>black<br></code></pre></td></tr></table></figure><p>还可以通过对象访问类中的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.rode()<br><br>---<br>小汽车能代步。<br></code></pre></td></tr></table></figure><p>那除了访问，我们是否可以对其进行修改呢？来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a.color = <span class="hljs-string">&#x27;red&#x27;</span><br>res = a.color<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>red<br></code></pre></td></tr></table></figure><p>可以看到，我们修改了对象的属性。那么，这个时候我们另外一个实例化对象<code>b</code>里是什么情况？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(b.color)<br><br>---<br>black<br></code></pre></td></tr></table></figure><p>依然还是<code>black</code>，并未收到<code>a</code>内属性变化的影响。</p><p>也就是说，我们操作单个对象进行属性修改，并不影响最初的类，也不会影响同一个类实例化出来的其他对象。</p><p>我们还可以给对象添加本来没有的属性来丰富这个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a.name = <span class="hljs-string">&#x27;AE86&#x27;</span><br><span class="hljs-built_in">print</span>(a.name)<br><br>---<br>AE86<br></code></pre></td></tr></table></figure><p>同样的，我们对单个对象进行的操作，一样不会影响原本的类以及其他实例化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(b.name)<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure><p>不出所料的报错了，错误类型为属性错误。告知我们并没有<code>name</code>这个属性。</p><p>好，再让我们来看看删除这个动作。我们就直接删除<code>a</code>对象刚创建的<code>name</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.name)<br><span class="hljs-keyword">del</span> a.name<br><span class="hljs-built_in">print</span>(a.name)<br><br>---<br>AE86<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure><p>程序显示打印了一次<code>name</code>的值，说明我们能正常获取，然后删除<code>a</code>对象中的这个属性，然后再打印来看，警告我们<code>AttributeError</code>类型错误。说明，这个时候的<code>name</code>已经不存在了。</p><p>好，让我们删除<code>a</code>继承下来的属性<code>brand</code>,不过这次为了让后续程序还能正常运行，我们使用<code>try</code>来捕获一下错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">del</span> a.brand<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AttributeError:&#x27;</span>, e)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a.brand: &#x27;</span>, a.brand)<br><br>---<br>AttributeError: brand<br>a.brand:  mustang<br></code></pre></td></tr></table></figure><p>可以看到，我们在执行删除<code>a.brand</code>的时候报错了，后面打印的结果也证明了<code>a.brand</code>这个属性还存在，可以被打印出来。</p><p>那么问题来了，为什么之前的<code>a.name</code>可以被删除，而<code>a.brand</code>不行？这两个属性到底有什么区别？</p><p>其实，单我们执行删除一个对象的属性时，只能删除当前这个对象自己的属性才可以。而我们执行的操作中，<code>brand</code>并不是<code>a</code>自己的属性，而是属于<code>Car</code>这个类的。因为无法进行删除。</p><p><code>a.name</code>则不一样，是单独在<code>a</code>对象内创建的属性，因此可以删除。</p><p>访问成员属性，会先访问对象自己的属性，如果没有，则去访问这个对象的类的属性。</p><p>修改对象的属性值时，实际上等于给这个对象创建了一个对象自己的属性。</p><p>添加对象的属性，是给对象创建了自己独有的属性。</p><p>删除属性，只能删除这个对象自己的属性，包括给对象添加的和修改的。</p><p>接着，我们来看看在类的外部，操作对象的方法。</p><p>访问对象的方法：实际上如果这个对象没有自己独立的方法，那么会访问这个对象的类的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.rode()<br><br>---<br>小汽车能代步<br></code></pre></td></tr></table></figure><p>我们来进行修改对象的方法：给这个对象的方法重新定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是重新定义的一个方法&#x27;</span>)<br><br>a.rode = func<br>a.rode()<br><br>---<br>这里是重新定义的一个方法<br></code></pre></td></tr></table></figure><p>这样，我们就完成了方法的重新定义。</p><p>访问、修改之后，我们能不能给对象添加新的方法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a.func2 = func<br>a.func2()<br><br>---<br>这里是重新定义的一个方法<br></code></pre></td></tr></table></figure><p>看来也是可以的，我们现在给这个对象自己新创建了一个方法。</p><p>来，删除一下方法试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> a.func2<br></code></pre></td></tr></table></figure><p>并未报错，我们继续执行下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.func2()<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;func2&#x27;</span><br></code></pre></td></tr></table></figure><p>看报错，说明我们删除成功了。</p><p>方法实际上和属性一样，我们可以删除对象自己的方法，但是无法删除对象的类的方法。</p><p>至此，我们可以总结如下：</p><p>一个类定义类成员属性和成员方法，那么通过这个类实例化的对象，也具备了这些方法和属性。</p><p>实际上，创建对象的时候，并不会把类中的属性的属性和方法复制一份给对象，而是在对象中应用父类的方法。因此在访问对象的属性时，会先去找对象自己的属性，如果没有就去找这个类的属性和方法。</p><p>一个对象由类创建以后，是一个独立的对象，会应用父类中的属性和方法。如果在对象创建后，给对象的属性或方法，进行修改或添加，那么此时等于给这个对象创建了一个自己的属性和方法。所以在删除时，只能删除对象呗修改或添加的成员。</p><p>除了在类的实例化对象中对类的成员进行操作之外，我们还可以直接在类上进行操作。比如，我们可以执行下列操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Car.brand = <span class="hljs-string">&#x27;BMW&#x27;</span><br></code></pre></td></tr></table></figure><p>那现在提一个问题，在原始类的成员修改之后，这个类创建的实例化对象会如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.brand) <span class="hljs-comment"># 先执行一次打印，原始属性</span><br>Car.brand = <span class="hljs-string">&#x27;BMW&#x27;</span><br>b = Car() <span class="hljs-comment"># 新创建一个实例化对象</span><br><span class="hljs-built_in">print</span>(b.brand) <span class="hljs-comment"># 打印新创建的对象的属性</span><br><span class="hljs-built_in">print</span>(a.brand) <span class="hljs-comment"># 打印修改之前创建的对象的属性</span><br><br>---<br>mustang<br>BMW<br>BMW<br></code></pre></td></tr></table></figure><p>很明显，我们直接在类上进行操作修改成员之后，不管是hi新创建的实例化对象，还是早已存在的实例化对象，其中的成员属性都被修改了。删除和新加都遵循着这样一个特性。</p><p>对成员属性和方法的操作，我们也就可以总结成两种，一是「对象操作成员」，一种是「类操作成员」。当然，由于类修改后会影响具体的实例化对象，所以并不推荐这么去做。</p><h4 id="对象操作成员">对象操作成员</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">成员属性：<br>  访问：  对象.成员属性名<br>  修改：  对象.成员属性名法 <span class="hljs-operator">=</span> 新值。（此时等于给这个对象创建了一个自己的属性）<br>  添加：  对象.新成员属性 <span class="hljs-operator">=</span> 值 (此时是给这个对象自己新建了一个属性)<br>  删除：  del 对象.成员属性 (注意：只能删除这个对象自己的属性)<br>  <br>成员方法：<br>  访问：  对象.成员方法名()<br>  修改：  对象.成员方法名 <span class="hljs-operator">=</span> func（此时等于给这个对象创建了一个自己的方法）<br>  添加：  对象.方法名 <span class="hljs-operator">=</span> func (此时是给这个对象自己新建了一个方法)<br>  删除：  del 对象.方法名 (注意：只能删除这个对象自己的方法)<br></code></pre></td></tr></table></figure><h4 id="类操作成员不推荐">类操作成员（不推荐）</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">成员属性：<br>  访问：  类名.成员属性名<br>  修改：  类名.成员属性名法 <span class="hljs-operator">=</span> 新值。（此时通过这个类创建的对象都具有这个属性）<br>  添加：  类名.新成员属性 <span class="hljs-operator">=</span> 值 (此时通过这个类创建的对象都具有这个属性)<br>  删除：  del 类名.成员属性 (注意：删除这个类的属性后，这个类创建的对象也没有这几个属性了)<br>  <br>成员方法：<br>  访问：  类名.成员方法名()<br>  修改：  类名.成员方法名 <span class="hljs-operator">=</span> func（此时通过类创建的对象都被修改）<br>  添加：  类名.方法名 <span class="hljs-operator">=</span> func (此时通过类创建的对象都被修改)<br>  删除：  del 类名.方法名 (注意：此时通过类创建的对象都被修改)<br></code></pre></td></tr></table></figure><p><strong>最终总结一下如下：</strong></p><ul><li>一个类可以实例化出多个对象，每个对象在内存中都独立存在的</li><li>当通过类实例化对象时，并不会把类中的成员复制一份给对象，而去给对象了一个引用</li><li>访问对象成员的时候，如果对象自己没有这个成员，对象会向实例化它的类去查找</li><li>对象成员的添加和修改，都只会影响当前对象自己，不会影响类和其它对象</li><li>删除对象的成员时，必须是该对象自己具备的成员才可以，不能删除类中引用的成员</li><li>对类的成员操作，会影响通过这个类创建的对象，包括之前创建的。</li></ul><h3 id="成员方法中的self">成员方法中的<code>self</code></h3><p><code>self</code>在方法中只是一个形参，并不是关键字。从它本身的意义上来说，是可以用其他的关键字去替换的，但是长久以来的惯例大家都一直在使用<code>self</code>。</p><p>其作为英文单词的本意是：自己。那么在类的方法中则代表的是「当前这个对象」。不太明白？让我们来看一个实际的例子：</p><p>让我们先定义一个「Person」类，然后实例化一个「张三」：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    sex = <span class="hljs-string">&#x27;sex&#x27;</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会唱歌&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会跳舞&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rap</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会饶舌&#x27;</span>)<br><br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>name<br></code></pre></td></tr></table></figure><p>成功打印出了<code>name</code>， 说明我们成功实例化了。</p><p>通过实例化的对象，我们可以在类的外部去访问成员属性和成员方法。（对象.成员）。</p><p>同样的，我们其实也可以在类的内部去访问成员属性和成员方法。让我们做一个实验，来说明一下<code>self</code>到底是什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    ...<br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-comment"># print(zs.name)</span><br><span class="hljs-built_in">print</span>(zs)<br>zs.func()<br><br>---<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a048c10</span>&gt;<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a048c10</span>&gt;<br></code></pre></td></tr></table></figure><p>我们修改了这个类，在内部创建了一个方法<code>func(self)</code>，然后打印了<code>self</code>这个参数。</p><p>然后我们在外面打印了实例化的<code>zs</code>，还通过这个具体的实例化对象执行了类内部的<code>func</code>方法。实际上就是打印了一下此刻的<code>self</code>。可以看到，两个打印结果完全一样，那说明，这两者本身就是一个东西。</p><p><code>self</code>代表调用这个方法的对象，谁调用了这个方法，<code>self</code>就代表的是谁。<code>self</code>就可以在类的内部代替对象进行各种操作。</p><p>我们通过<code>self</code>来进行的操作，其实完全就是实例化的对象所作的操作。我们在类中修改<code>func</code>这个方法，让其打印<code>name</code>，修改<code>name</code>， 调用方法<code>rap</code>来试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    ...<br><br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(self.name)<br>        self.name = <span class="hljs-string">&#x27;茶桁&#x27;</span><br>        <span class="hljs-built_in">print</span>(self.name)<br>        self.rap()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br>zs.name = <span class="hljs-string">&quot;张三&quot;</span><br>zs.func() <br><br>---<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a06bf40</span>&gt;<br>张三<br>茶桁<br>会饶舌<br></code></pre></td></tr></table></figure><p>我们就可以很清晰的看到<code>self</code>代表的含义，谁调用，<code>self</code>就代表谁。也就是说，只要是对象能干的事情，<code>self</code>就可以代表对象去完成，比如成员的添加、删除、更新、访问、调用等等。</p><p>我们再来修改一下类里的方法，让其更清晰的显示这个特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    ...<br><br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rap</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;self.name&#125;</span>, 我会饶舌&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>       ...<br>        self.rap()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br>zs.name = <span class="hljs-string">&quot;张三&quot;</span><br>zs.func() <br><br>---<br>我是张三, 我会饶舌<br></code></pre></td></tr></table></figure><p>在类中，我们修改了一下<code>rap</code>方法，让其调用<code>self.name</code>，在类被定义的时候，这个类中的<code>name</code>是被赋值为<code>name</code>的。然后，我们在<code>func</code>方法中调用了一下<code>self.rap()</code>,我们对其进行实例化一个对象<code>zs</code>，并且在这个实例中对<code>name</code>进行了重新赋值<code>张三</code>,接着，调用了实例化对象中的<code>func()</code>方法。</p><p>我们清晰的看到，<code>func()</code>调用了<code>self.rap()</code>，然后将<code>张三</code>打印在了屏幕上。充分说明了，这个时候的<code>self</code>代表的就是调用它的<code>zs</code>这个实例化对象。</p><p>我们直接调用类中的方法试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Person.func()<br><br>---<br>TypeError: Person.func() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">&#x27;self&#x27;</span><br></code></pre></td></tr></table></figure><p>我们收到了报错，被告知缺少必须的位置参数<code>self</code>。</p><p>好，那让我们再来做两个实验，第一个实验中，我们测试一下如果在类中的方法没有使用<code>self</code>接受参数会怎样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个没有`self`的方法。&#x27;</span>)<br><br>Person.func()<br><br>a = Person()<br>a.func()<br><br>---<br>我是一个没有`self`的方法。<br>TypeError: Person.func() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p>可以看到，我们可以使用类直接调用这个方法有效，但是我们创建一个实例化对象之后，利用实例化对象去调用则会报错。这个是因为，我们在用实例化对象去调用类中的方法的时候会传入一个参数。但是现在类中的<code>func()</code>方法并没有可以接受的参数，那么必定会报错。</p><p>第二个实验，我们试试不用<code>self</code>，而是其他的参数是否可以成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"><span class="hljs-built_in">vars</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;<span class="hljs-built_in">vars</span>.name&#125;</span>, 我使用了vars来接受参数。&#x27;</span>)<br><br>a = Person()<br>a.name = <span class="hljs-string">&#x27;admin&#x27;</span><br>a.func()<br><br>---<br>我是admin, 我使用了<span class="hljs-built_in">vars</span>来接受参数。<br></code></pre></td></tr></table></figure><p>可以看到，完全没有问题。也就是说，用实例化对象调用类中的方法时，是一定会将自己作为一个参数传给这个方法，需要一个具体的参数去接受。而参数的名称是什么则无所谓，只是大家在习惯上都是用<code>self</code>。区别如下：</p><ul><li>含有<code>self</code>或者可以接受对象作为参数的方法：非绑定类方法</li><li>不含<code>self</code>或者不能接受对象作为参数的方法：绑定类方法</li></ul><p>非绑定类方法，可以使用对象去访问, 绑定类方法，只能通过类去访问。</p><h3 id="魔术方法">魔术方法</h3><p>魔术方法是什么呢？</p><p>魔术方法也和普通方法一样都是类中定义的成员方法。这是一种不需要去手动调用的，在某种情况下，自动触发（自动执行）的方法。魔术方法特殊就特殊在定义的时候，多数的魔术方法前后都有两个连续的下划线。但是切记，这个方法并不是我们自己定义的，而是系统定义好的，我们来使用而已。</p><h4 id="init__-初始化方法"><code>__init__</code> 初始化方法</h4><p>这个初始化方法是在通过类实例化对象之后，自动触发的一个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个初始化方法。&#x27;</span>)<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大家好，我是茶桁。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><br>---<br>我是一个初始化方法。<br></code></pre></td></tr></table></figure><p>注意到了么？我们仅仅是实例化的对象而已，并没有进行任何调用，初始化方法就执行了一遍。那么，我们可以得到下面这些内容：</p><ul><li><code>__init__</code> 触发机制：在通过类实例化对象后，自动触发的一个方法</li><li>作用：可以在对象实例化之后完成对象的初始化（属性的复制，方法的调用）。</li><li>应用场景：文件的打开，数据的获取。 干活之前，做好一些准备工作。</li></ul><p>以下，我们改造一下这个类，然后再实例化的时候多做一些动作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个初始化方法。&#x27;</span>)<br>        <span class="hljs-comment"># 完成对象属性的初始化赋值</span><br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大家好，我是茶桁。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">41</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我叫<span class="hljs-subst">&#123;zs.name&#125;</span>, 我今年<span class="hljs-subst">&#123;zs.age&#125;</span>岁，性别:<span class="hljs-subst">&#123;zs.sex&#125;</span>&#x27;</span>)<br><br>---<br>我是一个初始化方法。<br>我叫张三, 我今年<span class="hljs-number">41</span>岁，性别:male<br></code></pre></td></tr></table></figure><p>当然，我们还可以再初始化方法中调用<code>say</code>方法，完成自我介绍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>  ...<br>  self.say()<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;打击好，我是<span class="hljs-subst">&#123;self.name&#125;</span>。&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="del__-析构方法"><code>__del__</code>： 析构方法</h4><p>和初始化方法一样，我们直接来解析一下这个方法的触发机制，作用以及注意点。</p><ul><li>触发机制： 析构方法方法会在对象被销毁时自动触发。</li><li>作用：关闭一些开发的资源</li><li>注意：对象被销毁时触发了析构方法，而不是析构方法销毁了对象。</li></ul><p>我们还是从代码里来观察这个方法。</p><p>我们来定义一个类，完成一个日志的记录，调用这个对象的时候，传递一个日志信息。这个对象会创建一个文件，开始写入，并在最后关闭这个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">writeLog</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    <span class="hljs-comment"># 文件的路径</span><br>    fileurl = <span class="hljs-string">&#x27;./data&#x27;</span><br>    <span class="hljs-comment"># 日志文件的名称</span><br>    filename = <span class="hljs-built_in">str</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>))+<span class="hljs-string">&#x27;.log&#x27;</span><br>    <span class="hljs-comment"># 初始化 打开文件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 完成文件的打开</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;初始化方法触发类，完成文件的打开&#x27;</span>)<br>        self.fileobj = <span class="hljs-built_in">open</span>(self.fileurl+self.filename, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-comment"># 写日志的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self,s</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;把日志<span class="hljs-subst">&#123;s&#125;</span>写入到文件中&#x27;</span>)<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;析构方法触发了，关闭打开的文件&#x27;</span>)<br>        <span class="hljs-comment"># 在对象被销毁时，关闭在初始化方法中打开的文件对象</span><br>        self.fileobj.close()<br><br>l = writeLog()<br>l.log(<span class="hljs-string">&#x27;today is good day.&#x27;</span>)<br><span class="hljs-keyword">del</span> l<br><br>---<br>初始化方法触发类，完成文件的打开<br>把日志today <span class="hljs-keyword">is</span> good day.写入到文件中<br>析构方法触发了，关闭打开的文件<br></code></pre></td></tr></table></figure><p>这段代码中，我们实例化了<code>writeLog()</code>类，调用了初始化方法。在方法中我们打开了文件，因为我用的是变量创建，所以不一定是什么文件。当前我操作的文件为<code>2023-08-16.log</code>。</p><p>然后我们调用<code>l.log()</code>，也就是实例化对象中的<code>log</code>方法来对该文件写入一段日志内容：<code>today is good day.</code>，在执行之后，我们又使用了<code>del l</code>来销毁这个实例。在销毁实例的时候，就会调用<code>__del__</code>方法来执行其中的方法。</p><p>那么对象会在什么情况下被销毁呢？</p><ol type="1"><li>当程序执行完毕，内存中所有的资源都会被销毁释放</li><li>使用 del 删除时</li><li>对象没有被引用时，会自动销毁</li></ol><h2 id="面向对象的三大特性">面向对象的三大特性</h2><p>面向对象有三大特性，分别是「封装、继承、多态」，那么它们具体都是什么呢？下面让我们分别来解释。</p><h3 id="封装">封装</h3><p>封装，就是使用特殊的语法，对成员属性和成员方法进行包装，达到保护和隐藏的目的。就像我们送礼的时候，会找东西把礼物包起来一样。</p><p>但是一定注意，不能把成员全部封装死，就失去意义了。就好比我们买的笔记本电脑，无论如何都会给你留下一些接口的，比如说电源接口，USB接口等等。只有有了这些接口，我们才能插上鼠标啊，移动硬盘等等来进行使用。</p><p>被封装的成员主要是供类的内部使用。被特殊语法封装的成员，会有不同的访问的权限。比如笔记本内的硬盘，内存等等，这些并不是不让你使用，而是提供给笔记本本身使用，我们可以操作笔记本电脑来达到间接使用它们的目的。</p><p>封装分为了几个不同的级别，一般情况下有三种：</p><p>公有的 public</p><p>受保护的 protected</p><p>私有的 private</p><p>被特殊语法封装的成员，会有不同的访问权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;talk about life.&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kiss</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;come on...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><br><span class="hljs-comment"># 查看对象的所有成员</span><br><br><span class="hljs-built_in">print</span>(Person.__dict__) <span class="hljs-comment"># 获取当前类的所有成员信息</span><br><span class="hljs-built_in">print</span>(zs.__dict__) <span class="hljs-comment"># 获取当前对象的所有成员信息</span><br><br><span class="hljs-comment"># 我们也可以直接访问对象所有的方法</span><br><span class="hljs-built_in">print</span>(zs.name)<br>zs.kiss()<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Person.__init__ at <span class="hljs-number">0x111a355a0</span>&gt;, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Person.say at <span class="hljs-number">0x111a35750</span>&gt;, <span class="hljs-string">&#x27;sing&#x27;</span>: &lt;function Person.sing at <span class="hljs-number">0x111a357e0</span>&gt;, <span class="hljs-string">&#x27;kiss&#x27;</span>: &lt;function Person.kiss at <span class="hljs-number">0x111a35870</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>张三<br>come on...<br></code></pre></td></tr></table></figure><p>在整段代码中，我们实例化对象的时候，基本可以访问<code>Person</code>类中所有的成员。我们说定义的属性和方法，都可以无障碍访问。那么，我们现在说定义的这些成员，就都是<code>Public</code>级别。</p><p>现在想象一个场景，我们走在美国街头上，遇到一个美女，然后我们上前询问人家的年龄，大多数时候我们得不到想要的答案。而如果我们上去询问性别（现在知道为什么我要设定为美国街头了吧？），我估计这个就是保密的了吧，有可能一种情况就是当事人在当时的情况下，自己都不知道自己是什么性别。</p><p>那这个时候，我们就需要改写一下这段代码了,改写之前，我们需要理解一下<code>Python</code>中不同级别成员的定义方式，分别为：</p><ul><li><code>str</code> =&gt; 公共的</li><li><code>_str</code> =&gt;受保护的（约定俗成，在Python中没有具体实现）</li><li><code>__str</code> =&gt; 私有的。</li></ul><p>在了解了定义方法之后，我们可以着手来做实验了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-literal">None</span><br>    _age = <span class="hljs-literal">None</span> <span class="hljs-comment"># 这是一个protected 成员属性</span><br>    __sex = <span class="hljs-literal">None</span> <span class="hljs-comment"># 这是一个 private 成员属性</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self._age = age<br>        self.__sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;talk about life.&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sing</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 这是一个protected 成员方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__kiss</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 这是一个private 成员方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;come on...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><br><span class="hljs-comment"># 查看对象的所有成员</span><br><br><span class="hljs-built_in">print</span>(Person.__dict__) <span class="hljs-comment"># 获取当前类的所有成员信息</span><br><span class="hljs-built_in">print</span>(zs.__dict__) <span class="hljs-comment"># 获取当前对象的所有成员信息</span><br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_age&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_Person__sex&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Person.__init__ at <span class="hljs-number">0x111f99630</span>&gt;, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Person.say at <span class="hljs-number">0x111f996c0</span>&gt;, <span class="hljs-string">&#x27;sing&#x27;</span>: &lt;function Person.sing at <span class="hljs-number">0x111f99870</span>&gt;, <span class="hljs-string">&#x27;kiss&#x27;</span>: &lt;function Person.kiss at <span class="hljs-number">0x111f99c60</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>: <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;_Person__sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们调用实例化方法得到的结果已经和之前有所不同了。最终拿到的<code>__sex</code>成员属性是属于类的。</p><p>现在让我们逐一来调用一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(zs._age)<br><span class="hljs-built_in">print</span>(zs.__sex)<br><br>---<br><span class="hljs-number">49</span><br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__sex&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>_age</code>作为受保护的成员属性可以调用，但是<code>__sex</code>作为私有成员属性则不允许。</p><blockquote><p>实际上，受保护的成员属性也是不能调用的，但是Python中因为没有具体实现，所以唯独在Python中可以调用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">zs._sing()<br>zs.__kiss()<br><br>---<br>sing a song.<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__kiss&#x27;</span><br></code></pre></td></tr></table></figure><p>那么，作为受保护的成员方法<code>_sing</code>被正常调用了，但是室友的成员方法<code>__kiss</code>调用的时候报错。看来和成员属性是一致的。</p><p>那么我们现在就可以总结如下：</p><table><colgroup><col style="width: 15%" /><col style="width: 21%" /><col style="width: 40%" /><col style="width: 23%" /></colgroup><thead><tr class="header"><th></th><th>公有的(Public)</th><th>受保护的(Protected)</th><th>私有的(Private)</th></tr></thead><tbody><tr class="odd"><td>在类的内部</td><td>可以访问</td><td>可以访问</td><td>可以访问</td></tr><tr class="even"><td>在类的外部</td><td>可以访问</td><td>不可以访问（Python中可以）</td><td>不可以访问</td></tr></tbody></table><p>在实现上我们总结如下：</p><table style="width:100%;"><colgroup><col style="width: 2%" /><col style="width: 23%" /><col style="width: 37%" /><col style="width: 37%" /></colgroup><thead><tr class="header"><th></th><th>公有的(Public)</th><th>受保护的(Protected)</th><th>私有的(Private)</th></tr></thead><tbody><tr class="odd"><td>定义</td><td>默认定义的成员都属于公有成员</td><td>在成员名称前面加一个下划线 <code>_成员名称</code></td><td>在成员名称前面加两个下划线 <code>__成员名称</code></td></tr><tr class="even"><td>特征</td><td>公有的成员可以在任何位置进行访问和操作</td><td>受保护的成员和公有成员一样可以在任何位置进行访问，但是一般不要随便访问和操作受保护成员</td><td>私有的成员只能在当前类的内部去访问和操作，不能在类的外部进行操作</td></tr></tbody></table><p><strong>⚠️ 这里我们需要注意Python特殊的亮点：</strong></p><ol type="1"><li>在python中并没有实现受保护的封装，属于开发者的约定俗成。</li><li>python中的私有化封装是通过改名策略实现的，并不是真正的私有化</li></ol><h3 id="继承">继承</h3><p>继承是什么？我们是不是经常听到「文化的继承，技艺的继承，衣钵的继承...」等等这些。</p><p>那计算机的继承又是什么？</p><p>在面向对象中，一个类去继承父类，那么这个类就拥有了父类中除了私有成员之外的所有成员，包括属性和方法。这个，就叫做继承。</p><p>在整个继承过程中，被其他类继承的类就称为「父类」，也可以称为「基类」或者「超类」。那么继承其他类的类，就被称为「子类」，也可以称为「派生类」。</p><p>那么我们继承又什么意义吗？继承的主要意义，就是为了提高代码的重用性，建立新的类与类的关系，方便其他逻辑的操作。</p><p>继承实现起来其实非常方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承的语法格式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父类</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>我们直接看代码来理解，比如，我有如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    coatColor = <span class="hljs-string">&#x27; white&#x27;</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们看，猫是不是也是属于猫科动物的一种动物？那么在猫科动物中定义的所有成员，其实在猫这边我也会有。不过这样重复定义是不是感觉特别繁琐？其实，我们在<code>Cat</code>中完全不需要再次输入这么多，完全可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    <span class="hljs-keyword">pass</span><br><br>mimi = Cat()<br>mimi.run()<br></code></pre></td></tr></table></figure><p>这样，我在定义<code>Cat</code>的时候就完成了对<code>Felidae</code>的继承，然后我们实例化一个<code>Cat</code>,再调用这个实例化对象中的方法<code>run()</code>，也就输出了原本是属于类<code>Felidae</code>中的<code>run()</code>方法。</p><p>我们再继承父类的时候，之类还可以写入自己独有的成员属性或方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    size = <span class="hljs-string">&#x27;small&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃猫粮。&#x27;</span>)<br>    <span class="hljs-keyword">pass</span><br>  <br>mimi = Cat()<br>mimi.run()<br><span class="hljs-built_in">print</span>(mimi.size)<br>mimi.eat()<br>Felidae.eat()<br><br>---<br>轻盈的跳跃<br>small<br>吃猫粮。<br><br>AttributeError: <span class="hljs-built_in">type</span> <span class="hljs-built_in">object</span> <span class="hljs-string">&#x27;Felidae&#x27;</span> has no attribute <span class="hljs-string">&#x27;eat&#x27;</span><br></code></pre></td></tr></table></figure><p>我们定义<code>Cat</code>的时候，除了继承<code>Felidae</code>里的成员之外，还定义了一个<code>size</code>成员属性和一个<code>eat</code>成员方法。然后我们在实例化对象中进行调用，都正常运行。</p><p>这个时候我们反过来，使用父类<code>Felidae</code>来调用在之类<code>Cat</code>中定义的成员，则会报错。说明这个成员是独属于之类的。</p><p>我们不仅可以继承的时候进行扩展，还可以复写父类中的方法，使的它与父类方法产生差异化。其方法是在子类中将父类的方法重新定义一遍就可以了。</p><p>那有什么办法在我重写父类方法的时候，仍然可以调用父类方法吗？也是可以的，就是使用<code>super().父类方法名()</code>来进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    size = <span class="hljs-string">&#x27;small&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().run()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;更加轻盈的跳跃。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃猫粮。&#x27;</span>)<br><br>    <span class="hljs-keyword">pass</span><br><br>mimi = Cat()<br>mimi.run()<br><br>---<br>轻盈的跳跃<br>更加轻盈的跳跃。<br></code></pre></td></tr></table></figure><p>我们可以看到，在子类中我们重写了父类中的<code>run</code>方法，但是由于我们在重写的时候在内部使用了<code>super().run()</code>。所以父类中的方法被完全调用了一遍。</p><p>所以，我们目前可以总结<strong>继承的特征</strong>如下：</p><ul><li>在不指定继承的父类时，所有类都继承自object类（系统提供） 了解</li><li>子类继承了父类后，就拥有了父类中的所有成员包括魔术方法（除了私有成员）</li><li>子类继承父类后，并不会把父类的成员复制给子类，而去引用</li><li>子类继承父类后可以重写父类中的方法，叫做 重写</li><li>子类重写父类的方法，依然可以使用<code>super().父类方法名()</code>的方式调用父类的方法</li><li>子类中如果定义了父类中不存在的方法，称为对父类的扩展</li><li>一个父类可以被多个子类继承，还可以存在 链式继承 。<ul><li>链式继承：A类继承了B类，B类继承了C类，C类继承了D类。。。</li></ul></li></ul><h3 id="单继承和多继承">单继承和多继承</h3><p>一个类只能继承一个父类的方式，就叫做单继承。如果一个类继承了多个父类的方式，就称为多继承。直接看例子，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人的样子。&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chusheng</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;畜生的特性。&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Japanese</span>(Person, Chusheng):<br>    <span class="hljs-keyword">pass</span><br><br>c = Japanese()<br>c<br><br>---<br>人的样子。<br>畜生的特性。<br></code></pre></td></tr></table></figure><p>像代码中定义的<code>Japanese</code>类，同时继承了<code>Person</code>和<code>Chusheng</code>，那这个，就属于多继承。我们来区分一下语法特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父类</span>():<br>  <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>  <span class="hljs-keyword">pass</span><br>  <br><span class="hljs-comment"># 多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父</span>():<br>  <span class="hljs-keyword">pass</span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">母</span>():<br>  <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子</span>(父，母):<br>  <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>在多继承的关系里，有一个有意思的部分，我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大口撕咬食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小口吞咽食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(Tiger, Cat):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;到底该怎么吃？&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = C()<br>c.eat()<br></code></pre></td></tr></table></figure><p>我们现在看到这段代码是一个多继承关系，我在<code>C</code>这个类中继承了<code>Tiger</code>和<code>Cat</code>两个类，并且复写了<code>eat()</code>这个方法。按道理来说，我们实例化<code>C</code>类之后，打印的结果一定是复写的结果。但是我们在<code>C</code>类的<code>eat</code>方法里还调用了<code>super().eat()</code>，我们知道<code>super()</code>是调用一遍父类的方法。那么这里到底是调用<code>Tiger</code>里的<code>eat</code>方法，还是<code>Cat</code>里的<code>eat</code>方法呢？</p><p>让我们看打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">---<br>大口撕咬食物...<br>到底该怎么吃？<br></code></pre></td></tr></table></figure><p>打印结果有没有出乎你的意料？那么这个原因是什么呢？其实也不复杂，就是因为<code>Tiger</code>的调用在前面，<code>Cat</code>在后面。让我们重新改一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大口撕咬食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小口吞咽食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(Cat,Tiger):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;到底该怎么吃？&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = C()<br>c.eat()<br><br>---<br>小口吞咽食物...<br>到底该怎么吃？<br></code></pre></td></tr></table></figure><p>这就证实了，谁在前面就调用谁的方法。</p><h3 id="菱形继承钻石继承">菱形继承（钻石继承）</h3><p>先来看一个图形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">A</span><br><span class="hljs-selector-tag">B</span>   C<br>  D<br></code></pre></td></tr></table></figure><p>那我们先有一个<code>A</code>类，下面有<code>B</code>和<code>C</code>类，再下面还有一个<code>D</code>类。</p><p>看图可能还是不太明白，它们之间的关系是这样的：<code>B</code>和<code>C</code>继承了<code>A</code>类，然后<code>D</code>又多继承了<code>B</code>和<code>C</code>。</p><p>那么这种继承关系就叫做菱形继承。</p><p>那么我们现在面临的一个问题就是：在这种菱形继承关系中，类与类是什么关系？<code>super()</code>调用时的顺序是怎样的？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菱形继承</span><br><br><span class="hljs-comment"># 祖先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    num = <span class="hljs-number">111</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学着凭借本能寻找食物...&#x27;</span>)<br><br><span class="hljs-comment"># 父亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">222</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化了，学会大口吃肉。。。&#x27;</span>)<br><br><span class="hljs-comment"># 母亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">333</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化的另外一个分支，小口吞咽...&#x27;</span>)<br><br><span class="hljs-comment"># 子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<br>    num = <span class="hljs-number">444</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;居然退化了，又忘了怎么吃...&#x27;</span>)<br><br>d = D()<br>d.eat()<br><br>---<br>学着凭借本能寻找食物...<br><span class="hljs-number">111</span><br>进化的另外一个分支，小口吞咽...<br><span class="hljs-number">333</span><br>进化了，学会大口吃肉。。。<br><span class="hljs-number">222</span><br>居然退化了，又忘了怎么吃...<br></code></pre></td></tr></table></figure><p>那么我们来看一下，究竟是怎样的一个顺序：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">D.super<span class="hljs-function"><span class="hljs-params">()</span> =&gt; <span class="hljs-title">B</span>.<span class="hljs-title">super</span><span class="hljs-params">()</span> =&gt;<span class="hljs-title">C</span>.<span class="hljs-title">super</span><span class="hljs-params">()</span> =&gt; <span class="hljs-title">A</span>.<span class="hljs-title">print</span><span class="hljs-params">()</span> -&gt;</span> C.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> B.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> D.<span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p>上边这一段中，<code>=&gt;</code>是继承关系，<code>-&gt;</code>是执行顺序。</p><p>好，那我们这个时候要清楚一个点是，我们使用的<code>d</code>这个实例化去执行的，那么在这所有的继承类中，<code>self</code>全部都是<code>c</code>这个实例化对象。让我们来看看到底是不是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菱形继承</span><br><br><span class="hljs-comment"># 祖先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    num = <span class="hljs-number">111</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学着凭借本能寻找食物...&#x27;</span>)<br><br><span class="hljs-comment"># 父亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">222</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化了，学会大口吃肉。。。&#x27;</span>)<br><br><span class="hljs-comment"># 母亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">333</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化的另外一个分支，小口吞咽...&#x27;</span>)<br><br><span class="hljs-comment"># 子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<br>    num = <span class="hljs-number">444</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;居然退化了，又忘了怎么吃...&#x27;</span>)<br><br>d = D()<br>d.eat()<br><br>---<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br>学着凭借本能寻找食物...<br><span class="hljs-number">111</span><br>进化的另外一个分支，小口吞咽...<br><span class="hljs-number">333</span><br>进化了，学会大口吃肉。。。<br><span class="hljs-number">222</span><br>居然退化了，又忘了怎么吃...<br></code></pre></td></tr></table></figure><p>打印的结果证实了我们刚才的说法。</p><p>这个地方可能比较让人意外的是之前那个继承关系上，明明我<code>B</code>继承的是<code>A</code>，怎么变成<code>C</code>了？我们来看看原因：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">在定义类之后，程序会自动生成一个继承的列表MRO(Method Realtion Order)方法关系列表</span><br><span class="hljs-string">MRO列表生成原则：</span><br><span class="hljs-string">1. 子类永远在父类的前面</span><br><span class="hljs-string">2. 同一等级的类，按照之类中的继承顺序摆放</span><br><span class="hljs-string">3. 先之类，后父类的顺序原则，最终的类是系统提供的obejct类</span><br><span class="hljs-string"></span><br><span class="hljs-string">MRO的调用方法</span><br><span class="hljs-string">类名.mro()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>D.mro()<br><br>---<br>[__main__.D, __main__.B, __main__.C, __main__.A, <span class="hljs-built_in">object</span>]<br></code></pre></td></tr></table></figure><p><code>super</code>在调用时，并不是查找父类，而是去MRO列表上找上一个类。</p><p><code>super</code>方法在调用时，会自动把当前<code>self</code>传入到上一级的类的方法中。</p><p>所以我们之前会呈现出<code>D=&gt;B=&gt;C=&gt;A</code>的顺序。</p><p>看着有点晕是吧？别着急，我们接下来介绍一个方法，能很方便的看到类关系。</p><h3 id="issubclass类关系检测"><code>issubclass()</code>类关系检测</h3><p>这个方法是检测一个类是否是另一个类的之类的方法。用起来也非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">issubclass</span>(D, B)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(D, C)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(D, A)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(A, D)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="多态">多态</h3><p>对于同一个方法，由于调用的对象不同，产生了不同形态的结果。这个就叫做多态。</p><p>比如说，我们现在的电脑上有一个USB接口，那么这个接口在接入不同的设备的时候，产生的结果也是不一样的。插入鼠标，我们可以点击。插入键盘我们可以输入，插入U盘呢，我们可以读取。对吧？对于这个USB接口来说。就属于多态。</p><p>好的，让我们来实现一下，直接看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>():<br>    <span class="hljs-comment"># 在电脑类中定义一个 sub 的规范的接口 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">usb</span>(<span class="hljs-params">self,obj</span>):<br>        obj.start()<br><br><span class="hljs-comment"># 定义鼠标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标启动成功，可以双击单击嗨起来。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义键盘类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBord</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘启动成功了，赶紧输入666。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义 U盘 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Udisk</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;U盘启动了，赶紧检查一下我的种子还在不在。。。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = Computer()  <span class="hljs-comment"># 电脑对象</span><br>m = Mouse()     <span class="hljs-comment"># 鼠标对象</span><br>k = KeyBord()   <span class="hljs-comment"># 键盘对象</span><br>u = Udisk()     <span class="hljs-comment"># u盘对象</span><br><br><br><span class="hljs-comment"># 把不同的设备插入到电脑的usb的接口中</span><br>c.usb(m)<br>c.usb(k)<br>c.usb(u)<br><br>---<br>鼠标启动成功，可以双击单击嗨起来。。。<br>键盘启动成功了，赶紧输入<span class="hljs-number">666</span>。。。<br>U盘启动了，赶紧检查一下我的种子还在不在。。。<br></code></pre></td></tr></table></figure><p>这样，我们就实现了一个多态的程序。</p><p>我们在实例化<code>Computer()</code>之后，利用实例化对象<code>c</code>调用类中的方法<code>usb</code>，将实例化对象传入，并且还传入了不同的<code>obj</code>，这里的<code>obj</code>是我们之前实例化过的<code>m, k, u</code>。那这样，我们<code>obj</code>代表了不同的实例化对象，那也就会启动不同的类方法。</p><p>那这样呢，属于一个普通的方式来实现，其实对于这段程序，我们还可以使用继承关系来完成。</p><p>我们先定义一个接口规范类，其他类都继承这个类，并实现（重写）父类中的方法。由于每个对象实现父类的方式或者过程都不相同，最后的结果是不一样的形态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承关系写多态</span><br><br><span class="hljs-comment"># 定义USB</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USB</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    info:</span><br><span class="hljs-string">        这个类是一个接口规范类，需要子类继承并实现start方法</span><br><span class="hljs-string">        start方法不做任何具体功能的实现</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 在usb类中定义一个规范的接口方法，但是不实现任何功能</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义鼠标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标启动成功，可以双击单击嗨起来。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义键盘类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBord</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘启动成功了，赶紧输入666。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义 U盘 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Udisk</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;U盘启动了，赶紧检查一下我的种子还在不在。。。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>m = Mouse()<br>k = KeyBord()<br>u = Udisk()<br><br>m.start()<br>k.start()<br>u.start()<br><br>---<br>鼠标启动成功，可以双击单击嗨起来。。。<br>键盘启动成功了，赶紧输入<span class="hljs-number">666</span>。。。<br>U盘启动了，赶紧检查一下我的种子还在不在。。。<br></code></pre></td></tr></table></figure><p>我们回来看这段代码，实际上，如果抛开<code>USB</code>类，我们单独去写后面的类，并且把继承关系去掉。最后是不是也可以进行打印？可以...</p><p>可是这样的话，那这三个方法中的<code>satrt</code>方法之间就毫无关系，继承了<code>USB</code>中的<code>start</code>方法，也就是继承了规范。</p><p>而且这个继承的形式，和我们之前实现的普通版本其实并无什么差别，虽然代码实现上有不同，可是逻辑上是完全相同的。</p><p>好了，关于面向对象，我们就先介绍到这里。不过别着急，并不是讲完了，我们下节课还要接着讲「面向对象」。讲解一些高级语法和思想。小伙伴们记得关注。</p><p>另外，面向对象这个东西，确实蛮难的，并不是看我这一两节课就能学懂的。虽然我尽力，但是我还是有自知之明。</p><p>在这里给大家推荐一本好书，有它在，你想不懂都难。 <code>^_^</code></p><p><a href="https://u.jd.com/2zo4Ee3">领取优惠券</a>再<ahref="https://u.jd.com/2QmKR3j">购买</a>：</p><p><imgsrc="https://img1.doubanio.com/view/subject/l/public/s24550919.jpg"alt="img" /></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Object-Oriented-Programming/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>20. 异常处理</title>
    <link href="https://hivan.me/Get-the-exception/"/>
    <id>https://hivan.me/Get-the-exception/</id>
    <published>2023-08-15T05:35:35.000Z</published>
    <updated>2023-08-15T12:58:41.436Z</updated>
    
    <content type="html"><![CDATA[<img src="/Get-the-exception/cover.png" class="" title="cover"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>在我们日常使用Python或者其他编程语言的时候，不可避免的都会出现报错和异常。那么，我们今天就来谈谈异常。</p><h2 id="什么是异常">什么是异常？</h2><p>异常异常，根据名字简单理解，那就是非正常，也就是没有达到预期目标。</p><p>异常呢，其实就是一个事件，并且这个异常事件在程序的运行过程中出现，会影响程序的正常执行。而一般来说，异常被分为两种：</p><ol type="1"><li>语法错误导致的异常</li><li>逻辑错误导致的异常</li></ol><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">varlist = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(varlist[<span class="hljs-number">3</span>])<br><br>---<br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>这个时候，系统抛出了异常，提示我们列表索引超出范畴。</p><p>这里我们需要知道，「异常」在Python中实际上也是一个对象，表示一个错误。当我们的程序无法继续正常进行时，就会被抛出。</p><p>我们来完整的看看这个报错信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">---------------------------------------------------------------------------<br>IndexError                                Traceback (most recent call last)<br>Cell In[<span class="hljs-number">2</span>], line <span class="hljs-number">2</span><br>      <span class="hljs-number">1</span> varlist = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>----&gt; <span class="hljs-number">2</span> <span class="hljs-built_in">print</span>(varlist[<span class="hljs-number">3</span>])<br><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>Python在遇到异常之后，首先会给出一个「错误回溯」，然后给出具体哪一句代码出现了问题。</p><p>然后在最后给出异常分类和解释。那么<code>IndexError</code>告知我们，这是一个「索引错误」，并且给出了具体的描述「列出索引超出范围」。其中<code>IndexError</code>是我们的异常类，<code>list index out of range</code>是我们的异常信息。</p><p>在程序运行过程中，会出现各种各样的异常类，常见标准异常类，我放在最下面作为一个附录。</p><h2 id="如何处理异常">如何处理异常</h2><h3 id="可预知">可预知</h3><p>如果错误发生的情况是我们可以预知的，那么就可以使用流程控制进行预防处理。比如，两个数字的运算，其中一个不是数字，运算就会出错，这个时候就可以判断来预防：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n2 = <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n2, <span class="hljs-built_in">int</span>):<br>    res = <span class="hljs-number">10</span>+n2<br>    <span class="hljs-built_in">print</span>(res)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;非整型。&#x27;</span>)<br><br>---<br>非整形<br></code></pre></td></tr></table></figure><p>在这一段代码中，我们使用<code>isinstance</code>方法来检测第一个参数是否是第二个参数的所属类型。这是一个用来检测的方法，返回<code>True</code>或者<code>False</code>。那我们在<code>if</code>中，只有真才会打印结果，假则会打印另外一则消息。</p><p>有些小伙伴会想，那既然知道不是整型就会出错，那前面限制传如整型不就好了，干嘛还要费劲去做非整判断。</p><p>你要知道，很多时候一个程序的编写和维护并不是单一一个人来做的，即便是一个人在做，也不能完全保证自己某个地方埋下了隐患。那么在每一段代码中，我们对可能预知的情况做妥善的预防是必须的。</p><h3 id="不可预知">不可预知</h3><p>那可预知的情况我们避免了，可是在我们编写代码的时候，更多的情况是我们自己都不知道我们到底埋了什么雷，哪一段没有遵循规则或者逻辑。那这种情况就是不可预知的。</p><p>对于这种不可预知的情况我们该怎么办呢？我们又没办法预先判断。那这种情况下，我们可以使用<code>try...except...</code>语句，在错误发生时进行处理。相关语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能发生异常错误的代码<br><span class="hljs-keyword">except</span>:<br>    如果发生异常这进入<span class="hljs-keyword">except</span>代码块进行处理<br><br>异常被捕获之后程序继续向下执行<br></code></pre></td></tr></table></figure><p>我们来看个示例，比如我们之前做过的一个注册、登录练习。其中我们有一段代码是要去读取列表中的所有用户。之前我们的练习中，有提到过文件不存在的情况，所以我们使用了<code>a+</code>的方法，当文件不存在的时候，就新建。</p><p>那么现在，我们假设我们就用了<code>r</code>的方法，当文件不存在的时候，一定会报错对吧？这个时候，我们可以使用两种方式来进行处理。</p><p>第一种方式，就可以在读取前先判断当前文件是否存在。</p><p>第二种方式，就可以使用<code>try...except...</code>在错误发生的时候进行处理。</p><p>那么这里，我们用第二种方式来做一下处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们读取的文件不存在，会发生错误</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user5.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件不存在。&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序继续运行...&#x27;</span>)<br><br>---<br>文件不存在。<br>程序继续运行...<br></code></pre></td></tr></table></figure><p>可以看到，我们准确的捕获了错误，并且之后程序仍然继续往后执行了。</p><blockquote><p>⚠️ <code>try...except...</code>是在错误发生后进行处理，并不是提前判断。也就是说，错误其实还是发生了。这和<code>if</code>实际上有根本性的区别。</p></blockquote><h2 id="try...except...-详解">try...except... 详解</h2><p>首先，我们认识<code>try...except</code>的一个特性，就是它可以处理指定的异常，如果引发了非指定的异常，则无法处理。比如，我们下面人为制造一个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-built_in">int</span>(s1)<br><br>---<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们这一段代码引发了一个<code>ValueError</code>异常。</p><p>现在我们来捕获一下,但是这次，我们为这个异常指定一个异常类再来看看，先看看正常状态下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序错误。&#x27;</span>)<br>    <br>---<br>程序错误。<br></code></pre></td></tr></table></figure><p>接着我们来看指定异常之后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序错误。&#x27;</span>)<br>    <br>---<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>这里我们指定了一个<code>IndexError</code>的异常类，显然我们之前看到了，程序报错是<code>ValueError</code>异常类，两者并不匹配。所以最后依然还是报错。</p><p>那么之前我们谈到过标准的异常类，并且也知道异常实际上也就是一个对象。而我们平时在使用的时候，<code>except</code>实际上就是去这个「标准的异常类」的列表里去查找，如果没有对应的异常类，它依然是无法捕获的。不过大部分时候，我们基本不会遇到标准异常类之外的异常。而这种处理指定的异常类的特性，平时也可以被我们使用。</p><p>其中一个使用方式，就是进行多分支处理异常类，不同的异常可以走不通的<code>except</code>进行处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    s1[<span class="hljs-number">5</span>] <span class="hljs-comment"># IndexError</span><br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是IndexError&#x27;</span>, e)<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是KeyError&#x27;</span>, e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是ValueError&#x27;</span>, e)<br>    <br>---<br>这里是IndexError string index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>是不是和<code>if...elif</code>的分支形式很像？</p><p>让我们继续，在我们说指定的异常类中，实际上会有一个万能的通用异常类。那就是<code>Exception</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception ===&#x27;</span>,e)<br>    <br>---<br>Exception === invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>基本上所有的异常，都可以走到这个异常类。在这段代码中，我们之前记得<code>int(s1)</code>是属于一个<code>ValueError</code>，但是我们使用<code>Exception</code>依然可以获取到这个错误。可是如果这两种异常类同时被指定的情况下会如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception ===&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError ===&#x27;</span>, e)<br>    <br>---<br>Exception === invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>我们看到，就是按照程序的从上至下的顺序在执行。</p><p>所以，其实我们可以这样理解，当我们进行多分支异常类+通用异常类的时候，<code>Exception</code>是最后的一个保底。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># int(s1) # ValueError</span><br>    s1[<span class="hljs-number">5</span>]    <span class="hljs-comment"># IndexError</span><br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IndexError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;KeyError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>,e)<br>    <br>---<br>IndexError string index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>除此之外，<code>try...except</code>是支持<code>else</code>的，当<code>try</code>里的代码顺利执行没有捕获到任何错误之后，还可以走到<code>else</code>之中额外执行分支内的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">str</span>(s1)<br>    <span class="hljs-built_in">print</span>(s1)<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IndexError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>,e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try代码块中没有引发异常时，执行&#x27;</span>)<br>    <br>---<br>hello<br><span class="hljs-keyword">try</span>代码块中没有引发异常时，执行<br></code></pre></td></tr></table></figure><p>我们再来了解一下<code>finally</code>,这个方法是无论是否引发异常都会执行。通常情况下用于执行一些清理工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(s1)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;如果前面的代码引发了异常，这个代码块将不在继续执行。。&#x27;</span>)<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IndexError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>,e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try代码块中没有引发异常时，执行&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无论是否引发了异常，都会执行这个代码块&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;如果上面的代码有异常并且进行了处理，那么后面的代码将继续执行&#x27;</span>)<br><br>---<br>ValueError invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>无论是否引发了异常，都会执行这个代码块<br>如果上面的代码有异常并且进行了处理，那么后面的代码将继续执行<br></code></pre></td></tr></table></figure><p>这段代码中，我们引发了一个异常，也被捕获了。但是依然执行了<code>finally</code>内的代码，并且也未影响程序继续往后执行。</p><p>在我们平常写代码的过程中还有一种情况，就是我们需要自己制作一个异常信息，然后抛出。这个时候，我们需要用<code>raise</code>，来主动抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;发生错误&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>, e)<br>    <br>---<br>Exception 发生错误<br></code></pre></td></tr></table></figure><p>除了上述的异常处理之外，其实还有另外一种方式，是直接判断逻辑是否成立，不成立抛出<code>AssertionError</code>错误。就是使用<code>assert</code>进行断言。它在表达式错误的时候，会直接抛出<code>AssertionError</code>错误，如果表达式正确，这什么都不做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span><br><br>---<br>AssertionError: <br></code></pre></td></tr></table></figure><h2 id="自定义异常处理类">自定义异常处理类</h2><p>虽然系统已经给到了很多异常处理的方式，而我们在平时开发中也会经常的使用。但是实际上，很多时候我们都需要一些自己的处理要求。比如说，当异常出现的时候，我们要将异常信息写入日志，在日后我们从日志里查看日常信息或者做数据分析，就是我们最常使用的。</p><p>那我们接下来看看，如果做一个异常处理的自定义开发:</p><p>再最开始，我们需要归纳一下，我们到底要保存怎样一个格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 日志的基本格式：</span><br><span class="hljs-bullet">-</span> 日期时间， 异常的级别<br><span class="hljs-bullet">-</span> 异常信息：引发的异常类别，异常的信息，文件及行号。<br></code></pre></td></tr></table></figure><p>在确定了日志格式后，我们可以进入开发了，首先我们需要导入两个所需的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先导入所需模块</span><br><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">import</span> logging<br></code></pre></td></tr></table></figure><p>让我们先来人为创建一个日常，并用<code>try</code>语句来捕获它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>  <br>---<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><p>这句代码报了一个<code>ValueError</code>异常类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在此进行异常的处理&#x27;</span>)<br>    <br>---<br>在此进行异常的处理<br></code></pre></td></tr></table></figure><p>没问题，我们捕获了异常并且正确的进入了<code>except</code>。那么，我们可以通过<code>traceback</code>模块来获取异常信息,替换一下打印信息我们来查看一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-comment"># 通过traceback获取异常信息</span><br>    errormsg = traceback.format_exc()<br>    <span class="hljs-built_in">print</span>(errormsg)<br>    <br>---<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/var/folders/h4/7cr1cmpn7v5b3x20_9wz8m740000gn/T/ipykernel_39689/2534911191.py&quot;</span>, line <span class="hljs-number">2</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><p>接下来，就轮到<code>logging</code>模块了。该模块定义了实现用于应用程序和库的灵活事件日志记录系统的函数和类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    filename = <span class="hljs-string">&#x27;./data/error.log&#x27;</span>, <span class="hljs-comment"># 日志存储的文件及目录</span><br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s \n %(message)s&#x27;</span>, <span class="hljs-comment"># 格式化存储的日志格式</span><br>    datefmt = <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>在定义了<code>logging</code>的基本信息之后，我们就可以定义一下将刚才的<code>errormsg</code>写入日志了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入日志</span><br>logging.error(traceback.format_exc())<br></code></pre></td></tr></table></figure><p>那么我们完善一下整个代码就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    filename = <span class="hljs-string">&#x27;./data/error.log&#x27;</span>, <span class="hljs-comment"># 日志存储的文件及目录</span><br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s \n %(message)s&#x27;</span>, <span class="hljs-comment"># 格式化存储的日志格式</span><br>    datefmt = <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>)<br><br><span class="hljs-comment"># 写入日志</span><br>logging.error(traceback.format_exc())<br></code></pre></td></tr></table></figure><p>我们需要在异常出发的时候，将错误写入到日志内。那么需要将这段代码放到<code>except</code>中。可是我们总不能每次都写这么长一段代码，那怎么办呢？嗯，没错，我们需要封装一个函数用于多次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Myexception</span>():<br>    <span class="hljs-comment"># logging的基本配置</span><br>    logging.basicConfig(<br>        filename = <span class="hljs-string">&#x27;./data/error.log&#x27;</span>, <span class="hljs-comment"># 日志存储的文件及目录</span><br>        <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s \n %(message)s&#x27;</span>, <span class="hljs-comment"># 格式化存储的日志格式</span><br>        datefmt = <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>    )<br><br>    <span class="hljs-comment"># 写入日志</span><br>    logging.error(traceback.format_exc())<br><br><span class="hljs-comment"># 使用自定义异常处理类</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;bb&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在此处进行异常的处理&#x27;</span>)<br>    Myexception() <span class="hljs-comment"># 在异常处理的代码块中去调用自定义异常类</span><br></code></pre></td></tr></table></figure><p>然后我们将导入库的方法也写进去，这样在我们需要的时候才会进行导入，顺便，我们将这个函数封装成一个类。就便于更多的文件调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义异常日志处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myexception</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">import</span> traceback<br>        <span class="hljs-keyword">import</span> logging<br><br>        <span class="hljs-comment"># logging的基本配置</span><br>        logging.basicConfig(<br>            filename=<span class="hljs-string">&#x27;./error.log&#x27;</span>,<span class="hljs-comment"># 日志存储的文件及目录</span><br>            <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s  %(levelname)s \n %(message)s&#x27;</span>,<span class="hljs-comment"># 格式化存储的日志格式</span><br>            datefmt=<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>        )<br>        <span class="hljs-comment"># 写入日志</span><br>        logging.error(traceback.format_exc())<br><br><span class="hljs-comment"># 使用自定义异常处理类</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;bb&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在此处进行异常的处理&#x27;</span>)<br>    Myexception() <span class="hljs-comment"># 在异常处理的代码块中去调用自定义异常类</span><br></code></pre></td></tr></table></figure><p>这样，一个自定义的获取异常之后写入日常的类就定义好了，我们可以在任意地方导入并调用这个类方法，以便获取以及日后查看整个程序中的异常。</p><h2 id="附录">附录</h2><h3 id="标准的异常类">标准的异常类</h3><table><colgroup><col style="width: 33%" /><col style="width: 66%" /></colgroup><thead><tr class="header"><th style="text-align: center;">异常名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BaseException</td><td style="text-align: center;">所有异常的基类</td></tr><tr class="even"><td style="text-align: center;">SystemExit</td><td style="text-align: center;">解释器请求退出</td></tr><tr class="odd"><td style="text-align: center;">KeyboardInterrupt</td><td style="text-align: center;">用户中断执行(通常是输入^C)</td></tr><tr class="even"><td style="text-align: center;">Exception</td><td style="text-align: center;">常规错误的基类</td></tr><tr class="odd"><td style="text-align: center;">StopIteration</td><td style="text-align: center;">迭代器没有更多的值</td></tr><tr class="even"><td style="text-align: center;">GeneratorExit</td><td style="text-align: center;">生成器(generator)发生异常来通知退出</td></tr><tr class="odd"><td style="text-align: center;">StandardError</td><td style="text-align: center;">所有的内建标准异常的基类</td></tr><tr class="even"><td style="text-align: center;">ArithmeticError</td><td style="text-align: center;">所有数值计算错误的基类</td></tr><tr class="odd"><td style="text-align: center;">FloatingPointError</td><td style="text-align: center;">浮点计算错误</td></tr><tr class="even"><td style="text-align: center;">OverflowError</td><td style="text-align: center;">数值运算超出最大限制</td></tr><tr class="odd"><td style="text-align: center;">ZeroDivisionError</td><td style="text-align: center;">除(或取模)零 (所有数据类型)</td></tr><tr class="even"><td style="text-align: center;">AssertionError</td><td style="text-align: center;">断言语句失败</td></tr><tr class="odd"><td style="text-align: center;">AttributeError</td><td style="text-align: center;">对象没有这个属性</td></tr><tr class="even"><td style="text-align: center;">EOFError</td><td style="text-align: center;">没有内建输入,到达EOF 标记</td></tr><tr class="odd"><td style="text-align: center;">EnvironmentError</td><td style="text-align: center;">操作系统错误的基类</td></tr><tr class="even"><td style="text-align: center;">IOError</td><td style="text-align: center;">输入/输出操作失败</td></tr><tr class="odd"><td style="text-align: center;">OSError</td><td style="text-align: center;">操作系统错误</td></tr><tr class="even"><td style="text-align: center;">WindowsError</td><td style="text-align: center;">系统调用失败</td></tr><tr class="odd"><td style="text-align: center;">ImportError</td><td style="text-align: center;">导入模块/对象失败</td></tr><tr class="even"><td style="text-align: center;">LookupError</td><td style="text-align: center;">无效数据查询的基类</td></tr><tr class="odd"><td style="text-align: center;">IndexError</td><td style="text-align: center;">序列中没有此索引(index)</td></tr><tr class="even"><td style="text-align: center;">KeyError</td><td style="text-align: center;">映射中没有这个键</td></tr><tr class="odd"><td style="text-align: center;">MemoryError</td><td style="text-align: center;">内存溢出错误(对于Python解释器不是致命的)</td></tr><tr class="even"><td style="text-align: center;">NameError</td><td style="text-align: center;">未声明/初始化对象 (没有属性)</td></tr><tr class="odd"><td style="text-align: center;">UnboundLocalError</td><td style="text-align: center;">访问未初始化的本地变量</td></tr><tr class="even"><td style="text-align: center;">ReferenceError</td><td style="text-align: center;">弱引用(Weakreference)试图访问已经垃圾回收了的对象</td></tr><tr class="odd"><td style="text-align: center;">RuntimeError</td><td style="text-align: center;">一般的运行时错误</td></tr><tr class="even"><td style="text-align: center;">NotImplementedError</td><td style="text-align: center;">尚未实现的方法</td></tr><tr class="odd"><td style="text-align: center;">SyntaxError</td><td style="text-align: center;">Python 语法错误</td></tr><tr class="even"><td style="text-align: center;">IndentationError</td><td style="text-align: center;">缩进错误</td></tr><tr class="odd"><td style="text-align: center;">TabError</td><td style="text-align: center;">Tab 和空格混用</td></tr><tr class="even"><td style="text-align: center;">SystemError</td><td style="text-align: center;">一般的解释器系统错误</td></tr><tr class="odd"><td style="text-align: center;">TypeError</td><td style="text-align: center;">对类型无效的操作</td></tr><tr class="even"><td style="text-align: center;">ValueError</td><td style="text-align: center;">传入无效的参数</td></tr><tr class="odd"><td style="text-align: center;">UnicodeError</td><td style="text-align: center;">Unicode 相关的错误</td></tr><tr class="even"><td style="text-align: center;">UnicodeDecodeError</td><td style="text-align: center;">Unicode 解码时的错误</td></tr><tr class="odd"><td style="text-align: center;">UnicodeEncodeError</td><td style="text-align: center;">Unicode 编码时错误</td></tr><tr class="even"><td style="text-align: center;">UnicodeTranslateError</td><td style="text-align: center;">Unicode 转换时错误</td></tr><tr class="odd"><td style="text-align: center;">Warning</td><td style="text-align: center;">警告的基类</td></tr><tr class="even"><td style="text-align: center;">DeprecationWarning</td><td style="text-align: center;">关于被弃用的特征的警告</td></tr><tr class="odd"><td style="text-align: center;">FutureWarning</td><td style="text-align: center;">关于构造将来语义会有改变的警告</td></tr><tr class="even"><td style="text-align: center;">OverflowWarning</td><tdstyle="text-align: center;">旧的关于自动提升为长整型(long)的警告</td></tr><tr class="odd"><td style="text-align: center;">PendingDeprecationWarning</td><td style="text-align: center;">关于特性将会被废弃的警告</td></tr><tr class="even"><td style="text-align: center;">RuntimeWarning</td><td style="text-align: center;">可疑的运行时行为(runtimebehavior)的警告</td></tr><tr class="odd"><td style="text-align: center;">SyntaxWarning</td><td style="text-align: center;">可疑的语法的警告</td></tr><tr class="even"><td style="text-align: center;">UserWarning</td><td style="text-align: center;">用户代码生成的警告</td></tr></tbody></table><p>那么，这节课到这里也就结束了。各位小伙伴，下去以后记得勤加练习。下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Get-the-exception/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>19. 第三方库的管理和虚拟环境</title>
    <link href="https://hivan.me/Third-party-libraries-and-virtual-environments/"/>
    <id>https://hivan.me/Third-party-libraries-and-virtual-environments/</id>
    <published>2023-08-15T03:48:45.000Z</published>
    <updated>2023-08-15T04:56:42.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/Third-party-libraries-and-virtual-environments/cover.png" class="" title="img"><p>Hi， 大家好。我是茶桁。</p><span id="more"></span><p>在我们之前的课程中，讲解了数据，函数，类，模块以及包。这些基本上已经构成了Python的全部了。</p><p>那么，我们在学习Python的包之后，有没有思考过，既然Python有内置模块，我们也可以自己写一些模块来使用，那一定有很多第三方写过相应的模块来供我们使用。那么，这些包该如何去找，找到以后如何使用和管理呢？今天，就让我们来看看这个问题。</p><h2 id="第三方库的管理">第三方库的管理</h2><p>现在很多编程语言都有第三方库的提供，比如<code>Ruby</code>,<code>Node</code>等。而Python的生态也是发展的最好的之一。Python中比较牛逼的地方就是由大量的第三方库提供给你使用。生态的蓬勃发展也是Python广为流行的最大的原因之一。</p><p>Python的第三方库的管理网站：<code>https://pypi.org/</code>。</p><h3 id="如何安装第三方库">如何安装第三方库？</h3><p><code>pip</code>就是Python得包管理工具，解决了包直接的依赖关系，可以方便的管理第三方库（包）。类似于<code>PHP</code>中的<code>Composer</code>,或者<code>Nodejs</code>中的<code>npm</code>,又或者<code>Mac</code>中的<code>Homebrew</code>。</p><p>我们可以使用<code>pip install 包名（库名）</code>来进行安装。而如果是有多个Python环境的情况下，可能需要使用<code>pip3</code>。比如说，我们要安装<code>pymysql</code>这个库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pymysql<br></code></pre></td></tr></table></figure><p>在安装命令过程中，有的时候我们可能对版本会有一定的要求，并不是越新的版本越好。这个时候，我们也可以安装指定版本的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install 包名==版本<br></code></pre></td></tr></table></figure><p>现在包都已经安装到本地了，可是因为安装的内容太多，我们可能有的时候会忘记自己以前是否安装过这个包。为了避免重复再装一次，我们可以搜索一下看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip show 包名<br></code></pre></td></tr></table></figure><p>这样，这个包的所有信息就会打印出来供我们查看：</p><img src="/Third-party-libraries-and-virtual-environments/image-20230815121349204.png" class="" title="img"><p>当然，我们也有类似于想要查看本地安装的所有包的需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip list<br></code></pre></td></tr></table></figure><p>这样，我们就可以把本地说安装的包名以及版本都列出来进行查看：</p><img src="/Third-party-libraries-and-virtual-environments/image-20230815121607429.png" class="" title="img"><p>这些呢，就是我们在包管理经常用到的一些命令。</p><p>等等，大家在执行安装的时候，一定会遇到安装特别缓慢的情况。多数时候可能是因为我们所在的环境因为各种原因连接不上官方的源服务器。</p><p>不过别着急，我们可以切换到镜像源上，找一个速度快的来下载安装。</p><p>目前国内的安装源有以下几个可供选择：</p><ul><li>阿里云 http://mirrors.aliyun.com/pypi/simple/</li><li>中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</li><li>豆瓣(douban) http://pypi.douban.com/simple/</li><li>清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</li><li>中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</li></ul><p>修改源的方式也很简单，包括了「临时修改」和「永久修改」两种。</p><p>临时修改，顾名思义，就是我们有的时候临时需要切换到其他源上进行下载了。</p><p>我们可以使用<code>pip</code>的时候在后面加上<code>-i</code>参数，指定pip源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple/ <br></code></pre></td></tr></table></figure><p>多数情况下，我还是习惯于将源永久修改为一个速度较快的镜像上，也懒得每次都输入长传的命令。那么永久修改的方式稍微复杂点，我们分系统来看：</p><p>在Linux中，我们找到<code>pip.conf</code>这个文件，一般来说，它的位置应该是<code>~/.pip/pip.conf</code>，如果没有的话，那就创建一个，然后写入如下内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>timeout = <span class="hljs-number">6000</span><br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br><span class="hljs-keyword">trusted</span>-host = pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><p>在Windows内原理也是一样的，不同的是路径和文件有所不同。</p><p>我们在<code>user</code>目录中创建一个<code>pip</code>目录，如：<code>C:\Users\du\pip</code>,然后在PIP目录下新建一个<code>pip.ini</code>文件，然后写入内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>timeout = <span class="hljs-number">6000</span><br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br><span class="hljs-keyword">trusted</span>-host = pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><p>这样，我们在之后安装第三方库的时候就会发现，速度快多了。</p><h2 id="虚拟环境">虚拟环境</h2><p>虚拟环境呢，就是在当前的系统环境中，去配置另外一个Python得运行环境。我们理论上是可以创建多个不同的虚拟环境的，Python得虚拟环境相互独立，互相之间不会影响。</p><p>那么虚拟环境下呢，具有以下一些特点：</p><ul><li>虚拟环境中可以在没有权限的情况下安装新的库（Linux系统中可能会出现的问题）</li><li>不同的应用可以使用不同的库或不同的版本。</li><li>虚拟环境中的库升级也不影响其它环境</li><li>虚拟环境可以作为一个项目的专有环境。在需要部署时，一键导出项目的所需要的包</li></ul><h3 id="默认方式">默认方式</h3><p>Python本身就支持创建和管理虚拟环境。可以使用以下方式进行创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m venv 虚拟环境名<br></code></pre></td></tr></table></figure><p>创建完成后，我们可以使用下面的方式进入虚拟环境，激活虚拟环境</p><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用source命令去执行v1/bin/目录下的activate</span><br>localhost:code yc$ <span class="hljs-built_in">source</span> v1/bin/activate<br></code></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Windows系统需要进入v1/Scripts/这个目录</span><br><span class="hljs-built_in">cd</span> v1/Scripts/<br><span class="hljs-comment"># 运行activate.bat文件</span><br>activate.bat<br>(v1) F:\code<br></code></pre></td></tr></table></figure><p>在这之后，我们现在就处于某一个虚拟环境中了，可以执行安装等操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pymysql<br><br>pip show pymysql<br></code></pre></td></tr></table></figure><p>那么如果我的某一个环境被我给搞乱了，我也找不到原因，还不如重新安装来的快。这会儿我们可能就想要退出并删除这个虚拟环境：</p><p>如果想要退出虚拟环境，在Linux中，我们可以输入下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 退出虚拟环境</span><br><br><span class="hljs-comment"># Linux</span><br>deactivate<br></code></pre></td></tr></table></figure><p>那如果是Windows中呢就比较简单了，直接<code>Ctrl+C</code>就好了。</p><p>在退出之后，我们直接删除虚拟环境的文件夹，就搞定了。</p><p>以上是我们不想要当前虚拟环境的情况下，那也有一种可能是我们需要更换电脑等原因，但是我想带着我的环境一起迁移，这该怎么办？</p><p>这也好办，我们可以到处当前环境所有安装过的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有安装的包</span><br>pip list<br>```<br>packageversion<br>------------------------<br>Numpy1.3.1<br>........<br><br><br><span class="hljs-comment"># 导出所有包到文件</span><br>pip freeze &gt; ./requirements.txt<br></code></pre></td></tr></table></figure><p>然后在下一个环境中，我们直接执行安装文件内所有包就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h3 id="conda">Conda</h3><p>虽然Python中已经有了包管理的方法，但是还是不得不说，有时候第三方提供的方案确实香。</p><p>目前，我现在都是使用<code>conda</code>(Andaconda)来管理我本地的虚拟环境。其使用也是非常的简单了，我们可以去其官网上（<ahref="https://www.anaconda.com/">https://www.anaconda.com/</a>）下载并安装对应自己系统的版本。</p><p>安装完成后，Conda就会创建一个默认的<code>base</code>环境，我们之前一直使用的<code>Jupyter Notebook</code>也一并是安装在环境中的。</p><p>那么在Conda中，我们经常会用的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装包</span><br>conda install 包名称<br><br><span class="hljs-comment"># 安全方式安装包</span><br>conda install -c conda-forge 包名称<br><br><span class="hljs-comment"># 创建环境</span><br>conda create --name 环境名 python=3.10 <span class="hljs-comment">#最后是输入当前环境要用的Python版本</span><br><br><span class="hljs-comment"># 切换（激活）环境</span><br>conda activate 环境名<br><br><span class="hljs-comment"># 查看环境列表</span><br>conda info --<span class="hljs-built_in">env</span><br><br><span class="hljs-comment"># 删除某个环境</span><br>conda remove --name 环境名 --all<br></code></pre></td></tr></table></figure><p>对比下来，<code>conda</code>真的是非常的方便。推荐大家使用。</p><p>那么，今天的课程就到这里结束了。我知道，今天的课程似乎显的特别的少。em....不是似乎，是确实。</p><p>原因在于这一部分必须拿出一个章节来介绍一下，否则大家平时在使用的过程中万一将自己的默认环境搞乱了，但是又不知道该怎么办，确实挺烦人的。所以我专门拿一节出来，将环境的问题好好的跟大家介绍下，顺便也是告诉大家，不管你做什么实验和操作，尽量新建一个环境来操作。这样，即便你把当前环境搞的乱七八糟无法恢复，删了就好了。</p><p>好，那我们这节课到这里也就结束了，咱们下节课讲讲如何处理异常。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Third-party-libraries-and-virtual-environments/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi， 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>18. Python中的模块与包</title>
    <link href="https://hivan.me/Modules-and-packages/"/>
    <id>https://hivan.me/Modules-and-packages/</id>
    <published>2023-08-14T09:00:32.000Z</published>
    <updated>2023-08-14T18:30:20.891Z</updated>
    
    <content type="html"><![CDATA[<img src="/Modules-and-packages/cover.png" class="" title="img"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>这一段Python之旅怎么样？还算顺利吧？</p><p>之前我们都学习了些什么？有基本常识，流程，函数，不同类型的数据以及一些模块对吧？并且还做了一些练习来巩固所学过的内容。</p><p>那么今天，我们接着来学习模块。不过今天要学的模块和以往不太一样了，以前我们学习的都是Python内置的一些模块，而今天呢，我们自己来打包模块。</p><h2 id="模块">模块</h2><p>简单点说，当我们定义一个Python文件，其后缀名为<code>.py</code>的时候，那么这个文件就被称为模块。</p><p>模块中通常呢会定义一些相似的类、函数等代码内容，提供给别的程序引入使用。那对于应用，之前我们已经用过很多次了对吧？我们曾多次应用系统模块来使用，那这次，我们还是从系统模块开始吧。</p><h3 id="系统模块">系统模块</h3><p>系统模块实际上就是一个Python的程序脚本，专门提供给我们自己的程序使用。它们是在安装好Python环境时，就已经存在的，需要的时候可以使用<code>import</code> 导入到程序中使用。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os, re, time, json, calendar<br></code></pre></td></tr></table></figure><h3 id="自定义模块">自定义模块</h3><p>那知道了系统模块是什么东西，在理解自定义模块就轻松多了对吧？其实就是我们自己创建一个Python脚本，定义一些类或方法，供别的脚本导入后使用。</p><blockquote><p>由于本节课比较特殊，所以课程源码除了<code>18.ipynb</code>这个笔记本文件之外，还有有一个文件夹，路径为<code>./Python/packages/file</code>，然后内部会有多个<code>.py</code>文件。</p></blockquote><p>比如我们定义一个<code>self.py</code>文件如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># self.py</span><br><br><span class="hljs-comment"># 定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个模块中的func函数&#x27;</span>)<br><br><span class="hljs-comment"># 定义变量</span><br>myStr = <span class="hljs-string">&#x27;iloveyou&#x27;</span><br></code></pre></td></tr></table></figure><p>然后让我们在笔记本中引用这个文件（模块）以及其他模块，让我们来看看，还记得我们是怎么引入模块的嘛？来，回忆一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先引入一个系统模块：time</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;time:<span class="hljs-subst">&#123;time.time()&#125;</span>&#x27;</span>)<br><br>---<br>time:<span class="hljs-number">1692005247.144672</span><br></code></pre></td></tr></table></figure><p>我们引入了一个系统模块<code>time</code>，然后执行了一下模块里的<code>time()</code>方法，并把最终结果打印了出来。</p><p>既然都已经有例子了，那我们有样学样来试试引入我们自己创建的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> self<br><br>---<br>ModuleNotFoundError: No module named <span class="hljs-string">&#x27;self&#x27;</span><br></code></pre></td></tr></table></figure><p>报错了，告诉我们并没有<code>self</code>这个模块。这个...</p><p>还记得我们刚才说过的文件路径嘛？<code>./Python/packages/file</code>，而我们当前文件<code>18.ipynb</code>是放在<code>Python</code>目录下的，层级关系如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>.<br><span class="hljs-bullet">- </span>Python/<br><span class="hljs-bullet">- </span>...<br><span class="hljs-bullet">- </span>18.ipynb<br><span class="hljs-bullet">- </span>packages/<br><span class="hljs-code">| - self.py</span><br></code></pre></td></tr></table></figure><p>也就是说，我们要应用<code>self.py</code>，需要找对路径才行。那我们将路径加上去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引入自定义模块</span><br><span class="hljs-keyword">import</span> packages.self <br></code></pre></td></tr></table></figure><p>这回执行之后是没报错了，应该没问题了。</p><p>那下面呢，让我们来操作一下文件内的类、函数之类的试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用模块中定义的类</span><br>obj = packages.self.MyException()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;packages.self.MyException <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10468cb80</span>&gt;<br></code></pre></td></tr></table></figure><p>没毛病，确实获取到了相关类病打印了出来。</p><p>可是我们这也太麻烦了，每次使用这个模块不是抖要输入这么长一段吧？<code>packages.self.xxx</code>，不知道之前的学习中大家有没有注意到一个关键字<code>as</code>，这个我之前课程中都没有特意讲解过，但是在我们引入模块的时候会经常的用到。所以这里顺带讲一下吧，比如，我们在操作文件的时候有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./file&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>  fp.read()<br></code></pre></td></tr></table></figure><p>那这个<code>as</code>我们能猜到是什么作用吗？其实，就是讲<code>as</code>前的内容放入<code>as</code>后面的这个变量里，然后将<code>as</code>身后的这个变量改为一个对象而已，在这段代码里，我们打开了文件，并且将其放入了<code>fp</code>这个变量里，变成了一个<code>fp</code>对象。也可以理解为，我们将<code>as</code>之前的内容起了一个别名。</p><p>那么我们导入文件的时候可以这么操作吗？我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.self <span class="hljs-keyword">as</span> self<br>obj = self.MyException()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;packages.self.MyException <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1046ce2c0</span>&gt;<br></code></pre></td></tr></table></figure><p>嗯，看来我们没搞错，确实可以这么用。</p><p>那让我们再来试试文件中的那个函数吧，函数内应该是执行了一段打印方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">self.func()<br><br>---<br>我是一个模块中的func函数<br></code></pre></td></tr></table></figure><p>确实正确执行了。这也太顺利了，趁热打铁，让我们再来获取其中的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(self.myStr)<br><br>---<br>iloveyou<br></code></pre></td></tr></table></figure><p>导入模块其实不是仅可导入模块，还能从一个模块中导入类，方法甚至是变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.self <span class="hljs-keyword">import</span> func<br><span class="hljs-keyword">from</span> packages.self <span class="hljs-keyword">import</span> myStr <span class="hljs-keyword">as</span> <span class="hljs-built_in">str</span><br><br>func()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p>应该能看出这一段代码的含义吧？就是<code>from</code>（从）一个模块中<code>import</code>导入一个对象。</p><h3 id="模块中的测试代码">模块中的测试代码</h3><p>在自定义模块中，通常我们只是去定义类或函数，变量等，并不调用。如果在指定模块中，想要写一些测试代码，在当前模块作为主程序使用时执行，而作为模块被别的程序导入时不执行，那么可以把测试代码写到下面的代码块中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这个位置的代码只有当前脚本被直接运行时才会运行。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>那么这个模块再被别的程序调用之后，这段代码中的程序是不会被执行的。因为只有这个模块作为主程序运行时才会运行这段代码。我们来看下面这些操作就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.self <span class="hljs-keyword">as</span> self<br>self<br><br>---<br>&lt;module <span class="hljs-string">&#x27;packages.self&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/packages/self.py&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>按道理，我们引入模块之后应该会拿到该模块内的所有方法，可是刚才我们写的打印并没有被执行。现在我们在命令行内直接大概这个<code>.py</code>文件来试试：</p><img src="/Modules-and-packages/image-20230814221847463.png" class="" title="img"><p>能看到，<code>if</code>里面的<code>print</code>被直接执行了，打印出了里面的字符串。</p><p>在这整段代码中，<code>__name__</code>是一个特殊的变量，这个变量在当前脚本作为模块被别的程序导入时<code>__name__</code>的值是当前这个模块的名称，也就是说，我在笔记本中导入的时候<code>__name__</code>就是<code>self</code>，而我们在<code>if</code>条件中的设定，是只有当前脚本被作为主程序直接由Python解析时才会进入判断，也就是<code>__name__</code>这个变量的值为<code>__main__</code>时。</p><p>我们来看看是不是如此，我们在<code>self.py</code>中加上一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = __name__<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;__name__: <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们直接让<code>self.py</code>在Python解释器中运行：</p><img src="/Modules-and-packages/image-20230814222553966.png" class="" title="img"><p>现在让我们在笔记本中重新引入一下模块中的变量<code>name</code>，再打印出来看看：</p><img src="/Modules-and-packages/image-20230814222932491.png" class="" title="img"><p>打印的第一段内容为引入模块的时候，模块内的<code>print(f'__name__: &#123;name&#125;')</code>执行了一次，第二段内容则是在笔记本中输入的方法<code>print(name)</code>。这样，我们就很直观的看到了<code>__name__</code>在不同位置时存储了不同的值。</p><p>我们在写程序的时候要记得，不要想着把所有的方法定义在一个脚本文件内。</p><h2 id="包">包</h2><p>那什么是包呢？包并不是模块。你可以将包理解为一个文件夹，这个文件夹里面包含了多个Python文件。</p><h3 id="包的结构">包的结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">package/   # 包(文件夹)</span><br><span class="hljs-string">├── __init__.py  # 包中的初始化文件</span><br><span class="hljs-string">├── a.py         # 包中的模块</span><br><span class="hljs-string">├── b.py</span><br><span class="hljs-string">└── ps/   # 子包</span><br><span class="hljs-string">  ├── __init__.py</span><br><span class="hljs-string">  ├── c.py</span><br><span class="hljs-string">  └── d.py</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="包的使用方法">包的使用方法</h3><p>其实，我们在刚才所讲的内容中，已经给大家演示过了包的使用方法，不知道小伙伴们能不能反应过来到底是哪里？不知道也没有关系，让我们从头来好好的盘一下这件事。</p><p>我们之前在当前目录下创建了一个文件夹<code>packages</code>，里面有我们<code>self.py</code>文件。实际上，这就是一个包了。</p><p>让我们将这个包搞的复杂一点，按照上面我们写的结构来增加一些文件，然后我们看看现在的目录结构：</p><img src="/Modules-and-packages/image-20230814225350552.png" class="" title="img"><p>我们可以看到，除了我们之前设定的文件之外，还有多出来一个文件夹<code>__pycache__</code>以及文件<code>self.cpython-310.pyc</code>，这个文件夹和文件是当这个包内的文件存在引入关系的时候，自动生成的缓存文件。大家可以不用管。</p><p>下面我们来看具体的包使用方法，我们预先在<code>a, b, c, d</code>这四个文件内都写入了一模一样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">funca</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a.py&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当然，方法名和打印的内容都和文件同名的。</p><p>然后我们回到<code>18.ipynb</code>这个笔记本文件内，开始操作使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages <span class="hljs-keyword">as</span> pa<br>pa.a.funca<br><br>---<br>AttributeError: module <span class="hljs-string">&#x27;packages&#x27;</span> has no attribute <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>似乎并不行，我们好像并不能引用包来直接使用。那我们怎么办呢？前面我们介绍过一个引用的方法<code>from ... import</code>，我们在使用包内的模块时，需要这样去引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages <span class="hljs-keyword">import</span> a, b<br>a.funca()<br>b. funcb()<br><br>---<br>a.py<br>b.py<br></code></pre></td></tr></table></figure><p>可以看到，这回我们引用成功了。那我们之前也学到了，在引入模块的时候，也可以直接就引用模块内的方法和变量，模块在包内也可以如此使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.a <span class="hljs-keyword">import</span> funca<br>funca()<br><br>---<br>a.py<br></code></pre></td></tr></table></figure><p>那既然我们得到了这种方式来导入模块内的内容，同样的，包内层如果还存在一个包，而我们要使用子包里的模块，也是这样的导入方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.ps <span class="hljs-keyword">import</span> c<br>c.funcc()<br><br>---<br>c.py<br></code></pre></td></tr></table></figure><p>看到了，同样能够正常使用。</p><p>那如果再过分点，我们要想导入<code>c.py</code>里的函数可以吗？试试就知道了,再使用<code>.</code>多链接一层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.ps.d <span class="hljs-keyword">import</span> funcd<br>funcd()<br><br>---<br>d.pys<br></code></pre></td></tr></table></figure><p>呐，完全没问题。</p><p>然后我们再反过来看最开始，其实呢，我们的第一种方法直接引用包不是不可以，这需要用到我们这个包内的<code>__init__.py</code>文件。</p><p><code>__init__.py</code>是一个包内的初始化文件，可以说，没有这个文件，这只是一个文件夹，只有有了这个文件，这才是一个包。在初始化的时候，就把包内的模块导入一次，在<code>__init__.py</code>中写下以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> a<br></code></pre></td></tr></table></figure><p>然后我们再回到笔记本文件中直接导入包来使用试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages<br>a.funca()<br><br>---<br>a.py<br></code></pre></td></tr></table></figure><p>这样就可以了。</p><p>好了，那如果这个时候我<code>packages</code>这个包里一大堆的模块，我不想一个个的来导入，有什么办法吗？也是有的，我们需要用到<code>__all__</code>这个参数，在<code>__init__.py</code>中将包内所有的模块名做成一个列表，然后赋值给<code>__all__</code>这个变量，那么我们在引入包内的模块的时候，就可以使用`<code>*</code>来代表所有文件：</p><p><code>__init__.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure><p>然后进行引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages <span class="hljs-keyword">import</span> *<br>b.funcb()<br><br>---<br>b.py<br></code></pre></td></tr></table></figure><p>这样，我们就一次性导入了<code>packages</code>这个包里的所有文件。</p><h2 id="导入方式的分类">导入方式的分类</h2><p>之前我们讲的内容中，把导入的方式都过了一遍。到现在这个位置，我们应该总结一下了。</p><p>具体的导入方式，我们可以将其分为两个类别，分别是<code>绝对导入</code>和<code>相对导入</code>。那两者有什么区别呢？</p><h3 id="绝对导入">绝对导入</h3><p>绝对导入的方式会使用「搜索路径」去查找和导入指定的包或模块，包括以下几种方式：</p><ul><li><p><code>import module</code> 导入模块</p></li><li><p><code>import package</code> 导入包</p></li><li><p><code>import package.module</code>导入包.模块</p></li><li><p><code>from module import func</code> 从模块中导入函数</p></li><li><p><code>from package import module</code>从包中导入模块</p></li><li><p><code>from package.module import func</code>从包.模块中导入函数</p></li></ul><p>关于「搜索路径」，我们先简单的理解一下就是，从当前文件夹中去找，如果找不到，就会去Python的安装环境中去寻找。</p><h3 id="相对导入">相对导入</h3><p>⚠️相对导入智能在非主程序的模块中使用，不需要直接运行的模块文件。比如：</p><ul><li><code>from .包名/模块名 import 模块/内容</code></li><li><code>from ..包名/模块名 import 模块/内容</code></li></ul><p><code>.</code>和<code>..</code>我们之前已经了解过了，<code>.</code>代表的就是当前这一级，<code>..</code>代表的就是上一级。</p><p>举个栗子好理解：假设我们现在去修改一下<code>ps/c.py</code>这个文件，在这个模块中如果需要当前包中的<code>d</code>模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .d <span class="hljs-keyword">import</span> funcd<br></code></pre></td></tr></table></figure><p>注意啊，我们这个时候不要在<code>c.py</code>中直接运行<code>funcd()</code>方法，这样会导致报错：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">ImportError: attempted relative <span class="hljs-keyword">import</span> <span class="hljs-keyword">with</span> <span class="hljs-literal">no</span> known parent package<br></code></pre></td></tr></table></figure><p>那我们需要怎么运行呢？我们需要讲<code>c.py</code>导入到其他文件中再执行。比如我们进入到笔记本<code>18.ipynb</code>中导入执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.ps.c <span class="hljs-keyword">as</span> c<br>c.funcd()<br><br>---<br>d.py<br></code></pre></td></tr></table></figure><p>然后让我们再在<code>c.py</code>中加上一段内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ..a <span class="hljs-keyword">import</span> funca<br></code></pre></td></tr></table></figure><p>小伙伴们应该都看出来了，我是在引用<code>c.py</code>的上一级的<code>a.py</code>。</p><p>让我们再在笔记本中执行一下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.ps.c <span class="hljs-keyword">as</span> c<br>c.funcd()<br>c.funca()<br><br>---<br>d.py<br>a.py<br></code></pre></td></tr></table></figure><p>这样，在我们引入了模块<code>c</code>之后，我们同时也拥有了<code>c.py</code>引入的同级和上一级中的<code>d.py</code>、<code>a.py</code>。</p><h3 id="搜索路径">搜索路径</h3><p>刚才我们简单提到了一下「搜索路径」， 这里我们详细的来展开说一下。</p><p>「搜索路径」就是在导入模块或者包的时候，程序查找的路径。主要的搜索路径包含以下三部分：</p><ul><li>当前导入模块的程序所在的文件</li></ul><ol start="2" type="1"><li>python的扩展目录中</li><li>python解释器指定的其它 第三方模块位置<code>/lib/sitepackages</code></li></ol><p>当然，如果你像我一样，系统中安装了多个Python版本，并且使用虚拟环境。那么你的「搜索路径」就不一定是在哪里了。那么我们到底该如何查找呢？我们来看一下以下查找方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在当前脚本中查看包或者模块的搜索路径</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.path)<br><br>---<br>[<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python310.zip&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python3.10&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python3.10/lib-dynload&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python3.10/site-packages&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们看到找到的搜索路径被以列表的形式呈现出来。当然，我们找到搜索路径后，其实是可以向其中添加一个的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sys.path.append(<span class="hljs-string">&#x27;/Users/du/AI/GPT&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="单入口程序">单入口程序</h2><p>那什么是单入口程序呢？顾名思义，这种程序就只有一个入口。那单入口程序就是指整个程序都是经过一个主程序文件在运行，其它程序都封装成了包或模块。</p><p>单入口文件是作为程序直接被运行的唯一文件，其他都是作为模块或者包，被导入单入口中去执行。打个比方说，我们要去做一个ATM机的程序，我们来实现一个单入口程序。那么可能的情况如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">ATM/<br>|-- main.py  # 当前程序的主入口文件，单入口文件<span class="hljs-punctuation">,</span>唯一直接运行的文件<br>|-- package/ # 主要程序模块包<br>|-- |--- __init__.py  # 包的初始化文件<br>|-- |--- View.py      # 视图函数模块<br>|-- |--- Controller.py# 控制器模块<br>|-- |--- Card.py      # 银行卡模块<br>|-- |--- User.py      # 用户模块<br>|-- databases/ # 数据存储文件夹<br>|-- |-- user.txt<br>|-- |-- user_id_card.txt<br></code></pre></td></tr></table></figure><p>那么这个程序中，<code>main</code>就是程序的主入口文件，会被直接作为主程序运行。所以<code>main.py</code>文件必须使用「绝对导入」的方式。</p><p>好，那讲到这里，我们今天的内容也就结束了。不知道小伙伴们理解了多少？</p><p>本节课也不太好放练习，那我们这节课就免了。下去之后，大家去拉取我的源码好好的研究一下引入关系，然后讲包、模块的概念好好的理解透。</p><p>那小伙伴们，咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Modules-and-packages/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>17. 正则表达式</title>
    <link href="https://hivan.me/regular-expression/"/>
    <id>https://hivan.me/regular-expression/</id>
    <published>2023-08-13T05:21:10.000Z</published>
    <updated>2023-08-13T16:51:01.994Z</updated>
    
    <content type="html"><![CDATA[<img src="/regular-expression/cover.png" class="" title="img"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>不知不觉中，咱们针对人工智能的Python课程已经过去了一半。相信大家这段时间也都有所进步了。</p><p>今天这节课呢，我给大家划一个重点。不仅仅是Python，很多语言里都是通用的，而且非常的强大。这就是我们的正则表达式。</p><p>说起正则表达式，很多程序员其实对其都不是很重视，但是学好它，必定在处理数据的时候事倍功半。虽然内容看似不多，但是市面上有一本经典的「精通电子表达式」整本书还是非常厚的。当然，它比咱们今天要讲的内容详尽的多了。听完我这节课之后想继续研究正则的小伙伴，推荐这本书（唯一推荐）。</p><img src="/regular-expression/s11292040.jpg" class="" title="img"><p>正则表达式是什么呢？其实就是使用字符、转义字符和特殊字符组成一个规则，使用这个规则对文本的内容完成一个搜索或匹配或替换的功能。</p><h2 id="正则表达式的组成">正则表达式的组成</h2><p>正则表达式内，包含了普通字符，转义字符，特殊字符以及匹配模式：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">普通字符： 大小写字母，数字，符号...<br>转义字符： <span class="hljs-string">\w,</span> <span class="hljs-string">\W,</span> <span class="hljs-string">\d,</span> <span class="hljs-string">\D,</span> <span class="hljs-string">\s,</span> <span class="hljs-string">\S</span> ...<br>特殊字符： . * ? + ^ $ [] &#123;&#125; () <br>匹配模式： I U ...<br></code></pre></td></tr></table></figure><p>接下来我们看几个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义字符串</span><br>myStr = <span class="hljs-string">&#x27;iloveyou521tosimida&#x27;</span><br><span class="hljs-comment"># 定义正则</span><br>myReg = <span class="hljs-string">&#x27;love&#x27;</span><br><br><span class="hljs-comment"># 调用正则函数方法</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;love&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们就匹配了一个字符串。如果我们想匹配数字，那<code>myReg=521</code>就能够匹配了。不过，现在我有一个新需求，我们重新定义一下<code>myStr = 'iloveyou521to123simida'</code>，我们可以看到，这个字符串十分的混乱，数字和字母都是混在一起的。现在，我就想把数字都单独的拎出来，又该怎么做呢？来，让我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123simida&quot;</span><br>myReg = <span class="hljs-string">&#x27;\d&#x27;</span><br><span class="hljs-comment"># 调用正则表达式相关函数</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们使用<code>\d</code>这个转义字符匹配到了字符串内相关的所有数字，返回了一个列表。</p><p>可是这还是不符合我们的要求，我们想要的是将其中的数字组合匹配出来，而不是单独的数字。接着继续改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123si7894mida&quot;</span><br>myReg = <span class="hljs-string">&#x27;\d\d\d&#x27;</span><br><span class="hljs-comment"># 调用正则表达式相关函数</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;521&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;789&#x27;</span>]<br></code></pre></td></tr></table></figure><p>将原本一个<code>\d</code>改为了三个叠在一起的<code>\d\d\d</code>，这样，我们匹配到了三位数字的组合。注意，我在原本的字符串内又加入了一个四位的数字组合<code>7894</code>，但是也只匹配出了<code>789</code>，那也就是说，这种数字匹配方式，有几个转义字符组合在一起，那就匹配出多少位;<code>\d</code>这个转义字符就是代表单个的数字。</p><p>整个代码中，<code>findall</code>就是正则中的相关函数，除了<code>findall</code>之外，还有一些其他函数，我们一起来认识下：</p><h3 id="re模块的函数"><code>re</code>模块的函数</h3><h3 id="match与search"><code>match</code>与<code>search</code></h3><p><code>match</code>和<code>search</code>经常是被放在一起来进行讨论的，因为这两个函数很像。具体它们有什么作用和区别呢？我们直接上代码，一点点讲：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>).span()) <span class="hljs-comment"># 起始位置匹配</span><br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;me&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>)) <span class="hljs-comment"># 不在起始位置匹配</span><br><br>---<br>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>可以看到，虽然第二段打印中，我输入的<code>me</code>也可以从字符串中找到，但是因为不是从起始位置匹配的，所以返回了<code>None</code>。</p><p>再来看看<code>search</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(re.search(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>).span()) <span class="hljs-comment"># 起始位置匹配</span><br><span class="hljs-built_in">print</span>(re.search(<span class="hljs-string">&#x27;me&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>).span()) <span class="hljs-comment"># 不在起始位置匹配</span><br><br>---<br>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p><code>search</code>方法中，无论我们要匹配的字符是在起始位置还是结束位置，只要是能找到，都会返回其位置。</p><p>有小伙伴们可能会奇怪，我在成功返回的末尾都加了一个<code>span()</code>,是不是这个影响的原因？我们来看看这两个方法匹配成功后的返回值就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(re.search(<span class="hljs-string">&#x27;me&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>)) <span class="hljs-comment"># 不在起始位置匹配</span><br><br>---<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;me&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>其完整的返回值应该是这样的，我后面加的<code>span()</code>只是为了获取返回值中的<code>span</code>信息。</p><p>所以对于这两个函数，我们可以稍微归纳一下：</p><p><strong><code>re.match()</code>函数</strong>：</p><ul><li>会从头开始进行匹配，如果第一个就符合要求，那么匹配成功</li><li>如果第一个不符合规则，则返回<code>None</code></li><li>匹配成功后返回<code>Match</code>对象</li><li>成功后可以使用<code>group()</code>和<code>span()</code>方法获取数据和下标区间</li></ul><p><strong><code>re.search()</code>函数</strong>：</p><ul><li>从字符串的开头开始进行搜索式的匹配</li><li>匹配成功则返回<code>Match</code>对象，匹配失败者返回<code>None</code></li><li>成功后可以使用<code>group()</code>和<code>span()</code>方法获取数据和下标区间</li></ul><p><strong>两者的区别：</strong></p><ul><li><code>match</code>方法是从字符串的开头进行匹配，如果开始就不符合正则的要求，则匹配失败，返回None。</li><li><code>search</code>方法是从字符串的开始位置一直搜索到字符串的最后，如果在整个字符串中都没有匹配到，则失败，返回None</li></ul><p>在看完<code>match</code>和<code>search</code>之后，我们再来看看<code>re</code>模块的其他函数：</p><h3 id="re.findall"><code>re.findall()</code></h3><p>这个函数在文章开头我们就用到了，但是并未给大家进行详解。现在我们就来认识一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123si7894lovemida&quot;</span><br>myReg = <span class="hljs-string">&#x27;love&#x27;</span><br><span class="hljs-built_in">print</span>(re.findall(myReg, myStr))<br><br>---<br>[<span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;love&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，和一开头我们所写的不同，这次返回的参数列表内出现了两个<code>love</code>，原因就是我对<code>myStr</code>这个变量又重新定义了一下，在接近尾部的地方多加了一个<code>love</code>。</p><p>从这我们也能看出来了，<code>findall</code>这个函数是按照正则表达式的规则在字符中匹配所有符合规则的元素，结果返回一个列表，如果没有找到的情况下，会返回一个空列表。</p><h4 id="re.finditer"><code>re.finditer()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = re.finditer(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;callable_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107ab3790</span>&gt;<br></code></pre></td></tr></table></figure><p>从返回的结果中看到，这个函数返回的是一个迭代器。那让我们利用迭代器规则来试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><br>---<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;love&#x27;</span>&gt;<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">22</span>, <span class="hljs-number">26</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;love&#x27;</span>&gt;<br>StopIteration:<br></code></pre></td></tr></table></figure><p>在第三个<code>next</code>方法的时候报错了，那和我们使用<code>findall</code>结果是一致的，返回了两个<code>love</code>。并且，<code>finditer</code>方法会返回每一个匹配值的下标范围。使用<code>span()</code>来获取到这个范围。</p><h3 id="re.sub"><code>re.sub()</code></h3><p>这个函数方法和之前介绍的方法有些不太一样了，以上我们所使用的可以说都是搜索、查找。那这个函数就是修改了。其功能是按照正则表达式的规则，在字符串中找到需要被替换的字符串，完成一个替换。主要参数有三个：</p><ul><li><code>pattern</code>: 正则表示的规则，匹配需要被替换的字符串</li><li><code>repl</code>: 替换后的字符串</li><li><code>string</code>: 被替换的原始字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123si7894lovemida&quot;</span><br>myReg = <span class="hljs-string">&#x27;love&#x27;</span><br>res = re.sub(myReg, <span class="hljs-string">&#x27;live&#x27;</span>, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>iliveyou521to123si7894livemida<br></code></pre></td></tr></table></figure><p>这样，我们对整个<code>myStr</code>就完成了特定字符串的替换，将其中的<code>love</code>全部替换成了<code>live</code>。</p><h3 id="re.split"><code>re.split()</code></h3><p>这个方法会按照指定的正则规则，进行数据切割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;hello my name is chaheng&#x27;</span><br>res = re.split(<span class="hljs-string">&#x27; &#x27;</span>, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;chaheng&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在这段代码中，我们将原字符串以空格<code></code>来进行风格，将整个字符串分割成了一个列表。其原理和我们将字符串时讲到的基本一致，这里就不详细讲解这个函数了。</p><h3 id="compile"><code>compile()</code></h3><p>这个函数可以直接将正则表达式定义为「正则对象」，使用正则对象直接操作。</p><p>我们现在来看一个示例：</p><p>假如说，我有下面这样一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<br>    <span class="hljs-string">&#x27;i love 123 you&#x27;</span>,<br>    <span class="hljs-string">&#x27;i love 234 you&#x27;</span>,<br>    <span class="hljs-string">&#x27;i love 456 you&#x27;</span>,<br>    <span class="hljs-string">&#x27;i love 678 you&#x27;</span><br>]<br></code></pre></td></tr></table></figure><p>我现在想要从中找到所有的数字，那么使用之前所学的内容，当然我们想到的一定是<code>for</code>循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>    newReg = <span class="hljs-string">&#x27;\d\d\d&#x27;</span><br>    res = re.search(newReg, i)<br>    <span class="hljs-built_in">print</span>(res.group())<br>    <br>---<br><span class="hljs-number">123</span><br><span class="hljs-number">234</span><br><span class="hljs-number">456</span><br><span class="hljs-number">678</span><br></code></pre></td></tr></table></figure><p>可以看到，我们确实正确的拿到了<code>arr</code>中的相关数字。</p><p>这里，我们稍微讲解一下正则表达式中的<code>\d&#123;n&#125;</code>，在正则中，<code>\d</code>是转义字符我们之前学过了，但是其实，我们并不需要写三个<code>\d</code>来去匹配三个数字，那如果真是这样的话，我们要匹配几十个数字的时候怎么办呢？这个时候我们可以用到<code>\d&#123;n&#125;</code>这样的写法，大括号中的<code>n</code>表示的就是前面这个<code>\d</code>的匹配连续匹配n次。那么，我们原本的<code>newReg='\d\d\d'</code>就可以改为<code>newRge='\d&#123;3&#125;'</code>。</p><p>让我们回过头来继续，刚才我们使用了<code>for</code>循环来完成了依次取值对吧。这个时候，让我们深入<code>search()</code>这个方法的源码去看看，其中是长这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">pattern, string, flags=<span class="hljs-number">0</span></span>):<br>  <span class="hljs-keyword">return</span> _<span class="hljs-built_in">compile</span>(pattern, flags).search(string)<br></code></pre></td></tr></table></figure><p>那么根据这个<code>return</code>的结构来看，我们是不是可以这样来写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\d&#123;3&#125;&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>    res = myReg.search(i).group()<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br><span class="hljs-number">123</span><br><span class="hljs-number">234</span><br><span class="hljs-number">456</span><br><span class="hljs-number">678</span><br></code></pre></td></tr></table></figure><p>确实，我们获得了我们想要的结果。</p><p>那上下两种写法的区别在于哪里呢？</p><p>其实，我们第一种写法里，我们定义了一个正则规则，然后传给<code>search(myReg, i)</code>之后，<code>search</code>方法在其内部先是调用了一下<code>_compile</code>,生成了一个正则对象，在这之后，才又传给了<code>search</code>方法，最后得到结果。</p><p>而我们在第二种写法中，直接用<code>compile</code>函数将规则定义成了一个对象，使用<code>search</code>直接得到了结果。</p><p>你们注意看结构，是不是我第二个写法里，<code>for</code>循环里的<code>myReg</code>实际上就是<code>search</code>方法内的<code>_compile(pattern, flags)</code>。</p><p>那我们这样写有什么意义呢？呃，实际上，从性能上来说虽然是快了一些，但是也不见得快多少。更多的是想让大家养成一个去方法源码中探究逻辑的好习惯。</p><p>那么接下来，才是这节课的重点。大家集中注意力，我们开始。</p><h2 id="正则表达式的规则">正则表达式的规则</h2><p>在本文的最开头，我们就先给到了正则表达式的基本规则，我们拿下来再复习一下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">普通字符： 大小写字母，数字，符号...<br>转义字符： <span class="hljs-string">\w,</span> <span class="hljs-string">\W,</span> <span class="hljs-string">\d,</span> <span class="hljs-string">\D,</span> <span class="hljs-string">\s,</span> <span class="hljs-string">\S</span> ...<br>特殊字符： . * ? + ^ $ [] &#123;&#125; () <br>匹配模式： I U ...<br></code></pre></td></tr></table></figure><p>那其实，我们之前介绍相关函数方法的时候，所使用到的基本都是普通字符，其中也用到了<code>\d</code>这个转义字符，明白<code>\d</code>就是去匹配数字。</p><h3 id="普通字符">普通字符</h3><p>普通字符实际上就是最简单的匹配方式，你写什么就是什么。可以理解为，我在全文中去搜索一个单词或者数字。而且我们之前也使用过多次了，所以这部分我们就不再继续向西介绍了。</p><h3 id="转义字符">转义字符</h3><p>转义字符包括：<code>\w, \W, \d, \D, \s, \S ...</code></p><p>什么都是从代码里去理解最直接，让我们先来定义一个字符串待用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">myStr</span> = <span class="hljs-string">&#x27;a2$_ilove521you&#x27;</span><br></code></pre></td></tr></table></figure><p>然后我们一个一个来看：</p><p><code>\w</code>, 这个转义字符匹配的内容是单个字母、数字、下划线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们看，在最后的结果中，我们匹配到了这个字符串中所有的字母，数字和下划线。其中的特殊字符和制表符都被过滤掉了。</p><p><code>\W</code>，注意，现在这个<code>W</code>是大写的。那这个转义字符规则会去匹配单个「非」字母、数字，下划线。啥意思？简单，看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 转义字符</span><br>myReg = <span class="hljs-string">&#x27;\W&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>]<br></code></pre></td></tr></table></figure><p>看到区别了吧？和<code>\w</code>(小写)完全相反，之前匹配到的字母、数字、下划线一个没匹配到，而之前没被匹配到的特殊字符和制表符，则被匹配后组成了一个列表。</p><p><code>\d</code>，这个转义字符规则会匹配单个的数字。这个我们之前用过了，这里就不演示了。</p><p><code>\D</code>，这个转义字符实际也非常简单，就是匹配非数字。注意到了吧？所有的转义字符里，小写字母大写之后，其匹配的内容都是相反的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\D&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>结果也是，除了数字其他的内容都被匹配到了。</p><p><code>\s</code>， 这个转义字符规则是匹配单个的空格符或制表符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\s&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;\t&#x27;</span>]<br></code></pre></td></tr></table></figure><p>结果却是如此，唯一的制表符被匹配了出来。（初学时，我一度长期混乱的认为<code>\s</code>是匹配所有字符串，大家别犯我一样的错误。）</p><p><code>\S</code>，那这个大写字母的匹配规则不用说，一定是匹配空格或制表符之外的所有内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\S&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>打印结果验证了我们的猜想。</p><p><code>\w&#123;4&#125;\d</code>，基本转义字符我们都介绍完了，这里我们来看看组合在一起会是什么样。其中的<code>\w&#123;4&#125;</code>大家也应该明白其含义，就是<code>\w\w\w\w</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;4&#125;\d&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;love5&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，这样组合之后匹配出来的就是4个字母、数字、下划线+一个数字。那是不是这次匹配我们也可以写成<code>\w&#123;5&#125;</code>呢？反正最后匹配出来的<code>love5</code>不也就是5个<code>w</code>的组合么？</p><p>那我们试试看就知道了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;5&#125;&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_ilov&#x27;</span>, <span class="hljs-string">&#x27;21you&#x27;</span>]<br></code></pre></td></tr></table></figure><p>没想道结果是这样的对吧？这是因为，<code>\w&#123;5&#125;</code>中，最后一位可以是字母，数字或者下划线都可以，而我们用<code>\w&#123;4&#125;\d</code>则是最后一位必须是数字，不能是其他的。</p><h3 id="特殊字符">特殊字符</h3><p>特殊字符包括：<code>. * ? + ^ $ [] &#123;&#125; ()</code></p><p>这回，让我们再重新定义一段合适的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;@_2i4l22oveyou&#x27;</span><br></code></pre></td></tr></table></figure><p>然后，我们还是一个一个的来看：</p><p><code>.</code>，表示匹配单个的任意字符，当然也有例外，就是除了换行符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;.&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>字符串内的所有内容，我们都匹配了出来，然后组成了一个列表。</p><p><code>*</code>,这个特殊字符需要和其他的匹配进行组合使用，它表示的是任意次数。具体什么意思呢？我们还是从代码里去看看是如何表现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @_2i4l22oveyou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>l<br></code></pre></td></tr></table></figure><p>这段代码我们应该是比较熟悉了，<code>\w</code>和<code>search</code>方法我们都已经学过了。那这个其实就是在字符串中从开头去匹配<code>\w</code>对吧？</p><p>我们再来继续往下看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @_2i4l22oveyou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w*&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>like<br></code></pre></td></tr></table></figure><p>我们看结果，这次<code>search</code>在匹配到第一个<code>\w</code>之后，又继续向后匹配了，直到遇到空格才停了下来。就是因为<code>\w</code>后面加了一个<code>*</code>,所以就会一直匹配任意次数，直到<code>\w</code>不再匹配了才结束。</p><p>这里有一个概念，就是<code>*</code>代表的匹配任意次数，为什么我要强调这个呢？就是任意次数其实是包含<code>0</code>次的。也就是说，我们只要使用了<code>*</code>这个特殊字符，那么就算没有符合匹配项，一样是酸是匹配成功了，只是返回的是空而已。我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27; like chaheng @_2i4l22oveyou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w*&#x27;</span><br>res = re.<span class="hljs-keyword">match</span>(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>我们在之前的字符串前面加了一个空格，按道理说是不符合<code>\w</code>匹配的。那么<code>match</code>从字符串的开头开始进行搜索式的匹配,没有就返回<code>None</code>对吧？可是这次，并没有返回<code>None</code>，我们看到<code>match=''</code>，也就是说，它匹配成功了，只是成功了0次。所以按照<code>*</code>匹配任意次的规则，它不会返回<code>None</code>。这里比较绕，大家好好理解一下。我们继续。</p><p><code>+</code>，这又是一个和其他规则配合使用的特殊字符，和<code>*</code>一样，它也表示匹配次数，但是这个表示的是至少要求匹配一次。正好，我们之前改造的字符串最前面多加了一个空格，让我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w+&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>like<br></code></pre></td></tr></table></figure><p>按<code>search</code>从字符串的开头开始进行搜索式的匹配，是不是这里我们应该返回<code>l</code>了？然而并没有，却返回了<code>like</code>，这是为什么呢？</p><p>原因就在于<code>+</code>这个特殊字符，它也并不是只拿到第一个就罢休了，和<code>\w*</code>一样，一直往后匹配，直到第二个空格的时候，才宣告罢休。所以<code>\+</code>是「至少」匹配一次，<code>0</code>次不干，而<code>1</code>之后如果可以连续，那就继续匹配。</p><p><code>?</code>,这个特殊字符的作用是「拒绝贪婪」，看着很特殊是吧？其实就是，在<code>?</code>之前的规则，只要达成即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w+?&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>l<br></code></pre></td></tr></table></figure><p>看，我们之前使用<code>\w+</code>的时候，<code>+</code>这孩子遇到第一个还不满足，非要向后继续拿。可是这个时候我多加了一个家长<code>?</code>，勒令<code>+</code>既然目的已经达到了，就不要再继续了。这就是<code>?</code>字符「拒绝贪婪」的作用。</p><p><code>&#123;&#125;</code>，这个特殊字符咱们用过了，应该大家也都知道它的含义。就是重复多少次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;5&#125;&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>chahe<br></code></pre></td></tr></table></figure><p>从结果我们可以看到，因为前面的<code>like</code>只有四位，并不符合连续匹配五次的标准，所以最后被匹配出来的是<code>chahe</code>。</p><p><code>&#123;&#125;</code>这个特殊字符其实还有一种用法，就是可以给定范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;1,4&#125;&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>like<br></code></pre></td></tr></table></figure><p>我们知道，下标1到下标4这个范围内，正好是<code>like</code>。</p><p><code>‘[]’</code>，这个特殊字符代表字符的范围。用于匹配范围内说包含的字符。使用<code>[]</code>我们可以更精准的筛选出我们需要匹配的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2i4l22LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br>myReg = <span class="hljs-string">&#x27;[a-z]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br>myReg = <span class="hljs-string">&#x27;[0-9]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br>myReg = <span class="hljs-string">&#x27;[_]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>]<br>[<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br>[<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]<br>[<span class="hljs-string">&#x27;_&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，不同的组合匹配出了不同的范围内的单个字符。</p><p><code>[A-Za-z0-9_]</code> 这个组合等价于<code>\w</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2i4l22LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;[A-Za-z0-9_]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>()</code>,这个特殊字符代表的子组，括号中的表达式首先作为整个正则的一部分，另外会把符合小阔中的内容单独提取一份。我们先看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2ial2345LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w+\d&#123;4&#125;\w+&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_2ial2345LoveYou&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这个组合我们匹配到了<code>_2ial2345LoveYou</code>，有且只有这一个组合了。不过这不是我想要的，我想要的是什么呢？是这段匹配出的字符串，并且，我还想要这段字符串中那段数字作为单独的匹配出来。那这个时候我们怎么做呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2ial2345LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;(\w+)(\d&#123;4&#125;)(\w+)&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[(<span class="hljs-string">&#x27;_2ial&#x27;</span>, <span class="hljs-string">&#x27;2345&#x27;</span>, <span class="hljs-string">&#x27;LoveYou&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>我们将用<code>()</code>将前中后包裹了起来，希望得到一个子组，而中间的部分，就是我们想要得到的4个数字的组合。</p><p><code>^</code>和<code>$</code>这两个特殊字符实际上属于「定位符」，<code>^</code>是匹配输入字符串开始的位置。<code>$</code>是匹配输入字符串结尾的位置。</p><p>那我们从一个案例中来了解一下这两个定位符的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;186301916675&#x27;</span><br><span class="hljs-comment"># 定义一个匹配手机号的正则表达式</span><br>myReg = <span class="hljs-string">&#x27;^1\d&#123;10&#125;$&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>返回了<code>None</code>，这又是为什么呢？原因就在于，我们用<code>^</code>限制了必须是1开始，而用了<code>$</code>来限制了到结尾必须是后面有十位数字，而我们数一下，我们给定了12位数字，超出了一位，才会匹配不上。</p><p>如果我们去掉限制结尾<code>$</code>再来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;186301916675&#x27;</span><br><span class="hljs-comment"># 定义一个匹配手机号的正则表达式</span><br>myReg = <span class="hljs-string">&#x27;^1\d&#123;10&#125;&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br><span class="hljs-number">18630191667</span><br></code></pre></td></tr></table></figure><p>可以看到，我们遵循了开头位1和后面跟十位数字的规则，但是原字符串中多出来的一位数字被直接过滤掉了。那我们并不知道，用户输入的数字中到底是哪个位置多输入了一个数对吧？</p><p>再来看，我们把结尾限制加上，但是开头限制改一个数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;186301916675&#x27;</span><br><span class="hljs-comment"># 定义一个匹配手机号的正则表达式</span><br>myReg = <span class="hljs-string">&#x27;^2\d&#123;10&#125;$&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>因为开头匹配不对，所以返回了<code>None</code>。</p><p>所以，争取的匹配方式至少有三个条件：</p><ol type="1"><li>1开头，当然，如果能把运营商的所有开头数字都拿到，那我们能够匹配的条件就变多了。</li><li>必须全部是数字</li><li>必须是11位</li></ol><p>这样，我们可以加上开头限制和结尾限制，正好能满足一个简易的手机号匹配规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;^1\d&#123;10&#125;$&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="正则的模式">正则的模式</h3><p>在正则的模式中，包含了一下几个模式：</p><p><code>re.I</code>: 不区分大小写</p><p><code>re.L</code>: 作本地化识别匹配</p><p><code>re.M</code>:多行匹配，会影响到<code>^</code>个<code>$</code></p><p><code>re.S</code>：使用<code>.</code>匹配包括换行在哪的所有字符</p><p><code>re.U</code>：根据<code>Unicode</code>字符集解析字符。这个标志影响<code>\w, \W, \b, \B</code></p><p><code>re.X</code>:改标志通过给予更灵活的格式以便将正则表达式写的更易于理解。</p><p>实际上，我们虽然列出了这么多模式，真正常用的，也就是<code>re.I</code>这个模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正常匹配，给定规则大写字母</span><br>myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2i4l22LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-comment"># 使用模式&#x27;re.I&#x27;， 其他不变</span><br>myReg = <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br>res = re.findall(myReg, myStr,re.I)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>]<br>[<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，当我设定了不区分大小写的情况下。字符串中的所有英文字母都被匹配了出来。</p><h2 id="练习">练习：</h2><p>这次，我们和以往不同，将练习和课程放在了一起。至于为什么嘛，只是因为我课程写完之后发现还有时间。<code>^_^</code></p><p>这次我们作这样一个练习：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 定义一个正则表达式来验证邮箱是否正确。<br><span class="hljs-bullet">2.</span> 完善手机号码的正则表达式<br><span class="hljs-bullet">3.</span> 定义一个匹配IP的正则表达式 [255.255.255.254]<br></code></pre></td></tr></table></figure><h3 id="验证邮箱">验证邮箱</h3><p>首先让我们来看，邮箱的格式基本包含以下内容：</p><ul><li><code>123456@qq.com</code> 纯数字</li><li><code>chaheng@qq.com</code> 纯字母</li><li><code>chaheng75@126.com</code> 数字加字母</li><li><code>cha_heng@163.com</code> 混合型</li><li><code>chaheng@vip.163.com</code> 多级域名</li><li><code>chaheng@hivan.me</code> 企业邮箱（企业域名）</li><li><code>cha.heng@gmail.com</code> 包含特殊字符<code>.</code></li></ul><p>好，让我们来看，我们以<code>@</code>来前后区分，那么我们先看左边，会包含的内容就是<code>数字，字母，下划线，特殊字符</code>，让我们先来写一下规则试一下：</p><p><code>[a-zA-Z0-9]+([_\.][a-zA-Z0-9])*</code></p><p>那么右边的部分呢？</p><p><code>@(\w)+\.[a-z]&#123;2,6&#125;</code></p><p>让我们结合其实试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mailReg</span>(<span class="hljs-params">mail</span>):<br>    myReg = <span class="hljs-string">&#x27;[a-zA-Z0-9]+([_\.][a-zA-Z0-9]+)*@(\w)+\.[a-z]&#123;2,6&#125;&#x27;</span><br>    res = re.search(myReg, mail)<br>    <span class="hljs-keyword">if</span> res:<br>        <span class="hljs-keyword">return</span> res.group()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res)<br>    <br>mailReg(<span class="hljs-string">&#x27;123456@qq.com&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;123456@qq.com&#x27;</span><br></code></pre></td></tr></table></figure><p>感觉是OK。那让我们多测试下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">mailReg(<span class="hljs-string">&#x27;cha.heng@gmail.com&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;cha.heng@gmail.com&#x27;</span><br><br>=========================<br>mailReg(<span class="hljs-string">&#x27;chaheng@vip.163.com&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>多级域名的测试没有通过，在函数内打印出了<code>None</code>。我们回过头来看看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">myReg</span> = &#x27;[a-zA-Z0-<span class="hljs-number">9</span>]+([_\.][a-zA-Z0-<span class="hljs-number">9</span>]+)*@(\w)+\.[a-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>既然是多级域名出现了问题，那问题肯定出现在多出的那一个点上，我们这样改：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">myReg</span> = &#x27;^[a-zA-Z0-<span class="hljs-number">9</span>]+([_\.][a-zA-Z0-<span class="hljs-number">9</span>]+)*@(\w+\.)+[a-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;$&#x27;<br></code></pre></td></tr></table></figure><p>注意，我们加上了<code>^</code>和<code>$</code>符号。</p><p>然后我们再重新试试看，这次呢，我不想一个个实验了，让我们来定义一个数组来批量测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mailReg</span>(<span class="hljs-params">mail</span>):<br>    myReg = <span class="hljs-string">&#x27;^[a-zA-Z0-9]+([_\.][a-zA-Z0-9]+)*@(\w+\.)+[a-z]&#123;2,6&#125;$&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mail:<br>        res = re.search(myReg, i)<br>        <span class="hljs-keyword">if</span> res:<br>            <span class="hljs-built_in">print</span>(res.group())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(res)<br><br>emailarr = [<br>   <span class="hljs-string">&#x27;123456@qq.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng@qq.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng75@126.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;cha_heng@163.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng@vip.163.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng@hivan.me&#x27;</span>,<br>   <span class="hljs-string">&#x27;cha.heng@gmail.com&#x27;</span>,<br>   <span class="hljs-string">&#x27; list@gmail.com &#x27;</span><br>]<br><br>mailReg(emailarr)<br><br>---<br><span class="hljs-number">123456</span>@qq.com<br>chaheng@qq.com<br>chaheng75@<span class="hljs-number">126.</span>com<br>cha_heng@<span class="hljs-number">163.</span>com<br>chaheng@vip<span class="hljs-number">.163</span>.com<br>chaheng@hivan.me<br>cha.heng@gmail.com<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>这一下子我们就将刚才想到的格式都测试完了，最后我们还特意加了一个不符合的格式来测试下康康是否被过滤了出来。结果说明我们写的正则没有问题。</p><h3 id="手机号码">手机号码</h3><p>就像我们上面写验证手机号正则提到过的，我们可以定义一个所有运营商可能的开头来做头部验证：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">13</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>],<span class="hljs-number">14</span>[<span class="hljs-number">5</span>-<span class="hljs-number">9</span>],<span class="hljs-number">15</span>[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>-<span class="hljs-number">9</span>],<span class="hljs-number">16</span>[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<span class="hljs-number">17</span>[<span class="hljs-number">0</span>-<span class="hljs-number">8</span>],<span class="hljs-number">18</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>],<span class="hljs-number">19</span>[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>-<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>实际上，我们还可以分的更细一点，区分运营商。不过在这个练习中，没必要分的这么细了。</p><p>来，我们实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;^(13[0-9]|14[5-9]|15[0-3,5-9]|16[2,5,6,7,8]|17[0-8]|18[0-9]|19[0-3,5-9])\d&#123;8&#125;$&#x27;</span><br><br>phonearr = [<br>    <span class="hljs-string">&#x27;13728739429&#x27;</span>,<br>    <span class="hljs-string">&#x27;13128319520&#x27;</span>,<br>    <span class="hljs-string">&#x27;17729231234&#x27;</span>,<br>    <span class="hljs-string">&#x27;23210023421&#x27;</span>,<br>    <span class="hljs-string">&#x27;189232198341&#x27;</span>,<br>    <span class="hljs-string">&#x27;19123214421&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> phonearr:<br>    res = re.search(myReg, i)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;手机号码不正确:&#x27;</span>, i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res.group())<br>        <br>---<br><span class="hljs-number">13728739429</span><br><span class="hljs-number">13128319520</span><br><span class="hljs-number">17729231234</span><br>手机号码不正确: <span class="hljs-number">23210023421</span><br>手机号码不正确: <span class="hljs-number">189232198341</span><br><span class="hljs-number">19123214421</span><br></code></pre></td></tr></table></figure><p>正确的辨认并打印了出来，不正确的也辨认了出来。</p><h3 id="匹配ip地址">匹配IP地址</h3><p>我们来看看，一个正确的IP地址（IPv4），是由四个三位数来组成的，包含：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.0.0.0</span> ~ <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure><p>既然是这样一个格式，我们来思考一下，</p><p>首先，我们需要匹配<code>0 ~ 199</code>的范围，也就是0或者1开头,这个比较简单：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[0-1]</span>?\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>这一段匹配中：</p><ul><li><p><code>[0-1]?</code>表示匹配0或1一次或者零次</p></li><li><p><code>\d</code>就是要匹配任意单个数字。0～9都可以</p></li><li><p><code>&#123;1,2&#125;</code>， 给定范围1 ～ 2，表示前面的<code>\d</code>出现1次或者2次。</p></li></ul><p>然后我们需要来匹配<code>200 ~ 255</code>范围,这个范围内比较复杂，包含了两种情况，一种是<code>201 ~250</code>的情况，一种是<code>251 ~ 255</code>的情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>((<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])|([<span class="hljs-number">0</span>-<span class="hljs-number">4</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]))<br></code></pre></td></tr></table></figure><p>这一段匹配，一开表示数字<code>2</code>开头</p><p>然后2之后用异或限定了开头可以是<code>5</code>或者可以是<code>0-4</code>之间的任意数字。</p><p>是<code>5</code>的话，后面需要匹配0-5<code>，是</code>4<code>的话，后面需要匹配</code>0-9`。</p><p>既然一次的匹配已经有了，那剩下的和第一次也都一样，就好些了，我们再多加一个<code>.</code>的匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">((<span class="hljs-number">2</span>((<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])|([<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d)))|([<span class="hljs-number">0</span>-<span class="hljs-number">1</span>]?\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;))(\.((<span class="hljs-number">2</span>((<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])|([<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d)))|([<span class="hljs-number">0</span>-<span class="hljs-number">1</span>]?\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)))&#123;<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>让我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;&#x27;</span><br><br><br>ipArr = [<br>    <span class="hljs-string">&#x27;25.232.123.241&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.242.211.221&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.123.421&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.421.4.5&#x27;</span>,<br>    <span class="hljs-string">&#x27;212.444.523&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>    <span class="hljs-string">&#x27;214.113.231.256&#x27;</span>,<br>    <span class="hljs-string">&#x27;54.214.213.265&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ipArr:<br>    res = re.search(myReg, i)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IP 地址不正确:&#x27;</span>, i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res.group())<br><br>---<br><span class="hljs-number">25.232</span><span class="hljs-number">.123</span><span class="hljs-number">.241</span><br><span class="hljs-number">123.242</span><span class="hljs-number">.211</span><span class="hljs-number">.221</span><br><span class="hljs-number">0.0</span><span class="hljs-number">.123</span><span class="hljs-number">.42</span><br>IP 地址不正确: <span class="hljs-number">123.421</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><br>IP 地址不正确: <span class="hljs-number">212.444</span><span class="hljs-number">.523</span><br><span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-number">214.113</span><span class="hljs-number">.231</span><span class="hljs-number">.25</span><br><span class="hljs-number">54.214</span><span class="hljs-number">.213</span><span class="hljs-number">.26</span><br></code></pre></td></tr></table></figure><p>从结果中可以看到，到底还是有漏网之鱼。第三个和最后两个判断都失误了。这是为什么呢？</p><p>似乎最后一位被截断判断了，也就是说，它并没有判断三位数。</p><p>哦，我大概猜到了。让我们把头部匹配和结尾匹配加上再试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;^((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;$&#x27;</span><br><br><br>ipArr = [<br>    <span class="hljs-string">&#x27;25.232.123.241&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.242.211.221&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.123.421&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.421.4.5&#x27;</span>,<br>    <span class="hljs-string">&#x27;212.444.523&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>    <span class="hljs-string">&#x27;214.113.231.256&#x27;</span>,<br>    <span class="hljs-string">&#x27;54.214.213.265&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ipArr:<br>    res = re.search(myReg, i)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IP 地址不正确:&#x27;</span>, i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res.group())<br><br>---<br><span class="hljs-number">25.232</span><span class="hljs-number">.123</span><span class="hljs-number">.241</span><br><span class="hljs-number">123.242</span><span class="hljs-number">.211</span><span class="hljs-number">.221</span><br>IP 地址不正确: <span class="hljs-number">0.0</span><span class="hljs-number">.123</span><span class="hljs-number">.421</span><br>IP 地址不正确: <span class="hljs-number">123.421</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><br>IP 地址不正确: <span class="hljs-number">212.444</span><span class="hljs-number">.523</span><br><span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>IP 地址不正确: <span class="hljs-number">214.113</span><span class="hljs-number">.231</span><span class="hljs-number">.256</span><br>IP 地址不正确: <span class="hljs-number">54.214</span><span class="hljs-number">.213</span><span class="hljs-number">.265</span><br></code></pre></td></tr></table></figure><p>这回没问题了。我们的正则匹配算是完成了。</p><p>那这节课下来之后，大家要多去理解，多去练习。这节课对于打算玩数据的人正的很重要。</p><p>好了，那我们下节课再见吧。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/regular-expression/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>16. 练习：万年历</title>
    <link href="https://hivan.me/Exercise-perpetual-calendar/"/>
    <id>https://hivan.me/Exercise-perpetual-calendar/</id>
    <published>2023-08-12T16:59:35.000Z</published>
    <updated>2023-08-12T19:03:57.332Z</updated>
    
    <content type="html"><![CDATA[<img src="/Exercise-perpetual-calendar/cover.png" class="" title="img"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>上一节课最后，我让我家去预习一下日历和时间的相关模块，不知道大家有没有去预习。不管如何，这节课，让我们开始做一个练习：万年历。</p><p>没有预习的小伙伴也跟着一起，在本次练习完成的时候，相信你会对这些模块有了初步的了解。</p><p>好，让我们开始吧。</p><p>首先，我们需要来看看<code>calendar.monthrange()</code>这个函数，它属于<code>calendar</code>模块内，返回指定年份和月份的数据，月份的第一天是周几，和月份中的天数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><br>res = calendar.monthrange(<span class="hljs-number">2023</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>我们接收了返回值，但是这个3和30分别是什么意思呢？我们打开日历看一下就明白了：</p><img src="/Exercise-perpetual-calendar/image-20230813010916395.png" class="" title="img"><p>如图所见，2023年的6月份一共是30天，第一天是周四。这也正是<code>(3, 30)</code>的含义。之所以是3而不是4，是因为是从0开始计算的，也就是说，周一是0。比如，2023年5月的第一天就是周一，我们来看看是不是这么回事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = calendar.monthrange(<span class="hljs-number">2023</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-number">0</span>, <span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>那有了这个，我们要做一个当月的日历就简单了，还记得我们之前做过一个星星的矩阵吗？是一样的概念，这是这次直接换成了数字而已，来，让我们从最基本框架开始（<strong>还是以6月份数据来做</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot; &quot;</span>)<br>        d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>01 02 03 04 05 06 07 <br>08 09 <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <br><span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <br><span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span> <span class="hljs-number">27</span> <span class="hljs-number">28</span> <br><span class="hljs-number">29</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <br></code></pre></td></tr></table></figure><p>这样，我们就将天数打印出来了。可是，明眼人一眼就看出了问题，这一月只有30天，怎么得到的35天的？让我们来修复一下这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-comment"># 判断是否输出</span><br>        <span class="hljs-keyword">if</span> d &gt; days:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>        d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>一   二    三   四   五    六   日<br>01   02   03   04   05   06   07   <br>08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <br><span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <br><span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <br><span class="hljs-number">29</span>   <span class="hljs-number">30</span>  <br></code></pre></td></tr></table></figure><p>我们在代码中加了一层判断，如果循环中的<code>d</code>大于<code>days</code>了，那我们就直接输出空格，否则才正确输出格式化的数字，那么这样就可以不输出<code>31-35</code>了。</p><p>完成了，顺便还打印了一行星期几。可是问题是，没有和实际情况对齐对吧？没事，我们继续来改动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-comment"># 判断是否输出</span><br>        <span class="hljs-keyword">if</span> d &gt; days <span class="hljs-keyword">or</span> (d==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i&lt;week):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;     &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>            d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>一   二    三   四   五    六   日<br>               01   02   03   04   <br>05   06   07   08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <br><span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <br><span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <br><span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>    <br></code></pre></td></tr></table></figure><p>我们在之前判断<code>d</code>大于<code>days</code>的判断上再加上一层，不仅如此，当<code>d==1</code>并且<code>i</code>小于<code>week</code>的时候，也都是出制表符，那自然最开始和最末尾不该出现数字的地方都被制表符补齐了。</p><p>我们再来多做一次实验，将月份改成7月来看看和实际情况是否相符,并且，这次我们多加一些内容，将其中的年份和月份也都打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">year = <span class="hljs-number">2023</span><br>month = <span class="hljs-number">7</span><br>res = calendar.monthrange(year, month)<br><br>days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;========= <span class="hljs-subst">&#123;year&#125;</span> 年  <span class="hljs-subst">&#123;month&#125;</span> 月 =========&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">32</span>)<br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-comment"># 判断是否输出</span><br>        <span class="hljs-keyword">if</span> d &gt; days <span class="hljs-keyword">or</span> (d==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i&lt;week):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;     &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>            d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">7</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>                         01   02   <br>03   04   05   06   07   08   09   <br><span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <br><span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <br><span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <br><span class="hljs-number">31</span>  <br></code></pre></td></tr></table></figure><p>我们来看看实际情况是不是如此：</p><img src="/Exercise-perpetual-calendar/image-20230813014347015.png" class="" title="img"><p>没错，确实如此。7月份的第一天从周六开始，一个月有31天，周一为最后一天。那说明，我们上面写的内容真实有效。</p><p>那现在要干嘛呢？当然是封装成一个函数，以<code>year</code>和<code>month</code>为参数，这样，不管我想要查询任意月份，只要我输入对应参数就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">showdate</span>(<span class="hljs-params">year, month</span>):<br>    res = calendar.monthrange(year, month)<br><br>    days = res[<span class="hljs-number">1</span>] <span class="hljs-comment"># 当前月份的天数</span><br>    week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> <span class="hljs-comment"># 当前月份第一天是周几</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;========= <span class="hljs-subst">&#123;year&#125;</span> 年  <span class="hljs-subst">&#123;month&#125;</span> 月 =========&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">32</span>)<br>    <span class="hljs-comment"># 实现日历信息的输出</span><br>    d = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> d &lt;= days:<br>        <span class="hljs-comment"># 循环周</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>            <span class="hljs-comment"># 判断是否输出</span><br>            <span class="hljs-keyword">if</span> d &gt; days <span class="hljs-keyword">or</span> (d==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i&lt;week):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;     &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>                d+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>()<br><br>showdate(<span class="hljs-number">2023</span>, <span class="hljs-number">12</span>)<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">12</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>                    01   02   03   <br>04   05   06   07   08   09   <span class="hljs-number">10</span>   <br><span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <br><span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <br><span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <span class="hljs-number">31</span>   <br></code></pre></td></tr></table></figure><p>我们尝试调用了一下封装好的函数，输出2023年12月份日历，大家可以看看自己手机里的日历，绝对真实可靠。</p><p>好了，现在我们要完成万年历的制作了。</p><p>万年历，自然是有一个初始值，那这个初始值必须是当前时间最妥当。不然你们试试打开你们的日历，看是不是打开默认都是指向的「今天」。</p><p>那么首先，让我们获取一下当前系统的年月，这个就需要用到我们的<code>time</code>模块里的<code>localtime()</code>方法，其返回参数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">time.struct_time(tm_year=<span class="hljs-number">2023</span>, tm_mon=<span class="hljs-number">8</span>, tm_mday=<span class="hljs-number">13</span>, tm_hour=<span class="hljs-number">1</span>, tm_min=<span class="hljs-number">50</span>, tm_sec=<span class="hljs-number">38</span>, tm_wday=<span class="hljs-number">6</span>, tm_yday=<span class="hljs-number">225</span>, tm_isdst=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>那我们如何从中拿到我需要的内容？我们接着看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>dd = time.localtime()<br>year = dd.tm_year<br>month = dd.tm_mon<br><br>showdate(year, month)<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">8</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>     01   02   03   04   05   06   <br>07   08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <br><span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <br><span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <br><span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <span class="hljs-number">31</span>  <br></code></pre></td></tr></table></figure><p>很明显，我们用<code>year</code>和<code>month</code>两个变量从得到的<code>localtime</code>里获取了其中的年份和月份信息。然后重新调用<code>showdate()</code>封装函数，将其传入。也就打印出了我们当前月份的日历。</p><p>可是这都是静态的，我们总不能就只看我们当月的月份。所以，我们接着扩展这个程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>...<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 默认输出当前年月的日历信息</span><br>    showdate(year, month)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &lt; 上一月     下一月 &gt; &#x27;</span>)<br>    c = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的选择 &quot;&lt;&quot; or &quot;&gt;&quot;：&#x27;</span>)<br>    <span class="hljs-comment"># 判断用户的输入内容</span><br>    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>        month -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>        month += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您输入内容错误，请重新输入&quot;&lt;&quot;或者&quot;&gt;&quot;来选择。&#x27;</span>)<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">8</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>     01   02   03   04   05   06   <br>07   08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <br><span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <br><span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <br><span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <span class="hljs-number">31</span>                  <br> &lt; 上一月     下一月 &gt; <br>&gt;<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">9</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>                    01   02   03   <br>04   05   06   07   08   09   <span class="hljs-number">10</span>   <br><span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <br><span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <br><span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>        <br> &lt; 上一月     下一月 &gt; <br></code></pre></td></tr></table></figure><p>我们在程序运行中没有图形界面，无法接收鼠标信息，那就用输入<code>&lt;</code>和<code>&gt;</code>来代替一下，其逻辑是相同的。</p><p>可以看到，我们做了一个判断，当输入<code>&lt;</code>的时候，我月份数字减少，当我们输入<code>&gt;</code>的时候，月份数字增加。所以当我们输入<code>&gt;</code>的时候，表示下一月，数字增加，也就打印出了9月份的月份信息。</p><p>可是问题又来了，我们总不能无限加或者无限减下去吧，12月份之后不可能是13月份吧。这又该怎么办呢？</p><p>别着急，我们继续研究下该怎么改善：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>...<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ...<br>    <span class="hljs-comment"># 判断用户的输入内容</span><br>    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>        month -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> month &lt; <span class="hljs-number">1</span>:<br>            month = <span class="hljs-number">12</span><br>            year -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>        month += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> month &gt; <span class="hljs-number">12</span>:<br>            month = <span class="hljs-number">1</span><br>            year += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;exit&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您输入内容错误，请重新输入&quot;&lt;&quot;或者&quot;&gt;&quot;来选择。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>既然月份是固定的数字，那就是最好办的，我们让变量控制在范围内不就好了。如果超过数字了，那就改变年份，将月份回滚为最小值或者最大值不就好了。两个简单的<code>if</code>解决了问题。</p><p>这就完了吗？并没有。在打印的过程当中，我发现一个问题，就是我们的月份信息不断的叠加，那导致打印区变的过长，最终都没打印完全。这并不是我们想要的，如图：</p><img src="/Exercise-perpetual-calendar/image-20230813021632548.png" class="" title="img"><p>所以，其实我都还没验证到底12月份之后是否正常变为2024年1月了。忍不了，这个问题也必须要解决。</p><p>那如何解决呢？我想起来，在<code>Linux</code>命令中有一个<code>clear</code>命令，其功能就是将当前窗口内容清理掉。那Python中又有很多和系统操作相同的功能，这次有没有呢？就算没有，我记得<code>os.system()</code>似乎可以调用系统命令的。</p><p>那，我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    os.system(<span class="hljs-string">&#x27;clear&#x27;</span>)<br>    <span class="hljs-comment"># 默认输出当前年月的日历信息</span><br>   ...<br></code></pre></td></tr></table></figure><p>实际操作了一下，无法在JupyterNotebook中实现，但是当你将代码存储成<code>.py</code>文件之后，在<code>shell</code>中执行是完全可以实现的。如下图：</p><img src="/Exercise-perpetual-calendar/ScreenFlow-1.gif" class="" title="img"><p>至此，我们本次的练习「万年历」就完成了。</p><p>大家可以下载我的源码来研究，第16课，包含一个<code>.ipynb</code>笔记本文件和一个<code>.py</code>完整文件。</p><p>有什么问题，评论区留言。</p><p>好了，下课，咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Exercise-perpetual-calendar/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>15. 系统内置模块</title>
    <link href="https://hivan.me/System-built-in-modules/"/>
    <id>https://hivan.me/System-built-in-modules/</id>
    <published>2023-08-10T15:20:33.000Z</published>
    <updated>2023-08-12T16:58:34.847Z</updated>
    
    <content type="html"><![CDATA[<img src="/System-built-in-modules/cover.png" class="" title="封面"><span id="more"></span><p>Hi，大家好。我是茶桁。</p><p>上一节中，在我们的学习到达一个阶段的时候，我们用之前所学过的知识创建了一个简单的注册登录系统。不知道小伙伴们有没有在课后自己实现一遍呢？编程这种事情，还是要多上手多练才行。</p><p>那么今天这节课，我们来学习一下Python系统内置模块。</p><p>系统内置模块就是安装完Python解释器之后，系统本身所提供的模块。我知道，咱们之前的课程里有学习系统的内置函数，这个模块和函数不是一个东西。模块这种东西，是需要导入后才可以使用的，比如：<code>json, re, os</code>等等。</p><p>行，废话不多说，让我们进入正题。</p><h2 id="序列化模块">序列化模块</h2><p>序列化，就是指可以把Python中的数据，以文本或者二进制的方式进行转换，并且还能反序列化为原来的数据。数据在程序和网络中进行传输和存储的时候，需要以更加方便的形式进行操作，因此需要对数据进行序列化。</p><p>对数据进行序列化主要有两种方法，一种呢是Python专用的二进制序列化模块：<code>pickle</code>，还有一种呢，是互联网通用的文本序列化模块<code>json</code>。</p><h3 id="pickle"><code>pickle</code></h3><p>按照官方的定义来讲</p><blockquote><p>pickle实现了对一个Python对象结构的二进制序列化和反序列化</p></blockquote><p>它提供了一些可供使用的函数，下面让我们来一一介绍一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br>myStr = <span class="hljs-string">&#x27;I love you&#x27;</span><br>res = pickle.dumps(myStr)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br><span class="hljs-string">b&#x27;\x80\x04\x95\x0e\x00\x00\x00\x00\x00\x00\x00\x8c\nI love you\x94.&#x27;</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bytes&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>当前是将一段字符串使用<code>dumps()</code>进行了转化，那其他数据类型是否可以呢？我们来一段列表试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>res = pickle.dumps(myList)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br><span class="hljs-string">b&#x27;\x80\x04\x95\x0f\x00\x00\x00\x00\x00\x00\x00]\x94(K\x01K\x02K\x03K\x04K\x05e.&#x27;</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bytes&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，依然进行了转化，并且类型还是<code>bytes</code>。其他的诸如字典、元组等都可以进行这样的转化，我们就不一一的在这里展示了。结论为，我们使用<code>pickle.dumps</code>方法可以进行序列化成为一个二进制的数据。</p><p>再让我们来看看反序列化的效果，我在源码中还做过一个元组的序列化，并且给<code>res</code>进行了赋值，我们就拿最后一次的结果来做演示（<code>res = b'\x80\x04\x95\x10\x00\x00\x00\x00\x00\x00\x00(K\x01K\x02K\x03K\x04K\x05K\x06t\x94.'</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = pickle.loads(res)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到, 之前序列化成二进制数据的元组被<code>loads()</code>反序列化转化回来恢复成了元组，我们打印其类型，为<code>tuple</code>。</p><p>除了以上两个方法之外，还有另外两个方法<code>dump()</code>和<code>load()</code>，这四者的区别如下：</p><ul><li><code>dumps(obj, protocol=None, *, fix_imports=True, buffer_callback=None)</code>:序列化，可以把一个Python的任意对象序列化成为一个二进制，返回一个序列化后的二进制数据。</li><li><code>dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None)</code>:序列化，把一个数据对象进行序列化并写入到文件中。注意，<code>demps</code>是返回并不写到文件中，而<code>dump</code>者是写入到文件中。所以多一个必填参数<code>file</code>，就是写入的文件对象。</li><li><code>loads(data, /, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=None)</code>:反序列化，可以把一个序列化后的二进制数据反序列化为Python的对象。返回一个反序列化后的Python对象。</li><li><code>load(file, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=None)</code>:反序列化，<strong>在一个文件中</strong>读取序列化的数据，并且完成一个反序列化。和<code>loads</code>最大的不同是加载的是读取的文件对象<code>file</code>，而不是<code>data</code>。</li></ul><p>可以看到，基本上来说，<code>dump</code>和<code>load</code>是对文件进行操作的方法，那能不能使用<code>dumps</code>和<code>loads</code>来完成呢？让我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义数据</span><br>myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-comment"># 进行序列化</span><br>res = pickle.dumps(myDict)<br><span class="hljs-comment"># 写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.write(res)<br></code></pre></td></tr></table></figure><p>然后我们看，文件夹中确实多了一个data.txt文件，当我想要打开的时候，提示我为二进制文件。</p><img src="/System-built-in-modules/image-20230811221839214.png" class="" title="储存文件"><p>那基本上可以确定，咱们所作的操作确实成功了。</p><p>借用其他的支持二进制文件的编辑器打开看看：</p><img src="/System-built-in-modules/image-20230811223427385.png" class="" title="二进制文件"><p>再来，我们把一个反序列的二进制文件读取处理，并完成反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br><br><span class="hljs-comment"># 进行反序列化</span><br>myDict = pickle.loads(res)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>以上两个方式，我们其实完全可以使用<code>pickle</code>模块提供的方法来完成，<code>dump</code>和<code>load</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data2.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    pickle.dump(myDict, fp)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data2.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    newdict = pickle.load(fp)<br>    <span class="hljs-built_in">print</span>(newdict)<br>    <br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们又重新创建了一个序列化，保存数据到<code>data2.txt</code>中，然后反序列化再从文件中读取转化。和之前我们用到的方法得到的结果一样，但是方法我们用的却完全不同。</p><h3 id="json序列化">JSON序列化</h3><p>JSON的全称为: JavaScript Object Notation,是一个受JS的对象字面量语法启发的轻量级数据交换格式。其在JS语言中是一个对象的表示方法，和Python中的字典的定义规则和语法都很像。</p><p>JSON在互联网中又是一种通用的数据交换，传输，定义的一种数据格式。</p><p>和之前的<code>pickle</code>序列化方法一样，JSON序列化也有四种函数，其功能基本是一模一样。只是最后转化的数据格式不同：</p><ul><li><code>json.dumps()</code>: 完成JSON格式数据的序列化</li><li><code>json.loads()</code>: 完成JSON格式数据的反序列化</li><li><code>json.dump()</code>:和<code>pickle</code>模块的<code>dump</code>方法一致</li><li><code>json.load()</code>:和<code>pickle</code>模块的<code>load</code>方法一致</li></ul><p>这里，我们先不着急写代码，我觉得需要对JSON简单了解一下，其实很简单，一说就明白了：</p><p>我们之前定义了一个字典：<code>myDict = &#123;'name':'茶桁', 'age':32, 'sex':'male'&#125;</code>，这个格式的数据在Python中是字典，但是在JS中，这个玩意是一个对象(<code>Object</code>)，如果它放在一个<code>.json</code>文件中，这会是正常的<code>json</code>格式的数据。</p><p>我们来做一下操作，上几张图就明白了，为了说明，我们创建一个<code>15_json.html</code>文件和<code>15_json.json</code>，大家来看：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> person = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person, <span class="hljs-title function_">typeof</span>(person))</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们在脚本中定义了一个<code>person</code>，格式和Python中的字典一模一样，但是在JS中，它被称为对象。我们在浏览器的控制台中打印出来看看：</p><img src="/System-built-in-modules/image-20230811230908151.png" class="" title="JS中的对象"><p>那如果在一个JSON文件中呢，它就是一个最普通的JSON数据格式。只是稍微需要注意一下，虽然我们这样写并不会报错，但是总会提示格式问题，JSON最正规的写法，是需要用<code>“"</code>，尽量不要使用<code>‘’</code>。</p><p>提前说这么多JSON的知识点，是因为接下来，如果我们没有说清楚，可能正的会分辨不清。好了，让我们转回Python中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(myDict, <span class="hljs-built_in">type</span>(myDict))<br><br><span class="hljs-comment"># 使用JSON模块的dumps方法进行JSON格式的转换</span><br>res = json.dumps(myDict)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br>&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;\u8336\u6841&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>我们在代码中执行了两次打印，第一次是定义完字典之后，第二次是转换为JSON之后。我们可以看到两次打印结果，几乎是一模一样。当然，中文部分转化的比较明显，但是如果我讲<code>name</code>的值设定为英文，比如<code>Hivan</code>，那么可以说几乎看不出区别。比较明显的，是我们将类型打印了出来，一个是<code>dict</code>,一个就是<code>str</code>。</p><p>当然，和<code>pickle</code>一样，<code>loads</code>方法将会进行反序列化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">newDict = json.loads(res)<br><span class="hljs-built_in">print</span>(newDict, <span class="hljs-built_in">type</span>(newDict))<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>JSON的转化，基本Python中所有的数据类型都可以进行序列化而不会出现报错的情况，但是有些数据是真的转为了JSON格式的数据，但是有的则只是转为了字符串而已。</p><p>让我们尝试将一个复杂的结构数据写到一个JSON文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">myList = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;female&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;du&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">34</span>,<span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(myList, fp)<br></code></pre></td></tr></table></figure><p>我们去查看一下文件的内容：</p><img src="/System-built-in-modules/image-20230812015421930.png" class="" title="15_data.json"><p>读取的话，当然也和<code>pickle</code>中的用法也是一致的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    newList = json.load(fp)<br>    <span class="hljs-built_in">print</span>(newList)<br><br>---<br>[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;du&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="数学与数值">数学与数值</h2><h3 id="数学模块-math">数学模块 Math</h3><p>Python中的内置数学模块Math提供了很多的数学相关运算。整个模块中的方法都非常简单，直接调用就可以了，当然，前提是需要导入数学模块。下面我们就简单的介绍一下相关方法(当然，其实我们之前已经介绍过一部分了。)：</p><ul><li>向上取整 <code>math.ceil()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># math.ceil() 向上取整</span><br>res = math.ceil(<span class="hljs-number">3.14</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个函数让你想到了什么？不知道小伙伴们还记得前面学习的内容不，是不是特别像我们曾经学过的<code>round()</code>方法？不过这两个方法还有不一样的地方，让我们来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.14</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.5</span>))<br><br>---<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>看到区别了吗？<code>round</code>实际上是一个四舍五入的函数，而<code>ceil</code>只是向上取整，则不管你小数点后面的数字大小。当然，有向上取整:<code>math.floor()</code>，这肯定有对应的向下取整，为了很清晰的看出来，我选择了一个向上接近整数的小数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.floor(<span class="hljs-number">3.94</span>))<br><br>---<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>接下来是求幂次方:<code>math:pow(x,y)</code>，这个方法会传入两个数值，前一个数值为底数，后一个则为指数，结果是浮点数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">1.44</span><br></code></pre></td></tr></table></figure><p>下面一个是求开平方，结果也是浮点数： <code>math.sqrt()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">4</span>))<br><br>---<br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p><code>math.fabs()</code>能够计算绝对值,结果是浮点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.fabs(-<span class="hljs-number">3.14</span>))<br><br>---<br><span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p><code>math.modf()</code>: 把一个数值拆分成小数和整数组成的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.modf(<span class="hljs-number">3.1415</span>))<br><br>---<br>(<span class="hljs-number">0.14150000000000018</span>, <span class="hljs-number">3.0</span>)<br></code></pre></td></tr></table></figure><p>至于最后的打印结果，不用太纠结。这并不是Python中的BUG，而是与计算机如何处理浮点数有关，因为计算机存储数据实际上都是二进制的，而二进制无法正确处理。</p><p>举个栗子：<code>1/3</code>，在十进制下，这个数是无限循环小数对吧？<code>3.33333333</code>，二进制实际上也有这种问题，比如说<code>1/10</code>,十进制下是<code>0.1</code>，可是二进制下呢，就成了无限循环小数：<code>0.000111001100110011...</code>。</p><p>其实大部分情况之下，这并不影响我们的使用，只是得到的数值需要处理一下四舍五入就可以了，但是也有不适用的情况。实际上，Python中有专门处理精度计算的模块：<code>decimal</code>，这个等我们以后再详细讲。</p><p><code>math.copysign(x,y)</code>:把第二个参数的正负符号拷贝给第一个参数，结果为浮点数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.copysign(-<span class="hljs-number">3</span>, <span class="hljs-number">99</span>))<br><span class="hljs-built_in">print</span>(math.copysign(<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">3.0</span><br>-<span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><p><code>math.fsum()</code> :将一个容器类型数据中的元素进行一个求和运算，结果为浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.fsum((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))<br><span class="hljs-built_in">print</span>(math.fsum(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))<br><br>---<br><span class="hljs-number">6.0</span><br><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure><p>这个方法的参数值需要注意一下，容器中的元素必须是可以运算的<code>number</code>类型。</p><p><code>math.factorial(x)</code>: 以一个整数返回x的阶乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.factorial(<span class="hljs-number">4</span>))<br><br>---<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>除了运算函数外，还有一些常量函数。最典型的就是<code>数学常数 π = 3.141592...</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.pi)<br><br>---<br><span class="hljs-number">3.141592653589793</span><br></code></pre></td></tr></table></figure><p>基本可以看出来，Python的数学模块基本都属于很简单的工具类函数，列举几个之后，大家基本上就都能上手了。其官方的文档地址可以看这里：相关文档地址为：<ahref="https://docs.python.org/zh-cn/3.10/library/math.html#module-math">https://docs.python.org/zh-cn/3.10/library/math.html#module-math</a>。</p><h3 id="随机模块-random">随机模块 <code>random</code></h3><p>随机模块也是一个比较简单的模块，大部分时候，我们是使用它来产生随机值使用的。</p><p><code>random</code>模块中的<code>random</code>函数直接使用会返回一个0-1之间的随机小数（左闭右开）</p><p>什么是左闭右开呢？通俗点说，就是<code>random</code>这个函数，有可能取到<code>0</code>这个值，而无论如何不会取到<code>1</code>这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.random())<br><br>---<br><span class="hljs-number">0.7363473107012012</span><br></code></pre></td></tr></table></figure><p><code>random.randrange([开始值]，结束值，[步进值])</code>:随机获取指定<strong>范围内的整数</strong>。对于这种需要开始值，结束值和步进值的参数形式的函数我们应该都已经非常熟悉了对吧？</p><p>这里有三个值，除了结束值是必选之外，另外两个值都是可选值。当<strong>只有一个参数</strong>时，默认就是从0到整数之间的值，<strong>存在两个参数</strong>时，就从开始值到结束值之间的随机数，而<strong>当有三个参数时</strong>，就会按照步进值从开始值到结束值之间产生一个随机数。需要记住一点，这三种参数取值方式，都是左闭右开的形式。也就是说，结束值是不会被取到的。</p><p>随机数大量应用在数字验证码，抽奖以及高并发下生成订单号等应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><code>random.randint()</code> 会随机产生指定范围内的随机整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>))<br><br>---<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>可能有的小伙伴会发出疑问了：茶桁老师，你这个解释是不是写错位置了？将<code>randrange</code>的解释直接复制了下来。其实没有，这两个的功能几乎一模一样，说几乎的意思当然是还是有不同点，唯一一点不相同的是，<code>randint</code>产生的随机整数，是左闭右闭的模式，也就是说，它是可以取到结束值的。</p><p>当然我们不能只随机整数对吧？实际应用场景中我们也需要大量的浮点数：</p><p><code>random.uniform()</code> 获取指定返回内的随机小数,实际应用中我们需要注意，这个函数是没有开始值和结束值的，只有<strong>范围值</strong>，也就是说，你最小值和最大值填入的先后顺序无所谓。</p><p>那有的小伙伴会想，如果两个值我填入的数值一样会如何？嗯，那就产生一个唯一的浮点值呗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br><br>---<br><span class="hljs-number">9.540258898738779</span><br><span class="hljs-number">7.343136835899989</span><br><span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure><p><code>random.choice()</code>，随机获取容器类型中的值。这个函数的应用范围就非常广了，我们在做数据分析的时候经常会用得到。因为大部分时候，我们说面对的应该都是容器类数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.choice(<span class="hljs-string">&#x27;123&#x27;</span>))<br><span class="hljs-built_in">print</span>(random.choice([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br><br>---<br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>random.shuffle()</code>随机打乱当前列表中的值，没有返回值，仅仅是打乱原数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>res = random.shuffle(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr:<span class="hljs-subst">&#123;arr&#125;</span> \nres:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>arr:[<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <br>res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>当然，我说介绍的函数都只是一部分，目的是打个样，让大家知道这些函数是个怎么回事。大部分时候会用到的函数抽出来讲解一下，更多的内容，还需要参考官方文档：<ahref="https://docs.python.org/zh-cn/3.10/library/random.html#module-random">https://docs.python.org/zh-cn/3.10/library/random.html#module-random</a></p><h2 id="系统操作相关模块">系统操作相关模块</h2><h3 id="os模块">OS模块</h3><p>OS模块，就是操作系统接口模块。这个模块提供了一些方便使用操作系统相关功能的函数。我们之前重点学习的<code>open()</code>，就是这个模块中的相关函数。现在让我们来看看除了<code>open</code>之外，还有哪些函数可供我们日常使用：</p><p><code>os.getcwd()</code>获取当前的工作目录,注意获取的不是当前脚本的目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>res = os.getcwd()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>/Users/du/git/AI_Cheats/Python<br></code></pre></td></tr></table></figure><p>不过需要注意一点是，这个函数并不是获取现在这个文件的所在目录，而是当前此文件的执行目录。这个怎么理解呢？我给大家举例说明一下：</p><p>我们首先需要知道一个，就是我们在Linux中执行<code>cd</code>和<code>pwd</code>的时候，一个是进入某个目录，一个是打印当前目录路径：</p><img src="/System-built-in-modules/image-20230812144245562.png" class="" title="命令符"><p>那么这里的<code>pwd</code>所执行的结果，是随着进入目录不同而变化的，比如我们进入我们当前的文件目录：</p><img src="/System-built-in-modules/image-20230812144439461.png" class="" title="切换目录"><p>也就是说，我在哪个目录下执行<code>pwd</code>，那么返回结果就是当前执行的这个目录，而不是<code>pwd</code>这个执行文件本身所在的目录。</p><p><code>gwtcwd()</code>文件，和<code>pwd</code>实际上就是相同的特点，如果在当前目录执行这个脚本文件，那么getcwd获取的就是当前的文件目录。如果这个时候我切换到了其他目录，但是写了<code>getcwd()</code>方法的文件没有挪动位置，那么此时我获取的返回值就是我切换的其他目录，而非文件所在的位置。下面我们可以测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;/Users/du/git/&#x27;</span>)<br>res = os.getcwd()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>/Users/du/git<br></code></pre></td></tr></table></figure><p>可以看到，我们执行了和上main相同的代码，但是这个时候<code>res</code>接收返回值发生了变化，其原因就是我使用了<code>os.chdir</code>来改变了一下当前的工作目录。不知道大家现在是否能理解<code>gwtcwd()</code>的工作原理？还是无法理解的，可以多自己写一下代码，做做尝试。连我这种笨人之前学习的时候都能很快理解，小伙伴们肯定更没有问题。</p><p>刚才我们的实验中，引出了另外一个方法：</p><p><code>os.chdir()</code>,如上所见，其功能就是修改<strong>当前工作目录</strong>。</p><p>下面我们直接介绍其他的函数：</p><p><code>os.listdir()</code>获取当前或指定目录中的所有项（文件，文件夹，隐藏文件），组成的列表</p><p>这个方法和Linux中的<code>list</code>命令就十分像了，让我们先将<strong>当前工作目录</strong>切回我们当前文件本来所在的目录，然后在来执行一下这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/&#x27;</span>)<br>res = os.listdir()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;12.ipynb&#x27;</span>, <span class="hljs-string">&#x27;10.ipynb&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;15_json.html&#x27;</span>, <span class="hljs-string">&#x27;14.ipynb&#x27;</span>, <span class="hljs-string">&#x27;8.ipynb&#x27;</span>, <span class="hljs-string">&#x27;14.py&#x27;</span>, <span class="hljs-string">&#x27;11.ipynb&#x27;</span>, <span class="hljs-string">&#x27;globals.ipynb&#x27;</span>, <span class="hljs-string">&#x27;13.ipynb&#x27;</span>, <span class="hljs-string">&#x27;Kalman.ipynb&#x27;</span>, <span class="hljs-string">&#x27;9.ipynb&#x27;</span>, <span class="hljs-string">&#x27;15.ipynb&#x27;</span>, <span class="hljs-string">&#x27;7.ipynb&#x27;</span>, <span class="hljs-string">&#x27;5.ipynb&#x27;</span>, <span class="hljs-string">&#x27;1.ipynb&#x27;</span>, <span class="hljs-string">&#x27;3.ipynb&#x27;</span>, <span class="hljs-string">&#x27;4.ipynb&#x27;</span>, <span class="hljs-string">&#x27;6.ipynb&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;2.ipynb&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，目录内所有的文件，包括隐藏文件<code>.DS_Store</code>和文件夹<code>data</code>都被放进了一个列表当中。</p><p>这是在不指定目录的情况下，默认为当前工作目录，当然，我们还可以指定目录来获取那个目录下的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.listdir(<span class="hljs-string">&#x27;/Users/du/AI/&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;AIGC&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;GPT&#x27;</span>, <span class="hljs-string">&#x27;AI_core_competence&#x27;</span>, <span class="hljs-string">&#x27;stable-diffusion-webui&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们就获取到了我们希望查找的目录下的所有内容。我们继续：</p><p><code>os.mkdir(文件夹路径, 权限)</code>这个函数用来创建文件夹，其命令 和Linux中是一模一样，功能也是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.listdir(<span class="hljs-string">&#x27;./data/&#x27;</span>))<br>os.mkdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>, <span class="hljs-number">0o777</span>)<br><span class="hljs-built_in">print</span>(os.listdir(<span class="hljs-string">&#x27;./data/&#x27;</span>))<br><br>---<br>[<span class="hljs-string">&#x27;black.txt&#x27;</span>, <span class="hljs-string">&#x27;user.txt&#x27;</span>, <span class="hljs-string">&#x27;13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;data2.txt&#x27;</span>, <span class="hljs-string">&#x27;data3.json&#x27;</span>, <span class="hljs-string">&#x27;13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;15_data.json&#x27;</span>, <span class="hljs-string">&#x27;data.txt&#x27;</span>]<br>[<span class="hljs-string">&#x27;black.txt&#x27;</span>, <span class="hljs-string">&#x27;user.txt&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;data2.txt&#x27;</span>, <span class="hljs-string">&#x27;data3.json&#x27;</span>, <span class="hljs-string">&#x27;13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;15_data.json&#x27;</span>, <span class="hljs-string">&#x27;data.txt&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到我们两次打印结果的对比，确实多了一个<code>test</code>的目录。前一个参数很好理解，重点是后一个参数，什么是权限？</p><p>关于系统中的文件权限，我下面所讲的仅限<code>Linux</code>系统，确切的说是<code>unix</code>，因为包括Mac一样通用：</p><p>来，我们先进入目录打印出来看看：</p><img src="/System-built-in-modules/image-20230812150938583.png" class="" title="命令符查看目录"><p>我们主要来看一下<code>data</code>目录的<code>drwxr-xr-x</code>，分别来介绍一下：</p><ul><li>第一个字母<code>d</code>代表的是一个目录，如果是<code>-</code>呢，这表示这是一个文件</li><li>前三位的<code>rwx</code>代表当前目录（文件）对所有人(u)的权限</li><li>中间位置的<code>r-x</code>代表的所属组(g)的权限</li><li>末尾的三位<code>r-x</code>代表的是其他人(o)的权限</li><li>三个位置介绍完了我们来看字母所代表的意义：</li></ul><p><code>r,w,x</code>代表不同的操作权限，其中:</p><ul><li><code>r</code>就是可读，权限针对文件，表示可以查看文件内容，针对目录，表示可以<code>ls</code>查看目录中存在的文件名称。</li><li><code>w</code>就是可写，针对文件，表示可以更改文件的内容，针对目录，表示是否可以删除目录中的子文件或者子目录。</li><li><code>x</code>是访问权限，针对文件，表示是否可以开启文件当中记录的程序，针对目录，这表示是否可以进入该目录。</li></ul><p>那为什么是<code>777</code>呢？那是因为<code>r</code>代表是<code>4</code>,<code>w</code>代表是<code>2</code>,<code>x</code>代表的是<code>1</code>,那么<code>7</code>就可以理解了，就是所有数值相加的结果。那么为什么是三个<code>7</code>呢？因为这是在设置三个不同目标的权限，三个位数分别是<strong>所有人，所有组，其他</strong>。</p><p>不过，大家还要注意的一点是，无法使用Python去创建一个比自己这个进程权限还要高的文件。</p><p><code>mkdir()</code>方法是只能创建一个文件夹，无法递归创建文件夹，而当我们需要进行递归创建该怎么办呢？也就是说，我们不仅仅是想要创建<code>test</code>文件夹，而是想创建<code>/test/a/b/c/d/e</code>该怎么办？</p><p><code>os.makedirs()</code>可是进行递归创建文件夹。我们先看一下当前目录结构，直接Finder来看吧：</p><img src="/System-built-in-modules/image-20230812153001971.png" class="" title="原目录结构"><p>好，让我们执行一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.makedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再来看看目录结构：</p><img src="/System-built-in-modules/image-20230812173639238.png" class="" title="执行后目录结构"><p>这样就能最直观的看到执行这个函数之后的结果了。</p><p>在创建完一些无用目录之后，我当然想着是怎么删除它们。</p><p><code>os.rmdir*()</code>删除<strong>空文件夹</strong>，比如我们尝试着删除一下刚才我们创建的目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><br>---<br>OSError: [Errno <span class="hljs-number">66</span>] Directory <span class="hljs-keyword">not</span> empty: <span class="hljs-string">&#x27;./data/test&#x27;</span><br></code></pre></td></tr></table></figure><p>报错了，告知我们无法删除一个空目录，原因就是我们在<code>test</code>里创建了好几层文件夹，那现在<code>test</code>肯定不是空目录，那让我们从内层开始试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>没有报错，应该是成功了，我们来看看：</p><img src="/System-built-in-modules/image-20230812173724292.png" class="" title="删除后的目录"><p>确实，<code>f</code>文件夹被删除了。不过太烦了，一个个删除到什么时候去了，还不如我到<code>Finder</code>中直接手动删除呢。</p><p><code>os.removedirs()</code>就是一个递归删除空文件夹的函数，我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.removedirs(<span class="hljs-string">&#x27;./data/test/&#x27;</span>)<br><br>---<br>OSError: [Errno <span class="hljs-number">66</span>] Directory <span class="hljs-keyword">not</span> empty: <span class="hljs-string">&#x27;./data/test/&#x27;</span><br></code></pre></td></tr></table></figure><p>居然又报错，告诉我们非空目录，这...</p><p>原来，<code>removedirs</code>方法使用必须是从后往前递归的，也就是说，我们需要将需要删除的所有目录的层级关系给到这个方法，在执行过程中，向上递归，路径中的所有空目录都会被删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.removedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再执行一次，这回没问题了。从<code>test</code>开始，下层的所有空目录都被删除了。</p><p>然后就是删除文件了</p><p><code>os.remove()</code>就是删除文件，为了测试这个方法，我在<code>data</code>目录下创建了一个空文件<code>test.txt</code></p><img src="/System-built-in-modules/image-20230812155752043.png" class="" title="创建test.txt"><p>不过在删除之前，我们还是要先用一下这个文件，来看看如何改名：</p><p><code>os.rename()</code>: 用于修改文件或者文件夹的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rename(<span class="hljs-string">&#x27;./data/test.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/System-built-in-modules/image-20230812173931755.png" class="" title="文件改名"><p>好了，文件用完了，现在让我们删除吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.remove(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>顺利删掉了刚才创建的文件。</p><p><code>os.system()</code> 执行操作系统中的命令</p><p>比如，我们刚才在命令行里执行过<code>ls -al</code>的命令用于查看当前目录下的所有文件及目录，包括其相关权限，那么我们在Python里可以执行吗？来试试看就知道了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;ls -al&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行效果如图：</p><img src="/System-built-in-modules/image-20230812174342944.png" class="" title="system()"><p>这个方法实际上不止是让你在Python中执行系统命令用的，可以用于执行其他<code>.py</code>，也就是Python文件。比如我们创建了一个<code>hello.py</code>文件，里面写了如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello Python。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>那么，我在其他Python文件中使用<code>os.system</code>方法就可以执行这段代码，当然，前提是你得写对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;/file_path/hello.py&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样，你在其他文件内写的一个方法就被当前文件执行了。</p><h3 id="os.path-路径模块"><code>os.path</code> 路径模块</h3><p>在Python创建的整个工程或者某一个函数里，路径操作也是经常要做的事情。比如：</p><p><code>os.path.abspath()</code>就是将相对路径转化为绝对路径吗，多数时候，我们是需要获取文件的绝对路径的，更多的是为了获取当前工作目录的绝对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&#x27;./15.ipynb&#x27;</span>))<br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&#x27;./&#x27;</span>))<br><br>---<br>/Users/du/git/AI_Cheats/Python/<span class="hljs-number">15.</span>ipynb<br>/Users/du/git/AI_Cheats/Python<br></code></pre></td></tr></table></figure><p><code>os.path.basename()</code>，这个方法可以获取到路径后截取返回主体部分，来看代码，一看就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.abspath(<span class="hljs-string">&#x27;./15.ipynb&#x27;</span>)<br><span class="hljs-built_in">print</span>(os.path.basename(res))<br><br>---<br><span class="hljs-number">15.</span>ipynb<br></code></pre></td></tr></table></figure><p>截取了路径中最末尾的文件名和扩展名，如果路径上最末尾的是一个文件夹不包含文件，那获取的就是那最后一个文件夹名称。</p><p><code>os.path.dirname()</code>， 返回路径中主体部分之前的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.dirname(<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/data/data.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>不过使用这个方法的时候需要注意，如果你填入的是一个相对路径，它并不能打印出绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.dirname(<span class="hljs-string">&#x27;./1.ipynb&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>.<br></code></pre></td></tr></table></figure><p><code>join()</code> 链接多个路径，组成一个新的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.join(<span class="hljs-string">&#x27;./data/test/&#x27;</span>, <span class="hljs-string">&#x27;2.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>./data/test/<span class="hljs-number">2.</span>txt<br></code></pre></td></tr></table></figure><p>实际上，它更像是一个字符串拼接，因为这个方法并不会去验证路径的有效性。</p><p><code>split()</code>这个方法和<code>join()</code>正好相反，用于拆分路径，把路径拆分为路径和主体部分。然后返回一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.split(<span class="hljs-string">&#x27;./data/test/2.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;./data/test&#x27;</span>, <span class="hljs-string">&#x27;2.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>splitext()</code>拆分路径，可以拆分文件后缀名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.splitext(<span class="hljs-string">&#x27;./data/test/2.jpg&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;./data/test/2&#x27;</span>, <span class="hljs-string">&#x27;.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>os.path.getsize()</code>获取文件的大小 , 单位是字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.getsize(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">91</span><br></code></pre></td></tr></table></figure><p><code>os.path.isdir()</code>会检测是否是一个文件夹，检测其是否存在，返回<code>True</code>或者<code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.isdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>os.path.isfile()</code>会检测文件是否存在，一样是返回<code>True</code>或者<code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.isfile(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><code>exists()</code>是一个通用函数，检测路径是否存在。和以上两个不同的是，也可以检测文件，也可以检测路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.exists(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br>res = os.path.exists(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>当我们有一个相对路径和一个绝对路径，而我们想看看两个路径是否指向一个目标位置的时候，是不是要先获取相对路径的绝对路径之后，再去对比呢？</p><p>其实没有那么麻烦,只需要<code>os.path.samefile(a, b)</code>就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;./data/data.txt&#x27;</span><br>b = <span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/data/data.txt&#x27;</span><br>res = os.path.samefile(a, b)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>使用这个方法，我们需要填入的两个值是真实存在的路径。</p><p>当然，官方的文档内还有更多的函数，我这里仅仅是列出了一些常用的。大家可以去官方文档内去看看。</p><h3 id="shutil高级操作模块"><code>shutil</code>高级操作模块</h3><p><code>shutil</code>模块对文件和文件集合提供了许多的高级操作。其中就有支持文件复制和删除的一些功能。</p><p>要说，其实<code>shutil</code>这个模块的很多方法和<code>Unix</code>里的<code>shell util</code>都一样，所以会用命令行的小伙伴，对这个模块应该是极其容易上手：</p><p><code>shutil.copy()</code>，一看就明白是干什么的是吧？就是将文件拷贝到指定目录的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br><br>---<br>FileNotFoundError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>报错了，咋回事？看提示，应该目录或文件不存在。嗯，这个方法要操作之前，目标路径中的目录是必须存在的，它无法自动创建目录。</p><p>让我们手动创建目录之后再试试，还记得我们之前创建目录的命令怎么做吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">os.mkdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br>shutil.copy(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>有返回值了，那我们操作应该完成了。走，去目录里看看：</p><img src="/System-built-in-modules/image-20230812193844046.png" class="" title="copy"><p>确实，目录和文件都存在了，这里注意我标注的两个文件，<code>copy</code>这个命令指示拷贝了一个副本到目标目录中，原文件还是存在于原来的位置。但是注意到时间了吗？修改时间被更改了，改为了我们执行当前操作的时间。</p><p><code>copy2</code>是另外一个拷贝方法，它所有功能和<code>copy</code>都一样，但是如果真是一模一样的方法，也就没必要多创建一个了对吧？这个方法最大的不同，就是保留了原文件的信息，包括操作时间和权限等。</p><p>再让我们操作一下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy2(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/System-built-in-modules/image-20230812194413804.png" class="" title="copy2"><p>除了这两个拷贝方法外，还有一个拷贝方法<code>copyfile()</code>，专门用于拷贝文件中的内容，写入到新的文件中去。让我们在<code>./data/test/</code>中新建一个<code>data2.txt</code>文件来接收写入内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copyfile(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data2.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们来打开<code>data2.txt</code>之后查看一下内容，确实写入了：</p><img src="/System-built-in-modules/image-20230812195204028.png" class="" title="copyfile"><p><code>shutil.copytree('./a', './b')</code>方法看名字应该就猜到是干什么的，是将整个目录结构全部拷贝到指定目录中。使用的时候要多注意，指定的目标目录必须不存在同名目录。</p><p><code>shutil.rmtree()</code>，我们之前有用到带<code>rm</code>的方法，那么看名字也就知道了，这个方法是删除整个文件夹，包括文件夹下的所有目录和文件，和之前我们使用的<code>removedirs</code>不同，这个方法并不是从下往上递归，而是直接全部删除。让我再创建一次多级目录才测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.makedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>目录创建完成后，来让我们将整个<code>test</code>文件夹全部删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.rmtree(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行成功，<code>test</code>整个目录及其内部文件全部删除了。</p><p>我们最后再来看一个用的非常多的方法<code>shutil.move()</code>，我们都知道，<code>windows</code>中有剪切和复制两种菜单命令，然后到新的目标目录后进行粘贴，如果是剪切命令，这原目录中文件会在粘贴完成后删除，而如果是复制，不会执行删除。<code>Linux</code>的逻辑稍微有些不同，是先进行拷贝，然后在目标目录之后决定是粘贴还是移动，如果是粘贴的话就保留原目录的文件，如果是移动，则会在粘贴完成之后在原位置删除文件。</p><p>虽然逻辑上有些许不同，但是不管是<code>Windows</code>还是<code>Linux</code>(包括Mac)，如果是移动某个文件的时候都遵循的是先复制一份到目标目录之后，再把原文件删除的先后顺序。</p><p>其实<code>move()</code>命令也是一样的逻辑，基于这个逻辑，<code>move</code>实际上也可以用于修改文件夹或文件的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.move(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/data_copy.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们去看一下：</p><img src="/System-built-in-modules/image-20230812201611443.png" class="" title="move"><p>可以看到，执行成功了。我们多注意一下就会发现，<code>move</code>命令也有和<code>copy2</code>相同的特性，将原文件的信息保留了下来。</p><h2 id="zipfile压缩模块"><code>zipfile</code>压缩模块</h2><p>ZIP文件格式基本是互联网上最通用的一种压缩格式，常见的存档和压缩标准。该模块提供了用于创建，读取，写入，附加和列出ZIP文件的工具。</p><p>在日常使用中，我们也会经常用到这个模块的相关功能。和之前介绍方法不同，我们这一部分按需求来介绍：</p><h3 id="压缩文件">压缩文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile, os<br><br><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> myzip:<br>    myzip.write(<span class="hljs-string">&#x27;./data/data_copy.txt&#x27;</span>)<br>    myzip.write(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>)<br>    myzip.write(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有没有发现，其方法和我们在对文件进行读写操作的时候很像，逻辑就是先创建一个压缩包文件，然后往里面扔入对应的文件。</p><img src="/System-built-in-modules/image-20230812202451930.png" class="" title="压缩文件"><h3 id="解压缩文件">解压缩文件</h3><p>压缩之后，我们这次解压缩来看看压缩包内的文件是不是我们刚才扔进去的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> myzip:<br>    myzip.extractall(<span class="hljs-string">&#x27;./data2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行之后结果：</p><img src="/System-built-in-modules/image-20230812202902088.png" class="" title="解压缩"><p>文件的确都是原来的文件。</p><h3 id="批量压缩">批量压缩</h3><p>不过之前压缩文件的时候也太麻烦了，文件一个一个的列出来扔进压缩包，那有没有办法将指定文件夹中的文件全部打包呢？</p><p>当然没问题，既然我们嫌弃手动一个个添加文件名太麻烦，那我们直接用机器添加不就好了，怎么做呢？</p><p>首先第一步当然是获取文件夹下所有的文件，应该还记得<code>listdir()</code>这个方法吧？才学的。</p><p>获取列表之后，我们直接用代码一个个的扔到压缩包内就可以了，用<code>for</code>循环吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED) <span class="hljs-keyword">as</span> myzip:<br>    <span class="hljs-comment"># 获取当前目录中的所有的项</span><br>    arr = os.listdir(<span class="hljs-string">&#x27;./&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>        myzip.write(i)<br>        <br>---<br>[<span class="hljs-string">&#x27;12.ipynb&#x27;</span>, <span class="hljs-string">&#x27;10.ipynb&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;15_json.html&#x27;</span>, <span class="hljs-string">&#x27;14.ipynb&#x27;</span>, <span class="hljs-string">&#x27;8.ipynb&#x27;</span>, <span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;14.py&#x27;</span>, <span class="hljs-string">&#x27;11.ipynb&#x27;</span>, <span class="hljs-string">&#x27;globals.ipynb&#x27;</span>, <span class="hljs-string">&#x27;13.ipynb&#x27;</span>, <span class="hljs-string">&#x27;Kalman.ipynb&#x27;</span>, <span class="hljs-string">&#x27;9.ipynb&#x27;</span>, <span class="hljs-string">&#x27;15.ipynb&#x27;</span>, <span class="hljs-string">&#x27;7.ipynb&#x27;</span>, <span class="hljs-string">&#x27;5.ipynb&#x27;</span>, <span class="hljs-string">&#x27;1.ipynb&#x27;</span>, <span class="hljs-string">&#x27;3.ipynb&#x27;</span>, <span class="hljs-string">&#x27;4.ipynb&#x27;</span>, <span class="hljs-string">&#x27;6.ipynb&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;2.ipynb&#x27;</span>]<br></code></pre></td></tr></table></figure><p>通过将打印出来的<code>arr</code>我们可以看到所有被成功扔进压缩包的内容。</p><h3 id="其他压缩方法">其他压缩方法</h3><p><code>zipfile</code>是Python中内置的专门用于压缩<code>zip</code>格式压缩包的方法，但是其实，我们并不限于压缩成<code>zip</code>格式。那是不是还有<code>rarfile</code>,<code>7zfile</code>等模块呢？那真是想多了，我们刚才学过的<code>shutil</code>方法，就可以进行压缩操作。不过不一样的是，虽然效果是一样的，但是我们这个方法是<strong>创建归档</strong>:</p><p><code>shutil.make_archive()</code>，用于创建一个压缩文档。这个方法中有三个比较重要的参数，一个是创建的归档文件名称，第二个是指定的归档格式，第三个则是要归档的文件或文件夹路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.make_archive(<span class="hljs-string">&#x27;temp&#x27;</span>, <span class="hljs-string">&#x27;tar&#x27;</span>, <span class="hljs-string">&#x27;./data&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/System-built-in-modules/image-20230812204243773.png" class="" title="archive_file"><p>成功完成<code>tar</code>格式的归档。</p><p>除了以上的这些介绍的内置模块之外，我们平时应用中还会用到许多其他的模块，比如日历模块<code>calendar</code>，时间模块<code>time</code>等等。我上方讲解模块使用的同时，更多的是想向大家传递一个思想就是内置模块基本都很易上手，并且就算一时之间不太明白，可以多看看官方文档。从官方文档上学习是一个很好的习惯。我们可以从官方<ahref="https://docs.python.org/zh-cn/3/py-modindex.html">Python模块索引</a>中去找到自己需要的模块。</p><p>好了，那这节课就先到这里了，下一节课中，我们利用日历和时间模块来做一个练习：万年历。大家要提前做预习，去官方文档好好学习一下其相关模块，包括<code>calendar</code>、<code>datetime</code>、<code>time</code>等.</p><p>那小伙伴们，让我们下节课练习再见吧。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/System-built-in-modules/cover.png&quot; class=&quot;&quot; title=&quot;封面&quot;&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>14. 练习：登录注册系统</title>
    <link href="https://hivan.me/Exercise-register-system/"/>
    <id>https://hivan.me/Exercise-register-system/</id>
    <published>2023-08-10T03:54:59.000Z</published>
    <updated>2023-08-10T11:06:03.178Z</updated>
    
    <content type="html"><![CDATA[<img src="/Exercise-register-system/cover.png" class="" title="封面"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>上一节课，我们详细的介绍了文件读写的流程和原理，并用Python进行实际操作了一下。</p><p>那么这节课呢，我们利用之前所学的内容，尝试做一个小练习：建立一个登录注册系统。上节课我们在结尾的时候讲练习内容贴了出来，还记得要求吗？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">实现功能：<br><span class="hljs-bullet">1.</span> 用户输入用户名和密码以及确认密码<br><span class="hljs-bullet">2.</span> 用户名不能重复<br><span class="hljs-bullet">3.</span> 两次密码要一致<br><span class="hljs-bullet">4.</span> 用户用已经注册的账户登录<br><span class="hljs-bullet">5.</span> 密码如果错误3次，锁定，无法再登录。<br></code></pre></td></tr></table></figure><p>那么这节课呢，因为都是一些讲过的知识点，所以在整个实现过程中我就不详细讲解了，我们重点在于介绍思想和流程。那让我们开始吧。</p><h2 id="注册功能">注册功能</h2><p>我们先把大的结构写出来，一个注册功能，那首先需要接收两个参数：用户名、密码。</p><p>并且，为了防止用户注册时候输错密码导致无法登录，还需要让用户确认一遍密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br><br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 用户输入密码</span><br>    password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br><br>    <span class="hljs-comment"># 请确认您的密码</span><br>    re_password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请再输入一次您的密码: &#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(username, password, re_password)<br><br><br>register()<br><br>---<br>du <span class="hljs-number">111111</span> <span class="hljs-number">111111</span><br></code></pre></td></tr></table></figure><p>下一步我们来细化这个框架，我们把用户名先放在一边，来挑一挑密码的刺：</p><p>首先，我们需要让密码保持安全性，那么我们对位数，组合就要有要求。这里我们简单点，必须输入6位以上吧。</p><p>然后，在确认密码的时候，肯定两次密码要一致才行。</p><p>OK，让我们补全这几个逻辑关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br><br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>    <br>    <span class="hljs-comment"># 用户输入密码</span><br>    password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br>    <br>    <span class="hljs-comment"># 检测密码长度不能低于6位</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>        <span class="hljs-comment"># 请确认您的密码</span><br>        re_password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请再输入一次您的密码: &#x27;</span>)<br>        <span class="hljs-comment"># 检测密码和确认密码是否一致</span><br>        <span class="hljs-keyword">if</span> re_password == password:<br>            <span class="hljs-comment"># 用户名和密码都正确，可以写入文件</span><br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;两次输入的密码不同，请重新输入。&#x27;</span>, username, password, re_password)<br><br>    <span class="hljs-comment"># 密码长度不够</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;密码格式不正确：&#x27;</span>, username, password)<br><br>register()<br><br>---<br>两次输入的密码不同，请重新输入。 du <span class="hljs-number">123456</span> <span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p>可以看得出来，我确认密码的时候输入了其他密码，判断逻辑没有问题。</p><p>继续来细化，现在的问题是，当我们输入第一次密码的时候判断有问题，或者两次密码输入不一致的时候，我们没有办法跳到一开始让用户重新输入，那么下面我们就来解决这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br><br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>    <br>    <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 用户输入密码</span><br>        password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检测密码长度不能低于6位</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>            <span class="hljs-comment"># 请确认您的密码</span><br>            re_password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请再输入一次您的密码: &#x27;</span>)<br>            <span class="hljs-comment"># 检测密码和确认密码是否一致</span><br>            <span class="hljs-keyword">if</span> re_password == password:<br>                <span class="hljs-comment"># 用户名和密码都正确，可以写入文件</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;恭喜你，注册成功&#x27;</span>, username, password, re_password)<br>                <span class="hljs-comment"># 结束循环</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;两次输入的密码不同，请重新输入。&#x27;</span>, username, password, re_password)<br><br>        <span class="hljs-comment"># 密码长度不够</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;密码格式不正确：&#x27;</span>, username, password)<br><br>register()<br><br>---<br>密码格式不正确： du <span class="hljs-number">12345</span><br>两次输入的密码不同，请重新输入。 du <span class="hljs-number">123456</span> <span class="hljs-number">1234567</span><br>恭喜你，注册成功 du <span class="hljs-number">123456</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>外面套一层<code>while</code>循环，这样就解决了。</p><p>只有当密码正确输入的时候，循环才会结束，否则就会跳到循环的最开始，重新进行输入。</p><p>接着，我们就来看看当输入正确之后，我们如何写入文件呢？这个是我们上一节课刚讲解的课程，现在让我们来实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>...<br>            <span class="hljs-keyword">if</span> re_password == password:<br>                <span class="hljs-comment"># 用户名和密码都正确，可以写入文件</span><br>                <span class="hljs-comment"># 打开文件，写入数据</span><br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>                    fp.write(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>:<span class="hljs-subst">&#123;password&#125;</span>\n&#x27;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;注册成功，用户名:<span class="hljs-subst">&#123;username&#125;</span>&#x27;</span>)<br>                <span class="hljs-comment"># 结束循环</span><br>                <span class="hljs-keyword">break</span><br>...<br>register()<br><br>---<br>注册成功，用户名:du<br></code></pre></td></tr></table></figure><p>这样，我们就将用户名和密码以<code>username:password</code>的格式以一行的形式存储到了一个<code>user.txt</code>文件内。并且，因为我们使用的<code>a+</code>的模式，所以每次打开指针都会是放在文件的末尾进行添加。</p><p>来，让我们看看是否成功了：</p><img src="/Exercise-register-system/image-20230810145145278.png" class="" title="user.txt"><p>可以看到，没问题。这样，我们在之后读取的时候就可以直接读取单行，并且以<code>key:value</code>的形式拿到我们说要的用户名和密码。用于验证<code>key</code>是否存在，<code>value</code>是否正确。</p><p>说到验证<code>key</code>是否存在，似乎我们还没写这一段验证代码，既然文件里已经有数据了，让我们把这段代码补全吧,我们在<code>register()</code>这个自定义函数外面写一段读取文件的代码，写在外面是因为，我们读取文件这个动作，和整个注册动作不能说毫无关系，只能说是没有关联。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.readlines()<br>    <span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;admin:123456\n&#x27;</span>, <span class="hljs-string">&#x27;du:654321\n&#x27;</span>]<br></code></pre></td></tr></table></figure><p>还记得吗？<code>readlines()</code>这个函数的应用，不记得的，看我教程的上一节内容复习下。</p><p>看似我们确实成功的读取到了全部内容，可是我们细想一下，这样想有没有问题？还记得我们上一节课上对<code>r</code>这个模式的说明吗？<code>r</code>是读取已有文件，但是如果文件不存在，那就会报错。</p><p>可是我们在整个程序运行过程中，不能因为这个原因就不让用户继续往下走了对吧？那么我们怎么去修改呢？来，我们一起尝试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    res = fp.readlines()<br>    <span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;admin:123456\n&#x27;</span>, <span class="hljs-string">&#x27;du:654321\n&#x27;</span>]    <br></code></pre></td></tr></table></figure><p>我们利用<code>a+</code>的特性，如果文件不存在则会创建，如果有，这将指针放在文件末尾。这样的话，这一段内容就没有问题了？为什么不用<code>w+</code>?还不是因为<code>w+</code>太霸道，虽然新人胜旧人，但也不能就直接把旧人干掉吧。</p><p>但是<code>a+</code>是将指针放在文件末尾的，我们直接使用的话，什么内容也读不到，所以我们使用可<code>seek(0,0)</code>来将指针放在了文件头的位置。</p><p>好了，继续。我们只将文件读取出来没用，需要将其中的数据放在一个变量里供我们检测，所以下一步，我们就需要创建一个变量，并且接收文件中的所有数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><br><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>userlist = []<br>pwdlist = []<br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>    res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>        r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>        mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>) <span class="hljs-comment"># 分隔用户名和密码</span><br>        userlist.append(mydict[<span class="hljs-number">0</span>])<br>        pwdlist.append(mydict[<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(userlist, pwdlist)<br>    <br>---<br>[<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>] [<span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;654321&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们拿到用户名和密码，并且分别放入了两个<code>list</code>变量中。</p><p>接下来，我们对于注册那一步就需要进行判断了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    ...<br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br><br>    <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>    <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 用户输入密码</span><br>            password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br>        ...<br><br><span class="hljs-comment"># register()</span><br></code></pre></td></tr></table></figure><p>在代码中，我们判断用户名是否存在于列表中，如果存在，打印已经存在，如果不存在，则继续往下执行。将之前输入密码的<code>while</code>循环放入了<code>else</code>判断逻辑中。</p><p>看似问题解决了，不过新的问题又来了。虽然我们现在判断了用户是否存在，并且用户不存在的话可以继续往下执行，可是如果存在呢？我们需要的是让用户重新输入用户名，但是现在是打印完之后就结束了。所以，我们还得继续修改代码，这回简单了，和<code>password</code>的处理用一样的方法就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 执行循环， 用户名操作</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 用户输入用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br><br>        <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>               ...<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>                    ...<br>                    <span class="hljs-keyword">if</span> re_password == password:<br>                        ...<br>                        <span class="hljs-comment"># 结束循环</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                      ...<br><span class="hljs-comment"># register()</span><br></code></pre></td></tr></table></figure><p>我们将<code>register()</code>内的所有判断代码放入了一个循环中，那么在<code>if</code>之后，没有向下执行<code>else</code>内的逻辑的时候，就会跳转到最开始的<code>while</code>循环重新执行。</p><p>不过这样似乎还是不行，那就是几遍<code>else</code>逻辑全部执行完毕，内部的<code>break</code>也是跳出里面那层<code>while</code>循环，外层循环只能无限的执行下去了。</p><p>我们目前所要做的，就是在所有的代码顺利执行到<strong>密码正确确认</strong>的时候，整个函数执行就全部终止了。那有什么办法吗？</p><p>我们看到了<code>while True</code>，然后开启了无限循环。那是不是说，如果<code>True</code>那里不为真，就无法进入循环了？</p><p>嗯，既然这样，我们设定一个变量，在需要终止函数的时候，设定变量为<code>Flase</code>就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 定义一个变量，用于控制外循环</span><br>    site = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 执行循环， 用户名操作</span><br>    <span class="hljs-keyword">while</span> site:<br>        ...<br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>                    ...<br>                    <span class="hljs-keyword">if</span> re_password == password:<br>                        ...<br>                        <span class="hljs-comment"># 结束循环</span><br>                        <span class="hljs-comment"># 结束外循环</span><br>                        site = <span class="hljs-literal">False</span><br>                        <span class="hljs-comment"># 结束内循环</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                        ...<br><br><span class="hljs-comment"># register()</span><br><br></code></pre></td></tr></table></figure><p>这样，在密码确认成功之后，<code>site</code>设定为<code>false</code>，<code>while</code>循环判断条件为假，无法再次进入循环。执行代码，输出<code>注册成功：用户名:du2</code>，并且跳出了循环不再继续向下执行。说明我们这一步已经没问题了。</p><p>那到这里，我们一个简易的可运行的注册方法就完成了，当然，这段代码中其实还有很多可以完善的空间，比如说，判断用户名是否存在之后，还要判断用户名是否合法，密码是否合法等等。还有就是我们一般接收账户密码的变量应该使用<code>key:value</code>形式的字典，不过大多数时候，我们还要考虑效率问题。分别保存成两份是不错的选择，那么这个时候，我们就需要用到获取当前字典中所有<code>key</code>值的方法了。以上代码在关键部位可以这样改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>userdict = &#123;&#125;<br>userlist = []<br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>    res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>        r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>        mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>        userdict.update(&#123;mydict[<span class="hljs-number">0</span>]:mydict[<span class="hljs-number">1</span>]&#125;)<br>        userlist = userdict.keys()<br>        <br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 定义一个变量，用于控制外循环</span><br>    site = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 执行循环， 用户名操作</span><br>    <span class="hljs-keyword">while</span> site:<br>        <span class="hljs-comment"># 用户输入用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br><br>        <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            ...<br>register()<br></code></pre></td></tr></table></figure><p>总之，代码的实现是需要一步一步细细琢磨的，而且实现的方式也不是只有一种。要考虑逻辑，效率等等因素。文章最后会给到我的源码文件，现在大家先一步步的跟着我往下走吧。</p><h2 id="登录功能">登录功能</h2><p>在实现登录功能之前，我们来分析一下这个功能要做的事情：</p><ol type="1"><li>需要使用已经注册的用户信息登录</li><li>密码输入错误3次之后，锁定账户信息（不能再使用这个账户进行登录操作）</li></ol><p>这是两个最基本的功能，既然要核对用户信息和密码，那和注册一样，我们还是需要读取<code>user.txt</code>文件，拿到里面的信息后传给相应的变量，用于检测。那好，我们先把注册那边实现的部分功能拿过来，就无需自己再写一遍了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搞定登录功能</span><br><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>userdict = &#123;&#125;<br>userlist = []<br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>    res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>        r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>        mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>        userdict.update(&#123;mydict[<span class="hljs-number">0</span>]:mydict[<span class="hljs-number">1</span>]&#125;)<br>        userlist = userdict.keys()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;userdict:<span class="hljs-subst">&#123;userdict&#125;</span>,\nuserlist:<span class="hljs-subst">&#123;userlist&#125;</span>&#x27;</span>)<br><br>---<br>userdict:&#123;<span class="hljs-string">&#x27;admin&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>: <span class="hljs-string">&#x27;654321&#x27;</span>, <span class="hljs-string">&#x27;du2&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;zhang&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;wang&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>&#125;,<br>userlist:dict_keys([<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>, <span class="hljs-string">&#x27;du2&#x27;</span>, <span class="hljs-string">&#x27;zhang&#x27;</span>, <span class="hljs-string">&#x27;wang&#x27;</span>]),<br></code></pre></td></tr></table></figure><p>执行过后可以看到，三个变量已经分别存储了一个字典和两个列表，也就是字典存储了健值对的用户密码，以及将用户和密码再分别存储到两个列表内。</p><p>数据准备好了，接下来，我们开始定义函数吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br><br>    <span class="hljs-comment"># 获取用户登录时输入的用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎登录，请输入您的用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 检测当前用户名是否存在</span><br>    <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>        <span class="hljs-comment"># 让用户输入密码</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 用户名不存在</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户名错误，亲重新输入&#x27;</span>)<br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br></code></pre></td></tr></table></figure><p>那么大的框架就定义好了。现在让我们逐步开始细化这些代码。</p><p>先不看让用户继续输入密码的逻辑，我们先来看看用户名不存在的逻辑该怎么做。</p><p>当用户名不存在的时候，我们肯定是先要告知提示用户，接下来应该是让用户重新输入一次用户名。那怎么做呢？之前实现注册那边实际上已经有经验了，用<code>while</code>循环呗，接下来，让我们完善一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-comment"># 自定义变量, 控制登录外循环</span><br>    isLogin = <span class="hljs-literal">True</span> <br>    <br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br><br>        <span class="hljs-comment"># 获取用户登录时输入的用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎登录，请输入您的用户名：&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检测当前用户名是否存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 让用户输入密码</span><br>                pwd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码：&#x27;</span>)<br>                <span class="hljs-comment"># 检测用户输入的密码是否正确</span><br>                <span class="hljs-keyword">if</span> pwd == userdict[username]:<br>                    <span class="hljs-built_in">print</span>(pwd)<br>                    isLogin = <span class="hljs-literal">False</span> <span class="hljs-comment"># 结束外循环</span><br>                    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 结束内循环</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您的密码输入有误。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 用户名不存在</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户名错误，亲重新输入&#x27;</span>)<br><br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br><br>login()<br></code></pre></td></tr></table></figure><p>在细化的代码中，我们用了和注册函数一样的方法，创建了一个外循环和一个内循环。原因就是我们分别需要判断用户名和密码，都需要返回来重新输入。</p><p>之前注册的循环已经讲的比较详细了，所以这里我们就不细致的讲解了，小伙伴们自己好好琢磨一下逻辑关系。</p><p>那到这里，我们还缺什么呢？看看需求，我们似乎还需要判断用户输入密码错误的次数对吧？</p><p>好的，让我们继续，从定义变量开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <br>    ...<br>    <span class="hljs-comment"># 定义变量，用来记录用户输入密码错误次数</span><br>    errorNum = <span class="hljs-number">3</span><br><br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br>        ...<br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>                <span class="hljs-keyword">if</span> pwd == userdict[username]:<br>                    ...<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 密码错误，修改变量次数</span><br>                    errorNum -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 判断当前密码错误次数</span><br>                    <span class="hljs-keyword">if</span> errorNum == <span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;给你机会你不中用啊细狗。账户已锁定，请联系管理人员并上供品。&#x27;</span>)<br>                        isLogin = <span class="hljs-literal">False</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;您的密码输入有误, 您还能再尝试<span class="hljs-subst">&#123;errorNum&#125;</span>次。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            ...<br><br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br><br>login()<br></code></pre></td></tr></table></figure><p>我们定义了一个<code>errorNum</code>的变量，因为我们只能尝试最多三次，所以我们给这个变量设定了一个3的值。</p><p>在之后的循环中，没尝试错误一次，我们就让这个变量<code>-1</code>操作，直到变为0为止。</p><p>然后，就是我们需要定义一个黑名单把用户名写入了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    ...<br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>                <span class="hljs-keyword">if</span> pwd == userdict[username]:<br>                    ...<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 密码错误，修改变量次数</span><br>                    errorNum -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 判断当前密码错误次数</span><br>                    <span class="hljs-keyword">if</span> errorNum == <span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;给你机会你不中用啊细狗。账户已锁定，请联系管理人员并上供品。&#x27;</span>)<br>                        <span class="hljs-comment"># 锁定当前账户，把锁定的用户拉入黑名单</span><br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>                            fp.write(username+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                        isLogin = <span class="hljs-literal">False</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;您的密码输入有误, 您还能再尝试<span class="hljs-subst">&#123;errorNum&#125;</span>次。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            ...<br><br>login()<br><br>---<br>您的密码输入有误, 您还能再尝试<span class="hljs-number">2</span>次<br>您的密码输入有误, 您还能再尝试<span class="hljs-number">1</span>次<br>给你机会你不中用啊细狗。账户已锁定，请联系管理人员并上供品。<br></code></pre></td></tr></table></figure><p>这样，当我们的账户被输入错误三次之后，就会得到神的审判：关入小黑屋了。需要上供才行。（谁家这么设计产品，估计死的会很快吧？）</p><p>好了，继续往后，我们只写入了黑名单还不行，这样在执行的时候，还是无法判断用户是否输入的是锁定的账户。接下来需要做的事情，就是读取这个黑名单的文件，然后把里面的用户名全部以列表形式传到这个变量中。</p><p>再然后，我们只要在用户输入用户名的时候判断此用户是否被关小黑屋了就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搞定登录功能</span><br><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>...<br>blackUserList = [] <span class="hljs-comment"># 定义一个小黑屋专用变量</span><br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>  ...<br><br><span class="hljs-comment"># 读取所有黑名单用户</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    res = fp.readlines()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>        r = i.strip() <span class="hljs-comment">#</span><br>        blackUserList.append(r)<br><br><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    ...<br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br><br>        <span class="hljs-comment"># 获取用户登录时输入的用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎登录，请输入您的用户名：&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检测当前用户名是否存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> blackUserList:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您的账户已经被锁定，并且还未给管理员上供品。&#x27;</span>)<br>            isLogin = <span class="hljs-literal">False</span> <span class="hljs-comment"># 结束外循环</span><br>        <span class="hljs-keyword">elif</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 用户名不存在</span><br>            ...<br><br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br><br>login()<br></code></pre></td></tr></table></figure><h2 id="功能合并">功能合并</h2><p>现在，我们把注册和登录功能都分别完成了，那么我们现在就剩下最后一步，将两个功能合并在一起。</p><p>注册和登录的函数是现成的，那么现在我们要做的事情就是：</p><ol type="1"><li>将读取数据的两个<code>with</code>方法封装到一个函数内</li><li>定义一个主函数，进入进程后就执行</li><li>告知用户选择登录还是注册</li><li>在执行登录注册函数之前，初始化数据（加载读取数据的函数）</li></ol><p>OK，让我们来实现吧：</p><p>首先是封装读取数据的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个读取所有用户数据的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readAllUsers</span>():<br>    <span class="hljs-comment"># 读取所有的注册信息</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>        <span class="hljs-keyword">global</span> userdict<br>        <span class="hljs-keyword">global</span> userlist<br>        fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>        res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>            r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>            mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>            userdict.update(&#123;mydict[<span class="hljs-number">0</span>]:mydict[<span class="hljs-number">1</span>]&#125;)<br>            userlist = userdict.keys()<br><br>    <span class="hljs-comment"># 读取所有黑名单用户</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        <span class="hljs-keyword">global</span> blackUserList<br>        fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        res = fp.readlines()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>            r = i.strip() <span class="hljs-comment">#</span><br>            blackUserList.append(r)<br></code></pre></td></tr></table></figure><p>注意我们这里用了<code>global</code>,因为我们需要使用外部定义的变量，所以必须要讲变量改成全局变量，改动才会有效。</p><p>注册登录函数不用改动，直接原封不动的粘贴过来就可以了。再来我们就需要直接进入主进程进行选择：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断当前脚本是否作为一个主进程脚本在执行</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    这里的代码，只有在使用Python解释器直接运行时才会执行</span><br><span class="hljs-string">    如果当前脚本作为了模块被其他文件导入后使用，那么这个地方的代码不会执行</span><br><span class="hljs-string">    因此这个地方的代码，适合写当前脚本中的一些测试，这样不会影响其他脚本</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 调用初始化方法，加载数据</span><br>    readAllUsers()<br>    <br>    isBegin = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> isBegin:<br>        myStr = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        ======================</span><br><span class="hljs-string">        ** 登录（0） 注册（1）**</span><br><span class="hljs-string">        ======================</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(myStr)<br><br>        <span class="hljs-comment"># 让用户选择对应的操作</span><br>        num = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入对应的序号，体验功能：&#x27;</span>)<br>        <span class="hljs-keyword">if</span> num == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            login()<br>            isBegin = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">elif</span> num == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            register()<br>            isBegin = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;后续功能还在开发中。&#x27;</span>)<br>            isBegin = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>这样当我们输入<code>python3 file.py</code>的时候，就会直接进入这个主程序内。然后执行加载数据的函数，打印用户选择内容，然后等待用户选择并执行后续操作，如图：</p><img src="/Exercise-register-system/image-20230810185215413.png" class="" title="执行截图"><p>而这其中我们设定一个变量<code>isBegin</code>来控制循环，每次执行完一次函数就会结束循环，然后需要重新执行。主要原因就是因为加载数据的方法我们写在了<code>while</code>循环外面，所以当我们注册之后再去登录，新创建的用户并不在用户列表内，无法完成登录。所以干脆结束掉之后重新加载数据，就可以执行登录了。</p><p>能不能改善呢？可以。只是今天的课程目的已经完毕了，所以当作留给大家的练习题吧。如何优化整个程序让其更合理高效，大家试试看。然后记得在评论区给我留言。</p><p>好了，这节课到这里就结束了，相关代码可以在我的仓库里去找到。</p><p>下一节课中，我们会讲解模块，系统的内置模块。我们下次见。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Exercise-register-system/cover.png&quot; class=&quot;&quot; title=&quot;封面&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>13. Python的文件操作</title>
    <link href="https://hivan.me/file-operations/"/>
    <id>https://hivan.me/file-operations/</id>
    <published>2023-08-08T13:26:16.000Z</published>
    <updated>2023-08-10T10:58:02.282Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230809125900.png?imgNote"alt="茶桁的AI秘籍" /></p><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>在之前的几节课程中，我们学习了Python的数据类型。和市面上大多数的Python教程不同的是，我先为大家介绍完函数之后才开始介绍数据类型，其中原因就是很多数据类型的方法及理解都需要先搞懂函数的基本语法。</p><p>在结束了Python数据类型学习之后，我们今天开始进入一个新的篇章。今天，让我们来详细了解一下在Python中如何去进行文件操作。</p><p>我们大家都使用过智能手机，电脑，iPad等电子产品。那我们肯定有打开文件的经验，比如说打开一个Word、Excel文档。最基础的操作实际上就两步，分别是1.打开文件， 2. 关闭文件。</p><p>我们要理解的一点是，文件都是放在存储设备中的，这才是我们能打开它的基础。那我们在存储设备中对文件进行打开之后进行的读写操作，实际上就是文件<code>I/O</code>。</p><p>什么是<code>I/O</code>?<code>I</code>代表<code>Input</code>(输入)，<code>O</code>代表<code>Output</code>（输出）。当你打开一个文件的时候，就算你没有对文件进行更改，也依然已经有了<code>I/O</code>操作，毕竟文件只有读取之后，才能显示到你的屏幕上。</p><p>那么文件读写到底分了几步呢？让我们引用一下宋丹丹的经典小品中的一段：</p><blockquote><p>问，把大象装进冰箱分几步？</p></blockquote><p>我们就不在这里进行分步讨论了，因为流程步骤实际上是一模一样的：</p><ol type="1"><li>打开文件<code>open()</code> ： 打开冰箱。</li><li>读取文件<code>read()</code>/ 写入内容<code>write()</code>：把大象装进冰箱。</li><li>关闭文件<code>close()</code>： 关闭冰箱。</li></ol><p>可以说，你在你的设备上做的任何操作都逃不开这几步，区别无非就是你有没有写入内容，从哪里打开的，读取的文件是什么类型的。</p><p>那么复杂一点的，就是当你打开一个App的时候，这个App执行某项操作的时候去互联网上的服务器找相应的文件然后到本地之后打开，读取。我们不讨论在打开文件之前的一系列例如下载（这个下载动作有时是主动的，有时是被动的）操作，就只说到本地之后读取文件并展示，就一定包含这三步。</p><p>理解到这，可以了。我们接着正式来学习Python如何对文件进行操作。</p><h2 id="文件操作">文件操作</h2><h3 id="open"><code>open()</code></h3><p><code>open</code>函数就是用于最初的打开文件的动作，其基本格式为：<code>open(文件路径, 打开方式, [字符集])</code>，完整的格式为：<code>open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)</code></p><p>在大部分时候，我们使用基本格式就足够了。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&#x27;&#x27;&#x27;<br>打开文件 open()<br><span class="hljs-code">    参数1: 文件路径</span><br><span class="hljs-code">    参数2: 打开的方式</span><br><span class="hljs-code">    参数3: 字符集</span><br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><p>路径，也就是<code>url</code>是一种统一资源定位符。其中包括<strong>相对路径</strong>和<strong>绝对路径</strong>。</p><p><strong>相对路径</strong>，比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走100米左右就到了。</p><p><strong>绝对路径</strong>，这个就非常好理解了，北京市西城区鼓楼东大街28号，特别准确了对吧？</p><p>这两个路径的描述呢，其实指向的是一个地方。只是一个是针对人所在的位置来告知你怎么走，另外一个是从最上层给到你一个绝对的地址。而电脑里的相对路径和绝对路径也基本就是这么个意思。</p><p><strong>我们来看相对路径</strong>，主要是使用<code>./</code>和<code>../</code>来进行描述，这两个都有一个共同点，就是以当前文件为准。也就是当前文件向我们问路，我们站在当前文件的地方告诉它该怎么走去到达自己的目的地。</p><p>举例,假设我们现在正在编辑<code>index.py</code>这个文件，也就是说，向我们问路的文件是<code>index.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">- project<br>| - index.py<br>|- test.txt<br>  | img<br>    |- person.jpg <br>    | - dog.jpg<br>    | - cat.jpg<br>- data<br>| - person.csv<br></code></pre></td></tr></table></figure><p>这样一个路径关系中：</p><ol type="1"><li>当我们需要去访问<code>person.jpg</code>并打开的话，那就是<code>index.py</code>同目录下的<code>img</code>目录里面去寻找<code>person.jpg</code>，那我们相对路径的写法为<code>./img/person.jpg</code>。</li><li>当我们要去找<code>person.csv</code>的时候，由于这个csv是存在于上一层目录的同级目录<code>data</code>内，那我们需要向上去寻找，就是<code>../data/person.csv</code>。</li></ol><p>这就是<code>./</code>和<code>../</code>的区别，一个是当前目录同级内去寻找，一个是向上一级的目录内去寻找。那如果文件存储于上两层目录中呢？那就向上翻两层呗：<code>../../</code>这样，多层的时候，依次类推。</p><p>相对路径介绍完了，<strong>我们来看看绝对路径</strong>。</p><p>绝对路径的前提是必须找到根目录。在<code>windows</code>中我们其实都熟悉一个东西就是盘符。比如说<code>C:\</code>，不严谨的说，盘符就算是绝对路径的根目录了。那为什么说不严谨的说呢？因为我们输入文件路径的时候可以输入：<code>C:\data\person.csv</code>这样去寻找。但是，盘符之上其实是整个硬盘，我们只是将硬盘虚拟成了不同的盘符用于划分空间而已。</p><p>在<code>Mac</code>或者<code>Linux</code>中，就是以整个硬盘为准去寻找文件的。比如说<code>/Users/xx/Downloads</code>，就是我们的下载目录。</p><p>那我们如果想要打开文件，这两种方式其实都可以，一般来说，为了代码能够适应环境变化，我们都会选择使用相对路径。</p><p>说完文件路径，让我们来说说打开方式，我先介绍一个模式，后面咱们再慢慢讲：</p><p><strong><code>w</code>模式： write， 写入</strong></p><p>如果文件不存在，创建这个文件；如果文件存在，则打开这个文件，并且清空文件内容。文件打开后，文件的指针在文件的最前面。什么是指针呢？可以这么理解，当我们打开一个word文档的时候，我们的光标是不是都在这个文档的最上面？这个光标的位置，就是指针的位置。</p><h3 id="write"><code>write()</code></h3><p><code>write()</code>是用于对文件写入内容来使用的，格式为:<code>文件对象.write(内容)</code></p><h3 id="close"><code>close()</code></h3><p>格式为: <code>文件对象.close()</code> , 可以关闭打开的文件。</p><p>我们需要注意一点，我们在对文件进行操作的时候，一定记得操作完要关闭它。否则，这个文件就会一直存在于内存地址中。</p><p>下面，让我们看看在Python中如何打开操作一个文件的。</p><blockquote><p>以下所有的操作演示都会在../Python/13.ipynb中进行编写，所以我们的操作路径都会以这个文件为准。</p></blockquote><p>让我们现在当前文件的中创建一个文件夹<code>data</code>，然后在其中放入一个文件<code>13-1.txt</code>，我们说要做的事情，就是打开这个文件，然后将我们之前写的内容复制一部分写入到这个<code>txt</code>文件中去，路径关系如下图：</p><img src="/file-operations/image-20230809191156847.png" class="" title="13-1.txt url"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开13-1 并且写入内容</span><br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-built_in">print</span>(fp, <span class="hljs-built_in">type</span>(fp))<br>fp.write(<span class="hljs-string">&#x27;相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走100米左右就到了。\n 绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街28号，特别准确了对吧？&#x27;</span>)<br>fp.close()<br><br>---<br>&lt;_io.TextIOWrapper name=<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span> mode=<span class="hljs-string">&#x27;w&#x27;</span> encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_io.TextIOWrapper&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>打印区打印的内容，实际上是我们<code>print</code>函数执行的结果，可以看到，我们打印<code>fp</code>这个变量的时候，显示的是<code>&lt;_io.TextIOWrapper name='./data/13-1.txt' mode='w' encoding='UTF-8'&gt;</code>,其类型是<code>&lt;class '_io.TextIOWrapper'&gt;</code>。</p><p>这些先放在一边，让我们看看文件到底写入没有：</p><img src="/file-operations/image-20230809193049499.png" class="" title="13-1.txt内容"><p>写入是写入了，可是这是什么鬼？</p><p>啊，差点忘了，整个<code>open()</code>方法内后面还有一个参数<code>encoding=</code>，这个参数是告诉我们这个文件以什么字符集去打开。默认的就是<code>UTF-8</code>，显然，我们保存的这个文件并不是，所以最终导致了乱码。</p><p>让我们修改一下代码，在<code>open()</code>内添加一下<code>encoding</code>，其他不变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>)<br>...<br><br>---<br>&lt;_io.TextIOWrapper name=<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span> mode=<span class="hljs-string">&#x27;w&#x27;</span> encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_io.TextIOWrapper&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，打印出来的<code>fp</code>最后的<code>encoding</code>值已经发生了变化。让我们再去看看文件如何了：</p><img src="/file-operations/image-20230809193522741.png" class="" title="13-1.txt"><p>果然没问题，内容能够正确显示而不会乱码了，我们注意到下方文件字符集确实为<code>GBK</code>。</p><blockquote><p>关于<code>字符集编码</code>的问题这里有疑问的，自己回过头再去把我之前讲的课程好好翻腾一下，复习一下。</p></blockquote><p>整段代码中，我们引用了刚才介绍的三个文件操作的函数：<code>open()</code>, <code>write()</code>, <code>close()</code>。</p><p>在简单了解了文件的操作步骤之后，我们接下来再继续看文件操作中另外一个比较重要的函数:<code>read()</code>。</p><h3 id="read"><code>read()</code></h3><p>在对文件进行操作的时候，一定要记得流程一定是打开<code>open</code>在最前面，<code>close</code>关闭在最后面。至于中间你是要读取，写入还是别的什么操作，那都不违反文件操作的整个流程。</p><p>所以在下面一段代码里，我们可以尝试把之前的<code>write()</code>替换为<code>read()</code>，顺便可以学一下如何在代码中看看我们刚修改过的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>)<br>res = fp.read()<br>fp.close()<br><br><span class="hljs-built_in">print</span>(res)<br><br>---<br>相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走<span class="hljs-number">100</span>米左右就到了。<br>绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街<span class="hljs-number">28</span>号，特别准确了对吧？<br></code></pre></td></tr></table></figure><p>可以看到，我们讲刚才写入的内容在打印区完整的打印了出来。</p><p>不知道小伙伴们有没有注意到，在使用<code>open()</code>函数的时候，其中的第二个参数「打开方式」这次发生了变化，改成了<code>‘r’</code>，这中打开模式就是专门用于读取文件的，它在打开文件的时候，不会想<code>‘w’</code>的打开方式一样清空文件。</p><p>比如，我们讲之前的代码中换一下打开方式来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>)<br>res = fp.read()<br>fp.close()<br><br><span class="hljs-built_in">print</span>(res)<br><br>---<br>UnsupportedOperation: <span class="hljs-keyword">not</span> readable<br></code></pre></td></tr></table></figure><p>报错了，提示不可读。</p><p>我们再去直接打开<code>13-1.txt</code>的时候可以看到。文件内空空如也，之前写入的内容全都被清空了。</p><p>到这里为止，大家了解了文件操作的四个基本操作函数，在这里我可以教大家一个文件操作中的一些高级技巧，比如，我们可以使用<code>with...as...</code>来进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">with open(文件路径, 打开模式) as 变量:</span><br><span class="hljs-string">变量.操作()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>让我们直接来看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br>相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走<span class="hljs-number">100</span>米左右就到了。<br>绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街<span class="hljs-number">28</span>号，特别准确了对吧？<br></code></pre></td></tr></table></figure><p>这样，我们也就直接完成了之前读取的操作。</p><p><code>read</code>函数内是有参数的：<code>read(count)</code>，接收的值为整型，这里是描述当前我要读取几个字节长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read(<span class="hljs-number">5</span>)<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br>相对路径:<br></code></pre></td></tr></table></figure><p>有的小伙伴看到我写到这可能就有疑问了，我为什么没有写<code>close()</code>函数，那是不是说，现在这个文件都还一直存在内容地址中。</p><p>其实并不是如此。在使用<code>with...as...</code>这个方式去打开一个文件的之后，在整个代码结束的时候会自动对当前打开的文件一遍执行<code>close()</code>函数。</p><p>好，让我接着继续：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    fp.write(res)<br><br>---<br>相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走<span class="hljs-number">100</span>米左右就到了。<br>绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街<span class="hljs-number">28</span>号，特别准确了对吧？<br></code></pre></td></tr></table></figure><p>打印区并未发生变化，原因就是我们的写入操作是在<code>print</code>之后进行的，我们直接打开文件来看看：</p><img src="/file-operations/image-20230809212650123.png" class="" title="写入操作"><p>可以看到，内容确实被写入文件中了。注意我打标记的地方，并没有换行对吧，也就是说，我们在做写入的时候，指针是标记在这个位置的，然后继续往后写入。</p><p>另外整个代码中需要注意的就是打开模式了，我们之前已经用过的打开模式有<code>‘w’和``'r'</code>，现在我们用了<code>‘r+’</code>的模式，那么<code>r+</code>呢就是既可以读，也可以写入。并且，不会一开始就清空文件的内容。</p><p>对应<code>‘w’</code>的清空模式，就是<code>‘w+’</code>,虽然<code>‘w+’</code>也是可读可写的模式，但是它和<code>‘w’</code>的模式一致，打开文件的时候直接清空整个文件的内容。</p><p>除了这四个模式之外，还有<code>'a'</code>和‘<code>'a+’</code>模式，是追加写的模式，这种模式的特点是打开文件的时候，指针是放在文件最末尾的。所以这种模式使用<code>read()</code>的时候，是读不到任何内容的。</p><p>以为到这里就结束了吗？太单纯了，整个文件操作的打开模式中，还有一个<code>‘x+’</code>的模式，这种模式我们可以称它为异或，什么意思呢？就是这种模式只会新建文件来执行后续操作，否则就会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;x+&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.read())<br>    <br>---<br>FileExistsError: [Errno <span class="hljs-number">17</span>] File exists: <span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>提示文件错误：文件存在。</p><p>如果我们操作的是一个本来不存在的文件，才可以正常的往下进行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;x+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    fp.write(<span class="hljs-string">&#x27;这里是&quot;x+&quot;模式下新加入的内容。&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br>这里是<span class="hljs-string">&quot;x+&quot;</span>模式下新加入的内容。<br></code></pre></td></tr></table></figure><p>我们在用<code>‘x+’</code>模式打开一个文件的时候，它已经新建了这个文件，我们可以看到读取之后并未读取到任何内容，因为这个文件内还是空的。在进行写入操作之后，我们在下面再一次读取这个文件，可以看到内容已经被写入了。</p><h3 id="详谈打开模式">详谈「打开模式」</h3><p>其实<code>mode</code>这个参数并不只是我们演示的这么点内容，<code>mode</code>这个参数是接收两种值的，一个是刚才我们一直在讲的<code>读写模式</code>,而另外一个则是<code>文件格式</code>：</p><p><strong>读写模式</strong>：</p><p>读写模式的参数主要有四种， 分别是<code>r</code>,<code>w</code>,<code>a</code>以及一个特殊<code>+</code>，其中<code>r</code>, <code>w</code>,<code>a</code>决定了当前文件默认是只读还是只写，还有就是指针位置。<code>+</code>是和前面三个结合使用的，无法单独使用，其主要作用是使的文件读写兼备。</p><p><strong>文件格式</strong>：</p><p>文件格式主要是以两种格式为准，一种是普通的文本文件，一种是二进制格式文件。不要以为二进制格式没什么大不了，我们一般谈到非文本文件都属于二进制格式文件，比如：图片。</p><p>这两个格式控制字符一个是<code>t</code>:以文本格式打开文件（默认值）， 一个是<code>b</code>:以二进制格式打开文件。</p><p>一般来说，我们大部分时候都不会单独使用某一个参数吗，而是结合着一起使用。比如：</p><p><code>r+</code>，打开一个文件用于读写，文件存在就打开，文件不存在则报错。指针在文件头。这种模式要注意，因为指针在文件头，所以新写入的内容会在原内容之前。</p><p><code>w+</code>,打开一个文件用于读写，文件存在就打开，并且会清空所有内容后进入编辑模式，如果文件不存在则会创建一个新文件。虽然指针也在文件头，但是因为它霸道的清空属性，所以也不存在新写入的内容会在原内容之前了。</p><p><code>a+</code>，以追加的模式打开一个文件用于读写，如果文件存在就打开，如果文件不存在，则会创建一个新文件用于读写。这种模式下和<code>w+</code>不同的地方在于它会将指针放在文件末尾，写入的时候是从文件尾部开始写。并且，它没那么霸道，要清空原内容才可以。</p><p>其他的模式就是在打开文件格式和读写模式的组合，一般我们不写是因为大部分时候我们操作的都是文本文件进行操作，而如果我们需要用二进制格式打开文件的时候，就不能使用默认的<code>t</code>而是<code>b</code>了，一般我们会是这样进行组合：<code>rb</code>,<code>rb+</code>, <code>wb</code>, <code>wb+</code>, <code>ab</code>,<code>ab+</code>。</p><p>当然，最后就是我们刚才用到的<code>x+</code>，其实它也是一种组合形式，原本应该是<code>x</code>,这种模式是在Python3中新添加的，它在文件不存在的时候它会创建一个新文件用于写入。如果这个文件存在，就会报错。</p><p>那么有了<code>x</code>这个参数之后，我们以前为了避免误操作覆盖原文件，那么我们会先去判断一个文件是否存在，然后再去执行后续的写入操作。可是使用<code>x</code>就没那么麻烦了，可以直接操作写入，反正文件如果存在会返回错误。</p><h3 id="关于指针位置">关于指针位置</h3><p>那么我们在使用了<code>r+</code>之后，有没有什么办法可以让我们不在原内容之前写入内容而是从后开始写呢？</p><p>答案是有办法，也就是调整指针位置，调整完毕之后再进行写入操作就可以了。</p><p>调整指针的方法为<code>seek(offset[, whence])</code>。我们来看一个对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个新文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.write(<span class="hljs-string">&#x27;1. Hello Python.\n2. Hello C++. \n3. Hello Ruby.&#x27;</span>)<br><br><span class="hljs-comment"># 正常状态下</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.readline())<br>    <span class="hljs-built_in">print</span>(fp.readline())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------------&#x27;</span>)<br><br><span class="hljs-comment"># 设置指针重新偏移到头部</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.readline())<br>    fp.seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(fp.readline())<br><br>---<br><span class="hljs-number">1.</span> Hello Python.<br><br><span class="hljs-number">2.</span> Hello C++. <br><br>------------<br><span class="hljs-number">1.</span> Hello Python.<br><br><span class="hljs-number">1.</span> Hello Python.<br></code></pre></td></tr></table></figure><p>在最开始，我们重新创建了一个文件，然后写了三行文字。分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> Hello Python.<br><span class="hljs-number">2.</span> Hello C++. <br><span class="hljs-number">3.</span> Hello Ruby.<br></code></pre></td></tr></table></figure><p>然后我们开始用不同的方法进行读取，每次仅读取一行。</p><p>正常状态下，<code>readline()</code>这个方法是顺序往下执行的，第一次执行的时候读取的是第一行，第二次执行的时候就是读取的第二行。这种方式是不是感觉有些熟悉，像不像迭代器？</p><p>回过头来，我们再来看两次执行的结果，不同的是，第二次我在两个<code>readline()</code>方法中间加入了一段<code>fp.seek(0,0)</code>来将指针再次调整到头部，别着急，我们一会讲为什么这样写，先来看看结果。</p><p>因为有了<code>fp.seek(0,0)</code>的存在，第二次执行和第一次完全不同。第一段内容被读取了两次。这就是<code>seek()</code>的作用，讲指针又调整到了文件头部。</p><p>现在，让我们来说说<code>seek()</code>内参数的含义，完整的写法是：<code>seek(offset[, whence])</code>，其中<code>offset</code>是偏移量，而<code>whence</code>是从哪开始。<code>whence</code>就只有三个值，<code>0, 1, 2</code>，0就表示是从头部开始偏移，1就表示从当前位置开始偏移，2就代表从文件末尾开始偏移。而我们写的<code>(0,0)</code>意思就是从文件头部开始偏移，偏移量为0。</p><p>再来看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置指针重新偏移到头部</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    fp.write(<span class="hljs-string">&#x27;这里是使用r+添加到末尾的内容&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.read())<br>    <br>---<br><span class="hljs-number">1.</span> Hello Python.<br><span class="hljs-number">2.</span> Hello C++. <br><span class="hljs-number">3.</span> Hello Ruby.这里是使用r+添加到末尾的内容<br></code></pre></td></tr></table></figure><p>通过前面的学习我们知道，<code>r+</code>在打开文件之后，指针是放在头部的，但是我们这里用<code>seek(0,2)</code>将指针调整到了最末尾，并且写入了一段文字。</p><p>学到这里，文件的基本操作也就差不多学完了，让我们来分别总结一下：</p><h2 id="相关函数">相关函数</h2><ul><li><p><code>open()</code>, 打开文件,格式：<code>open(file_name [, access_mode][, buffering])</code></p></li><li><p><code>read()</code>, 读取内容，格式：<code>fileObject.read([count])</code></p></li></ul><p>不设置<code>count</code>是从当前位置读取到文件末尾，设置<code>count</code>这是读取指定长度的字符。</p><ul><li><code>readline()</code>, 读取一行</li></ul><p>不设置<code>count</code>是从当前位置读取到这一行末尾，设置<code>count</code>这是读取这一行中指定长度的字符。</p><ul><li><code>readlines()</code>, 读取所有行</li></ul><p>不设置参数是表示读取所有汗，每一行作为一个参数，返回了一个列表。设置<code>count</code>是按照行进行读取，可以设置读取的字节数，设置的字节数不足一行按一行来读取。</p><ul><li><code>write()</code>，写入内容,格式：<code>fileObject.write(string)</code></li><li><code>writelines()</code>, 写入容器类型数据：</li></ul><p>写入容器类数据的时候要注意，这个容器类数据必须是可更新的类型。</p><ul><li><code>seek()</code>, 设置文件指针的偏移, 格式:<code>seek(offset[, whence])</code></li><li><code>close()</code>， 关闭文件</li></ul><p>当然，除了这几个之外，文件还有很多其他的函数，但是目前我们用这些进行读写操作就足够了。</p><h2 id="打开模式图">打开模式（图）</h2><p>关于打开模式，我之前写的那些内容看懂理解了，其实也就不需要现在这两张图了，可是我担心的是有些小伙伴理解不了，那有了下面的图，至少操作的时候可以参考：</p><table><colgroup><col style="width: 6%" /><col style="width: 93%" /></colgroup><thead><tr class="header"><th style="text-align: left;">模式</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">t</td><td style="text-align: left;">文本模式 (默认)。</td></tr><tr class="even"><td style="text-align: left;">x</td><tdstyle="text-align: left;">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr class="odd"><td style="text-align: left;">b</td><td style="text-align: left;">二进制模式。</td></tr><tr class="even"><td style="text-align: left;">+</td><td style="text-align: left;">打开一个文件进行更新(可读可写)。</td></tr><tr class="odd"><td style="text-align: left;">U</td><td style="text-align: left;">通用换行模式（不推荐）。</td></tr><tr class="even"><td style="text-align: left;">r</td><tdstyle="text-align: left;">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr class="odd"><td style="text-align: left;">rb</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">r+</td><tdstyle="text-align: left;">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr class="odd"><td style="text-align: left;">rb+</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">w</td><tdstyle="text-align: left;">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr class="odd"><td style="text-align: left;">wb</td><tdstyle="text-align: left;">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">w+</td><tdstyle="text-align: left;">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr class="odd"><td style="text-align: left;">wb+</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">a</td><tdstyle="text-align: left;">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr class="odd"><td style="text-align: left;">ab</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr class="even"><td style="text-align: left;">a+</td><tdstyle="text-align: left;">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr class="odd"><td style="text-align: left;">ab+</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>总结一下最常用的六种模式：</p><table><thead><tr class="header"><th style="text-align: center;">模式</th><th style="text-align: center;">r</th><th style="text-align: center;">r+</th><th style="text-align: center;">w</th><th style="text-align: center;">w+</th><th style="text-align: center;">a</th><th style="text-align: center;">a+</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">读</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;">✓</td></tr><tr class="even"><td style="text-align: center;">写</td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td></tr><tr class="odd"><td style="text-align: center;">创建</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td></tr><tr class="even"><td style="text-align: center;">覆盖</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">指针在开始</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">指针在结尾</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td></tr></tbody></table><p>下面这张经典的流程图可以告诉你在什么时候需要用什么：</p><img src="/file-operations/drawio.png" class="" title="流程图"><h2 id="结尾与预告">结尾与预告</h2><p>文件的基本操作就介绍到这里了，大家下课之后记得要去多多的熟悉和练习。</p><p>那么下一节课呢，我们会根据我们这之前所讲的所有内容，尝试做一个小<code>demo</code>，实现一个简单的注册和登录功能。</p><p>这里先介绍一下这个<code>demo</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">实现功能：<br><span class="hljs-bullet">1.</span> 用户输入用户名和密码以及确认密码<br><span class="hljs-bullet">2.</span> 用户名不能重复<br><span class="hljs-bullet">3.</span> 两次密码要一致<br><span class="hljs-bullet">4.</span> 用户用已经注册的账户登录<br><span class="hljs-bullet">5.</span> 密码如果错误3次，锁定，无法再登录。<br></code></pre></td></tr></table></figure><p>好了，小伙伴们，咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230809125900.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>12. 数据类型 - 集合详解</title>
    <link href="https://hivan.me/Detailed-of-set/"/>
    <id>https://hivan.me/Detailed-of-set/</id>
    <published>2023-08-08T04:59:49.000Z</published>
    <updated>2023-08-10T10:58:12.939Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230808130113.png?imgNote"alt="茶桁的AI秘籍 Python-set" /></p><p>Hi， 大家好。我是茶桁</p><span id="more"></span><p>通过最近几节课的内容，我们已经了解到了大部分的容器类数据的特性和应用，今天这一节课是容器类数据的最后一部分。让我们今天来详细了解一下「集合」。</p><p>集合是<strong>确定的</strong>一组<strong>无序的</strong>数据的组合。注意这一句话中的几个概念：</p><ul><li>首先是「确定的」，当前集合中的元素的值是不能重复的。</li><li>集合是由多个数据组合的容器类型数据</li><li>集合中的数据没有先后顺序</li><li>集合的作用大多数时候是为了从成员检测、从无序列中去除重复项。还有就是数学中的集合类计算，例如交集、并集、差集一集对称差集等等。</li></ul><h2 id="集合的定义">集合的定义</h2><p>集合的定义和字典类数据的定义非常像，包含了三种定义方式：</p><ul><li>可以直接使用<code>&#123;&#125;</code>来定义集合</li><li>可以使用<code>set()</code>进行集合的定义和转换</li><li>使用集合推导式来完成集合的定义</li></ul><blockquote><p>⚠️ 需要注意：集合中的元素不能重复，集合中存放的数据为：Number,String, Tuple，冰冻集合</p></blockquote><h2 id="冰冻集合">冰冻集合</h2><p>在集合的定义部分，其他数据类型我们都能理解，唯独多出来一个<code>冰冻集合</code>似乎没有见过，也难以理解。</p><p>冰冻集合的定义，需要且仅能使用<code>frozenset()</code>函数来进行定义。故名思义，冰冻集合一旦定义之后，是不能进行修改的，只能做一些集合相关的运算，比如交集，差集等等。</p><p>回过头来看冰冻集合的定义函数<code>frozenset()</code>，这个函数本身是一个强制转换类的函数，可以把其他任何容器类型的数据转为冰冻集合，然后参与集合运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个冰冻集合</span><br>mySets = <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-number">666</span>, <span class="hljs-number">333</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;MAMT&#x27;</span>,<span class="hljs-string">&#x27;55IW&#x27;</span>&#125;)<br><br><span class="hljs-comment"># 遍历集合</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mySets:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot;, &quot;</span>)<br><br>---<br><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, 55IW, love, <span class="hljs-number">333</span>, MAMT, <span class="hljs-number">666</span>, a, <br></code></pre></td></tr></table></figure><p>也是可以看到，打印的结果完全没有任何顺序。</p><p>冰冻集合当然也可以使用集合推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">frozenset</span>(&#123;i&lt;&lt;<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)&#125;)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;)<br></code></pre></td></tr></table></figure><p>可以进行拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = res.copy()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;)<br></code></pre></td></tr></table></figure><p>当然冰冻集合也可以进行集合的运算，不过这部分我们将在后面讲解集合的时候来学习。暂时我们只是对「冰冻集合」的概念有个了解就可以了。</p><h2 id="集合的基本操作和常规函数">集合的基本操作和常规函数</h2><p>以往的几节，我们都是将集合的操作和函数分开来讲，而这次我们放在一起讲。其实也没其他原因，就是因为这部分的内容并没有多少，并且很容易理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义集合</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>mySets<br><br>---<br>&#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-number">3.1415</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;love&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>打印的结果再一次验证了集合无序，除此之外，我们可以看到打印出来的集合比我们进行定义的时候似乎少了,这又是为什么呢？</p><p>原来，在集合内布尔类型的数据其实就是0和1， True表示为1，False表示为0，而集合内的值是不能重复的，所以，布尔值和<code>0,1</code>就只能存在一个。</p><p>我们来尝试检测一下集合中的值，和其他容器类数据一样，我们可以直接使用<code>for...in</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检测集合中的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-keyword">in</span> mySets)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> mySets)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>然后一样，可以使用<code>len()</code>检测长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(mySets))<br><br>---<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>遍历的方法依然是用<code>for</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mySets:<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-built_in">type</span>(i))<br>    <br>---<br><span class="hljs-literal">False</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bool&#x27;</span>&gt;<br><span class="hljs-literal">True</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bool&#x27;</span>&gt;<br><span class="hljs-number">3.1415</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br>love &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>abc &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-number">123</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-number">123</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>为什么我这次会将数据类型也打印出来呢？是因为我想让大家好好记住这些类型，目前集合就只支持这些数据类型，其他的并不支持放入。比如说列表，是无法进入集合内的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看看列表是否能放入</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>,[<span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]&#125;<br><br>---<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到报错信息提示，不支持类型：列表。</p><p>那我们如何像集合中追加元素呢？可以使用<code>add()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义集合</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>res = mySets.add(<span class="hljs-string">&#x27;茶桁&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">&#x27;\nres:&#x27;</span>, res)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125; <br>res: <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>可以看到我们在其中追加了一个字符串<code>茶桁</code>,但是我们再一次验证了集合的无序，新加入的字符串并没有和其他数据类型一样新加入的元素放在最末端。</p><p>并且我们注意到了，我用<code>res</code>来接收了<code>add()</code>的返回值，返回了一个<code>None</code>。</p><p>除了追加之外，当然我们也可以对集合进行删除元素的处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySets.pop()<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">&#x27;\nres:&#x27;</span>, res)<br><br>---<br>&#123;<span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125; <br>res: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>用<code>pop()</code>删除集合内的元素是随机的，并且，会将删除的元素返回。</p><p>如果想指定删除集合中的元素有没有办法呢？其实也有，<code>remove()</code>和<code>discard()</code>都可以做到，但是两者又有些区别，我们接着看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用remove()</span><br>res = mySets.remove(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets)<br>res = mySets.remove(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125; <br>res: <span class="hljs-literal">None</span><br>KeyError: <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><p>能看到，<code>remove()</code>确实可以删除集合内的指定元素，并给一个返回值<code>None</code>。不过当集合内没有此元素的时候，就会报错，提示关键词错误。</p><p>那让我们再来看看<code>discard()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用discard</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>res = mySets.discard(<span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br>res = mySets.discard(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>&#125; res:<span class="hljs-literal">None</span><br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>&#125; res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>和<code>remove()</code>一样，也删除了一个指定元素，并且返回了<code>None</code>。不同的是，当我们使用<code>discard</code>删除一个不存在的元素时，<code>discard</code>虽然没有删除任何内容，但是也没有报错。</p><p>一个个删除太麻烦了，这个集合我就想让它变成一个空集合，好办，用<code>clear()</code>做清空处理呗，和字典一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">print</span>(mySets)<br>mySets.clear()<br><span class="hljs-built_in">print</span>(mySets)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125;<br><span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>空集合拿到了，可以放入我们喜欢的元素了。依然和字典一致，我们可以使用<code>update</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySets.update(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br>res = mySets.update(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125; res:<span class="hljs-literal">None</span><br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>结果中显示，我们更新成功了，新添加了一些元素进入集合。那第二次添加，为什么就只有<code>6</code>添加进去了呢？还记得么？集合不能有重复值，就跟字典不能有重复的<code>key</code>一样。在字典中使用<code>update</code>，遇到相同<code>key</code>后面的<code>value</code>会被更新，那其实集合也是一样的，只是因为只有一个值，所以更新完不还是这个值么。</p><p>在冰冻集合的时候我们用到过一次<code>copy</code>，这里我们要单独拿出来说说，因为集合中的元素都是不可变的，包括元组和冰冻集合，所以当前集合的浅拷贝并不存在深拷贝的问题。换句话说，就是不存在在拷贝后，对集合中不可变的二级容器进行操作的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>res = mySets.copy()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>集合是没有<code>deepcopy</code>方法的。</strong></p><h2 id="集合的运算和检测">集合的运算和检测</h2><p>集合的主要运算有四种，以下将列出这四种以及他们的方法:</p><ul><li>交集<code>&amp;, set.intersection(), set.intersection_update()</code></li><li>并集 <code>|, union(), update()</code></li><li>差集 <code>-, difference(), difference_update()</code></li><li>对称差集<code>^, symmetric_difference(), symmetric_difference_update()</code></li></ul><p>我们先来看看符号运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先定义两个集合</span><br>mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>然后让我们先求交集<code>&amp;</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求两个集合交集</span><br>res = mySet1 &amp; mySet2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>求两个集合并集（求并集的时候会去除重复项）<code>|</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1 | mySet2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>求两个集合差集<code>-</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1 - mySet2<br>res2 = mySet2 - mySet1<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(res2)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>这段代码结果中<code>res</code>和<code>res2</code>的区别在于，<code>res</code>是<code>mySet1</code>中有，而<code>mySet2</code>中没有，<code>res2</code>是<code>mySet2</code>中有，而<code>mySet1</code>中没有。</p><p>求两个集合对称差集<code>^</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1 ^ mySet2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>看完符号运算，我们可以再来看看函数运算</p><p>交集的运算函数为<code>set.intersection(), set.intersection_update()</code>,那这两个函数又有什么区别呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1.intersection(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>让我们先记住<code>intersection()</code>的结果,<code>mySet1</code>和<code>mySet2</code>并没有发生变化，而返回值为两个集合相同的内容。然后我们再来看看另外一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1.intersection_update(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Python&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>首先我们就能看到，返回值为<code>None</code>,并且<code>mySet1</code>发生了变化。也就是说，<code>set.intersection_update()</code>是将两者的交集重复赋值给到了头部的变量，这里就是<code>mySet1</code>，然后返回一个<code>None</code>值。</p><p>接着我们来看一下并集运算函数: <code>union(), update()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet1.union(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们首先看到了返回值，正事两个集合的并集，两个原始集合也没有发生变化。</p><p>再来看看<code>update()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet1.update(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以很明显看到区别：返回值为<code>None</code>，并集的计算结果被复制给了第一个变量，这里是<code>mySet1</code>。</p><p>再看完并集之后，就轮到差集了,分别是这两个函数<code>difference(),difference_update()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet1.difference(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值为差集的计算结果,这里是<code>mySet1</code>有的而<code>mySet2</code>没有的。那不用问，按照一贯的惯例，<code>difference_update()</code>一定是将计算结果返回给第一个变量，这回我们换一下，将<code>mySet2</code>换成第一个变量试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet2.difference_update(mySet1)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>果然就跟料想的一样，最终的计算结果赋值给了<code>mySet2</code>。</p><p>最后当然就是对称差集函数<code>symmetric_difference()  symmetric_difference_update()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet2.symmetric_difference(mySet1)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><code>res</code>接收了计算结果，成为了一个新集合。</p><p>接下来，大家应该能猜到了吧？不过还是要做做实验才知道，万一和自己想的不一样呢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet2.symmetric_difference_update(mySet1)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>嗯，这个结果，一点都没有惊喜和意外。</p><p>好吧，运算我们学完之后，接着我们要看看集合的检测方法,一共有三个，记住用法就可以了：</p><ul><li><code>issuperset()</code>检测是否为超集</li><li><code>issubset()</code>检测是否为子集</li><li><code>isdisjoint()</code>检测是否不相交</li></ul><p>为了更好的说明，我们不能在用之前的集合，这回，我们定义三个集合来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>mySet2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>mySet3 = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br></code></pre></td></tr></table></figure><p>接下来从第一个检测开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(mySet1.issuperset(mySet2))<br><span class="hljs-built_in">print</span>(mySet2.issuperset(mySet1))<br><span class="hljs-built_in">print</span>(mySet1.issuperset(mySet3))<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>不知道大家在数学里有没有学过「超集」的概念，我们从最后的打印结果可以看出来，<code>mySet1</code>是<code>mySet2</code>的超集，反过来则不是，并且，<code>mySet1</code>也不是<code>mySet3</code>的超集。观察三个集合内的元素我们可以得出结论，如果集合<code>a</code>是另外一个集合<code>b</code>的超集，那么集合<code>b</code>内的元素一定在集合<code>a</code>中都找得到。</p><p>再来检测子集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(mySet1.issubset(mySet2))<br><span class="hljs-built_in">print</span>(mySet2.issubset(mySet1))<br><span class="hljs-built_in">print</span>(mySet3.issubset(mySet1))<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>从这个结果中我们能看到，子集的概念就和超集完全相反了。</p><p>最后就是检测两个集合是否相交了，也就是集合中的元素有没有重复的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(mySet1.isdisjoint(mySet2))<br><span class="hljs-built_in">print</span>(mySet2.isdisjoint(mySet1))<br><span class="hljs-built_in">print</span>(mySet3.isdisjoint(mySet1))<br><span class="hljs-built_in">print</span>(mySet2.isdisjoint(mySet3))<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>虽然前三个都打印的<code>False</code>，最后一个打印的<code>True</code>，但是我们从集合中应该知道，只有<code>mySet2</code>和<code>mySet3</code>没有相交关系。所以我们可以知道，<code>isdisjoint()</code>这个函数其实是检测不相交的。也就是说，返回结果为<code>False</code>则证明相交，返回结果为<code>True</code>反而是不相交。</p><h2 id="结语">结语</h2><p>至此，随着我们的集合内容讲完，咱们的容器类数据类型就全部讲完了。</p><p>咱们下一节开始，咱们要开始行的篇章。下一节内容预告：Python中File文件的操作。</p><p>本节课一样就不布置作业了，大家好好的将最近将的容器类数据好好的回顾一下，将基础打扎实。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230808130113.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍 Python-set&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi， 大家好。我是茶桁&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>11. 数据类型 - 字典</title>
    <link href="https://hivan.me/Detailed-of-dictonary/"/>
    <id>https://hivan.me/Detailed-of-dictonary/</id>
    <published>2023-08-07T11:40:50.000Z</published>
    <updated>2023-08-10T10:58:17.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807194318.png?imgNote"alt="茶桁的AI秘籍-dictionary" /></p><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>关于Python的数据类型，我们已经详细讲解了三种，字符串，列表和元组。那么今天，我们再来讲一种：字典。</p><p>字典也是一种数据的集合，由健值对组成的数据集合，字典中的键是不能重复的。</p><p>字典中的键必须是不可变的数据类型，常用的键主要是：字符串，整型...</p><p><strong>实际上，在之前字符串和列表的铺垫之后，任何数据类型其实都会感觉差不多，当然，每个数据类型也都有自己的特点以及需要注意的地方，不过在方法，操作上也会有很多类同点。</strong></p><p>那么，让我们开始学习字典吧。</p><h2 id="字典的定义">字典的定义</h2><ul><li>字典可以通过把以逗号分隔的<code>key:value</code>对列表包含于花括号之内来创建字典。</li><li>也可以通过<code>dict</code>构造器来创建</li></ul><p><code>&#123;'jack': 666, 'stored': 777&#125;</code>或者<code>&#123;666:'jack', 777:'stored'&#125;</code></p><p>让我们开始写代码来做实验：</p><p>使用<code>&#123;&#125;</code>定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>dict(key=value, key=value)</code>函数进行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;张三&#x27;</span>, sex=<span class="hljs-string">&#x27;male&#x27;</span>, age=<span class="hljs-number">22</span>)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>&#125;<br></code></pre></td></tr></table></figure><p>数据类型的转换：<code>dict(二级容器类型)</code>列表或元组，并且只有二级容器才可以转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>([[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>]])<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>让我们来试试如果不是二级容器类型会如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>TypeError: <span class="hljs-built_in">dict</span> expected at most <span class="hljs-number">1</span> argument, got <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>报错了，提示我们字典最多一个参数，但是现在里面有3个。</p><p>再继续试试其他情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>([[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>]]])<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>ValueError: dictionary update sequence element <span class="hljs-comment">#0 has length 3; 2 is required</span><br></code></pre></td></tr></table></figure><p>再次抛出异常，提示字典更新序列元素长度为3，第2位是必填项。</p><p>以上可以看出，只有二级容器才能通过<code>dict()</code>函数来做数据类型的转换。</p><p><code>zip</code>压缩函数，<code>dict</code>转类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>ex2 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><br><span class="hljs-comment"># 压缩过后做的事情其实就是数据类型的转换</span><br>myDict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(ex1, ex2))<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="字典的操作">字典的操作</h2><p>还记得吗，无论是列表还是元组，都支持数学的基本运算符<code>+</code>和<code>*</code>。那字典是不是也同样支持？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>ex2 = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">4</span>:<span class="hljs-string">&#x27;d&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(ex1 + ex2)<br><br>---<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> +: <span class="hljs-string">&#x27;dict&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;dict&#x27;</span><br></code></pre></td></tr></table></figure><p>提示类型错误，<code>*</code>实际上也是一样，这里我们就不占用篇幅再多打印一次错误了。说明，字典并不支持这两个基本的数学运算符。想想我们之前提到的<code>dict</code>中<code>key</code>不能重复其实也就好理解了。如果支持<code>+</code>，那相加的两个字典内<code>key</code>值如果相同，那到底舍去那一个呢？<code>*</code>法就更容易理解，原本<code>*</code>就是将相同的数据重复乘n份，不支持也就理所应当了。</p><p>那么，字典到底支持哪些操作呢？我们接着往下看实验：</p><p>首先，让我们尝试获取一下元素，既然字典是<code>key:value</code>形式的，那要想拿到<code>value</code>值，必然是使用<code>key</code>来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = ex1[<span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>拿到元素了，那如果我们是要修改元素呢？直接赋值试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">111</span><br><span class="hljs-built_in">print</span>(ex1)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">111</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>看来是有效的，增删改查，我们现在来试试删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> ex1[<span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-built_in">print</span>(ex1)<br><br>---<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>也没毛病。</p><p>接下来，当然就是添加元素了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1[<span class="hljs-string">&#x27;aa&#x27;</span>]  = <span class="hljs-string">&#x27;aaaaa&#x27;</span><br><span class="hljs-built_in">print</span>(ex1)<br><br>---<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;aa&#x27;</span>: <span class="hljs-string">&#x27;aaaaa&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>之前我们反复说过字典的一个特点，就是字典不能有重复的<code>key</code>，这也是我们无法使用<code>+</code>和<code>*</code>操作字典的原因。那么问题来了，如果我在添加元素的时候<code>key</code>重复了怎么办？</p><p>什么怎么办，添加<code>key</code>重复了，那不就变成修改元素了吗？<code>^_^</code></p><h2 id="检测和获取">检测和获取</h2><p>增删改查我们前三个基本都已经讲完了，那剩下的，就是查了。让我们看看如何检测和获取元素。</p><p>成员检测，只能检测<code>key</code>，无法检测<code>value</code>。是否注意到我们之前一直使用的一句代码<code>for i in range(10)</code>,大家应该都能明白这一句代码是做什么吧？其实，我们坚持是否包含的时候，就可以用<code>in</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AA&#x27;</span> <span class="hljs-keyword">in</span> ex1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AA&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ex1)<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>获取当前字典的长度，只能检测当前有多少个健值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ex1))<br><br>---<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>我们还可以获取当前字典中的所有<code>key</code>键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ex1.keys())<br><br>---<br>dict_keys([<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;aa&#x27;</span>])<br></code></pre></td></tr></table></figure><p>当然，不只是<code>key</code>。实际上，字典中所有的<code>value</code>值，我们一样可以获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ex1.values())<br><br>---<br>dict_values([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>])<br></code></pre></td></tr></table></figure><p>最后，让我们尝试把<code>key</code>和<code>value</code>一起获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ex1.items())<br><br>---<br>dict_items([(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>)])<br></code></pre></td></tr></table></figure><h2 id="字典的遍历">字典的遍历</h2><p>当我们谈到对字典的遍历时，实际上和检测、获取时一样的。只是写进了遍历循环里而已，让我们来看看吧：</p><p>在我们遍历当前字典时，只能获取当前的<code>key</code>,但是我们可以通过获取到的<code>key</code>来完成获取当前<code>key</code>的<code>value</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ex1:<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&#x27;:&#x27;</span>, ex1[i], end=<span class="hljs-string">&quot;; &quot;</span>)<br>    <br>---<br>b : <span class="hljs-number">2</span>; c : <span class="hljs-number">3</span>; aa : aaaaa; <br></code></pre></td></tr></table></figure><p>这种获取方式就显得略微繁琐一点，既然我们之前有提到一个将<code>key</code>和<code>value</code>一起获取到的函数方法，那我们在<code>for</code>里一样可以使用它来将<code>key</code>和<code>value</code>一起获取到，只是，我们需要用到两个参数来接收：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> ex1.items():<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&#x27;:&#x27;</span>, v, end=<span class="hljs-string">&quot;; &quot;</span>)<br>    <br>---<br>b : <span class="hljs-number">2</span>; c : <span class="hljs-number">3</span>; aa : aaaaa; <br></code></pre></td></tr></table></figure><p>既然之前介绍的获取上我们可以单独获取<code>key</code>和<code>value</code>，当然这里也通通能用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历所有的key</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> ex1.keys():<br>    <span class="hljs-built_in">print</span>(k, end=<span class="hljs-string">&quot;; &quot;</span>)<br><br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-comment"># 遍历所有的value</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> ex1.values():<br>    <span class="hljs-built_in">print</span>(v, end=<span class="hljs-string">&quot;; &quot;</span>)<br><br>---<br>b; c; aa; <br><span class="hljs-number">2</span>; <span class="hljs-number">3</span>; aaaaa; <br></code></pre></td></tr></table></figure><h2 id="字典的相关函数">字典的相关函数</h2><p>和列表、元组一样，字典也有一些相关函数。有些嘛，一看到就很熟悉，在其他地方也能用，可是也有一些事字典专用的。</p><p><code>len(dict)</code>: 获取字典的健值对个数</p><p><code>dict.keys()</code>获取当前字典的所有<code>key</code>键，组成的列表</p><p><code>dict.values()</code>获取当前字典的所有<code>value</code>值，组成的列表</p><p><code>dict.items()</code>返回由字典项（（键，值）对）组成一个新视图</p><p><code>iter(dict)</code>返回以字典的键为元素的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">iter</span>(ex1)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>---<br>b<br>[<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;aa&#x27;</span>]<br></code></pre></td></tr></table></figure><p>接下来，让我们重新定义一个新的字典来继续下面的函数学习：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p><code>dict.pop(key)</code>通过<code>key</code>从当前字典中弹出健值对，删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>myDict.pop(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要注意一个点，就是<code>pop()</code>这个函数其实是有返回值的，会返回当前删除的健值对的<code>value</code>,我们拿一个变量来接收一下返回值看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>res = myDict.pop(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>res</code>接收到了<code>pop()</code>方法的返回值<code>1</code></p><p><code>dict.popitem()</code>:后进先出（LIFO）的方式删除健值对，我们这里需要理解一下什么叫后进先出，就是最后一个加入字典的元素，先出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>myDict.popitem()<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>和<code>pop</code>方法一样，<code>popitem</code>方法也会有一个返回值，不过是返回一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = myDict.popitem()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>上面我们在讲获取的时候提到，可以直接使用<code>key</code>来获取元素的<code>value</code>，不过如果字典内如果没有这个<code>key</code>的话，程序会报错。除了使用<code>key</code>来直接获取，字典里还有一个<code>get()</code>方法可以用来获取一个元素，用<code>get</code>获取元素存在就返回，不存在也不回报错，而是回返回<code>None</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(myDict.keys(<span class="hljs-string">&#x27;f&#x27;</span>))<br><br>---<br>TypeError: <span class="hljs-built_in">dict</span>.keys() takes no arguments (<span class="hljs-number">1</span> given)<br><br>============<br><span class="hljs-comment"># get方法获取</span><br>myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(myDict.get(<span class="hljs-string">&#x27;f&#x27;</span>))<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>字典的<code>update</code>方法可以更新对字典进行更新，如果这个<code>key</code>存在的话，就是更新。如果<code>key</code>不存在，则会进行添加。<code>update</code>可是使用<code>key = value</code>的形式更新，也可以直接获取一个新字典进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>myDict.update(a=<span class="hljs-number">11</span>, b=<span class="hljs-number">22</span>)<br>myDict.update(&#123;<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">33</span>, <span class="hljs-string">&#x27;f&#x27;</span>:<span class="hljs-number">66</span>&#125;)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-number">66</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际上可以这么理解，update方法在获取其他字典更新原字典就有点像使用数学运算符的+,区别只是，update是强制把最终确定值定为 + 号后方的值。</p></blockquote><p>字典中还有一个方法<code>setdefault()</code>,完整的写法为:<code>dict.setdefault(key[, default])</code>这个方法会去字典中找寻存在的<code>key</code>，并且会返回它的值。如果这个<code>key</code>不存在，这会插入一个值为<code>default</code>的<code>key</code>，并且返回<code>default</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>res = myDict.setdefault(<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br>res = myDict.setdefault(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br><span class="hljs-number">123</span><br><span class="hljs-number">1</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;aa&#x27;</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，如果这个<code>key</code>在字典中本来就存在，则并不会修改原本<code>key</code>的值，即便你在后面设定了一个<code>default</code>。并且返回的也会是字典内原本的<code>value</code>。也就是说，这个方法只能用来查询和新增。</p><h2 id="字典推导式">字典推导式</h2><p>和之前介绍的数据类型一样，字典也可以使用推导式来实现一些功能。比如：</p><p>字典中的健值对位置进行交换，先用普通的方法实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br><br>newDict = &#123;&#125;<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> myDict.items():<br>    newDict[v] = k<br><br><span class="hljs-built_in">print</span>(newDict)<br><br>---<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>然后再让我们看看字典推导式如何完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>newDict = &#123;v:k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> myDict.items()&#125;<br><span class="hljs-built_in">print</span>(newDict)<br><br>---<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>有的小伙伴可能会在推导式前方只写了一个变量来进行接收，那会变成什么样呢？我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>newDict = &#123;v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> myDict.items()&#125;<br><span class="hljs-built_in">print</span>(newDict, <span class="hljs-built_in">type</span>(newDict))<br><br>---<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;set&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，最终打印的字典似乎看起来怪怪的，不是<code>key:value</code>的对形式，而是只有一个值。我们<code>type</code>一下能看到，类型并非是字典，而是<code>set</code>，也就是说这是一个集合。</p><p>来让我们再看一个案例，让我们把一个字典中的<code>value</code>值有偶数的对保留下来，并且交换健值对的位置，一样的，让我们先用普通方式做一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;f&#x27;</span>:<span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment"># 使用普通方式完成</span><br>newDict = &#123;&#125;<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> myDict.items():<br>    <span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        newDict[v] = k<br><span class="hljs-built_in">print</span>(newDict)<br></code></pre></td></tr></table></figure><p>再让我们使用字典推导式来完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">newDict = &#123;v:k <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> myDict.items() <span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;<br><span class="hljs-built_in">print</span>(newDict)<br><br>---<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>OK，关于字典的东西基本上也就这么多。在前面学习过字符串和列表之后，是不是其他的<strong>容器类数据</strong>就没那么难了？很多东西都是普遍适用的，所以我们要活学活用，多思考。</p><p>那今天就不留练习题了，咱们下节课是数据类型最后一节了，之后我们开始讲解具体实际应用。字符串和容器类数据是Python中的基础也是重点，大家一定要好好的巩固。</p><p>下一节：集合。咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807194318.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍-dictionary&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>10. 数据类型 - 元组详解</title>
    <link href="https://hivan.me/Detailed-of-tuple/"/>
    <id>https://hivan.me/Detailed-of-tuple/</id>
    <published>2023-08-07T03:44:38.000Z</published>
    <updated>2023-08-07T10:37:50.276Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807182811.png?imgNote"alt="茶桁的AI秘籍 Python - tuple" /></p><p>Hi，大家好。我是茶桁。</p><p>之前两节分别介绍了字符串和列表，今天，我们来讲讲另外一个常用到的数据类型：元组。</p><span id="more"></span><p>元组和列表很像，两者都是一组有序的数据的组合。但是也有很多不同点，比如元组内的元素一旦定义了就不可以再修改，因此元组称为<strong>不可变数据类型</strong>。</p><h2 id="元组定义">元组定义</h2><p>元组的定义方式包括以下要点：</p><ul><li>定义元组<code>变量 = ()</code>, 或者<code>变量 = tuple()</code></li><li>可以使用<code>变量 = (*iterable)</code>定义含有数据的元组</li><li>⚠️需要注意：如果元组中只有一个元素时，这唯一的元素后面也必须加逗号，这是为了区分其他元素标识这是一个元组:<code>(1,)</code></li><li>特例： <code>变量 = 1,2,3</code>，这种方式也可以定义为一个元组。</li></ul><h2 id="元组的相关操作">元组的相关操作</h2><p>由于元组是一个不可变的数据类型，因此其在创建之后只能使用索引进行访问，无法进行其他操作。访问方式其实和列表一样，同样可以使用切片方式获取元素。</p><p>元组可以进行切片操作，在访问数据这件事情上和列表几乎一样，没有什么区别，所以完全可以借鉴上一节我讲的内容来看，这里就不详细介绍了，仅仅给大家写出一些案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常见的元组切片索引查询操作</span><br>tup = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[:]:\t&#x27;</span>,tup[:]) <span class="hljs-comment"># 获取全部</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[::]:\t&#x27;</span>, tup[::]) <span class="hljs-comment"># 获取全部</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[1:]:\t&#x27;</span>, tup[<span class="hljs-number">1</span>:]) <span class="hljs-comment"># 从索引1开始获取到最后</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[1:3]:\t&#x27;</span>, tup[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 从索引1开始索引到3之前</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[:3]:\t&#x27;</span>, tup[:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 从0开始索引到3之前</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[1:5:2]:\t&#x27;</span>, tup[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 从1开始索引到5之前，步进值为2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[::2]:\t&#x27;</span>, tup[::<span class="hljs-number">2</span>]) <span class="hljs-comment">#从0开始索引到最后，步进值为2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[5:1:-1]:\t&#x27;</span>, tup[<span class="hljs-number">5</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 从5开始往前索引到1， 步进值为-1。</span><br><br>---<br>[:]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>[::]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>[<span class="hljs-number">1</span>:]: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>[:<span class="hljs-number">3</span>]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]: (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>[::<span class="hljs-number">2</span>]: (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br>[<span class="hljs-number">5</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]: (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>除了常用的切片操作之外，和列表一样，元组也能使用一些基本函数来完成查询操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取元组的长度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(tup))<br><br><span class="hljs-comment"># 统计一个元素在元组中出现的次数</span><br><span class="hljs-built_in">print</span>(tup.count(<span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 获取一个元素在元组内的下标（索引值）</span><br><span class="hljs-built_in">print</span>(tup.index(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>))<br><br>---<br><span class="hljs-number">10</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>除此之外，元组还可以引用基础的数学运算符<code>+</code>和<code>*</code>来进行加和乘的运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加和乘操作</span><br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) + (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) * <span class="hljs-number">5</span>)<br><br>---<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>有一个同学曾经问过我：既然元组是不可修改的，那为什么还能用加和乘的运算呢？</p><p>不知道在座的小伙伴有没有这种想法？</p><p>这样吧，我重新写一段代码，小伙伴们应该就明白了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组是这样的</span><br>tup = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(tup))<br>tup2 = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>tup = tup + tup2<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(tup))<br><br>---<br><span class="hljs-number">4446580864</span><br><span class="hljs-number">4450629120</span><br><span class="hljs-number">4450647984</span><br><span class="hljs-number">4459297216</span><br></code></pre></td></tr></table></figure><p>不知道大家看明白没有。解释一下，其实就是说，在进行加法和乘法运算的时候，即便我们的变量名是一样的，实际上也是生成了一个新的元组，而不是之前那一个了。所以这个并非是修改和更新，而是创建。</p><p>为了对比，我再写一段更新的代码给大家看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试更新元组</span><br>tup = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(tup[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">del</span> tup[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(tup)<br><br>---<br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> doesn<span class="hljs-string">&#x27;t support item deletion</span><br></code></pre></td></tr></table></figure><p>可以看到，报错提示了，<code>tuple</code>对象不支持删除项目</p><p>作为对比，我们看看列表的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看看列表更新（只看id）</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-keyword">del</span> items[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items), <span class="hljs-string">&#x27;\t&#x27;</span>,items)<br><br>---<br><span class="hljs-number">4450415936</span><br><span class="hljs-number">4450415936</span>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>可以看到，不仅是内部元素被删除了，并且<code>id</code>完全没有变化。也就是说，我们是在这个列表本身做了删除动作，并未生成新的列表。关于这部分，我们上一节中的深拷贝和浅拷贝讲的很清楚，大家可以回去好好看看理解一下。</p><h2 id="元组推导式-生成器">元组推导式 生成器</h2><p>在起初，我们先来看看元组是否和列表一样支持使用推导式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(tup)<br><br>---<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x109cfa570</span>&gt;<br></code></pre></td></tr></table></figure><p>这段并非是报错，而是打印出了<code>tup</code>的类型：生成器对象。</p><p>我们之前学过，使用列表推导式生成的结果是一个列表，但是元组似乎和列表并不一样，生成的结果是一个生成器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">列表推导式 ==&gt; [变量运算 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 容器]  ==&gt; 结果 是一个 列表<br>元组推导式 ==&gt; (变量运算 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 容器)  ==&gt; 结果 是一个 生成器<br></code></pre></td></tr></table></figure><p>那这里就有个疑问了，什么是生成器？</p><p>生成器是一个特殊的迭代器，生成器可以自定义，也可以使用元组推导式去定义。</p><p>生成器是按照某种算法去推算下一个数据或结果，只需要往内存中存储一个生成器，节约内存消耗，提升性能。</p><p><strong>语法</strong></p><ol type="1"><li>里面是推导式，外面是一个()的结果就是一个生成器</li><li>自定义生成器，含有yield关键字的函数就是生成器</li></ol><p>那么，我们到底应该怎样操作生成器呢？</p><p>既然生成器是迭代器的一种，那我们是否可以使用迭代器的操作方法来操作生成器呢？</p><p>说干就干，让我们直接操作做实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(tup))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(tup))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(tup))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(tup))<br><br>---<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>没毛病，确实支持<code>next()</code>函数，并且内部元素在使用后也被移除了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 让我们将其转为元组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tuple</span>(tup))<br><br>---<br>()<br></code></pre></td></tr></table></figure><p>哎，为什么里面是空的？那是因为，我们上一段代码中的最后一句，已经讲所有迭代器内的元素转为了列表，素衣目前迭代器<code>tup</code>内是没有任何元素了，所以我们转过来必须是空的。</p><p>再来生成一个，我们来试试用<code>for</code>对它进行循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tup:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <br>---<br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><p>可以看到结果没有问题。可以推断出，生成器和迭代器没有任何区别，我们在平时使用的时候，就直接将它作为迭代器使用就可以了。</p><h2 id="yield关键字">yield关键字</h2><p>在之前，我们提到了，含有<code>yield</code>关键字的函数就是生成器。</p><p>它返回的结果是一个迭代器。我们可以理解为，生成器函数就是一个返回迭代器的函数。</p><p>那么<code>yield</code>有哪些需要注意的点呢？我们先在下面列一下，之后再带着大家一起过：</p><p><code>yield</code>和函数中的<code>return</code>有点像</p><ul><li>共同点： 执行到这个关键字后会把结果返回来</li><li>不同点：<ul><li><code>return</code>会把结果返回，并结束当前函数的调用</li><li><code>yield</code>会返回结果，并记住当前代码执行的位置，下一次调用时会从上一次离开的位置继续向下执行。</li></ul></li></ul><p>上实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个普通函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br><br>func()<br>func()<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello <span class="hljs-keyword">yield</span><br></code></pre></td></tr></table></figure><p>在这个自定义函数内，<code>return</code>执行的时候，就会结束当前函数的调用，而在之前，第一个<code>print()</code>函数正确执行了，但是第二个<code>print()</code>函数因为在<code>return</code>之后，所以并未运行。即便我们一共执行了两次函数，可是也仅仅是讲第一个<code>print()</code>函数执行了两次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><span class="hljs-built_in">next</span>(res)<br><span class="hljs-built_in">next</span>(res)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello again<br></code></pre></td></tr></table></figure><p>可以看到，当我们使用<code>next()</code>函数的时候，迭代器起作用了，每执行一次，分别调用第一个<code>yield</code>之前和之后的<code>print()</code>，也就是说<strong>继续</strong>执行了。</p><p>那如何验证<code>yield</code>的返回呢？我们将这段代码改造一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><span class="hljs-built_in">str</span> = <span class="hljs-built_in">next</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><span class="hljs-built_in">str</span> = <span class="hljs-built_in">next</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span><br>Hello again<br><span class="hljs-keyword">return</span> again<br></code></pre></td></tr></table></figure><p>没问题，依次打印出了返回值<code>return yield</code>和<code>return again</code>。</p><p>还记得我们之前教过，使用<code>list</code>函数去调用，可以讲迭代器的返回结果，作为容器的元素，让我们再来改造一下这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><br>items = <span class="hljs-built_in">list</span>(res)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello again<br>[<span class="hljs-string">&#x27;return yield&#x27;</span>, <span class="hljs-string">&#x27;return again&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们看见，确实，返回结果被依次放入了一个<code>list</code>容器中。</p><p>当然，除了<code>list</code>函数之外，还可以使用<code>for</code>来获取迭代器内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>    items.append(i)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello again<br>[<span class="hljs-string">&#x27;return yield&#x27;</span>, <span class="hljs-string">&#x27;return again&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们来分析一下在以上这几段代码中，生成器函数调用时到底是什么过程。</p><p>首先，调用生成器函数，返回一个迭代器：</p><ol type="1"><li>第一次去调用迭代器，走到当前的生成器函数中，遇到第一个<code>yield</code>,把<code>return yield</code>返回，并且记住当前的执行状态（位置），暂停了执行，等待下一次的调用</li><li>第二次去调用迭代器，从上一次遇到的<code>yield</code>位置开始执行，遇到了第二个<code>yield</code>，把<code>return again</code>返回，并重新记录状态，暂停执行，等待下一次调用。</li><li>如果最后又调用了迭代器，那么会从上一次的<code>yield</code>位置开始，可是后面没有了，就会超出范围，抛出异常：<code>StopIteration:</code>。</li></ol><p>那么这种一次一次调用执行的方式什么时候适用呢？比如说，我们在处理一个非常大的数据，电脑可能吃不住，这个时候我们就可以拆开来一次一次的执行获取结果。</p><h2 id="小练习">小练习</h2><blockquote><ol type="1"><li>为了能达到练习的目的，从这一节开始，所有练习可以不在课程中展示了。大家先做一下，然后可以在我下一节课中的源码中去找答案，然后来看看和自己做的是否一样。</li><li>以下所有练习必须使用列表推导式来实现</li><li>有些练习不止一个方法，大家尝试用多种方法来实现一下。</li><li>做完的小伙伴可以在课程后面留言讨论。</li><li>上一节的练习已经放到本次教程的源码内，可以在此获取：https://github.com/hivandu/AI_Cheats/tree/main/Python</li></ol></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">今天就一个练习：使用生成器改写斐波那契数列函数<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807182811.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍 Python - tuple&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;之前两节分别介绍了字符串和列表，今天，我们来讲讲另外一个常用到的数据类型：元组。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>9. 数据类型 - 列表详解</title>
    <link href="https://hivan.me/Detailed-of-list/"/>
    <id>https://hivan.me/Detailed-of-list/</id>
    <published>2023-08-06T06:45:03.000Z</published>
    <updated>2023-08-07T13:17:11.602Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807211708.png?imgNote"alt="茶桁的AI秘籍" /></p><p>Hi，大家好。我是茶桁。</p><p>最近几节课，我们都是在详细讲解Python内的数据类型，上一节课我们详细了解了字符串，这节课，让我们来详解一下列表。</p><span id="more"></span><p>首先，我们先有一个大的概念，列表，其实就是<strong>一组有序的数据组合</strong>；另外，列表中的数据是可以被修改的。也就是说，列表是<strong>一个可变序列类型</strong>。</p><h2 id="列表定义">列表定义</h2><p>如何在Python的定义列表，记住以下几点就可以了：</p><ul><li>可以使用中括号进行定义<code>[]</code></li><li>可以使用<code>list()</code>函数定义</li><li>还可以使用列表推导式定义: <code>[x for x in iterable]</code></li><li>在定义列表中的元素时，需要在每个元素之间使用逗号（英文逗号），进行分隔。<code>[1, 2, 3]</code></li><li>列表中的元素可以是任意类型，通常用于存放同类项目的集合。</li></ul><h2 id="列表的基本操作">列表的基本操作</h2><p>让我们先来定义一个列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items2 = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;1234&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(items,<span class="hljs-string">&#x27;\n&#x27;</span>, items2)<br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <br> [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们使用了最基本的两个方式来定义列表。至于<strong>列表推导式</strong>，先不用着急，我们后面会单独讲它。</p><p>我们可以看到，刚才我刻意将<code>item</code>和<code>items</code>两个列表定义了不同种类的元素，那他们到底能否拼接在一起？我们尝试一下列表的相加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items + items2)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br></code></pre></td></tr></table></figure><p>没问题，两种不同类型的元素拼接到了一起，组成了一个新的列表。</p><p>让我们将这段代码搞的复杂一点，新的列表对于我要的模拟数据来说太少了，我想再增加5倍的长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>((items + items2) * <span class="hljs-number">5</span>)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br></code></pre></td></tr></table></figure><p>没毛病，也就是说，我将小学学到的基本数学运算用到这里完全适用。</p><p>那如果用到减法呢，虽然难以想象最后的结果，试试中可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items - items2)<br><br>---<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> -: <span class="hljs-string">&#x27;list&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure><p>果然是我想多了，完全不支持操作数类型。</p><p>那是不是关于列表的操作也就到此为止了？并不是，列表除了利用加和乘进行拼接和循环的操作之外，还有很多其他的基本操作，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items[<span class="hljs-number">2</span>] = <span class="hljs-number">9</span><br><span class="hljs-built_in">print</span>(items, <span class="hljs-string">&quot;\t&quot;</span>,items[<span class="hljs-number">3</span>])<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这里，我们利用了列表的下标操作修改了列表内的下标<code>[2]</code>的元素（第三个），并且将修改后的列表和列表内下标<code>[3]</code>的元素打印了出来。</p><p>有这样一种情况大家想过没有，这个列表呢，我并不知道有多长，但是我知道最后一个数字，现在我就想把最后一个数字取出来该怎么办？用<code>len()</code>获取长度之后再-1?是不是太麻烦了？</p><p>还记得之前咱们讲过，下标是可以从后往前数的吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">items[-<span class="hljs-number">1</span>]<br><br>---<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>嗯，我想再这个列表添加几个数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">items[<span class="hljs-number">4</span>] = <span class="hljs-number">10</span><br><br>---<br>IndexError: <span class="hljs-built_in">list</span> assignment index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>哎，我似乎想的并不对。本以为原列表下标<code>[3]</code>是最后一个元素，那我多加一个下标就会再多加一个元素，可是似乎并不行。那么我们该怎么在列表内最佳元素呢？</p><p>可以尝试一下专门添加元素的<code>append()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items.append(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>加是加了，可是我们之前是想加<code>10</code>的，现在不小心加成<code>2</code>了，不行，我要删了它。该怎么办？随便吧，我就记得windows的CMD命令中的删除文件似乎是<code>del</code>，试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> items[-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>居然成了...这就神奇了。看起来，Python并不是很难。不过我们这里不得不说，在Python中还有一个针对列表删除元素的方法：<code>pop()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items.pop()<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><code>pop([index=-1])</code>函数专门用于移除列表中的一个元素，其中参数<code>index</code>为索引值，默认为<code>-1</code>，也就是说默认是从列表移除最后一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将索引值改为从前数第一个</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items.pop(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="列表中的切片">列表中的切片</h2><p>在学习了列表的基本操作之后，我们来看看列表中的切片。提前说一声，在数据分析的应用中，对数据整理的过程绝大多数时候都需要用到列表的切片操作，所以大家这部分要好好理解。</p><p>列表的切片操作基本语法其实很简单</p><p><code>list[开始值:结束值:步进值]</code></p><p>看起来很熟悉对吧？在我们之前介绍<ahref="../Detailed-of-string/">字符串相关的操作</a>的时候，就是这种方式。其用法和字符串中也是如出一辙：</p><ul><li><code>list[开始值:]</code> 从开始值索引到列表的最后</li><li><code>list[:结束值]</code>从列表最前面索引到结束值之前</li><li><code>list[开始值:结束值]</code>按照给到的开始值开始索引，到结束值之前为止。</li></ul><p>当然，除了这三个基本的操作之外还有<code>list[::], list[::步进值], list[开始值::步进值], list[:结束值:步进值],list[开始值:结束值:步进值]</code>，我们下面一一的来看看，在字符串相关操作中没有特别理解的没关系，这里再来加深下印象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先来定义一个列表方便后续操作</span><br>items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>从开始值索引到最后：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items[<span class="hljs-number">2</span>:])<br><br>---<br>[<span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从下标<code>[2]</code>开始，也就是从第三个<code>Ruby</code>开始向后索引。</p><p><strong>从最前面索引到结束值之前：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items[:<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>]<br></code></pre></td></tr></table></figure><p>现在我们让这两个语言单独露脸，算是对它们进行补偿了。</p><p><strong>从开始值索引到结束值之前：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>])<br><br>---<br>[<span class="hljs-string">&#x27;Ruby&#x27;</span>]<br></code></pre></td></tr></table></figure><p>哎，为什么只索引出来一个值？因为结束值为<code>3</code>，它之前不就是<code>2</code>吗。开始值也是<code>2</code>，那可不就只有一个值而已。</p><p>这回，<strong>我们把步进值加上：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加上步进值</span><br><span class="hljs-built_in">print</span>(items[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从最前面索引到最后，步进值为<code>2</code>，所以是隔一个索引一个。那为什么<code>PHP</code>没索引到？估计你又忘了，是索引到结束值之前，不包含结束值，自然<code>PHP</code>就没被索引到。</p><p><strong>只有步进值</strong>会是什么情况？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只有步进值</span><br><span class="hljs-built_in">print</span>(items[::-<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br></code></pre></td></tr></table></figure><p>步进值为负数，那显然是从后向前索引了。隔一个索引一个，等等，为啥第一个<code>Python</code>被索引到了？那是因为，当我们开始值和结束值都没取值的情况下，默认是从头到尾索引，现在嘛，应该是从尾到头索引。也就是包含了头尾，不存在最后一个值之前，所以列表内的所有值都索引了一个遍，只是因为有步进值的关系，所以变成隔一个索引一个。</p><p>再让我们<strong>将所有值都去掉</strong>，只留下<code>[::]</code>试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删掉所有值试试</span><br><span class="hljs-built_in">print</span>(items[::])<br><span class="hljs-built_in">print</span>(items[:])<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>]<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从结果上看，中括号内一个冒号和两个冒号出来的结果是一样的。</p><p>在索引查找之后，我们来看看，利用切片的方式是否可以对列表内的元素进行更新和删除？</p><p>从指定下标开始，到指定下标前结束，并替换为对应的数据(容器类型数据，会拆分成每个元素进行赋值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>指定的切片内的元素被替换掉了。</p><p>刚才我们使用切片替换元素的时候元素是一一对应的，那如果我们没有对应的话会发生什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片范围大于添加元素的个数</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>] = [<span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>结果并没有报错，而是将切片范围内的元素都移除之后添加了一个元素<code>7</code>。我们再试试其他的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># # 切片范围小于添加元素的个数</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>可以看到，比起原本的列表，我们的值增加了。原本下标<code>[2]</code>的元素被移除之后，在这个位置插入了<code>[7,8,9,0]</code>四个元素。</p><p>以此，我们可以总结切片更新列表，实际上就是删除掉切片范围内的元素，再在原来的位置上插入新加的元素，并且将之后的元素向后移动。</p><p>那既然这样的话，我们是不是可以利用这种特性对列表内的元素进行删除？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] = []<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>没毛病，确实可以这么用。</p><p>当然，除了这种插入空列表的方式之外，还有其他方式可以删除列表内的指定元素,还记得前面我们介绍的<code>del</code>方法吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">del</span> items[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>那既然我们可以用添加空列表的方式来删除列表内的元素，<code>del</code>是不是就没用武之地了？实际上，并非如此。<code>del</code>有一个特殊的用法，就是在利用步进值来跳着删除元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">del</span> items[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>那聪明的小伙伴肯定想，添加空列表的方式也加上步进值就不行吗？我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>] = []<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>ValueError: attempt to assign sequence of size <span class="hljs-number">0</span> to extended <span class="hljs-built_in">slice</span> of size <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>报错提示我们，序列分配不正确。说明我们不能这样使用。如果要这样使用的话，替换的元素个数必须对应才行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>] = [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="列表相关函数-重点">列表相关函数(✨ 重点)</h2><p>除了以上介绍的关于列表的一些方法之外，Python还为我们提供了一些列表常用的相关函数：</p><p><strong><code>len()</code></strong></p><p>这个函数可以检测当前列表的长度，列表中元素的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br><span class="hljs-built_in">len</span>(items)<br><br>---<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong><code>count()</code></strong></p><p>这个函数可以检测当前列表中指定元素出现的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">items.count(<span class="hljs-string">&#x27;Python&#x27;</span>)<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong><code>append()</code></strong></p><p>这个函数前面我们已经介绍过了，就是向列表尾部追加新的元素，返回值为None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items.append(<span class="hljs-string">&#x27;SQL&#x27;</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;SQL&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong><code>insert()</code></strong></p><p>这个函数可以向列表中指定的索引位置添加新的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items.insert(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Go&#x27;</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;SQL&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong><code>pop()</code></strong></p><p>还记得我们之前删除列表中元素的时候介绍<code>pop()</code>函数吗？其实，<code>pop()</code>函数是对指定索引位置上的元素做出栈操作，然后返回出栈的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br><span class="hljs-built_in">print</span>(items.pop())<br><span class="hljs-built_in">print</span>(items.pop(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>PHP<br>Ruby<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>]<br></code></pre></td></tr></table></figure><p>默认的情况下，<code>pop()</code>是把列表的最后一个元素出栈，当给值之后，是将指定索引的元素进行出栈。</p><p><strong><code>remove()</code></strong></p><p>这个函数是专门删除特定元素用的，可以指定列表中的元素进行删除，只删除第一个，如果没有找到，则会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.remove(<span class="hljs-string">&#x27;PHP&#x27;</span>)<br><span class="hljs-built_in">print</span>(items)<br>items.remove(<span class="hljs-string">&#x27;Go&#x27;</span>)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>]<br>ValueError: <span class="hljs-built_in">list</span>.remove(x): x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p>可以看到，第一个<code>remove</code>成功删除了<code>PHP</code>，但是第二个<code>remove</code>并未在列表中找到<code>Go</code>，所以报错。</p><p><strong><code>index()</code></strong></p><p>这个函数可以查找指定元素在列表中第一次出现的索引位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.index(<span class="hljs-string">&#x27;PHP&#x27;</span>)<br><br>---<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>除此之外，<code>index()</code>还能接收索引值，当输入索引值的时候，<code>index()</code>会在指定范围内查找元素的索引位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br><span class="hljs-built_in">print</span>(items.index(<span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>))<br>items.index(<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><br>---<br><span class="hljs-number">2</span><br>ValueError: <span class="hljs-string">&#x27;PHP&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p>可以看到，指定范围内没有说要查找的元素的时候就会报错，告知元素不在列表内。</p><p><strong><code>extend()</code></strong></p><p>这个函数接收一个容器类型的数据，把容器的元素追加到原列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = [<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;MATLAB&#x27;</span>]<br>items.extend(a)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;MATLAB&#x27;</span>]<br></code></pre></td></tr></table></figure><p>看到这，是不是感觉很像两个列表相加？那既然我们可以将两个列表相加了，这个方法似乎有些多余了。</p><p>这么想的小伙伴们，我们再来看两段示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>items.extend(a)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>另外一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>items = items + a<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>TypeError: can only concatenate <span class="hljs-built_in">list</span> (<span class="hljs-keyword">not</span> <span class="hljs-string">&quot;tuple&quot;</span>) to <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p>可以看到，第二段代码直接报错了。那说明，相加这个操作必须两个都是列表才可以，不支持列表和元组相加。可是<code>extend()</code>方法是支持将任意一个容器类型的数据中的元素追加到原列表中的。</p><p>我们再来多看一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = <span class="hljs-string">&#x27;1234&#x27;</span><br>items.extend(a)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br></code></pre></td></tr></table></figure><p>将<code>a</code>定义为一段字符串，一样可以使用<code>extend()</code>来接收并追加到原列表内。</p><p><strong><code>clear()</code></strong></p><p>这个函数比较简单，就是清空列表内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br></code></pre></td></tr></table></figure><p><strong><code>reverse()</code></strong></p><p>这个函数可以对列表进行翻转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.reverse()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong><code>sort()</code></strong></p><p>该函数将对列表进行排序,在默认的情况下，会对元素进行从小到大的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.sort()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>]<br></code></pre></td></tr></table></figure><p>额，这样似乎并不明显，我们重新换个案例。不过大家也可以想想现在这段代码中，为什么会有这样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>]<br>items.sort()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>嗯，这回明显了。</p><p>除了从小到大排序外，我们还可以将其从大到小排序，利用关键参数<code>reverse</code>来开启：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>]<br>items.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>OK，现在让我们来回过头来解释一下第一段代码中的结果：<code>['C++', 'Java', 'JavaScript', 'Node', 'PHP', 'Python', 'Ruby', 'Rust', 'Swift']</code>，之所以会产生这样的结果，不是因为它按英文字母来排序，当然这么想也对但是不全对，而是因为它的排序依据是ASCII码，之前我们学习过，ASCII码只包含了128个字符，仅仅是美国的标准，128个字符里面都是西文码，那么如果中间包含了中文会怎样呢？</p><p>不如我们直接来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;茶&#x27;</span>, <span class="hljs-string">&#x27;桁&#x27;</span>]<br>items.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>TypeError: <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">not</span> supported between instances of <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>完了，直接报错。不过这个似乎和编码无关，而是数据类型的问题，告诉我们字符和整型之间不能排序。别问我怎么看懂的，我也是查字典。</p><p>知道是数据类型的问题就好办了，我们将数据类型变成一致的再试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;茶&#x27;</span>, <span class="hljs-string">&#x27;桁&#x27;</span>]<br>items.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;茶&#x27;</span>, <span class="hljs-string">&#x27;桁&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>]<br></code></pre></td></tr></table></figure><p>居然成功了，那既然是ASCII码，那为什么还会支持中文排序呢？还记得我们除了介绍ASCII码之外，还介绍过一个Unicode编码。那即是说，Python中的<code>sort()</code>排序的依据是<code>Unicode</code>编码。</p><p>当然，除了默认规则之外，我们还可以自己对排序进行干预，加上你想要的规则。<code>sort(key)</code>内的<code>key</code>参数可以接收一个函数，按照函数的处理结果进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [-<span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">6</span>]<br>items.sort(key=<span class="hljs-built_in">abs</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br></code></pre></td></tr></table></figure><p>这一段是不是让小伙伴们想到之前我们在<ahref="../python-Built-in-functions">Python的内置函数</a>中介绍高阶函数的内容？没错，就是一样的。所以，我们这次就不对函数内部排序过程进行分析了，有兴趣的小伙伴可以回去看看第七节的内容。</p><h2 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h2><p>接着，让我们来看看关于拷贝的问题，先说浅拷贝。</p><p>说到浅拷贝，实际上是仅拷贝了列表中的一维元素，如果列表中存在二维元素或容器，则为引用而不是拷贝。使用<code>copy</code>函数或者<code>copy</code>模块中的<code>copy</code>函数拷贝的都是浅拷贝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>res = items.copy()<br><span class="hljs-built_in">print</span>(items, <span class="hljs-string">&#x27;\t&#x27;</span>, res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><code>copy()</code>之后的新列表和原列表内容上是一样的。</p><p>接着让我们来操作一下<code>copy</code>之后的<code>res</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>res = items.copy()<br><span class="hljs-keyword">del</span> res[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(items)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>可以看到，对<code>res</code>进行操作完全不影响原列表的内容。这就说明，<code>copy</code>产生的新列表和原列表并不是一个列表，我们可以验证一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><br>---<br><span class="hljs-number">4636359872</span><br><span class="hljs-number">4636086464</span><br></code></pre></td></tr></table></figure><p>当我们用<code>id()</code>函数的时候，可以看到他们是两个完全不同的<code>id</code></p><p>刚才我们定义的<code>items</code>是一个一维列表，接着让我们再来定义一个多维列表来尝试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>res = items.copy()<br><span class="hljs-keyword">del</span> res[<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(items)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>我们可以看到，做删除操作之后，<code>res</code>内容变了，但是原列表<code>items</code>没变化。似乎和之前的并没有什么不同，让我们再继续试试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> res[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>发生了什么？我们明明是操作的<code>res</code>而不是原列表<code>items</code>，为什么<code>items</code>也发生了变化？难道是<code>id</code>是相同的吗？来，试试就知道了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><br>---<br><span class="hljs-number">4636427264</span><br><span class="hljs-number">4636085824</span><br></code></pre></td></tr></table></figure><p>似乎并不相同。那既然不是同一个元素，为什么我们操作<code>res</code>的时候，<code>items</code>也会跟着一起变化？</p><p>别着急，让我们接着看下面的操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items[<span class="hljs-number">4</span>])) <span class="hljs-comment"># items这个位置是列表[&#x27;a&#x27;, &#x27;c&#x27;]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res[<span class="hljs-number">3</span>])) <span class="hljs-comment"># res这个位置是列表[&#x27;a&#x27;, &#x27;c&#x27;]</span><br><br>---<br><span class="hljs-number">4635245952</span><br><span class="hljs-number">4635245952</span><br></code></pre></td></tr></table></figure><p>如何，一模一样对吧？这就说明，在<code>items</code>以及它的copy列表<code>res</code>中，这个嵌套的列表是同一份。这也就能解释为什么我们对<code>res</code>内的嵌套列表进行操作的时候,<code>items</code>也发生了变化。</p><p>这个就是我们在一开始说到的，<code>copy</code>仅仅是拷贝了列表中的一维元素，对二维元素和容器仅仅是引用，这个应用对象当然还是原来那个对象。所以，两者的<code>id</code>才是是同一个。</p><p>浅拷贝我们理解完之后，才看看什么是深拷贝。</p><p>深拷贝和浅拷贝比起来就有深度的多，嗯，这么讲是因为深拷贝不仅仅是拷贝了当前的列表，同时还把列表中的多维元素或容易也拷贝了一份，而不是像浅拷贝一样仅仅是引用。完成深拷贝的函数是<code>copy</code>模块中的<code>deepcopy</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>res = items.deepcopy()<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;list&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;deepcopy&#x27;</span><br></code></pre></td></tr></table></figure><p>额，尴尬。居然报错了...似乎<code>deepcopy</code>并不是和<code>copy</code>函数一样的用法。</p><p>细心的小伙伴应该之前就注意到了，在介绍<code>copy</code>函数和<code>deepcopy</code>函数的时候，我都在强调是<code>copy</code>模块中的这句话，确实，我们在使用<code>deepcopy</code>的时候，是需要先引用模块再使用的，并且，使用方式也有一些不同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>res = copy.deepcopy(items)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>没错，我们这就对<code>items</code>完成了深拷贝，生成了新的列表<code>res</code>。</p><p>那到底是否是真的深拷贝呢？让我们试一试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items[<span class="hljs-number">3</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res[<span class="hljs-number">3</span>]))<br><br>---<br><span class="hljs-number">4636282048</span><br><span class="hljs-number">4634799872</span><br><span class="hljs-number">4636285120</span><br><span class="hljs-number">4637491072</span><br></code></pre></td></tr></table></figure><p>没问题，我们打印出来的<code>id</code>各不一样，包括<code>items</code>内的二维列表以及<code>res</code>内的二维列表，<code>id</code>也都不同，说明确实是深拷贝。</p><p>不放心的小伙伴，我们再来更改列表元素测试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> res[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]<br><br><span class="hljs-built_in">print</span>(res[<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(items[<span class="hljs-number">3</span>])<br><br>---<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，当我们更改<code>res</code>内的二维列表时，<code>items</code>并未发生改变。说明二维列表我们也一样完成了拷贝，而不是像浅拷贝一样仅是引用了。</p><h2 id="列表推导式">列表推导式</h2><p>在本文最开始，我们介绍列表的时候提过三种列表生成方式，包括直接定义列表,用<code>list</code>函数，最后一个就是列表推导式。那我们接下来，就要详细讲讲列表推导式。</p><p>列表推导式提供了一个更简单的创建列表的方法，常见的用法是把某种操作应用于序列或可迭代的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。</p><p>采用一种表达式的当时，对数据进行过滤或处理，并且把结果组成一个新的列表。</p><p>哎，最怕就是定义和文字过多，让我们直接上示例吧。</p><h3 id="基本的列表推导式使用方式">基本的列表推导式使用方式</h3><p><code>结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据]</code></p><p>现在，假设我们想要创建一个平方列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用普通方法完成</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    items.append(i**<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p>这是用我们所学过的内容来进行创建，当然，我们还学过另外一种方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 map函数和list完成</span><br>items = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p>这里似乎有一点复杂，咱们还是来分析一下吧。</p><p>首先，我们创建了一个匿名函数<code>lambda x:x**2</code>,再创建了一个可迭代对象<code>range(10)</code>。</p><p>接着，我们给<code>map</code>函数传入了这两个参数，分别传给了<code>func</code>和<code>*iterables</code>,关于<code>map</code>函数，我们在第七节：内置函数中有讲解过，完了的小伙伴可以翻看前面复习一下。</p><p><code>map</code>函数在对传入的可迭代数据中的每一个元素进行处理，然后返回一个新的迭代器,最后用<code>list</code>函数将这个新的迭代器转换成了一个列表。</p><p>然后，我们将传入的<code>func</code>函数用一个匿名函数</p><p>没错，我们使用<code>map</code>函数和<code>list</code>也可以进行实现。</p><p>那么最后，让我们来看看列表推导式如何完成这个需求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表推导式</span><br>items = [i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p>简简单单一句话，比用<code>map</code>函数更简单的逻辑，就完成了我们的需求。这一句话的代码其实逻辑桁清晰，也很好理解：</p><p>首先，我们用<code>for</code>来进行循环传值给<code>i</code>，接着，我们用<code>i**2</code>来得到我们期望的值，最后生成列表。本质上，其实和我们用的第一种普通方法是一样的。</p><p>接着我们再来看一个， 我们现在有一个字符串<code>'1234'</code>，想要得到这样一个列表<code>[2, 4, 6, 8]</code>。照例，从普通方法开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通方法</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;1234&#x27;</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>:<br>    items.append(<span class="hljs-built_in">int</span>(i)*<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>OK，没问题。我们继续：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>items = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">int</span>(x)*<span class="hljs-number">2</span>, <span class="hljs-built_in">str</span>))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>可以看到，我们先将<code>items</code>清空之后再继续操作的，这次我们用了<code>list</code>+<code>map</code>的方式，一样得到了我们想要的结果。</p><p>最后，当然是用列表推导式的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>items = [<span class="hljs-built_in">int</span>(i)*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>同样，我们得到了想要的结果。</p><p>讲到这里了，我给大家秀一个小技巧，俗称骚操作，就是我们其实可以运用位运算操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>items = [<span class="hljs-built_in">int</span>(i) &lt;&lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>具体代码执行的时候发生了什么，就算是给大家留个小思考题。<strong>提示：可以回头翻看下我们之前讲到的位运算符。</strong></p><h3 id="带有判断条件的列表推导式">带有判断条件的列表推导式</h3><p>除了基本的列表推导式，我们还有一种带有判断条件的列表推导式。</p><p><code>结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据 条件表达式]</code></p><p>相比起基本的列表推导式，我们现在多了一个<code>条件表达式</code>，那么我们该怎么利用呢？来个需求：从0~9，求所有的偶数并且形成一个新的列表。这回，我们就只完成常规方法和列表推导式，对比着来观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常规方式</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        items.append(i)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>很好，我们完成了需求。接下来，大家试试不看我下面写的代码，自己从常规方式思考下该怎么写，然后自己运行一下试试写对了没，最后，再和我写的对比一下看看咱们写的有没有区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>没错，就是这么简单，你做对了吗？</p><h3 id="带有条件判断的多循环推导式">带有条件判断的多循环推导式</h3><p>现在有这样一个需求，我们拿到两个列表<code>[1,2,3], [3,1,4]</code>,要将这两个列表中的元素两两组合，要求组合的元素不能重复：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常规方法</span><br>items = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:<br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]:<br>        <span class="hljs-keyword">if</span> x != y:<br>            items.append((x,y))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]<br></code></pre></td></tr></table></figure><p>这样，我们就完成了刚才的需求。那用推导式该如何实现呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">if</span> x != y]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]<br></code></pre></td></tr></table></figure><p>没毛病，我们完全实现了刚才的需求。这个很好理解对吧？</p><p>让我们接着来看最后一个推导式的形式。</p><h3 id="对于嵌套循环的列表推导式">对于嵌套循环的列表推导式</h3><p>这次我们直接写需求，然后上示例。</p><p>需求为，现在我们有一个3x4的矩阵，由3个长度为4的列表组成，我们现在要交换其行和列。</p><p><strong>注意哦，这个行转列需求在处理数据的时候经常会用到。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"># 需求样例<br>&#x27;&#x27;&#x27;<br>[<br><span class="hljs-code">    [1, 2, 3, 4],</span><br><span class="hljs-code">    [5, 6, 7, 8],</span><br><span class="hljs-code">    [9, 10, 11, 12]</span><br>]<br><br>==&gt;<br><br>[<br><span class="hljs-code">    [1, 5, 9],</span><br><span class="hljs-code">    [2, 6, 10],</span><br><span class="hljs-code">    [3, 7, 11],</span><br><span class="hljs-code">    [4, 8, 12]</span><br>]<br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><p>来，让我们尝试着实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先，定义初始数据，大家可以直接copy我给到的矩阵数据</span><br><br><span class="hljs-comment"># 先定义数据</span><br>arr = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]<br>]<br><br><span class="hljs-comment"># 使用常规方法</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    res = []<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr:<br>        res.append(row[i])<br>    items.append(res)<br><span class="hljs-built_in">print</span>(items)<br><br><span class="hljs-comment"># 使用列表推导式, 我们从内向外来写</span><br>items = [[row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]]<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]]<br><br></code></pre></td></tr></table></figure><p>这样，我们就完成了刚才的需求。我们拆解呢，还是从外层开始讲起：</p><p>首先，因为我们发现数据是4列，所以我们设定了一个<code>range(4)</code>来进行4次迭代，将<code>0,1,2,3</code>这四个下标分别传到内层循环。</p><p>然后我们开始在<code>arr</code>内循环找到当前的<code>row</code>,循环会依次去寻找<code>[1,2,3,4]，[5,6,7,8],[9,10,11,12]</code>。然后将每一个<code>row</code>中的寻找当前的<code>row[i]</code>，并且填入一个新列表内。那么这三组列表中的<code>row[i]</code>就会是这样的：</p><p><code>row[1]</code>分别为<code>1, 5, 9</code>,<code>row[2]</code>分别为<code>2, 6, 10</code>....依次类推。当外层循环完成之后，就正好是组成了新的四个新的列表，最后再将新列表依次传到<code>items</code>这个空列表内，就完成了。</p><p>那同样都是两次<code>for</code>循环嵌套，为什么上面那个案例就是顺序写的，内层<code>for</code>循环写在了后面，而下面这个案例的内层<code>for</code>循环就写到了前面呢？</p><p>好的，让我们来看看，如果将下面这个案例的内存<code>for</code>循环写在后面会是怎样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [row[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr]<br>items<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><p>看到了吗？顺序还是对的，只是依次传入了数据，并未形成矩阵。那有小伙伴就说了，那是不是因为没在<code>row[i]</code>上加<code>[]</code>从而形成列表呢？</p><p>好的，让我们再来做一个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [[row[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr]<br>items<br><br>---<br>[[<span class="hljs-number">1</span>], [<span class="hljs-number">5</span>], [<span class="hljs-number">9</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">6</span>], [<span class="hljs-number">10</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">7</span>], [<span class="hljs-number">11</span>], [<span class="hljs-number">4</span>], [<span class="hljs-number">8</span>], [<span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure><p>可以看到，列表是形成了，但是却是一个元素占一个列表，并没形成我们想要的矩阵。</p><p>估计小伙伴们看出来了，在推导式中，因为<code>变量或变量的处理结果</code>必须放在前面，所以我们为了要形成矩阵内层新的<code>row</code>，所以才必须将<code>处理结果</code>和内层循环方法放在一起，并加上<code>[]</code>来确保这组结果能形成一个列表,也就是我们现在这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [[row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>items<br><br>---<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure><p>看一次没看懂的小伙伴，可以多看看，尝试着自己去分解，将其理解透彻。因为这个方法在我们后续的数据清洗中使用非常频繁。</p><h2 id="小练习">小练习</h2><blockquote><ol type="1"><li>为了能达到练习的目的，从这一节开始，所有练习可以不在课程中展示了。大家先做一下，然后可以在我下一节课中的源码中去找答案，然后来看看和自己做的是否一样。</li><li>以下所有练习必须使用列表推导式来实现</li><li>有些练习不止一个方法，大家尝试用多种方法来实现一下。</li><li>做完的小伙伴可以在课程后面留言讨论。</li></ol></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1. 让我们尝试将字典中的健值对转成`key = value`的数据格式</span><br>&#123;<span class="hljs-string">&#x27;user&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;phone&#x27;</span>:<span class="hljs-string">&#x27;133&#x27;</span>&#125; 转为 [<span class="hljs-string">&#x27;user=admin&#x27;</span>,<span class="hljs-string">&#x27;age=20&#x27;</span>,<span class="hljs-string">&#x27;phone=133&#x27;</span>]<br><br><span class="hljs-comment"># 2. 把列表中的所有字符全部转为小写</span><br>[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>, <span class="hljs-string">&#x27;SHIss&#x27;</span>, <span class="hljs-string">&#x27;Sipoa&#x27;</span>,<span class="hljs-string">&#x27;Chaheng&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;dsAhio&#x27;</span>]<br><br><span class="hljs-comment"># 3. x是0～5之间的偶数，y是0~5之间的奇数，把x，y组成一个元组，放到列表中</span><br><br><span class="hljs-comment"># 4. 使用列表推导式完成九九乘法表</span><br><br><span class="hljs-comment"># 5. 求M, N中矩阵和元素的乘积</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">M = [</span><br><span class="hljs-string">    [1, 2, 3],</span><br><span class="hljs-string">    [4, 5, 6],</span><br><span class="hljs-string">    [7, 8, 9]</span><br><span class="hljs-string">]</span><br><span class="hljs-string"></span><br><span class="hljs-string">N = [</span><br><span class="hljs-string">    [2, 2, 2],</span><br><span class="hljs-string">    [3, 3, 3],</span><br><span class="hljs-string">    [4, 4, 4]</span><br><span class="hljs-string">]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br></code></pre></td></tr></table></figure><p>最后，大家记得做练习并且留言，下课。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807211708.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;最近几节课，我们都是在详细讲解Python内的数据类型，上一节课我们详细了解了字符串，这节课，让我们来详解一下列表。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>8. 数据类型 - 字符串详解</title>
    <link href="https://hivan.me/Detailed-of-string/"/>
    <id>https://hivan.me/Detailed-of-string/</id>
    <published>2023-08-05T03:28:07.000Z</published>
    <updated>2023-08-07T13:15:13.169Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807211459.png?imgNote"alt="茶桁的AI秘籍 Python - String" /></p><p>Hi, 大家好。我是茶桁。</p><p>前几节课中我们学习了函数，那么这节课开始，我们花几节课返过头来详细的学习一下Python内的数据类型。第一节课，让我们先从字符串开始：</p><span id="more"></span><ul><li>回顾字符串的定义方式</li><li>了解转义字符</li><li>字符串格式化的方法</li><li>字符串相关函数</li></ul><h2 id="字符串的定义方式">字符串的定义方式</h2><ol type="1"><li>单引号定义字符串 <code>‘ ’</code></li><li>双引号定义字符串<code>“ ”</code></li><li>三引号定义字符串<code>‘’‘内容’‘’</code>或者<code>“”“内容”“”</code></li><li>字符串定义时，引号可以互相嵌套</li></ol><h2 id="转义字符">转义字符</h2><blockquote><p>一个普通的字符出现在转义符<code>\</code>的后面时，实现了另外一种意义。</p></blockquote><ul><li><code>\</code> 转义符，续行符。</li></ul><p>作为转义符时，在<code>\</code>后面出现的字符可能会实现另外一种意义。</p><p>作为续行符时，在行尾使用了<code>\</code>后，可以换行继续书写内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;123&#x27;</span>\<br>    <span class="hljs-string">&#x27;456&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br><span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>打印结果看，并未换行，说明续行符起作用了。</p><ul><li><code>\n</code> 代表一个换行符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;岁月是一把杀猪刀， \n但是它拿长得丑的人一点办法都没有。&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>岁月是一把杀猪刀， <br>但是它拿长得丑的人一点办法都没有。<br></code></pre></td></tr></table></figure><ul><li><code>\r</code>代表光标位置（从<code>\r</code>出现的位置开始作为光标的起点）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;岁月是一把杀猪刀， \r但是它拿长得丑的人一点办法都没有。&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>但是它拿长得丑的人一点办法都没有。<br></code></pre></td></tr></table></figure><ul><li><code>\t</code>代表一个水平制表符（table 缩进）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;岁月是一把杀猪刀\t但是它拿长得丑的人一点办法都没有。&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>岁月是一把杀猪刀但是它拿长得丑的人一点办法都没有。<br></code></pre></td></tr></table></figure><ul><li><code>\b</code> 代表一个退格符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;岁月是一把杀猪刀\b但是它拿长得丑的人一点办法都没有。&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>岁月是一把杀猪但是它拿长得丑的人一点办法都没有。<br></code></pre></td></tr></table></figure><p>注意看，并不是毫无改变的打印出来了，整句话中<code>\b</code>前面的<code>刀</code>这个字被退格了。</p><ul><li><code>\\</code>反转义<code>\</code>，输出了<code>\</code>，取消<code>\</code>的转义效果</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;岁月是一把杀猪刀\\n但是它拿长得丑的人一点办法都没有。&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>岁月是一把杀猪刀\n但是它拿长得丑的人一点办法都没有。<br></code></pre></td></tr></table></figure><p>第二个<code>\</code>被前面的<code>\</code>转义了，所以<code>n</code>就不会再被转义，也就没有换行。</p><ul><li><code>r</code>，如果我们想把转义字符也作为普通字符输出，那我们可以在字符串的最前面加上<code>r</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">r&quot;岁月是一把杀猪刀\n但是它拿长得丑的人一点办法都没有。&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>岁月是一把杀猪刀\n但是它拿长得丑的人一点办法都没有。<br></code></pre></td></tr></table></figure><p>字符串内的转移字符<code>\n</code>被打印了出来。</p><h2 id="字符串相关的操作">字符串相关的操作</h2><ul><li>字符串<code>+</code>操作,将参与运算的字符串相加后组成一个新的字符串。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>=<span class="hljs-string">&quot;君不见，黄河之水天上来，奔流到海不复回。&quot;</span><br>str2 = <span class="hljs-string">&quot;君不见，高堂明镜悲白发，朝如青丝暮成雪。&quot;</span><br>res = <span class="hljs-string">&#x27;将进酒\n&#x27;</span>+ <span class="hljs-built_in">str</span> + <span class="hljs-string">&#x27;\n&#x27;</span> + str2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>将进酒<br>君不见，黄河之水天上来，奔流到海不复回。<br>君不见，高堂明镜悲白发，朝如青丝暮成雪。<br></code></pre></td></tr></table></figure><ul><li>字符串<code>*</code>操作，<code>str*n</code>就是将当前字符串重复<code>n</code>遍</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;重要的话说三遍\n&#x27;</span> * <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>重要的话说三遍<br>重要的话说三遍<br>重要的话说三遍<br></code></pre></td></tr></table></figure><ul><li>字符串<code>[]</code>切片操作</li></ul><p>字符串的索引操作，字符串中只能使用<code>[]</code>下标访问，不能修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>[start:stop:step]<br>功能，获取<span class="hljs-built_in">str</span>的特定下标或者对<span class="hljs-built_in">str</span>进行切片操作<br>参数：<br>start: 可选，开始值，默认为<span class="hljs-number">0</span><br>  stop: 可选，结束值，默认为<span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)<br>  step：可选，步进值，默认为<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>因为所有参数都是可选项，所以其实我们可以什么参数都不给，直接使用默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;凡诗之所谓风者，多出于里巷歌谣之作，所谓男女相与咏歌，各言其情者也。&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><span class="hljs-comment"># 等同于</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[::])<br><br>---<br>凡诗之所谓风者，多出于里巷歌谣之作，所谓男女相与咏歌，各言其情者也。<br>凡诗之所谓风者，多出于里巷歌谣之作，所谓男女相与咏歌，各言其情者也。<br></code></pre></td></tr></table></figure><p>当我们写一个值，那就是获取指定下标的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">6</span>])<br><br>---<br>者<br></code></pre></td></tr></table></figure><p>但是当我们只写一个值，并且后面跟上符号<code>::</code>,那含义就是从<code>start</code>开始，向后取完：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">6</span>::])<br><br>---<br>者，多出于里巷歌谣之作，所谓男女相与咏歌，各言其情者也。<br></code></pre></td></tr></table></figure><p>从这我们可以看出来，当我们只写一个单独的值而没有加<code>::</code>的时候，含义就是从<code>start</code>开始，但是并不向后继续取值，而有了<code>::</code>就是继续向后取值。其实，只写一个<code>:</code>也是一样的，因为只要知道向后取值，<code>step</code>默认值就是为<code>1</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">6</span>:])<br><br>---<br>者，多出于里巷歌谣之作，所谓男女相与咏歌，各言其情者也。<br></code></pre></td></tr></table></figure><p>那如果我们在这个基础上加上一个值，那就是从<code>start</code>开始直到<code>stop</code>之前。和<code>range()</code>一样，取不到<code>stop</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>])<br><br>---<br>之所谓风<br></code></pre></td></tr></table></figure><p>然后再多加一个值，和<code>range()</code>一样，就是往后数<code>step</code>个数再取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>:<span class="hljs-number">15</span>:<span class="hljs-number">2</span>])<br><br>---<br>之谓者多于巷谣<br></code></pre></td></tr></table></figure><p>其实，这里比较饶的并不是如何取值，二是<code>::</code>这两个符号。当我们将上面讲的这些内容了解通透后，就可以玩转字符串的切片了。</p><p>那对应的，如果我们想将字符串完全取值，但是是隔一个取一个，那我们就可以使用<code>start</code>和<code>stop</code>的默认值，而只定义<code>step</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[::<span class="hljs-number">2</span>])<br><br>---<br>凡之谓者多于巷谣作所男相咏，言情也<br></code></pre></td></tr></table></figure><p>那如果我们想让整个字符串倒过来呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[::-<span class="hljs-number">1</span>])<br><br>---<br>。也者情其言各，歌咏与相女男谓所，作之谣歌巷里于出多，者风谓所之诗凡<br></code></pre></td></tr></table></figure><h2 id="字符串的格式化方法">字符串的格式化方法</h2><p>常用的字符串的格式化方法就是<code>format()</code></p><p>先让我们看看最普通的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;茶桁&#x27;</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;乘舟将欲行，忽闻岸上踏歌声。&#x27;</span><br></code></pre></td></tr></table></figure><p>我定义了这两个字符串，现在我想将两段字符串合在一起变成一句“<strong>茶桁乘舟将欲行，忽闻岸上踏歌声。</strong>”（嗯，权吾乃青蓮居士。）</p><p>很多小伙伴是不是觉得太简单了，我们之前学了<code>+</code>号，直接拼接不就好了。自然也是可以的，只是我们现在要用更普遍和便捷的方式来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;茶桁&#x27;</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#123;&#125;乘舟将欲行，忽闻岸上踏歌声。&#x27;</span>.<span class="hljs-built_in">format</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>茶桁乘舟将欲行，忽闻岸上踏歌声。<br></code></pre></td></tr></table></figure><p>假如说，我们现在只有诗词的大半句，其中少了<strong>踏歌行</strong>这三个字，那我们又该如何？那我们就往<code>format</code>中传入两个参数，后面那个参数自定义出这三个字符就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;茶桁&#x27;</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#123;&#125;乘舟将欲行，忽闻岸上&#123;&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(s, <span class="hljs-string">&quot;踏歌行&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>茶桁乘舟将欲行，忽闻岸上踏歌行。<br></code></pre></td></tr></table></figure><p>看到这里，我们是不是认为字符串使用<code>format</code>就只能顺序传值？第一个答案填入第一个空，第二个答案填入第二个空...其实不只是如此，字符串后使用<code>format</code>，其中的<code>&#123;&#125;</code>还可以接受索引传参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;茶桁&#x27;</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#123;1&#125;乘舟将欲行，忽闻岸上&#123;0&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&quot;踏歌行&quot;</span>, s)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>茶桁乘舟将欲行，忽闻岸上踏歌行。<br></code></pre></td></tr></table></figure><p>通过索引传参的适用范围毕竟还是有限，我们很容易一不小心就会把参数顺序搞乱。那还有没有其他办法呢？</p><p>我们还可以通过关键字传参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#123;s2&#125;乘舟将欲行，忽闻岸上&#123;s1&#125;。&#x27;</span>.<span class="hljs-built_in">format</span>(s1 = <span class="hljs-string">&quot;踏歌行&quot;</span>, s2 = <span class="hljs-string">&quot;茶桁&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>茶桁乘舟将欲行，忽闻岸上踏歌行。<br></code></pre></td></tr></table></figure><p>那假如说我们得到的是一个列表数据，是否需要先转换数据？其实也没必要，<code>format</code>支持对容器型数据的传参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;豪放派：&#123;0[0]&#125;，婉约派：&#123;0[1]&#125;，流氓派:&#123;0[3]&#125;,蛋黄派：&#123;0[2]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>([<span class="hljs-string">&#x27;李白&#x27;</span>,<span class="hljs-string">&#x27;辛弃疾&#x27;</span>,<span class="hljs-string">&#x27;达利园&#x27;</span>,<span class="hljs-string">&#x27;茶桁&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>豪放派：李白，婉约派：辛弃疾，流氓派:茶桁,蛋黄派：达利园<br></code></pre></td></tr></table></figure><p>那么如果是字典类型的呢？那就更简单了，我们之前提到的关键字传参，不就正好对应字典吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-string">&#x27;蛋黄派&#x27;</span>&#125;<br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;&#123;a&#125;乘舟将欲行，忽闻岸上&#123;b&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">dict</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>茶桁乘舟将欲行，忽闻岸上蛋黄派<br></code></pre></td></tr></table></figure><p>嗯，不错。似乎我们创建了一句新的诗句。</p><p>其实，<code>format</code>还有其他的用法，就是直接用关键字<code>f</code>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dict</span>[<span class="hljs-string">&quot;a&quot;</span>]&#125;</span>乘舟将欲行，忽闻岸上<span class="hljs-subst">&#123;<span class="hljs-built_in">dict</span>[<span class="hljs-string">&quot;b&quot;</span>]&#125;</span>&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>茶桁乘舟将欲行，忽闻岸上蛋黄派<br></code></pre></td></tr></table></figure><p><code>f</code>是在3.7版本中新增的格式化方法，在使用的过程中，要注意字符串符号<code>“”</code>和<code>‘’</code>的嵌套关系。</p><p>在基本使用之外，我们还有一些风骚的特殊用法，比如，我们可以用<code>format</code>直接限定小数的位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;圆周率是多少：&#123;:.5f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-number">3.1415926</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>圆周率是多少：<span class="hljs-number">3.14159</span><br></code></pre></td></tr></table></figure><h2 id="字符串相关函数">字符串相关函数</h2><p>在Python中，字符串应该是最常见的数据类型，对应字符串的函数也有不少。大家可以去看看<ahref="https://docs.python.org/zh-cn/3.10/library/stdtypes.html#text-sequence-type-str">官方的文档</a></p><h3 id="英文字符与字符检测相关函数">英文字符与字符检测相关函数</h3><p>我们可以返回字符串的副本，并且将首字母大写，其余小写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;I am a data product manager&#x27;</span><br><span class="hljs-built_in">str</span>.capitalize()<br><br>---<br><span class="hljs-string">&#x27;I am a data product manager&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>因为我在使用JupyterNotebook，所以即便我么有使用<code>print</code>，依然可以打印出执行结果。只是仅可以打印最后一个执行的函数。</p></blockquote><p>可以把字符串中的一个单词的首字母大写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.title()<br><br>---<br><span class="hljs-string">&#x27;I Am A Data Product Manager&#x27;</span><br></code></pre></td></tr></table></figure><p>可以全部改为大写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.upper()<br><br>---<br><span class="hljs-string">&#x27;I AM A DATA PRODUCT MANAGER&#x27;</span><br></code></pre></td></tr></table></figure><p>把字符串全部改为小写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.lower()<br><br>---<br><span class="hljs-string">&#x27;i am a data product manager&#x27;</span><br></code></pre></td></tr></table></figure><p>字符串中的大小写字符转换，大写转小写，小写转大写:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.swapcase()<br><br>---<br><span class="hljs-string">&#x27;i AM A DATA PRODUCT MANAGER&#x27;</span><br></code></pre></td></tr></table></figure><p>检测字符是否包含在字符串内：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;o&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;love&#x27;</span>)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>检测字符串是否为全部大写字母组成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.isupper()<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>检测字符串是否为全部小写字母组成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.islower()<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>检测字符串是否符合标题<code>title</code>的要求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.istitle()<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>检测字符串是否由数字和字母组成，如果字符串中包含来非数字字母的其它字符，则返回False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.isalnum()<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>检测字符串是否全部由字符(包含英文字符和中文)组成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.isalpha()<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>检测字符串是否由纯数字字符组成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;123&#x27;</span>.isdigit()<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>检测当前字符串是否为 空格 字符组成 ' ’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27; &#x27;</span>.isspace()<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>检测字符串是否以指定的字符开始的，也可以指定开始和结束的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.startswith(<span class="hljs-string">&#x27;I&#x27;</span>)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.startswith(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>检测字符串是否以 指定的字符 结束的，也可以指定开始和结束的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.endswith(<span class="hljs-string">&#x27;a&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.endswith(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.endswith(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>))<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="字符串的查找和操作相关函数-重点">字符串的查找和操作相关函数（✨重点）</h3><p>前面铺垫了那么多之后，接下来这部分，<strong>才是这一节的重点。</strong></p><p>让我们先从查找来看：</p><p><code>str.find(sub[, start[, end]])</code></p><p><code>find</code>会返回一个子字符串，找到字符中符合条件的第一个字符出现的索引位置，未找到则返回<code>-1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;I am a data product manager.&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;am&#x27;</span>))<br><br>---<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>让我们用切片的方式反过来找一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;am&#x27;</span>)<br><span class="hljs-built_in">str</span>[res:res+<span class="hljs-number">2</span>]<br><br>---<br><span class="hljs-string">&#x27;am&#x27;</span><br></code></pre></td></tr></table></figure><p>我们从之前可以知道<code>res</code>取值为<code>2</code>，现在等于是<code>str[2:4]</code>，正好是<code>am</code>所在的位置。</p><p><code>find</code>中有<code>start</code>和<code>end</code>，是支持切片查找的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;am&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.find(<span class="hljs-string">&#x27;am&#x27;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>))<br><br>---<br><span class="hljs-number">2</span><br>-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，在从4开始找到10的时候找不到<code>am</code>,<code>find</code>有一个功能相同，但是方向不同的方法<code>rfind()</code>,和<code>find</code>的不同点只是，<code>rfind</code>是从后往前找的。</p><p><code>str.index(sub[, start[, end]])</code></p><p>类似于<code>find()</code>，但在找不到子字符串的时候会引发<code>ValueError</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.index(<span class="hljs-string">&#x27;python&#x27;</span>)<br><br>---<br>ValueError: substring <span class="hljs-keyword">not</span> found<br></code></pre></td></tr></table></figure><p><code>str.count(sub[, start[, end]])</code></p><p>这个函数会在字符串中去查找<code>sub</code>在其中<code>[start, end]</code>范围内非重叠出现的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.count(<span class="hljs-string">&#x27;a&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>.count(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">12</span>))<br><br>---<br><span class="hljs-number">6</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>接下来让我们看看字符串操作相关的函数：</p><p><code>str.split(sep=None, maxsplit=-1)</code></p><p>这个方法可以按照指定的分隔符(<code>sep</code>)，把字符串分隔成列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;user_admin_id_123&#x27;</span><br><span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27;_&#x27;</span>)<br><br>---<br>[<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>]<br></code></pre></td></tr></table></figure><p>整个方法里的<code>maxsplit</code>是进行多少次拆分，比如<code>1</code>为一次拆分，也就是会返回2个元素。默认值为<code>-1</code>，意思是不限制拆分次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.split(<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-number">1</span>)<br><br>---<br>[<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin_id_123&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>str.rsplit(sep=None, maxsplit=-1)</code></p><p>和<code>split</code>方法相似，只是方向不同。这个是从后向前获取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.rsplit(<span class="hljs-string">&#x27;_&#x27;</span>)<br><br>---<br>[<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这段代码可以看到功能上是完全一样的，如果我们把<code>maxsplit</code>加进去，就能看到方向上的不同：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.rsplit(<span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-number">1</span>)<br><br>---<br>[<span class="hljs-string">&#x27;user_admin_id&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样就能清晰看到，<code>rsplit</code>是从后面开始拆分的。</p><p><code>str.join(iterable)</code></p><p><code>join</code>的功能和<code>split</code>可以看成是相反的，是使用指定的字符串，把一个容器中的元素连接成一整个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = [<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>]<br><span class="hljs-string">&#x27;_&#x27;</span>.join(<span class="hljs-built_in">str</span>)<br><br>---<br><span class="hljs-string">&#x27;user_admin_id_123&#x27;</span><br></code></pre></td></tr></table></figure><p><code>str.strip([chars])</code></p><p>去除字符串左右两侧的指定字符,<code>chars</code>参数为置顶要溢出字符的字符串，默认移除空白符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27; chaheng &#x27;</span><br><span class="hljs-built_in">str</span>.strip(<span class="hljs-string">&#x27; &#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;chaheng&#x27;</span><br></code></pre></td></tr></table></figure><p>这个函数有两个伴生函数，一个是<code>rstrip</code>，从方法名应该能猜的出来，这是去掉字符串右侧的指定字符，另一个是<code>lstrip</code>，这是去除左侧的指定字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span>.rstrip(<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">str</span>.lstrip(<span class="hljs-string">&#x27; &#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27; chaheng&#x27;</span><br><span class="hljs-string">&#x27;chaheng &#x27;</span><br></code></pre></td></tr></table></figure><p><code>len()</code>函数可以获取当前字符串的长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>)<br><br>---<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><code>str.replace(old, new[, count])</code></p><p>可以替换对应的字符串，将<code>old</code>都替称为<code>new</code>。<code>count</code>则是替换次数。比如一个字符串内出现了十次<code>old</code>，我`<code>count</code>给的5,则只替换前5次出现的<code>old</code>字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;abcabcabcabcabcabc&#x27;</span><br><span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-built_in">str</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">2</span>)<br><br>---<br><span class="hljs-string">&#x27;ebcebcebcebcebcebc&#x27;</span><br><span class="hljs-string">&#x27;ebcebcabcabcabcabc&#x27;</span><br></code></pre></td></tr></table></figure><p>可以注意一下两次打印的区别。</p><p>这次就不留练习题了，字符串的查询和操作函数属于重中之重，大家最好是多去练习几遍，将其中的方法记会杯熟。</p><p>好，今天就到这里。咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807211459.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍 Python - String&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;前几节课中我们学习了函数，那么这节课开始，我们花几节课返过头来详细的学习一下Python内的数据类型。第一节课，让我们先从字符串开始：&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>7. Python的内置函数</title>
    <link href="https://hivan.me/python-Built-in-functions/"/>
    <id>https://hivan.me/python-Built-in-functions/</id>
    <published>2023-08-04T08:13:00.000Z</published>
    <updated>2023-08-10T10:58:51.773Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807211857.png?imgNote"alt="茶桁的AI秘籍-1" /></p><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>讲完了基础函数和高阶函数之后，我们这一节来研究下Python的内置函数，看看Python在安装完毕之后的解释器里，到底都预先给我们提供好了哪些可用的函数。</p><p>本节内容着重介绍一些常用函数，并且会做一些应用上的示例。当然，对于Python的内置函数，我们还可以查询官方文档，我这节参照的为<ahref="https://docs.python.org/zh-cn/3.10/">3.10版本文档</a></p><h2 id="range函数"><code>range()</code>函数</h2><p>这几节课中，我们频繁使用并且着重介绍过这个函数，那我们就从它开始介绍吧。</p><p>一般我们需要遍历一个数值序列的时候，<code>range()</code>函数就会派上用场，它生成算数级数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">range() 函数</span><br><span class="hljs-string">功能： 能够生成一个置顶的数值序列</span><br><span class="hljs-string">参数：</span><br><span class="hljs-string">    start: 开始的值，默认为0</span><br><span class="hljs-string">    stop: 结束的值</span><br><span class="hljs-string">    [, step]: 可选，步进值， 默认为1</span><br><span class="hljs-string">返回值： 可迭代的对象，数字序列</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">range</span>(start, stop, [, step])<br></code></pre></td></tr></table></figure><p>让我们来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>-----------------------------<br><span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;range&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到这其实就是一个<code>range</code>的类，其实在我们Python中，任何数据都是一个对象而已。</p><p>来看案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># range函数的使用方式</span><br>res = <span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>当我们的<code>range</code>内只写一个参数时，这个参数就是<code>stop</code>值，也就是从<code>start</code>的默认值0开始到输入的参数值（<code>stop</code>）之前为止，比如这段代码中，<code>stop</code>会结束到<code>11</code>之前，也就是<code>10</code>。</p><p>我们在这段代码中，将<code>range</code>的内容转化成一个<code>list</code>并打印了出来。当然，我们也可以使用循环，依次去除<code>range</code>内的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>  <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>  <br>-----------------------------<br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure><p>记得上节课我们提到过，<code>range()</code>是不支持<code>next()</code>函数的，不过如果我们将其转成迭代器，就可以使用<code>next()</code>函数调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">11</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>可以看到，使用<code>iter</code>转成迭代器之后，可以正常使用<code>next()</code>函数，并且我们再次查看<code>res</code>的内容，<code>0,1</code>已经被拿走，只将剩余内容转化为<code>list</code>打印了出来。</p><p>当我们在<code>range</code>中添加两个参数的时候，<code>start</code>就是第一个参数，第二个参数就是<code>stop</code>值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加两个参数</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br><br>-----------------------------<br><span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><p>当我们输入三个参数的时候，第一个参数为<code>start</code>,第二个参数为<code>stop</code>, 第三个参数就是<code>[, step]</code>，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加三个参数</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <br>-----------------------------<br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>这段代码的含义就是从<code>1</code>开始,以<code>3</code>为步进来提取数字，并打印出来，一直到<code>10</code>之前的数字为止。</p><p>如果不太理解步进值的可以执行数一遍就理解了，比如我们从<code>1</code>开始顺序往后数<code>3</code>个数，那就是2、3、<code>4</code>，数到了<code>4</code>,再继续往后数<code>3</code>个数，就是5、6、<code>7</code>，数到了<code>7</code>。再继续往后就是8、9、<code>10</code>。但是，我们代码中的<code>stop</code>值为<code>10</code>，所以到<code>9</code>就结束了，也就是说，我们这段代码就只取出了<code>1, 4, 7</code>三个值。</p><p>三种参数值的情况我们都了解之后我们可以思考下，难道我们只能选择顺序取值吗？其实不然，我们还可以倒叙取值，聪明的小伙伴可能想到了，调换一下<code>start</code>和<code>stop</code>值不就可以了嘛？我们从<code>10</code>开始取值，取到<code>0</code>为止：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><p>执行一下，哎，似乎什么都没打印出来。这又是为什么呢？是不是出BUG了？</p><p>其实，什么都没打印出来才是正确的，这是因为，虽然我们给了开始和结束值，但是我们遗忘了一个重要的参数，那就是步进值<code>step</code>，这个值默认可是<code>1</code>，从<code>10</code>开始<code>+1</code>来计数，无论如何也算不到<code>0</code>。所以，我们将步进值改成负数，也就是倒着数了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <br>-----------------------------<br><span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure><p>至此，我们可以得到结论，是否倒叙取值除了开始和结束值，更重要的是看<code>step</code>是正数还是负数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">range</span>(-<span class="hljs-number">10</span>,-<span class="hljs-number">20</span>,-<span class="hljs-number">1</span>) <br><span class="hljs-comment"># [-10, -11, -12, -13, -14, -15, -16, -17, -18, -19]</span><br>res = <span class="hljs-built_in">range</span>(-<span class="hljs-number">20</span>,-<span class="hljs-number">10</span>) <br><span class="hljs-comment"># [-20, -19, -18, -17, -16, -15, -14, -13, -12, -11]</span><br>res = <span class="hljs-built_in">range</span>(-<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br><span class="hljs-comment"># [-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h2 id="zip函数"><code>zip()</code>函数</h2><p><code>zip()</code>函数可以接受多个可迭代的对象，然后把每个可迭代对象中的第i隔元素组合在一起，形成一个新的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">参数： *iterables, 任意个的可迭代对象</span><br><span class="hljs-string">返回值： 返回一个元组的迭代器</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">zip</span>(*iterables)<br></code></pre></td></tr></table></figure><p>让我们来直接看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n1 = <span class="hljs-string">&#x27;1234&#x27;</span><br>n2 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>n3 = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br><span class="hljs-comment"># 调用zip函数，合成新的元组迭代器</span><br>res = <span class="hljs-built_in">zip</span>(n1, n2, n3)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>[(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>), (<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>), (<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>我知道你们看到这个执行结果会有很多疑问，先别着急，我们先看一下它是否包含迭代器的特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>  <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><p>当你执行这段代码的时候就会发现，似乎什么都没发生。</p><p>那到底是怎么回事？我们不用<code>for</code>，让我们再转换一次<code>list</code>之后看看里边有什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>[]<br></code></pre></td></tr></table></figure><p>列表居然是空的。是不是瞬间想到了什么？</p><p>没错，这个似乎就是迭代器的特性之一，当其中元素被使用之后，会删掉使用过的元素。而我们之前在执行<code>print(list(res))</code>的时候，已经将内部元素都转成<code>list</code>并展现过，所以现在<code>res</code>内的元素都被删掉了。</p><p>没事，让我们再重新来定义一次，也就是重新给<code>res</code>内填满元素然后直接<code>for</code>循环一次看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">n1 = <span class="hljs-string">&#x27;1234&#x27;</span><br>n2 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>n3 = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<br><span class="hljs-comment"># 调用zip函数，合成新的元组迭代器</span><br>res = <span class="hljs-built_in">zip</span>(n1, n2, n3)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>  <span class="hljs-built_in">print</span>(i)<br>  <br>-----------------------------：<br>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>)<br>(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)<br>(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们可以看到，每次打印<code>i</code>的时候都打印了一个元组，而这个元组就是一个新元素，比如第一行<code>('1', 'a', 'A')</code>,这整个元组就是一个新元素。</p><p>让我们再用<code>next</code>试试（当然我又重新填满了<code>res</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><br>-----------------------------<br>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;A&#x27;</span>)<br>(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>next</code>函数也能正常执行，那可以说明，<code>zip</code>确实组合成了一个新的迭代器。</p><p>现在我们返回来再看一遍代码中的<code>n1,n2,n3</code>,分别是<code>1234</code>, <code>[‘a’, 'b', 'c']</code>,<code>['A', 'B', 'C', 'D']</code>。最后组成的迭代器对象为：<code>[('1', 'a', 'A'), ('2', 'b', 'B'), ('3', 'c', 'C')]</code>。</p><p>通过分析可以看出来，<code>zip</code>的工作原理是先分别取可迭代对象的第一个元素组合成一个元组，然后再分别取第二个元素组合成一个元组，依次往后取...</p><p>可是<code>n1, n3</code>分别都是四个元素，为什么我们最后只组合成了三个元组？那是因为<code>n2</code>中只包含了三个元素，当在其中找不到第四个元素的时候，就会放弃组合。</p><p>来，让我们在看一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">n1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>n2 = [<span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>]<br>res = <span class="hljs-built_in">zip</span>(n1, n2)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>[(<span class="hljs-number">1</span>, <span class="hljs-number">22</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">33</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">44</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">55</span>)]<br></code></pre></td></tr></table></figure><p>大家看到最后的执行结果有没有觉得很眼熟？可能很多小伙伴一时间想不到，我们来调整一下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<br>(<span class="hljs-name">1</span>, <span class="hljs-number">22</span>), <br>(<span class="hljs-name">2</span>, <span class="hljs-number">33</span>), <br>(<span class="hljs-name">3</span>, <span class="hljs-number">44</span>), <br>(<span class="hljs-name">4</span>, <span class="hljs-number">55</span>)<br>]<br></code></pre></td></tr></table></figure><p>记住这个数据结构，我们在后期做数据分析的时候，当我们做矩阵运算的时候用的非常多。</p><p>不知道大家是否都学过高等数学里的线性代数、微积分，包括概率统计。这些在我们之后做数据分析，数据挖掘，包括机器学习、人工智能这些科学运算里面，非常重要的一些数学功底。</p><p>不太记得了也没关系，这些我后面将会专门拿几节出来给大家补一下这方面。</p><p>让我们继续，<code>zip</code>还有一种应用方式，当其与<code>*</code>运算符结合使用的时候，可以用来拆解列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># zip 与 * 运算符相结合使用</span><br>x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>y = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">zip</span>(x, y))<br><span class="hljs-built_in">print</span>(*<span class="hljs-built_in">zip</span>(x, y))<br><br>-----------------------------<br>&lt;<span class="hljs-built_in">zip</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107b8d200</span>&gt;<br>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>) (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>) (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>可以看到，<code>zip</code>是一个迭代器，<code>*zip</code>这生成了组合好的多个元组数据。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">x1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>y1 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><br>x2, y2 = <span class="hljs-built_in">zip</span>(*<span class="hljs-built_in">zip</span>(x, y))<br><span class="hljs-built_in">print</span>(x2, y2)<br><br>-----------------------------<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>这样，我们就将两个列表转换成了两个元组。当然，其实我们这样操作还不如直接使用<code>tuple</code>函数来的方便快捷一点。</p><p>那下面，我们就看看都有哪些数据类型转换相关的内置函数。</p><h2 id="数据类型转换相关的内置函数">数据类型转换相关的内置函数</h2><p>这些函数的功能非常简单和单一，属于拿来就用的函数，我们就仅列出来，不多做介绍了。</p><ul><li><code>int()</code> 将其它类型数据转为整型</li><li><code>float()</code>转为浮点类型</li><li><code>bool()</code>转为布尔类型</li><li><code>complex()</code>转为复数</li><li><code>str()</code>转为字符串类型</li><li><code>list</code> 转为列表类型</li><li><code>tuple</code>转为元组类型</li><li><code>dict</code> 转为字典类型</li><li><code>set</code> 转为集合类型</li></ul><h2 id="变量相关函数">变量相关函数</h2><ul><li><code>id()</code> 获取当前数据的ID标识</li><li><code>type()</code> 获取当前数据的类型字符串</li><li><code>print()</code>数据的打印</li><li><code>input()</code>获取输入的数据</li><li><code>isinstance()</code>检测是否为指定的数据类型</li></ul><h2 id="数学相关函数">数学相关函数</h2><p><code>abs()</code>获取一个数的绝对值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">abs</span>(-<span class="hljs-number">99.99</span>))<br><br>-----------------------------<br><span class="hljs-number">99.99</span><br></code></pre></td></tr></table></figure><p><code>sum()</code>求和 从 start 开始自左向右对 iterable中的项求和并返回总计值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br><br>-----------------------------<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><code>max()</code> 获取最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">99</span>,<span class="hljs-number">12</span>,<span class="hljs-number">45</span>))<br><br>-----------------------------<br><span class="hljs-number">3</span><br><span class="hljs-number">99</span><br></code></pre></td></tr></table></figure><p><code>min()</code> 获取最小值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>([<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,-<span class="hljs-number">9</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">2</span>))<br><br>-----------------------------<br>-<span class="hljs-number">9</span><br>-<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>pow(x, y)</code>幂运算 返回 x 的 y 次幂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br>      <br>-----------------------------<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><code>round(x, n)</code> 对x四舍五入，小数点保留n位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.1415926</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.1415926</span>,<span class="hljs-number">2</span>))<br><br>-----------------------------<br><span class="hljs-number">3</span><br><span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><blockquote><p><code>round</code>这个函数不是绝对意义上的四舍五入，在取整这个问题是是奇进偶退：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">4.5</span>))<br><br>-----------------------------：<br><span class="hljs-number">4</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="进制函数及字符集">进制函数及字符集</h2><p><code>bin()</code> 将数值类型转为二进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">123</span>)) <br><br>-----------------------------<br><span class="hljs-number">0b1111011</span><br></code></pre></td></tr></table></figure><p><code>int()</code> 将二进制转化为整型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-number">0b1111011</span>))<br><br>-----------------------------<br><span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><code>oct()</code> 转为八进制数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">123</span>))<br><br>-----------------------------<br><span class="hljs-number">0o173</span><br></code></pre></td></tr></table></figure><p><code>hex()</code> 转为十六进制数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">123</span>))<br><br>-----------------------------<br><span class="hljs-number">0x7b</span><br></code></pre></td></tr></table></figure><h2 id="ascii及字符集">ASCII及字符集</h2><p>ASCII，全称为美国信息互换标准代码。是一套基于拉丁字母的字符编码，共收录了128 个字符，用一个字节就可以存储，它等同于国际标准 ISO/IEC646。它一共有128个支付，最后更新是1986年。</p><p>我们要知道的是，ASCII编码是美国人给自己设计的，他们并没有考虑欧洲那些扩展的拉丁字母，也没有考虑韩语和日语，我大中华几万个汉字更是不可能被重视。计算机也是美国人发明的，起初使用的就是ASCII码，只能显示英文字符。各个国家为了让本国公民也能正常使用计算机，开始效仿ASCII 开发自己的字符编码，例如 ISO/IEC8859（欧洲字符集）、shift_Jis（日语字符集）、GBK（中文字符集）等。</p><p>从65开始到90为止，是大写字母（A ~ Z), 97到122是小写字母(a ~z)，48到57是0 ~ 9。</p><p>而我们经常使用的是GB2312-80, GBK和GBK18030以及Unicode字符集。</p><p>GB2312-80 是 1980 年制定的中国汉字编码国家标准。共收录 7445个字符，其中汉字 6763 个。</p><p>GBK 于1995年制定 收录了 21003 个汉字。GBK向下与 GB 2312编码兼容，</p><p>GBK180302001年的1月正式强制执行，是我国制订的以汉字为主并包含多种我国少数民族文字（如藏、蒙古、傣、彝、朝鲜、维吾尔文等）的超大型中文编码字符集强制性标准，其中收入汉字70000余。</p><p>Unicode（统一码、万国码、单一码）是计算机科学领域里的一项业界标准，包括字符集、编码方案等。</p><ul><li>它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。1990年开始研发，1994年正式公布。</li><li>UTF-8 以字节为单位对Unicode进行编码。</li></ul><blockquote><p>我们现在写代码的时候基本遵循UTF-8编码为主。</p></blockquote><p>有的时候，我们是需要将字符转为ASCII， 也有对应的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>))<br><br>-----------------------------<br>a<br></code></pre></td></tr></table></figure><p>将ASCII转为字符也一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">chr</span>(<span class="hljs-number">65</span>))<br><br>-----------------------------<br>A<br></code></pre></td></tr></table></figure><h2 id="高阶函数">高阶函数</h2><p>和上一节课不同，我们现在要讲的高阶函数，是Python解释器里的内置高阶函数。</p><h3 id="sorted"><code>sorted()</code></h3><p>很多时候，我们在处理数据的时候都需要对数据进行排序。不管是以序号，名称还是日期的方式。<code>sorted()</code>就是我们最常用的排序函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sorted</span>(iterable, [reverse, key])<br>‘’‘<br>运行原理：把可迭代数据里面的元素，一个一个的取出来，放到key这个函数中进行处理，并按照函数中<span class="hljs-keyword">return</span>的结果进行排序，返回一个新的列表<br>功能：排序<br>参数：<br>    iterable:可迭代的数据 （容器类型数据，<span class="hljs-built_in">range</span>数据序列，迭代器）<br>    reverse:可选，是否反转，默认为<span class="hljs-literal">False</span>，不反转， <span class="hljs-literal">True</span>反转<br>    key:可选， 函数，可以是自定义函数，也可以是内置函数<br>返回值：排序后的结果<br>’‘’<br></code></pre></td></tr></table></figure><p>我们来看几个示例，首先我们先来看看默认的排序方式：从小到大：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>]<br>res = <span class="hljs-built_in">sorted</span>(arr) <br><span class="hljs-built_in">print</span>(res)<br><br>-----------------------------<br>[-<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><p>当然，既然我们能从小到大来进行排序，那就可以用从大到小的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(arr,reverse=<span class="hljs-literal">True</span>))<br><br>-----------------------------<br>[<span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>现在我们得到了从小到大排序，也得到了从大到小排序。然后我们再来作妖：能不能按照所有数字的绝对值大虾哦进行排序呢？哎，还记得我们刚讲过的数学相关的函数里有一个求绝对值的函数嘛？既然<code>sorted()</code>这个函数里的参数<code>key</code>可以接收函数，那让我们结合在一起试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>]<br>res = <span class="hljs-built_in">sorted</span>(arr,key=<span class="hljs-built_in">abs</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>-----------------------------<br>[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><p>果然，我们得到了想要的结果。来分析下内部到底做了什么：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">[3,7,1,-9,20,10] <span class="hljs-comment"># 原始列表</span><br>3<span class="hljs-number"> 7 </span>1<span class="hljs-number"> 9 </span>20<span class="hljs-number"> 10 </span> <span class="hljs-comment"># 求绝对值</span><br>1<span class="hljs-number"> 3 </span>7<span class="hljs-number"> 9 </span>10<span class="hljs-number"> 20 </span><span class="hljs-comment"># 给绝对值进行排序</span><br>1<span class="hljs-number"> 3 </span>7 -9<span class="hljs-number"> 10 </span>20  <span class="hljs-comment"># 转换成原本的值</span><br></code></pre></td></tr></table></figure><p>那现在，我再多尝试一下，我试试看自己定义一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>函数定义好了，让我们尝试使用自定义函数对数据进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(arr, key = func))<br><br>-----------------------------<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>看似起结果了。那到底函数内干了些什么呢？让我们在其中多打印一点东西出来，看个明白：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(num, num % <span class="hljs-number">2</span>, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span><br>  <br>arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(arr, key = func))<br><br>-----------------------------<br><span class="hljs-number">3</span> <span class="hljs-number">1</span> <br><span class="hljs-number">2</span> <span class="hljs-number">0</span> <br><span class="hljs-number">4</span> <span class="hljs-number">0</span> <br><span class="hljs-number">6</span> <span class="hljs-number">0</span> <br><span class="hljs-number">5</span> <span class="hljs-number">1</span> <br><span class="hljs-number">7</span> <span class="hljs-number">1</span> <br><span class="hljs-number">9</span> <span class="hljs-number">1</span> <br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>这样我们就很清晰的看到了对原数字和取余结果，在对取余进行排序之后，再在取余的结果上进行默认的从小到大进行排序，就得到了最后的结果<code>[2, 4, 6, 3, 5, 7, 9]</code></p><p>不过，这种功能大多数时候我们基本是临时用一下，特意写一个方法似乎有点多余。还记得咱们之前讲的匿名函数吧？让我们用匿名函数优化一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用匿名函数优化</span><br>arr = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]<br>res = <span class="hljs-built_in">sorted</span>(arr, key=<span class="hljs-keyword">lambda</span> num:num%<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>-----------------------------<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>正是我们所要的结果。</p><p>从这就能看出来，高阶函数<code>sorted()</code>的<code>key</code>因为能接收自定义函数，所以给了我们很大的可玩空间。小伙伴们还能想到哪些方法，快去做做实验。</p><h3 id="map"><code>map()</code></h3><p>这个函数在对传入的可迭代数据中的每一个元素进行处理，然后返回一个新的迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(func, *iterables)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">功能： 对传入的可迭代数据中的每个元素放入到函数中进行处理，返回一个新的迭代器</span><br><span class="hljs-string">参数：</span><br><span class="hljs-string">    func 函数  自定义函数|内置函数</span><br><span class="hljs-string">    iterables：可迭代的数据</span><br><span class="hljs-string">返回值：迭代器</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>让我们先来看一个普通的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 把一个字符串数字的列表转为整型列表</span><br>items = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br>new_list = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items:<br>    new_list.append(<span class="hljs-built_in">int</span>(i))<br><br><span class="hljs-built_in">print</span>(new_list)<br><br>-----------------------------<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>我们将一个内部元素均为字符串的列表，转成了一个整型列表。</p><p>不过这个函数看起来似乎还是有些麻烦，让我们再用<code>map</code>试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br>res = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, items)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>看，是不是简便多啦？当然，最后<code>map</code>最后生成的是迭代器而并不是列表，我们还是需要转化一下数据类型。</p><p>这段代码中<code>map</code>的处理方式其实非常简单，它将<code>items</code>里的每一个元素用<code>int</code>方法转换成整型，转换完之后形成一个新的迭代器，然后返回。</p><p>再让我们看一个示例感受一下, 这次我们将两段对比写在一起：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通方法进行实现</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>res = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items:<br>    x = i ** <span class="hljs-number">2</span><br>    res.append(x)<br><span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-comment"># 使用map函数处理</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x ** <span class="hljs-number">2</span><br>res = <span class="hljs-built_in">map</span>(func, items)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>]<br>&lt;<span class="hljs-built_in">map</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107ea5030</span>&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>]<br></code></pre></td></tr></table></figure><p>我们看到执行结果完全一样，不过使用<code>map()</code>的方式更简洁，逻辑也更清晰。我们要知道，Python本身是自带幂次方方法的。即便是我们自己来实现，其实我们还可以把代码写的更简洁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>res = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x**<span class="hljs-number">2</span>, items)<br><span class="hljs-built_in">print</span>(res,<span class="hljs-built_in">list</span>(res))<br><br>-----------------------------<br>&lt;<span class="hljs-built_in">map</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107c98610</span>&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>]<br></code></pre></td></tr></table></figure><p>基于<code>map</code>的应用，我们来个<strong>小作业</strong>吧：</p><blockquote><p>我们现在有这样一个列表：<code>['a','b','c','d']</code></p><p>要求将其转换成：<code>[65,66,67,68]</code></p></blockquote><p>最后，再给大家留个课后作业，我给大家两个函数及其功能介绍，大家自己去尝试看看，然后自己琢磨下其用法。</p><p><code>reduce(func, iterable)</code></p><p>功能：每一次从 iterable拿出两个元素，放入到func函数中进行处理，得出一个计算结果，然后把这个计算结果和iterable中的第三个元素，放入到func函数中继续运算，得出的结果和之后的第四个元素，加入到func函数中进行处理，以此类推，直到最后的元素都参与了运算</p><p><code>filter(func, iterable)</code></p><p>功能：过滤数据，把 iterable 中的每个元素拿到 func函数中进行处理，如果函数返回True则保留这个数据，返回False则丢弃这个数据。</p><p>这两个函数在处理数据上作用都非常大。</p><p>好了，下课。大家有问题记得留言。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807211857.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍-1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>6. Python的高阶函数</title>
    <link href="https://hivan.me/Higher-order-functions/"/>
    <id>https://hivan.me/Higher-order-functions/</id>
    <published>2023-08-03T06:07:17.000Z</published>
    <updated>2023-08-10T10:58:21.534Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://qiniu.hivan.me/picGo/20230807211857.png?imgNote" /></p><p>Hi，大家好。 我是茶桁。</p><span id="more"></span><p>本节课，我们来学习一下Python中的「高阶函数」。</p><h2 id="递归函数">递归函数</h2><p>让我们先来了解一下，什么是递归函数。</p><p>递归函数就是定义一个函数，然后在此函数内，自己调用自己。</p><p>既然是自己调用自己，那这个函数必须要有一个结束才行，否则会一直重复的调用下去，直到调用层数越来越多，最终会导致栈溢出。</p><p>让我们先写一个雏形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初步认识一下递归函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursion</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(num)<br>    recursion(num - <span class="hljs-number">1</span>)<br><br>recursion(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> -<span class="hljs-number">1</span> -<span class="hljs-number">2</span> -<span class="hljs-number">3</span> -<span class="hljs-number">4</span> -<span class="hljs-number">5</span> -<span class="hljs-number">6</span> -<span class="hljs-number">7</span> ....<br><br>RecursionError: maximum recursion depth exceeded <span class="hljs-keyword">while</span> calling a Python <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>最后，导致栈溢出，程序报错。</p><p>那么这个程序到底做了什么？</p><p>首先，我们定义了一个函数，然后执行，执行的时候给了一个参数<code>3</code>。</p><p>进入程序之后，先将<code>3</code>打印了一遍，然后在函数内部，又调用了一遍自己，参数为<code>3-1</code>，也就是传了一个参数<code>2</code>，在进入函数之后，打了了<code>2</code>，继续自己调用自己，传参<code>2-1</code>，<code>1-1</code>,<code>0-1</code>, <code>...</code>就这样一直循环下去。</p><p>那么我们怎么样让这个程序停下来？就是在函数自己调用自己之前，加上一个限制条件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初步认识一下递归函数 3 2 1 0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursion</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(num)<br>    <span class="hljs-comment"># 检测当前值是否到0</span><br>    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 调用函数本身</span><br>        recursion(num - <span class="hljs-number">1</span>)<br>recursion(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们给调用之前加了一个条件，如果<code>num &gt;  0</code>才允许继续执行，这样，当程序传递了<code>1-1</code>之后，执行了最后一次打印，然后就不向下执行了。</p><p>不过不要以为程序到这里就结束了，我们多加一行代码试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初步认识一下递归函数 3 2 1 0</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recursion</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(num, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-comment"># 检测当前值是否到0</span><br>    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 调用函数本身</span><br>        recursion(num - <span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(num, end=<span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment"># 又加了一个print函数</span><br>recursion(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>如果你不知道程序做了什么，我们稍微分析一下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">解析当前递归函数的执行过程：<br>```<br>recursion(<span class="hljs-number">3</span>) ==&gt; <span class="hljs-number">3</span> <br>    recursion(<span class="hljs-number">3</span><span class="hljs-number">-1</span>) ==&gt; <span class="hljs-number">2</span><br>        recursion(<span class="hljs-number">2</span><span class="hljs-number">-1</span>) ==&gt; <span class="hljs-number">1</span><br>            recursion(<span class="hljs-number">1</span><span class="hljs-number">-1</span>) ==&gt; <span class="hljs-number">0</span><br>            recursion(<span class="hljs-number">0</span>) ==&gt; <span class="hljs-number">0</span><br>        recursion(<span class="hljs-number">1</span>) ==&gt; <span class="hljs-number">1</span><br>    recursion(<span class="hljs-number">2</span>) ==&gt;<span class="hljs-number">2</span><br>recursion(<span class="hljs-number">3</span>) ==&gt; <span class="hljs-number">3</span><br>```<br></code></pre></td></tr></table></figure><p>也就是，在递归函数中，程序是一层一层的进入，然后再一层一层的返回。</p><p>这就好像是，我们在上学的时候，你坐在最后一排，但是你有个心仪的女孩坐在最前面。你想要对方电话，这个时候你传递一个纸条给前面的同学，前面的同学再往前传，一直往前传到女孩手里。女孩看完之后，写完回复再一次次的传回来。最后你满怀期待的打开一看：“滚。”</p><p>当然，我们的递归函数和这个不同的地方是最后不会多加那个“滚”字。</p><h2 id="回调函数">回调函数</h2><p>什么是回调函数呢？</p><p>我们首先来思考一个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(a)<br><br>func(a)<br></code></pre></td></tr></table></figure><p>在这个简单的函数中，我们已经学会了传值<code>a</code>给到<code>func()</code>，那么参数到底可以传一些什么进去？<code>a</code>可以是什么？能不能是一个函数呢？</p><p>这就引出了我们现在的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 带有回调函数参数的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">obj</span>):<br>    <span class="hljs-built_in">print</span>(obj, <span class="hljs-built_in">type</span>(obj))<br>    <span class="hljs-comment"># 并且在函数中调用传递进来的形参函数</span><br>    obj()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_self</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i am _self&quot;</span>)<br><br>func(_self)<br><br><span class="hljs-comment"># 执行结果</span><br>&lt;function _self at <span class="hljs-number">0x111ed4280</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;function&#x27;</span>&gt;<br>i am _self<br></code></pre></td></tr></table></figure><p>可以看到，我们选择执行的是<code>func</code>函数，但是最后打印出了<code>_self</code>函数中语句。原因就是我们在执行<code>func</code>函数的时候，将<code>_self</code>函数作为参数传递给了<code>func</code>的形参<code>obj</code>，我们在其中打印了<code>obj</code>以及<code>obj</code>的类型，并且最后执行了一下<code>obj</code>，实际上也就是执行了一遍<code>_self</code>函数。</p><p>如果在一个函数中要求传递的参数是一个函数作为参数，并且在函数中使用了传递进来的函数，那么这个函数我们就可以称为是一个<strong>回调函数</strong>。</p><p>我们拿系统内部的一个现成的函数来重新封装一个新的函数来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 做一个数学计算的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">x, y, obj</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    此函数用来整合其他的数学运算</span><br><span class="hljs-string">    在当前函数中，需要接收三个参数，前两个为数值，最后一个为函数</span><br><span class="hljs-string">    x, y: int</span><br><span class="hljs-string">    f: function</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(obj(x, y))<br><br>func(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-built_in">pow</span>)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>在日后使用这个函数的时候，就可以传入数值和要做什么计算的方法，就可以了。</p><p>当然，这个函数写的并不完善，比如，我们在执行<code>func(2, 3, sum)</code>的时候就会报错，原因是因为<code>sum()</code>函数内部是要进行迭代的的，然而<code>int</code>类型中没有魔法方法<code>__iter__</code>,所以无法迭代。所以，要想这个函数具有通用性，还需要在内部完成很多工作。</p><h2 id="闭包函数">闭包函数</h2><p>之前我们在回调函数中将函数作为参数进行了传递，那么问题来了，既然函数能作为参数进行传递，那能不能作为参数被<code>return</code>呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>    money = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>        <span class="hljs-built_in">print</span>(money)<br>    <span class="hljs-keyword">return</span> work<br><br>person()<br><br><span class="hljs-comment"># 执行结果</span><br>&lt;function __main__.person.&lt;<span class="hljs-built_in">locals</span>&gt;.work()&gt;<br></code></pre></td></tr></table></figure><p>我们可以看到，<code>work</code>函数被成功返回出来了。但是并未继续执行，因为其内部的<code>print()</code>没起作用。</p><p>我们用一个变量来接收这个返回的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>    money = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>        <span class="hljs-built_in">print</span>(money)<br>    <span class="hljs-keyword">return</span> work<br><br>res = person()<br>res()<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>说明<code>res</code>接收到返回的<code>work()</code>函数，并且最后执行成功了。</p><p>好了，让我们继续为这个函数做一点什么，看看有什么变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>    money = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>        <span class="hljs-keyword">nonlocal</span> money<br>        money += <span class="hljs-number">100</span><br>        <span class="hljs-built_in">print</span>(money)<br>    <span class="hljs-keyword">return</span> work<br><br>res = person()<br>res()<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>这个结合前几节所讲的内容就很好理解了对吧？<code>nonlocal</code>关键字拿到上一层函数定义的变量，然后在内层函数中进行使用，最后打印出来。</p><p>那我们继续执行会如何？让我们多执行几次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>    money = <span class="hljs-number">0</span>  <span class="hljs-comment"># 函数中定义了一个局部变量</span><br>    <span class="hljs-comment"># 定义内函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">work</span>():<br>        <span class="hljs-keyword">nonlocal</span> money   <span class="hljs-comment"># 在内函数中使用了外函数的临时变量</span><br>        money += <span class="hljs-number">100</span><br>        <span class="hljs-built_in">print</span>(money)<br>    <span class="hljs-comment"># 在外函数中返回了内函数，这个内函数就是闭包函数</span><br>    <span class="hljs-keyword">return</span> work<br><br>res = person() <span class="hljs-comment"># return work  res = work</span><br>res() <span class="hljs-comment"># res() == work()</span><br>res()<br>res()<br>res()<br>res()<br><span class="hljs-comment"># 此时 就不能够在全局中对money这个局部变量进行任何操作了，</span><br><span class="hljs-comment"># 闭包的作用：保护了函数中的变量不受外部的影响，但是又能够不影响使用</span><br></code></pre></td></tr></table></figure><p>你会不会认为会一直打印<code>100</code>?让我们看看执行结果到底是怎样的：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">100<br>200<br>300<br>400<br>500<br></code></pre></td></tr></table></figure><p>怎么样，是不是完全没想到？这个就是<strong>闭包函数</strong>的特点。</p><p>在一个函数内返回了一个内函数，并且这个返回的内函数还使用了外函数中局部变量，这个就是闭包函数。其特点为：</p><ul><li>在外函数中定义了局部变量，并且在内部函数中使用了这个局部变量</li><li>在外函数中返回了内函数，返回的内函数就是闭包函数</li><li>⚠️主要在于保护了外函数中的局部变量，既可以被使用，又不会被破坏。</li><li>检测一个函数是否为闭包函数，可以使用<code>func.__closure__</code>，如果是闭包函数返回<code>cell</code></li></ul><h2 id="匿名函数----lambda表达式">匿名函数 -- lambda表达式</h2><p>首先，我们先弄清楚什么是匿名函数：匿名函数的意思就是说可以不使用<code>def</code>来定义，并且这个函数也没有名字。</p><p>在Python中，我们可以使用<code>lambda</code>表达式来定义匿名函数。我们需要注意，<code>lambda</code>仅仅是一个表达式，并不是一个代码块，所以<code>lambda</code>又称为一行代码的函数。</p><p>在<code>lambda</code>表达式中，也有形参，并且不能够访问除了自己的形参之外的任何数据，包括全局变量。其语法如下：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 语法：</span><br><span class="hljs-built_in">lambda</span> [参数列表]<span class="hljs-symbol">:</span>返回值<br></code></pre></td></tr></table></figure><p>让我们来尝试写写看，我们先来定义一个普通的加法运算的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装一个函数做加法运算</span><br><span class="hljs-comment"># 普通函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x+y<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><p>毫无疑问，执行结果为<code>5</code>。那么接下来，用<code>lambda</code>该怎么写呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 改成lambda表达式来封装</span><br>res = <span class="hljs-keyword">lambda</span> x, y:x+y<br><span class="hljs-built_in">print</span>(res(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>结合闭包函数的讲解，这里就应该很容易看懂了吧？一样的地方就是，使用了一个变量<code>res</code>来接收这个返回的函数，然后执行<code>res</code>函数。</p><p>让我们再来一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-keyword">lambda</span> sex:<span class="hljs-string">&quot;很man&quot;</span> <span class="hljs-keyword">if</span> sex==<span class="hljs-string">&#x27;male&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;很nice&#x27;</span><br><span class="hljs-built_in">print</span>(res(<span class="hljs-string">&#x27;female&#x27;</span>))<br><br><span class="hljs-comment"># 执行结果</span><br>很nice<br></code></pre></td></tr></table></figure><p>只看结果的话，我们很清楚这段函数最后执行到了<code>else</code>语句内。但是是如何进入的呢？让我们将这段代码用普通函数的写法展开来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">sex</span>):<br>    <span class="hljs-keyword">if</span> sex == <span class="hljs-string">&#x27;male&#x27;</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;很man&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;很nice&#x27;</span><br><br>func(<span class="hljs-string">&#x27;female&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样是不是很清晰了？回过头来让我们看刚才那段<code>lambda</code>表达式，我们可以这样去看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  lambda 参数列表: 真区间 if 表达式判断 else 假区间</span><br><span class="hljs-keyword">lambda</span> sex: <span class="hljs-string">&#x27;很man&#x27;</span> <span class="hljs-keyword">if</span> sex==<span class="hljs-string">&#x27;male&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;很nice&#x27;</span><br><br><span class="hljs-comment"># 然后用一个变量接收函数</span><br>res = <span class="hljs-keyword">lambda</span> sex: <span class="hljs-string">&#x27;很man&#x27;</span> <span class="hljs-keyword">if</span> sex==<span class="hljs-string">&#x27;male&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;很nice&#x27;</span><br></code></pre></td></tr></table></figure><p>所以可以看出来，其实<code>lambda</code>十分的方便，并且并不难理解，当你习惯了<code>lambda</code>之后，会非常便捷。</p><h2 id="迭代器">迭代器</h2><p>迭代器是一个很有意思的功能，可以说是Python中最具特色的功能之一，它是访问集合元素的一种方式。</p><p>迭代器是一个可以记住访问遍历的位置的对象。从集合的第一个元素开始访问，直到集合中的所有元素被访问完毕。</p><p>迭代器只能是从前往后一个一个的遍历，不能后退。</p><p>我们把之前一直使用的<code>range()</code>拿过来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># range(10, 3, -1) 返回一个可迭代的对象</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">10</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <br></code></pre></td></tr></table></figure><p>表面上来看，似乎<code>range()</code>本身就是一个迭代器，可是我们来尝试做个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(x))<br><br><span class="hljs-comment"># 执行结果</span><br>TypeError: <span class="hljs-string">&#x27;range&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> an iterator<br></code></pre></td></tr></table></figure><p>当我们尝试调用<code>next()</code>函数的时候报错了，被告知<code>range</code>不是一个迭代器。</p><p>那么，<code>range</code>不是迭代器，究竟是什么呢？这里我们就要先深入研究下迭代器的特性：</p><p>严格来说，迭代器是指实现了迭代协议的对象，迭代协议是指实现了<code>iter</code>方法并返回一个实现了<code>next</code>方法的迭代器对象，并通过<code>StopIterator</code>一场标识迭代完成。</p><h4 id="iter"><code>iter()</code></h4><p><code>iter()</code>能把迭代的对象，转为一个迭代器对象，其参数为可迭代的对象(<code>str, list, tuple, dict</code>)，返回值为<strong>迭代器对象</strong>。其中需要注意的一点是：迭代器一定是一个可以迭代的对象，但是可迭代的对象并不一定是迭代器。</p><p>我们在迭代器上使用<code>iter</code>会得到相同的对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">iter</span>(i) <span class="hljs-keyword">is</span> i)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(<span class="hljs-built_in">iter</span>(i)))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(i))<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-literal">True</span><br><span class="hljs-number">4425502096</span><br><span class="hljs-number">4425502096</span><br></code></pre></td></tr></table></figure><p>基于此，我们可以这样实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(i, i))<br><br><span class="hljs-comment"># 执行结果</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]<br></code></pre></td></tr></table></figure><h4 id="next"><code>next()</code></h4><p><code>next()</code>函数可以去调用迭代器，并返回迭代器中的下一个数据。</p><p>我们使用<code>iter</code>函数可以从任何可迭代对象中获取一个迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(a))<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> a)<br><br><span class="hljs-comment"># 执行结果</span><br>&lt;list_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x124111a50</span>&gt;<br><span class="hljs-number">1</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>可以看到，我们使用<code>iter</code>函数可以从任何可迭代对象中获取一个迭代器。而且迭代器有个特点，即每次用完一个元素即消耗掉该元素，不会保留在迭代器中，也就是说，是一次性的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res), end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res), end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res), end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res), end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># print(next(res))</span><br>r = <span class="hljs-built_in">list</span>(res)<br><span class="hljs-built_in">print</span>(r)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> []<br></code></pre></td></tr></table></figure><p>可以看到，<code>list</code>里面已经空了。</p><p>我们用<code>for</code>来取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br><br>r = <span class="hljs-built_in">list</span>(res)<br><span class="hljs-built_in">print</span>(r)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> []<br></code></pre></td></tr></table></figure><p><code>for</code>直接将迭代内的元素全部取完了，所以最后打印下一个值的时候也显示空了。所以我们可以得到迭代器的取值方案：</p><h4 id="迭代器的取值方案">迭代器的取值方案</h4><ul><li><code>next()</code>：调用一次获取一次，直到数据被取完。</li><li><code>list()</code>：使用<code>list</code>函数直接取出迭代器中的所有数据。</li><li><code>for</code>：使用<code>for</code>循环遍历迭代器的数据</li></ul><p>总结一下：</p><ul><li><p>迭代器是一个可以记住遍历的位置的对象。</p></li><li><p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p></li><li><p>迭代器有两个基本的方法：<code>iter()</code> 和<code>next()</code>。</p></li><li><p>字符串，列表或元组对象都可用于创建迭代器：</p></li></ul><p>那么，再回过头来看看<code>range</code></p><p><code>range</code>可以像任何其他可迭代对象一样循环使用，但是它并不具备迭代器中的一些特性，比如，我们之前实验过，<code>range</code>并不能使用<code>next</code>方法，而我们可以从<code>range</code>中得到一个迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">iter</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 执行结果</span><br>&lt;range_iterator at <span class="hljs-number">0x124184570</span>&gt;<br></code></pre></td></tr></table></figure><p>我们在迭代器中使用元素就会消耗掉该元素，但是我们遍历一个<code>range</code>对象并不消耗它，比如：</p><p><img src="https://qiniu.hivan.me/picGo/20230803185035.png?imgNote"alt="image-20230803185018932" /></p><p>很明显我们可以重复使用。</p><p>来一个更直接的，我们之前用<code>for</code>获取了迭代里的值，我们对<code>range()</code>也来使用一下看看会不会有不同的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br><br>r = <span class="hljs-built_in">list</span>(res)<br><span class="hljs-built_in">print</span>(r)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>一样的代码，对象不同。我们可以明显看到区别，<code>range</code>拿到最后里面的元素并没有减少。这也说明了，<code>range</code>并不是迭代器。</p><p>实际上，<code>range</code>的迭代是通过<code>iter</code>协议来实现的，只是一种类似迭代器的鸭子类型，并非真正的迭代器。</p><p>其实，有一种可以直接检测迭代器和可迭代对象的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检测迭代器和可迭代对象</span><br><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator, Iterable <br><br>varstr = <span class="hljs-string">&#x27;123456&#x27;</span><br>res = <span class="hljs-built_in">iter</span>(varstr)<br>r = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># isinstance() 检测一个数据是不是一个指定的类型</span><br><span class="hljs-comment"># Iterable: 迭代对象，Iterator: 迭代器</span><br>r1 = <span class="hljs-built_in">isinstance</span>(varstr, Iterable) <br>r2 = <span class="hljs-built_in">isinstance</span>(varstr, Iterator)<br>r3 = <span class="hljs-built_in">isinstance</span>(res, Iterable)<br>r4 = <span class="hljs-built_in">isinstance</span>(res, Iterator) <br>r5 = <span class="hljs-built_in">isinstance</span>(r, Iterable) <br>r6 = <span class="hljs-built_in">isinstance</span>(r, Iterator)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;varstr 是迭代对象：<span class="hljs-subst">&#123;r1&#125;</span>, \t varstr 是迭代器: <span class="hljs-subst">&#123;r2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;res 是迭代对象：<span class="hljs-subst">&#123;r3&#125;</span>, \t res 是迭代器: <span class="hljs-subst">&#123;r4&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r 是迭代对象：<span class="hljs-subst">&#123;r5&#125;</span>, \t r 是迭代器: <span class="hljs-subst">&#123;r6&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 执行结果</span><br>varstr 是迭代对象：<span class="hljs-literal">True</span>,  varstr 是迭代器: <span class="hljs-literal">False</span><br>res 是迭代对象：<span class="hljs-literal">True</span>,  res 是迭代器: <span class="hljs-literal">True</span><br>r 是迭代对象：<span class="hljs-literal">True</span>,  r 是迭代器: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>今天的知识点讲到这就结束了，接下来，让我们来做两个小练习。</p><h2 id="练习题">练习题</h2><h3 id="递归查询斐波那契数列位数">递归查询斐波那契数列位数</h3><p>还记得我们之前讲过的斐波那契数列吗？不记得没关系，我们来复习一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 斐波那契数列: 0, 1, 1, 2, 3, 5, 8, 13...</span><br></code></pre></td></tr></table></figure><p>我们这次来实现一个函数，用于查询斐波那契数列中当前位置的数值是多少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 递归实现斐波那契数列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fibonacci</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">elif</span> n == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>)<br>    <br>res = fibonacci(<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>我为大家画了张图，来看看程序内部到底做了些什么：</p><p><img src="https://qiniu.hivan.me/picGo/20230803213720.png?imgNote"alt="画板" /></p><p>从这张图中，我们可以看到递归的步骤和返回的结果。</p><h3 id="递归实现阶乘">递归实现阶乘</h3><p>什么是阶乘？比如我们实现7的阶乘，那么就是 <spanclass="math display">\[1\times2\times3\times4\times5\times6\times7\]</span> 让我们来试着实现一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实现阶乘</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n*factorial(n-<span class="hljs-number">1</span>)<br>    <br>res = factorial(<span class="hljs-number">7</span>)<br><span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">5040</span><br></code></pre></td></tr></table></figure><p>验证一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span>*<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">4</span>*<span class="hljs-number">5</span>*<span class="hljs-number">6</span>*<span class="hljs-number">7</span>)<br><br><span class="hljs-comment"># 执行结果</span><br><span class="hljs-number">5040</span><br></code></pre></td></tr></table></figure><p>看来结果没问题，那让我们来看看程序内发生了什么：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&#x27;&#x27;&#x27;<br>factorial(7) =&gt; <br>7 * factorial(6) =&gt; <br><span class="hljs-code">    6 * factorial(5) =&gt; </span><br><span class="hljs-code">        5 * factorial(4) =&gt; </span><br><span class="hljs-code">            4 * factorial(3) =&gt; </span><br><span class="hljs-code">                3 * factorial(2) =&gt; </span><br><span class="hljs-code">                    2 * factorial(1) =&gt; </span><br><span class="hljs-code">                        factorial(1) = 1</span><br><span class="hljs-code">                    2 * 1 = 2</span><br><span class="hljs-code">                3 * 2 = 6</span><br><span class="hljs-code">            4 * 6 = 24</span><br><span class="hljs-code">        5 * 24 = 120</span><br><span class="hljs-code">    6 * 120 = 720</span><br>7 * 720 = 5040<br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><p>虽然实现了，最后还是不得不说几点注意事项：</p><p>递归函数的效率并不高，所以尽量能不用就不要用。</p><p>一个函数如果调用后没有结束，那么栈空间中就一直存在，直到这个函数运算结束才会销毁。</p><p>好了，今天的课程到此结束。大家课后记得多练习。下课！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://qiniu.hivan.me/picGo/20230807211857.png?imgNote&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。 我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波器的非数学介绍</title>
    <link href="https://hivan.me/2023_8_3_Kalman/"/>
    <id>https://hivan.me/2023_8_3_Kalman/</id>
    <published>2023-08-02T11:23:14.000Z</published>
    <updated>2023-08-02T17:20:14.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你想查看的话，本文的代码可以在我的<ahref="https://github.com/hivandu/AI_Cheats/blob/main/Python/Kalman.ipynb">Github</a>上查看。</p></blockquote><p>卡尔曼滤波器非常巧妙。如果你从未听说过卡尔曼滤波器，那么一种非常直观（也可以说是还原）的思考方式就是将其视为一个漏斗，在这里你可以从多个嘈杂的信息源中获取信息，并将其浓缩为一个更精确的统计数据。</p><span id="more"></span><p>如果这一切听起来含糊不清，请不要担心。稍后，我们将把这句话剥离成一个更容易理解的例子，希望能进一步加深我们的直觉。要研究和推理卡尔曼滤波器，没有比数学更好的工具了。但同样，卡尔曼滤波器的基础数学具有挑战性，包含线性代数、概率论和微积分等内容。因此，并非所有人都能轻松掌握。这篇文章的目的就是希望为你提供一个易于理解的直观印象，或许能促使你自己深入研究这个问题。现在，让我们开始吧，同时牢记这一点："以下内容仅提供直觉，可能并不完整"。</p><p>让我们先问一句："为什么卡尔曼滤波器是必要的？对于这个问题，一个简单而又故意模糊的答案是：现实生活并不完美。请看这个激励性的例子：想象一艘船在一个维度上行驶，从港口出发（x=0）并行驶一段距离。这艘船的发动机被设定为为船提供一个恒定的速度，例如10 米/秒。</p><p><img src="https://qiniu.hivan.me/picGo/20230803010908.png?imgNote"alt="img" /></p><p>我们首先要问的问题是，在离开港口 2秒钟后，船到底在哪里？很自然，你会说船离港口的距离是2<em>10=20m，因为毕竟距离 = 速度 </em>时间。在理想世界里，这的确是正确的，根本不需要卡尔曼滤波器。但在现实世界中，情况绝非如此简单。首先，可能没有足够的发动机能够产生足够的力，使每个时间点的速度始终保持在10 米/秒。当然，你可能会在某些时候获得 10.00001 的速度，或在其他时候获得9.99999 m/s 或介于两者之间的某个数字，但正如所说，99.99%的完美终究还是不完美。其次，即使你说你确实拥有这样一个完美的发动机，但当你施加一个精确测量的力时，你也不可能获得预期的完美速度。波浪运动可能会让你的船稍微慢一点，或者风可能会让它加速，或者谁也不知道什么东西会以什么方式对它产生影响。</p><blockquote><p>因此，仅仅通过测量你想要的位置，你永远无法确定你的船在哪里。</p></blockquote><p>那么，我们是否注定永远无法真正知道自己的位置呢？不尽然！这就是传感器的用武之地。想象一下，你，水手，随身携带一个全球定位系统。这样，GPS就能精确地告诉您在任何给定时刻的位置！事实上，你现在甚至不需要船的速度，因为无论船如何行驶，你的全球定位系统都能准确地告诉你所在的位置。问题解决了吗？就像我说的，不完全是。在现实中，传感器经常会出现错误，而且不可靠。也就是说，它们确实能告诉你你在哪里，但测量结果可能并不精确。因此，您的GPS 可能会告诉您，3 秒钟后您距离港口 29.998 米或 30.002米，甚至是距离港口 100米，但这种可能性极低。此外，您也无法确保传感器永远不会出现故障。以 GPS传感器为例。一旦你发现自己身处没有卫星覆盖的地区，它就会失灵。事实上，如果有一个传感器能保证永远不会离线，并能以任意的精确度测量出你想知道的信息，那就根本不需要卡尔曼滤波器了。</p><p>有了这些，我们现在就可以回答为什么需要卡尔曼滤波器了。而答案与我们之前已经确定的并没有什么不同。卡尔曼滤波器是一个漏斗，它能接收两个或更多不完美、不可靠的信息源，并对你想知道的信息做出更准确的估计。在这个例子中，卡尔曼滤波器会把你在任何时间的速度估计值和GPS估计值（如果有的话）作为输入，然后给出比这两个信息加起来更准确的估计值！事实上，如果你有更多的信息来源，比如雷达或声纳，甚至是你目前在水中看到的鱼的种类，理论上你可以将这些测量结果结合起来，从而对你的位置做出更准确的估计。</p><p><img src="https://qiniu.hivan.me/picGo/20230803011007.png?imgNote"alt="img" /></p><p>因此，现在的问题是，如果不使用这样的数学知识（摘自维基百科），我们如何理解卡尔曼滤波器的作用和原理？</p><p><img src="https://qiniu.hivan.me/picGo/20230803011011.png?imgNote"alt="img" /></p><p>首先，我们假设船上没有一名乘客，而是有一千名乘客，每个人都有自己的GPS设备。现在，每位乘客都可以通过以下方式进行基于速度的估算，从而估算出自己的位置（进而估算出船的位置）：</p><p><img src="https://qiniu.hivan.me/picGo/20230803011016.png?imgNote"alt="img" /></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima">from <span class="hljs-built_in">random</span> import <span class="hljs-built_in">gauss</span><br>def new_position(<span class="hljs-built_in">last</span>):<br> velocity = <span class="hljs-number">10</span><br> wind = <span class="hljs-built_in">gauss</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br> wave = <span class="hljs-built_in">gauss</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.1</span>)<br> <span class="hljs-built_in">return</span> <span class="hljs-built_in">last</span> + velocity + wind + wave<br></code></pre></td></tr></table></figure><blockquote><p>注：有关高斯函数的可选但更完整的解释，请参阅下面的附录。目前，只需说明它会产生一个随机数（正数/负数），其顺序由第二个参数指示即可。</p></blockquote><p>从本质上讲，这 1000名乘客中的每一个人都是这样做的：取上一次已知的位置（在现在之前的时间），加上速度，并且知道风和水波会轻微地改变航向，再加上一些随机的估计波动。现在，如果这些乘客真的有估算风速和水速的好方法，他们就会使用它。但因为他们没有，所以只能用随机数来估计影响。实际上，现实生活中也是如此。我们不可能测量所有的东西，所以我们只能用一些简单的方法来估计它们，就像我们上面用平均值（0）和偏差参数（0.1和 2）所做的那样。</p><p>现在我们进入卡尔曼滤波法的第二阶段，即测量。在这一阶段，所有乘客都知道，由于风噪和水噪的影响，他们对自己的状态（所处位置）只有不完全的了解，因此，他们会利用自己的传感器来改善自己的状态：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> sensor(t):<br> <span class="hljs-attribute">if</span> t == <span class="hljs-number">3</span>:<br> <span class="hljs-comment"># oops, passing through a thunderstorm. GPS fluctuating!</span><br> <span class="hljs-attribute">sensor_noise</span> = gauss(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br> <span class="hljs-attribute">elif</span> t == <span class="hljs-number">6</span>:<br> <span class="hljs-comment"># uh-oh, satellite unavailable!</span><br> <span class="hljs-attribute">sensor_noise</span> = gauss(-<span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br> <span class="hljs-attribute">else</span>:<br> <span class="hljs-attribute">sensor_noise</span> = gauss(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br> <span class="hljs-attribute">return</span> true_position[t] + sensor_noise<br><br></code></pre></td></tr></table></figure><p>请记住，传感器是一种不精确的设备，也就是说，它们返回的统计数据大多是正确的，在本例中就是变量true_position，但它们本身也有噪声，我们再次使用高斯函数随机生成的数字来模拟这种噪声。此外，我们在这里还模拟了传感器的不稳定性，即在某些情况下（t=3和t=6），由于某些因素传感器基本上是不可用的，而这些因素并非完全不可想象。因此，每位乘客在使用传感器时，实际上都会得到不同的测量结果。</p><p>想象一下，这艘船现在离开港口，每秒行驶这些距离：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">true_position</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">19.2</span>, <span class="hljs-number">28</span>, <span class="hljs-number">38.1</span>, <span class="hljs-number">48.5</span>, <span class="hljs-number">57.2</span>, <span class="hljs-number">66.2</span>,<br>                 <span class="hljs-number">77.5</span>, <span class="hljs-number">85</span>, <span class="hljs-number">95.2</span>]<br></code></pre></td></tr></table></figure><p>也就是说，船从港口出发（x=0），第一秒行驶 9 米，第二秒行驶 10.2米，最后到达 19.2米，以此类推。现在，乘客们的任务是利用他们所掌握的嘈杂且不可靠的测量数据，尽可能准确地预测出每一秒的不同位置。</p><p>因此，在时间 t = 1 时，乘客可以通过上述函数得到这些读数：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># 如果 t=<span class="hljs-number">0</span> 时的新位置为 <span class="hljs-number">0</span>，则 t=<span class="hljs-number">1</span> 时的新位置为 <span class="hljs-number">0n</span>ew<span class="hljs-constructor">_position(0)</span> =&gt; <span class="hljs-number">9.37</span><span class="hljs-function"> (<span class="hljs-params">error</span> -0.37)# <span class="hljs-params">t</span> = 1<span class="hljs-params">s</span> 时的传感器读数<span class="hljs-params">sensor</span>(1) =&gt;</span> <span class="hljs-number">8.98</span>                (error +<span class="hljs-number">0.02</span>)<br></code></pre></td></tr></table></figure><p>所有乘客都是如此。现在的问题是，真相到底是什么？是我们的牛顿物理知识更可靠，还是GPS 传感器更可靠？在这种特殊情况下，由于我们已经知道船的真实位置距离true_position 变量 9米，答案可能是显而易见的，但情况并非总是如此。在这种情况下，为了将这两个独立的统计数据结合起来，我们实际上采用了一种非常简单的方法：取两者的平均值！在上面的例子中，我们可以得出以下结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">combined</span> =&gt; (<span class="hljs-number">9</span>.<span class="hljs-number">37</span>+<span class="hljs-number">8</span>.<span class="hljs-number">98</span>)/<span class="hljs-number">2</span> =&gt; <span class="hljs-number">9</span>.<span class="hljs-number">17</span>         (error -<span class="hljs-number">0</span>.<span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p>请注意，在这个例子中，综合统计量的误差比单独的速度估计值要小，但比传感器估计值要差。但问题是，我们实际上可以做得比取平均值更好。考虑一下这样的情况：你知道你的传感器实际上是最先进的，而且非常可靠。这实际上意味着你应该更倾向于传感器的数据，而不是速度更新的数据。实际上，您可以通过使用加权平均值来做到这一点。请看这段代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">combine</span>(<span class="hljs-params">A, B, trustA, trustB</span>):<br> total_trust = trustA + trustB<br> <span class="hljs-keyword">return</span> (A * trustA + B * trustB) / total_trust<br></code></pre></td></tr></table></figure><p>这就综合了 A 和 B来源的两个数字，但也考虑到了您对这些来源的信任程度。因此，如果您将其称为</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">combine</span>(<span class="hljs-number">9</span>.<span class="hljs-number">37</span>, <span class="hljs-number">8</span>.<span class="hljs-number">98</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>) =&gt; <span class="hljs-number">9</span>.<span class="hljs-number">33</span>         (error -<span class="hljs-number">0</span>.<span class="hljs-number">33</span>)<br><span class="hljs-attribute">combine</span>(<span class="hljs-number">9</span>.<span class="hljs-number">37</span>, <span class="hljs-number">8</span>.<span class="hljs-number">98</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>) =&gt; <span class="hljs-number">9</span>.<span class="hljs-number">01</span>         (error -<span class="hljs-number">0</span>.<span class="hljs-number">01</span>)<br></code></pre></td></tr></table></figure><p>在第一次调用中，您对源 A（速度）的信任度远高于源 B（传感器），即 10比 1，因此得到的答案更倾向于源 A，即更接近9.37。这种基于信任的加权平均法是卡尔曼滤波器的核心，也是它的数据组合能力所在。</p><p>但现在，我们遇到了一个新问题。哪个来源更可信，或者如何计算可信度？是应该优先考虑速度呢？还是应该优先考虑GPS测量结果？决定这一点的是偏差或方差指标。想想看，什么更值得信赖？是波动剧烈的信息源还是没有波动的信息源？试想一下，你收听10 个气象广播电台，其中 4 个告诉你会下雨，6个告诉你会是晴天。现在想象一下，你登录 10 个天气网站，其中 9个告诉你会下雨，1个告诉你会是晴天。哪个消息来源更可靠？你倾向于相信大多数气象广播电台告诉你的（晴天）？还是你倾向于相信天气网站告诉你的（下雨）？理性的做法是更倾向于网站的结论，因为许多网站的结论都是一致的，即它们的方差较小，而气象广播电台，至少在这个例子中，它们的结论似乎波动很大，所以也许不应该太相信。</p><p>这样，完整的更新步骤就变成了这样：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> statistics import <span class="hljs-built_in">variance</span><br><br><span class="hljs-comment"># Find updated positions per passenger at t seconds</span><br>def update(t, <span class="hljs-keyword">last</span>):<br> velocity_updates = []<br> sensor_updates = []<br><br> <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>): <span class="hljs-comment"># for each passenger</span><br> <span class="hljs-comment"># new velocity update based on last known position</span><br> <span class="hljs-comment"># for the passenger</span><br> velocity_updates.append(new_position(<span class="hljs-keyword">last</span>[p]))<br> sensor_updates.append(sensor(t))<br> <br> <span class="hljs-comment"># Calculate trust metrics for velocity and sensor measurements</span><br> <span class="hljs-comment"># Remember that as fluctuation increases, trust decreases</span><br> <span class="hljs-comment"># And vice-versa</span><br> fluctuation_velocity = <span class="hljs-built_in">variance</span>(velocity_updates)<br> fluctuation_sensor = <span class="hljs-built_in">variance</span>(sensor_updates)<br><br> <span class="hljs-comment"># calculate trust</span><br> trust_velocity = <span class="hljs-number">1</span>/fluctuation_velocity<br> trust_sensor = <span class="hljs-number">1</span>/fluctuation_sensor<br><br> <span class="hljs-comment"># combine these together for each passenger</span><br> combined = []<br> <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br> combined.append(<span class="hljs-built_in">combine</span>(A = velocity_updates[p],<br> B = sensor_updates[p],<br> trustA = trust_velocity,<br> trustB = trust_sensor))<br> <span class="hljs-comment"># Sensor updates &amp; velocity updates returned for plotting purposes</span><br> <span class="hljs-literal">return</span> sensor_updates, velocity_updates, combined<br></code></pre></td></tr></table></figure><blockquote><p>注：有关方差函数的更多信息，请参阅附录。现在，只需将其视为数字列表波动的度量。</p></blockquote><p>这段代码相对简单。对于每位乘客，它都会进行基于速度的噪声测量和基于传感器的噪声测量。根据所有乘客的这些测量结果，计算出每个测量结果的信任度指标，作为方差的倒数（因为方差增加，信任度降低），然后调用包含相关信任度参数的组合方法。值得注意的是，这里的每位乘客都在为自己进行位置更新。在这些单个更新结束后，可以根据所有乘客位置的平均值推断出船只本身的实际位置。</p><p>我们使用以下代码来连接上述整个代码。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># W<span class="hljs-string">e&#x27;ll do a final plot using this list</span><br><span class="hljs-string">plot_data = []</span><br><span class="hljs-string"></span><br><span class="hljs-string">def update_plot(t, sensor, velocity, combined_position):</span><br><span class="hljs-string"> # add true position at this time</span><br><span class="hljs-string"> plot_data.append(&#123;&#x27;</span>passenger<span class="hljs-string">&#x27;: &#x27;</span>tru<span class="hljs-string">e&#x27;, &#x27;</span>typ<span class="hljs-string">e&#x27;: &#x27;</span>tru<span class="hljs-string">e&#x27;, &#x27;</span><span class="hljs-type">time</span><span class="hljs-string">&#x27;: t,</span><br><span class="hljs-string"> &#x27;</span>position<span class="hljs-string">&#x27;: true_position[t]&#125;)</span><br><span class="hljs-string"> # for each passengers</span><br><span class="hljs-string"> for p in range(1000):</span><br><span class="hljs-string"> plot_data.append(&#123;&#x27;</span>passenger<span class="hljs-string">&#x27;: p, &#x27;</span>typ<span class="hljs-string">e&#x27;: &#x27;</span>sensor<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-type">time</span><span class="hljs-string">&#x27;: t,</span><br><span class="hljs-string"> &#x27;</span>position<span class="hljs-string">&#x27;: sensor[p]&#125;)</span><br><span class="hljs-string"> plot_data.append(&#123;&#x27;</span>passenger<span class="hljs-string">&#x27;: p, &#x27;</span>typ<span class="hljs-string">e&#x27;: &#x27;</span>velocity<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-type">time</span><span class="hljs-string">&#x27;: t,</span><br><span class="hljs-string"> &#x27;</span>position<span class="hljs-string">&#x27;: velocity[p]&#125;)</span><br><span class="hljs-string"> plot_data.append(&#123;&#x27;</span>passenger<span class="hljs-string">&#x27;: p, &#x27;</span>typ<span class="hljs-string">e&#x27;: &#x27;</span>combined<span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-type">time</span><span class="hljs-string">&#x27;: t,</span><br><span class="hljs-string"> &#x27;</span>position<span class="hljs-string">&#x27;: combined_position[p]&#125;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">update_plot(0, [0]*1000, [0]*1000, [0]*1000)</span><br><span class="hljs-string">estimated_positions = [0]*1000 # all estimates start from 0</span><br><span class="hljs-string">for t in range(1, 10): # ten seconds</span><br><span class="hljs-string"> _sensor, _velocity, estimated_positions = update(t, estimated_positions)</span><br><span class="hljs-string"> update_plot(t, _sensor, _velocity, estimated_positions)</span><br></code></pre></td></tr></table></figure><p>update_plot函数只是做一些基本的簿记工作，以存储用于绘图的瞬时统计数据。这里的主要迭代只是最底层的for循环，它使用乘客当前的最佳估计值，在任何给定时间持续更新位置估计值。除此以外，代码基本上不言自明。</p><p>使用 seaborn 库绘制的结果如下：</p><p><img src="https://qiniu.hivan.me/picGo/20230803011025.png?imgNote"alt="img" /></p><p>由于目前的比例尺，这有点难以解析。让我们放大这两个区域，特别是 t=0.75至 t=1，即传感器正常工作时，以及 t=2 至 t=4 出现故障时。</p><p><img src="https://qiniu.hivan.me/picGo/20230803011027.png?imgNote"alt="img" /></p><p><img src="https://qiniu.hivan.me/picGo/20230803011030.png?imgNote"alt="img" /></p><blockquote><p>注：包络线指的是不确定性。线中的包络线越宽，我们对数字的不确定性就越大。</p></blockquote><p>在第一种情况下，正如您所看到的，所有 1000名乘客的综合位置估计值比单独的速度估计值要好（绿色），虽然在第一种情况下，我们的估计值确实比我们的传感器读数要差，但在第二种情况下，我们的估计值实际上比单独的故障传感器读数要好得多！这是因为卡尔曼滤波器会自动调整不可预见的波动造成的剧烈变化，并始终为我们提供合理可靠的指标。如下图所示，一旦我们的传感器恢复正常（t=4到t=5），卡尔曼滤波器就会再次偏向于传感器（由于传感器读数和真实值重叠太多，所以有点难看）。</p><p><img src="https://qiniu.hivan.me/picGo/20230803011033.png?imgNote"alt="img" /></p><p>我相信你至少对卡尔曼滤波器的工作原理有了一些直观的了解。卡尔曼滤波器的实际理论基础同样引人入胜，如果你的工作需要，我鼓励你继续深入研究。与此同时，我希望这篇文章能证明，代码作为一种形式语言，能在多大程度上帮助人们对那些乍看之下令人生畏的概念产生直觉。我也希望能够通过简单的代码，向大家传授一些我认为很有吸引力的话题的更多见解。</p><h3 id="高斯函数"><strong>高斯函数</strong></h3><p>这里唯一需要知道的特殊函数是正态分布函数，即 gauss(0, 0.1) 和gauss(0,2)。简单地说，它给你一个随机数，这个数通常在 0附近（技术上正确的说法是以 0 为中心），而得到离 0更远的数的几率由第二个参数控制，即 2 和 0.1。</p><p>因此，如果调用 gauss(0,0.1)，得到0.06、-0.07、-0.06、0.02、-0.23、-0.06、0.09等数字的可能性较大，顺序不分先后。</p><p>而如果调用 gauss(0,2)，则更有可能得到1.05、1.03、-1.06、0.32、1.29、-0.40、-1.72 等数字，同样不分先后。</p><p>直观地说，第二个参数也叫标准偏差，控制着测量值的波动程度。在上面的代码中，这意味着您通常会认为风的偏差过大（大风天？请注意下面直方图中偏差=2和偏差=0.1 所产生的数字的频率（特别注意 x轴）。虽然数字的范围有很大不同，但这两个直方图的形状看起来差不多。这种钟形分布被称为高斯分布、正态分布或钟形曲线分布，在自然界中经常出现。</p><p><img src="https://qiniu.hivan.me/picGo/20230803011036.png?imgNote"alt="img" /></p><p><img src="https://qiniu.hivan.me/picGo/20230803011039.png?imgNote"alt="img" /></p><h3 id="方差"><strong>方差</strong></h3><p>方差是衡量一致性的标准。也就是说，如果一致性好，方差就小，反之亦然。在上图中，由于x轴实际上是自动调整的，所以你无法完全看到方差。如果我们在相同的坐标轴限制内绘制上图中的直方图，就会得到如下结果：</p><p><img src="https://qiniu.hivan.me/picGo/20230803011041.png?imgNote"alt="img" /></p><p><img src="https://qiniu.hivan.me/picGo/20230803011044.png?imgNote"alt="img" /></p><p>注意到第一张图片有多宽了吗？这是因为其中的数字变化很大。也就是说，你会发现其中有很多-2、2、0 和一些 4、-4。但在第二幅图中，你会发现很多 0、0.1、-0.1等，但你会发现-2、2等的数量会少很多。正确地说，第一个分布的方差（准确地说是4）大于第二个分布的方差（0.01）。有关方差的更多信息，请上网查阅。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果你想查看的话，本文的代码可以在我的&lt;a
href=&quot;https://github.com/hivandu/AI_Cheats/blob/main/Python/Kalman.ipynb&quot;&gt;Github&lt;/a&gt;上查看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;卡尔曼滤波器非常巧妙。如果你从未听说过卡尔曼滤波器，那么一种非常直观（也可以说是还原）的思考方式就是将其视为一个漏斗，在这里你可以从多个嘈杂的信息源中获取信息，并将其浓缩为一个更精确的统计数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
    <category term="Math" scheme="https://hivan.me/tags/Math/"/>
    
  </entry>
  
</feed>
