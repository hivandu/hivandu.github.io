<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶桁.MAMT</title>
  
  <subtitle>ChaHeng Notes，codding and writting ~</subtitle>
  <link href="https://hivan.me/atom.xml" rel="self"/>
  
  <link href="https://hivan.me/"/>
  <updated>2023-08-24T07:51:09.512Z</updated>
  <id>https://hivan.me/</id>
  
  <author>
    <name>Hivan Du</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>茶桁的AI秘籍 - 人工智能数学基础篇 导言</title>
    <link href="https://hivan.me/Math-Introduction/"/>
    <id>https://hivan.me/Math-Introduction/</id>
    <published>2023-08-24T07:43:45.000Z</published>
    <updated>2023-08-24T07:51:09.512Z</updated>
    
    <content type="html"><![CDATA[<p><imgsrc="https://raw.githubusercontent.com/hivandu/notes/main/img/20230824152200.png"alt="数学基础篇 Cover" /></p><p>Hi, 大家好。又见面了，我是茶桁。</p><span id="more"></span><p>在之前的一个多月前，我有了一个写一个AI系列的想法，起名为《茶桁的AI秘籍》，简单规划之后，于7月27日发出预告，然后历时二十多天将近一个月，完成了其中《Python篇》的写作。</p><p>不知道其中的内容对大家是否有帮助呢？</p><p>那么今天我又回来了，根据规划，Python以及相关第三方科学计算库只是我们基础学习的一小部分，而很大一部分基础学习都还未进行。</p><p>那么这次，我依然给大家带来的是另外一篇基础部分，「人工智能数学基础篇」。</p><p>数学对于计算机编程来说重要性是毋庸置疑的，更何况我们现在不仅仅是编程，而是走在「人工智能」的路上。可以说，数学应该是最重要的基础。</p><p>我们在学习AI的过程当中可能会遇到的一些关于数学方面的一些东西，比如说线性代数里面的矩阵运算，比如说求导，还有一些概率统计，图论方面的一些东西。</p><p>如果您觉得自己对于微积分，线性代数，概率统计这些内容自认为掌握的还不错的同学，其实是可以不用看了。如果大家是从文科转过来或者说以前上的数学很多年了也忘的差不多了，那可以来学习一下这套课程。</p><h2 id="你将会学到的">你将会学到的</h2><table><tbody><tr class="odd"><td>✓ 掌握数据科学领域必备数学知识点</td><td>✓ 掌握机器学习算法中常用数学</td></tr><tr class="even"><td>✓ 通俗理解各项数学公式的作用</td><td>✓ 掌握数学知识点应用领域与方法</td></tr><tr class="odd"><td>✓ 掌握高等数学</td><td>✓ 掌握线性代数</td></tr><tr class="even"><td>✓ 掌握概率论</td><td>✓ 掌握统计分析方法</td></tr><tr class="odd"><td>✓ 掌握结合Python进行数学操作</td><td></td></tr></tbody></table><h2 id="课程内容">课程内容</h2><h3 id="数学导论">数学导论</h3><ul><li>数学导论概述</li><li>微积分基础（导数）</li><li>线性代数基础（矩阵）</li><li>概率&amp;统计基础（随机变量）</li><li>图论（图的概念）</li></ul><h3 id="微积分">微积分</h3><ul><li>函数</li><li>极限&amp;连续</li><li>导数</li><li>微分</li><li>链式法则</li><li>偏导数</li><li>梯度</li><li>积分</li><li>牛顿-莱布尼兹公式</li><li>泰勒展开</li></ul><h3 id="线性代数">线性代数</h3><ul><li>线性方程组</li><li>行列式与克拉默法则</li><li>矩阵及其运算</li><li>神经网络中的矩阵/向量</li><li>矩阵的性质</li><li>矩阵与线性变换</li><li>线性变换的几何意义</li><li>特征值与特征向量</li><li>NumPy中矩阵的操作</li></ul><h3 id="概率统计">概率&amp;统计</h3><ul><li>概率是什么</li><li>古典概型&amp;几何概型</li><li>条件概率&amp;联合概率</li><li>期望&amp;方差&amp;协方差</li><li>二项分布</li><li>高斯分布</li><li>中心极限定理</li><li>泊松分布</li><li>贝叶斯先验分布&amp;后验分布</li><li>机器学习分类指标</li></ul><h3 id="图论">图论</h3><ul><li>图的由来</li><li>图的构成</li><li>图的表示</li><li>邻接矩阵</li><li>图的种类</li><li>最短路径问题</li><li>Dijkstra算法</li><li>树</li><li>最小生成树</li><li>图与人工智能</li></ul><h2 id="要求">要求</h2><ul><li>有一定的数学基础学习起来更顺手</li><li>熟悉Python将更快上手进行统计分析</li></ul><h2 id="说明">说明</h2><p>本篇是系列《茶桁的AI秘籍》中的《基础数学篇》，旨在帮助同学们快速打下数学基础，通俗讲解其中每一个知识点。课程内容涉及高等数学，线性代数，概率论与统计学，同学们在学习过程中应当以理解为出发点并不需要死记每一个公式，快速掌握核心知识点。课程章节内容较多，零基础同学按顺序学习即可，有基础的同学们可以按照自己的需求来有选择的学习！</p><h2 id="此课程面向哪些人">此课程面向哪些人：</h2><ul><li>数据科学方向的同学们；</li><li>准备继续学习机器学习，深度学习等方向的同学；</li><li>准备面试及就业AI相关方向的同学</li></ul><p>对此有需求的小伙伴，赶紧如下方式订阅起来：</p><p>扫码并关注微信号「坍缩的奇点」，然后搜索「数学篇」。</p><p><imgsrc="https://raw.githubusercontent.com/hivandu/notes/main/img/20230824154925.png"alt="扫码_搜索联合传播样式-标准色版" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img
src=&quot;https://raw.githubusercontent.com/hivandu/notes/main/img/20230824152200.png&quot;
alt=&quot;数学基础篇 Cover&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi, 大家好。又见面了，我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Math" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Math/"/>
    
    
    <category term="Math" scheme="https://hivan.me/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>27. Pandas</title>
    <link href="https://hivan.me/AI-Python-Pandas/"/>
    <id>https://hivan.me/AI-Python-Pandas/</id>
    <published>2023-08-22T05:21:59.000Z</published>
    <updated>2023-08-22T16:10:43.276Z</updated>
    
    <content type="html"><![CDATA[<img src="/AI-Python-Pandas/cover.png" class="" title="cover"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>先跟小伙伴们打个招呼，今天这节课呢，就是我们Python基础课程的最后一节课了。</p><p>在本节课之前，我们讲解了Python的基础，介绍了两个第三方库。而今天一样会介绍一个第三方库：Pandas。</p><p>虽然是最后一节课了，但是本节课的任务却是一点也不轻松。相比较而言，如果你以后从事的是数据治理和分析工作，那么本节课的内容可能会是你在今后工作中用到的最多的内容。我们需要学习行列索引的操作，数据的处理，数据的合并，多层索引，时间序列，数据的分组聚合（重点）。最后，我们会有一个案例的展示。</p><p>听着是不是很兴奋？那我们就开始吧。</p><p>在开始讲解pandas之前，我们讲解一些关于数据的小知识。</p><p>我们大部分人应该都用过Excel表格，而我们从数据库中拿到的数据，也基本上和Excel上的数据差不多，都是由行列组成的。可以直接导出为<code>csv</code>文件。</p><p>也就是说，我们大部分时候要处理的数据，基本上都一组二维数据。例如，我们今天最后案例要用到的一个电影数据(部分)，如图：</p><img src="/AI-Python-Pandas/move_dataset.png" class="" title="move_dataset"><p>这里面，我们就将数据通过行列来展示和定位。</p><p>了解了这一点之后，我们来开始学习pandas。</p><h2 id="pandas简介">Pandas简介</h2><img src="/AI-Python-Pandas/image-20230822134436992.png" class="" title="pandas"><p>在之前的介绍中，我们发现很多的操作似乎都似曾相识，在NumPy中我们好像都接触过。</p><p>有这种感觉很正常，Pandas本身就是基于NumPy的一种工具，该⼯具是为了解决数据分析任务⽽创建的。Pandas纳⼊了⼤量库和⼀些标准的数据模型，提供了⾼效地操作⼤型数据集所需的⼯具。pandas提供了⼤量能使我们快速便捷地处理数据的函数和⽅法。</p><h2 id="series对象">Series对象</h2><p>Pandas基于两种数据类型：<code>series</code>与<code>dataframe</code>。</p><p><code>Series</code>是Pandas中最基本的对象，Series类似⼀种⼀维数组。事实上，Series基本上就是基于NumPy的数组对象来的。和NumPy的数组不同，Series能为数据⾃定义标签，也就是索引（index），然后通过索引来访问数组中的数据。</p><p><code>Dataframe</code>是⼀个⼆维的表结构。Pandas的dataframe可以存储许多种不同的数据类型，并且每⼀个坐标轴都有⾃⼰的标签。你可以把它想象成⼀个series的字典项。</p><p>在开始基于代码进行学习之前，我们需要应用一些必要项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> Series<br><span class="hljs-keyword">from</span> pandas <span class="hljs-keyword">import</span> DataFrame <span class="hljs-keyword">as</span> df<br></code></pre></td></tr></table></figure><p>现在我们来看看Series的一些基本操作：</p><p><strong>创建Series对象并省略索引</strong></p><p><code>index</code> 参数是可省略的，你可以选择不输⼊这个参数。如果不带<code>index</code> 参数，Pandas 会⾃动⽤默认 <code>index</code>进⾏索引，类似数组，索引值是 <code>[0, ..., len(data) - 1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sel = Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(sel)<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">1</span><br><span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">2</span>    <span class="hljs-number">3</span><br><span class="hljs-number">3</span>    <span class="hljs-number">4</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>我们之前在NumPy中学习了dtype,以及它的相关数据类型。所以现在的<code>dtype: int64</code>我们应该能理解是什么意思了。</p><p>我们看打印的结果，在<code>1,2,3,4</code>前面，是Series默认生成的索引值。</p><p><strong>通常我们会⾃⼰创建索引</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sel = Series(data=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], index= <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>))<br><span class="hljs-built_in">print</span>(sel)<br><br>---<br>a    <span class="hljs-number">1</span><br>b    <span class="hljs-number">2</span><br>c    <span class="hljs-number">3</span><br>d    <span class="hljs-number">4</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>这个时候，我们可以对这个Series对象操作分别<strong>获取内容和索引</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;values: <span class="hljs-subst">&#123;sel.values&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(sel.index)<br><br>---<br>values: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br>Index([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>], dtype=<span class="hljs-string">&#x27;object&#x27;</span>)<br></code></pre></td></tr></table></figure><p>又或者，我们可以直接<strong>获取健值对</strong>（索引和值对）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(sel.iteritems()))<br><br>---<br>[(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">4</span>)]<br></code></pre></td></tr></table></figure><p>那么这种健值对的形式让你想到了什么？是字典对吧？</p><p>我们完全可以<strong>将字典转为Series</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>=&#123;<span class="hljs-string">&quot;red&quot;</span>:<span class="hljs-number">100</span>,<span class="hljs-string">&quot;black&quot;</span>:<span class="hljs-number">400</span>,<span class="hljs-string">&quot;green&quot;</span>:<span class="hljs-number">300</span>,<span class="hljs-string">&quot;pink&quot;</span>:<span class="hljs-number">900</span>&#125;<br>se3=Series(<span class="hljs-built_in">dict</span>) <br><span class="hljs-built_in">print</span>(se3)<br><br>---<br>red      <span class="hljs-number">100</span><br>black    <span class="hljs-number">400</span><br>green    <span class="hljs-number">300</span><br>pink     <span class="hljs-number">900</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>Series数据获取</p><p>在Series拿到数据转为Series对象之后，诺大的数据中，我们如何定位并获取到我们想要的内容呢？</p><p>Series在获取数据上，支持位置、标签、获取不连续数据，使用切片等方式。我们一个个的看一下：</p><p>Series对象同时⽀持<strong>位置和标签</strong>两种⽅式获取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;索引下标&#x27;</span>,sel[<span class="hljs-string">&#x27;c&#x27;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;位置下标&#x27;</span>,sel[<span class="hljs-number">2</span>])<br><br>---<br>索引下标 <span class="hljs-number">3</span><br>位置下标 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>获取不连续的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;位置切⽚\n&#x27;</span>,sel[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<span class="hljs-comment"># 左包含右不包含</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n索引切⽚\n&#x27;</span>,sel[<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-string">&#x27;d&#x27;</span>])<span class="hljs-comment"># 左右都包含</span><br><br>---<br>位置切⽚<br>b    <span class="hljs-number">2</span><br>c    <span class="hljs-number">3</span><br>dtype: int64<br><br>索引切⽚<br>b    <span class="hljs-number">2</span><br>c    <span class="hljs-number">3</span><br>d    <span class="hljs-number">4</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>我们看到结果，发现两组数据数量不对，但是其实我们获取的位置都是一样的。这是因为，位置切片的方式会是「左包含右不包含」的，而索引切片则是「左右都包含」。</p><p>重新赋值索引的值</p><p>除了获取数据之外，我们还可以对数据进行重新索引。其实在之前我们将索引的时候，第二种自己赋值的方式实际上就是一个重新赋值了，将自己定义的值替换了默认值。这里让我们再来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sel.index = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;dcba&#x27;</span>)<br><span class="hljs-built_in">print</span>(sel)<br><br>---<br>d    <span class="hljs-number">1</span><br>c    <span class="hljs-number">2</span><br>b    <span class="hljs-number">3</span><br>a    <span class="hljs-number">4</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>还有一种重新索引的方法<code>reindex</code>，这会返回一个新的Series。调用<code>reindex</code>将会重新排序，缺失值这会用<code>NaN</code>填补。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(sel.reindex([<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>]))<br><br>---<br>b    <span class="hljs-number">3.0</span><br>a    <span class="hljs-number">4.0</span><br>c    <span class="hljs-number">2.0</span><br>d    <span class="hljs-number">1.0</span><br>e    NaN<br>dtype: float64<br></code></pre></td></tr></table></figure><p>在重新索引的时候，我们特意多增加了一个索引。在最后一位没有数据的情况下，缺失值被<code>NaN</code>填补上了。</p><p>丢弃指定轴上的项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">sel = pd.Series(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>))<br><span class="hljs-built_in">print</span>(sel)<br><span class="hljs-built_in">print</span>(sel.drop([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]))<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">10</span><br><span class="hljs-number">1</span>    <span class="hljs-number">11</span><br><span class="hljs-number">2</span>    <span class="hljs-number">12</span><br><span class="hljs-number">3</span>    <span class="hljs-number">13</span><br><span class="hljs-number">4</span>    <span class="hljs-number">14</span><br>dtype: int64<br><span class="hljs-number">0</span>    <span class="hljs-number">10</span><br><span class="hljs-number">1</span>    <span class="hljs-number">11</span><br><span class="hljs-number">4</span>    <span class="hljs-number">14</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>使用<code>drop</code>，会丢弃掉轴上的项，例子中，我们将2，3进行了丢弃。</p><p><strong>Series进⾏算术运算操作</strong></p><p>对 Series 的算术运算都是基于 index进⾏的。我们可以⽤加减乘除（<code>+ - * /</code>）这样的运算符对两个Series 进⾏运算，Pandas 将会根据索引index，对响应的数据进⾏计算，结果将会以浮点数的形式存储，以避免丢失精度。如果Pandas 在两个 Series ⾥找不到相同的 index，对应的位置就返回⼀个空值<code>NaN</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Series 算数运算</span><br>series1 = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&#x27;London&#x27;</span>,<span class="hljs-string">&#x27;HongKong&#x27;</span>,<span class="hljs-string">&#x27;Humbai&#x27;</span>,<span class="hljs-string">&#x27;lagos&#x27;</span>])<br>series2 = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>],[<span class="hljs-string">&#x27;London&#x27;</span>,<span class="hljs-string">&#x27;Accra&#x27;</span>,<span class="hljs-string">&#x27;lagos&#x27;</span>,<span class="hljs-string">&#x27;Delhi&#x27;</span>])<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;series1-series2:&#x27;</span>)<br><span class="hljs-built_in">print</span>(series1-series2) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nseries1+series2:&#x27;</span>)<br><span class="hljs-built_in">print</span>(series1+series2) <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nseries1*series2:&#x27;</span>)<br><span class="hljs-built_in">print</span>(series1*series2)<br><br>---<br>series1-series2:<br>Accra       NaN<br>Delhi       NaN<br>HongKong    NaN<br>Humbai      NaN<br>London      <span class="hljs-number">0.0</span><br>lagos      -<span class="hljs-number">2.0</span><br>dtype: float64<br><br>series1+series2:<br>Accra        NaN<br>Delhi        NaN<br>HongKong     NaN<br>Humbai       NaN<br>London       <span class="hljs-number">2.0</span><br>lagos       <span class="hljs-number">10.0</span><br>dtype: float64<br><br>series1*series2:<br>Accra        NaN<br>Delhi        NaN<br>HongKong     NaN<br>Humbai       NaN<br>London       <span class="hljs-number">1.0</span><br>lagos       <span class="hljs-number">24.0</span><br>dtype: float64<br></code></pre></td></tr></table></figure><p>除此之外，Series的算术运算操作同样也<strong>支持NumPy的数组运算</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">sel = Series(data = [<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], index = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>))<br><span class="hljs-built_in">print</span>(sel[sel&gt;<span class="hljs-number">3</span>]) <span class="hljs-comment"># 布尔数组过滤</span><br><span class="hljs-built_in">print</span>(sel*<span class="hljs-number">2</span>) <span class="hljs-comment"># 标量乘法</span><br><span class="hljs-built_in">print</span>(np.square(sel)) <span class="hljs-comment"># 可以直接加⼊到numpy的数学函数</span><br><br>---<br>b    <span class="hljs-number">6</span><br>d    <span class="hljs-number">5</span><br>dtype: int64<br>a     <span class="hljs-number">2</span><br>b    <span class="hljs-number">12</span><br>c     <span class="hljs-number">6</span><br>d    <span class="hljs-number">10</span><br>dtype: int64<br>a     <span class="hljs-number">1</span><br>b    <span class="hljs-number">36</span><br>c     <span class="hljs-number">9</span><br>d    <span class="hljs-number">25</span><br>dtype: int64<br></code></pre></td></tr></table></figure><h2 id="dataframe">DataFrame</h2><p>DataFrame（数据表）是⼀种2维数据结构，数据以表格的形式存储，分成若⼲⾏和列。通过DataFrame，你能很⽅便地处理数据。常见的操作⽐如选取、替换⾏或列的数据，还能重组数据表、修改索引、多重筛选等。我们基本上可以把DataFrame 理解成⼀组采⽤同样索引的 Series 的集合。调⽤<code>DataFrame()</code>可以将多种格式的数据转换为DataFrame对象，它的的三个参数<code>data</code>、<code>index</code>和<code>columns</code>分别为数据、⾏索引和列索引。</p><h3 id="dataframe的创建">DataFrame的创建</h3><p><strong>我们可以使用二维数组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = df(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)),index=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],columns=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>   a  b  c  d<br><span class="hljs-number">1</span>  <span class="hljs-number">9</span>  <span class="hljs-number">6</span>  <span class="hljs-number">3</span>  <span class="hljs-number">0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">6</span>  <span class="hljs-number">2</span>  <span class="hljs-number">7</span>  <span class="hljs-number">0</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">1</span>  <span class="hljs-number">6</span>  <span class="hljs-number">5</span><br><span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>也可以<strong>使用字典创建</strong></p><p>行索引由index决定，列索引由字典的键决定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span>=&#123;<span class="hljs-string">&#x27;Province&#x27;</span>: [<span class="hljs-string">&#x27;Guangdong&#x27;</span>, <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;Qinghai&#x27;</span>,<span class="hljs-string">&#x27;Fujian&#x27;</span>],<span class="hljs-string">&#x27;pop&#x27;</span>: [<span class="hljs-number">1.3</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">0.7</span>], <span class="hljs-string">&#x27;year&#x27;</span>: [<span class="hljs-number">2022</span>, <span class="hljs-number">2022</span>, <span class="hljs-number">2022</span>, <span class="hljs-number">2022</span>]&#125;<br>df2= df(<span class="hljs-built_in">dict</span>,index=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]) <br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>    Province  pop  year<br><span class="hljs-number">1</span>  Guangdong  <span class="hljs-number">1.3</span>  <span class="hljs-number">2022</span><br><span class="hljs-number">2</span>    Beijing  <span class="hljs-number">2.5</span>  <span class="hljs-number">2022</span><br><span class="hljs-number">3</span>    Qinghai  <span class="hljs-number">1.1</span>  <span class="hljs-number">2022</span><br><span class="hljs-number">4</span>     Fujian  <span class="hljs-number">0.7</span>  <span class="hljs-number">2022</span><br></code></pre></td></tr></table></figure><p><strong>使用<code>from_dict</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dict2=&#123;<span class="hljs-string">&quot;a&quot;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<span class="hljs-string">&quot;b&quot;</span>:[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]&#125;<br>df6=df.from_dict(dict2) <br><span class="hljs-built_in">print</span>(df6)<br><br>---<br>   a  b<br><span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">4</span><br><span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">5</span><br><span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>索引相同的情况下，相同索引的值会相对应，缺少的值会添加<code>NaN</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<br> <span class="hljs-string">&#x27;Name&#x27;</span>:pd.Series([<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-string">&#x27;ls&#x27;</span>,<span class="hljs-string">&#x27;we&#x27;</span>],index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]),<br> <span class="hljs-string">&#x27;Age&#x27;</span>:pd.Series([<span class="hljs-string">&#x27;10&#x27;</span>,<span class="hljs-string">&#x27;20&#x27;</span>,<span class="hljs-string">&#x27;30&#x27;</span>,<span class="hljs-string">&#x27;40&#x27;</span>],index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>]),<br> <span class="hljs-string">&#x27;country&#x27;</span>:pd.Series([<span class="hljs-string">&#x27;中国&#x27;</span>,<span class="hljs-string">&#x27;⽇本&#x27;</span>,<span class="hljs-string">&#x27;韩国&#x27;</span>],index=[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>])<br>&#125;<br>df = pd.DataFrame(data)<br><span class="hljs-built_in">print</span>(df)<br><br>---<br>  Name Age country<br>a   zs  <span class="hljs-number">10</span>      中国<br>b   ls  <span class="hljs-number">20</span>      韩国<br>c   we  <span class="hljs-number">30</span>      ⽇本<br>d  NaN  <span class="hljs-number">40</span>     NaN<br></code></pre></td></tr></table></figure><p>看了那么多DataFrame的转换方式，那我们如何将数据转为字典呢？DataFrame有一个内置方法<code>to_dict()</code>能将DataFrame对象转换为字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dict</span> = df.to_dict()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dict</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Name&#x27;</span>: &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;zs&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;ls&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;we&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>: nan&#125;, <span class="hljs-string">&#x27;Age&#x27;</span>: &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;30&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-string">&#x27;40&#x27;</span>&#125;, <span class="hljs-string">&#x27;country&#x27;</span>: &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;中国&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;韩国&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;⽇本&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>: nan&#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="dataframe对象常属性">DataFrame对象常⽤属性</h3><p>让我们先来生成一组数据备用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">df_dict = &#123;<br><span class="hljs-string">&#x27;name&#x27;</span>:[<span class="hljs-string">&#x27;James&#x27;</span>,<span class="hljs-string">&#x27;Curry&#x27;</span>,<span class="hljs-string">&#x27;Iversion&#x27;</span>],<br><span class="hljs-string">&#x27;age&#x27;</span>:[<span class="hljs-string">&#x27;18&#x27;</span>,<span class="hljs-string">&#x27;20&#x27;</span>,<span class="hljs-string">&#x27;19&#x27;</span>],<br> <span class="hljs-string">&#x27;national&#x27;</span>:[<span class="hljs-string">&#x27;us&#x27;</span>,<span class="hljs-string">&#x27;China&#x27;</span>,<span class="hljs-string">&#x27;us&#x27;</span>] &#125;<br>df = pd.DataFrame(data=df_dict,index=[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>])<br><span class="hljs-built_in">print</span>(df)<br><br>---<br>       name age national<br><span class="hljs-number">0</span>     James  <span class="hljs-number">18</span>       us<br><span class="hljs-number">1</span>     Curry  <span class="hljs-number">20</span>    China<br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span>       us<br></code></pre></td></tr></table></figure><p>获取⾏数和列数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.shape)<br><br>---<br>(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>获取⾏索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.index.tolist())<br><br>---<br>[<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]<br></code></pre></td></tr></table></figure><p>获取列索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.columns.tolist())<br><br>---<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;national&#x27;</span>]<br></code></pre></td></tr></table></figure><p>获取数据的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.dtypes)<br><br>---<br>name        <span class="hljs-built_in">object</span><br>age         <span class="hljs-built_in">object</span><br>national    <span class="hljs-built_in">object</span><br>dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>获取数据的维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.ndim)<br><br>---<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>values属性也会以<strong>⼆维ndarray的形式</strong>返回DataFrame的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.values)<br><br>---<br>[[<span class="hljs-string">&#x27;James&#x27;</span> <span class="hljs-string">&#x27;18&#x27;</span> <span class="hljs-string">&#x27;us&#x27;</span>]<br> [<span class="hljs-string">&#x27;Curry&#x27;</span> <span class="hljs-string">&#x27;20&#x27;</span> <span class="hljs-string">&#x27;China&#x27;</span>]<br> [<span class="hljs-string">&#x27;Iversion&#x27;</span> <span class="hljs-string">&#x27;19&#x27;</span> <span class="hljs-string">&#x27;us&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>展示df的概览</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.info())<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;<br>Index: <span class="hljs-number">3</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">2</span><br>Data columns (total <span class="hljs-number">3</span> columns):<br> <span class="hljs-comment">#   Column    Non-Null Count  Dtype </span><br>---  ------    --------------  ----- <br> <span class="hljs-number">0</span>   name      <span class="hljs-number">3</span> non-null      <span class="hljs-built_in">object</span><br> <span class="hljs-number">1</span>   age       <span class="hljs-number">3</span> non-null      <span class="hljs-built_in">object</span><br> <span class="hljs-number">2</span>   national  <span class="hljs-number">3</span> non-null      <span class="hljs-built_in">object</span><br>dtypes: <span class="hljs-built_in">object</span>(<span class="hljs-number">3</span>)<br>memory usage: <span class="hljs-number">96.0</span>+ <span class="hljs-built_in">bytes</span><br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>显示头⼏⾏,默认显示5⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.head(<span class="hljs-number">2</span>))<br><br>---<br>    name age national<br><span class="hljs-number">0</span>  James  <span class="hljs-number">18</span>       us<br><span class="hljs-number">1</span>  Curry  <span class="hljs-number">20</span>    China<br></code></pre></td></tr></table></figure><p>显示后⼏⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.tail(<span class="hljs-number">1</span>))<br><br>---<br>       name age national<br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span>       us<br></code></pre></td></tr></table></figure><p>获取DataFrame的列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df[<span class="hljs-string">&#x27;name&#x27;</span>])<br><br>---<br><span class="hljs-number">0</span>       James<br><span class="hljs-number">1</span>       Curry<br><span class="hljs-number">2</span>    Iversion<br>Name: name, dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>因为我们<strong>只获取⼀列</strong>，所以返回的就是⼀个Series</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(df[<span class="hljs-string">&#x27;name&#x27;</span>]))<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;pandas.core.series.Series&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>如果<strong>获取多个列</strong>，那返回的就是⼀个DataFrame 类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df[[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>]])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(df[[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>]]))<br><br>---<br>       name age<br><span class="hljs-number">0</span>     James  <span class="hljs-number">18</span><br><span class="hljs-number">1</span>     Curry  <span class="hljs-number">20</span><br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span><br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;pandas.core.frame.DataFrame&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>获取一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df[<span class="hljs-number">0</span>:<span class="hljs-number">1</span>])<br><br>---<br>    name age national<br><span class="hljs-number">0</span>  James  <span class="hljs-number">18</span>       us<br></code></pre></td></tr></table></figure><p>去多⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><br>---<br>       name age national<br><span class="hljs-number">1</span>     Curry  <span class="hljs-number">20</span>    China<br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span>       us<br></code></pre></td></tr></table></figure><p>取多⾏⾥⾯的某⼀列（不能进⾏多⾏多列的选择）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>][[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>]])<br><br>---<br>       name age<br><span class="hljs-number">1</span>     Curry  <span class="hljs-number">20</span><br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>⚠️注意：<code>df[]</code>只能进⾏⾏选择，或列选择，不能同时多⾏多列选择。比如在NumPy中的<code>data[:,1:3]</code>这种是不行的。当然，并不是没有办法获取，我们接着往下看:</p><p><code>df.loc</code>通过标签索引⾏数据;<code>df.iloc</code>通过位置获取⾏数据</p><p>获取某⼀⾏某⼀列的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>])<br><br>---<br>James<br></code></pre></td></tr></table></figure><p>⼀⾏所有列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-string">&#x27;0&#x27;</span>,:])<br><br>---<br>name        James<br>age            <span class="hljs-number">18</span><br>national       us<br>Name: <span class="hljs-number">0</span>, dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>某⼀⾏多列的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-string">&#x27;0&#x27;</span>,[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>]])<br><br>---<br>name    James<br>age        <span class="hljs-number">18</span><br>Name: <span class="hljs-number">0</span>, dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>选择间隔的多⾏多列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.loc[[<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>],[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;national&#x27;</span>]]) <br><br>---<br>       name national<br><span class="hljs-number">0</span>     James       us<br><span class="hljs-number">2</span>  Iversion       us<br></code></pre></td></tr></table></figure><p>选择连续的多⾏和间隔的多列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;2&#x27;</span>,[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;national&#x27;</span>]])<br><br>---<br>       name national<br><span class="hljs-number">0</span>     James       us<br><span class="hljs-number">1</span>     Curry    China<br><span class="hljs-number">2</span>  Iversion       us<br></code></pre></td></tr></table></figure><p>取⼀⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.iloc[<span class="hljs-number">1</span>])<br><br>---<br>name        Curry<br>age            <span class="hljs-number">20</span><br>national    China<br>Name: <span class="hljs-number">1</span>, dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>取连续多⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br><br>---<br>    name age national<br><span class="hljs-number">0</span>  James  <span class="hljs-number">18</span>       us<br><span class="hljs-number">1</span>  Curry  <span class="hljs-number">20</span>    China<br></code></pre></td></tr></table></figure><p>取间断的多⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.iloc[[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],:])<br><br>---<br>       name age national<br><span class="hljs-number">0</span>     James  <span class="hljs-number">18</span>       us<br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span>       us<br></code></pre></td></tr></table></figure><p>取某⼀列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.iloc[:,<span class="hljs-number">1</span>])<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">18</span><br><span class="hljs-number">1</span>    <span class="hljs-number">20</span><br><span class="hljs-number">2</span>    <span class="hljs-number">19</span><br>Name: age, dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><p>某⼀个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df.iloc[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br><br>---<br>Curry<br></code></pre></td></tr></table></figure><p>修改值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df.iloc[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=<span class="hljs-string">&#x27;panda&#x27;</span><br><span class="hljs-built_in">print</span>(df)<br><br>---<br>       name age national<br><span class="hljs-number">0</span>     panda  <span class="hljs-number">18</span>       us<br><span class="hljs-number">1</span>     Curry  <span class="hljs-number">20</span>    China<br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span>       us<br></code></pre></td></tr></table></figure><p>dataframe中的排序⽅法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df = df.sort_values(by=<span class="hljs-string">&#x27;age&#x27;</span>, ascending*=<span class="hljs-literal">False</span>) <br><span class="hljs-built_in">print</span>(df)<br><br>---<br>       name age national<br><span class="hljs-number">1</span>     Curry  <span class="hljs-number">20</span>    China<br><span class="hljs-number">2</span>  Iversion  <span class="hljs-number">19</span>       us<br><span class="hljs-number">0</span>     panda  <span class="hljs-number">18</span>       us<br></code></pre></td></tr></table></figure><p><code>ascending=False</code>是降序排列，默认为<code>True</code>，也就是升序。</p><h3id="dataframe修改indexcolumns">dataframe<strong>修改</strong>index<strong>、</strong>columns</h3><p>一样，让我们先创建一组新的数据供我们使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), index = [<span class="hljs-string">&#x27;bj&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;gz&#x27;</span>], columns=[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>])<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>    a  b  c<br>bj  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br>sh  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br>gz  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>修改 df1 的 index</p><p><code>df1.index</code>可以打印出df1的索引值，同时也可以为其赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.index) <span class="hljs-comment"># 可以打印出print的值，同时也可以为其赋值</span><br>df1.index = [<span class="hljs-string">&#x27;beijing&#x27;</span>, <span class="hljs-string">&#x27;shanghai&#x27;</span>, <span class="hljs-string">&#x27;guangzhou&#x27;</span>]<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>Index([<span class="hljs-string">&#x27;bj&#x27;</span>, <span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;gz&#x27;</span>], dtype=<span class="hljs-string">&#x27;object&#x27;</span>)<br>           a  b  c<br>beijing    <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br>shanghai   <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span><br>guangzhou  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>⾃定义map函数（x是原有的⾏列值）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ⾃定义map函数（x是原有的⾏列值） </span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_map</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x+<span class="hljs-string">&#x27;_ABC&#x27;</span><br><span class="hljs-built_in">print</span>(df1.rename(index=test_map, columns=test_map, inplace=<span class="hljs-literal">True</span>))<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br><span class="hljs-literal">None</span><br>               a_ABC  b_ABC  c_ABC<br>beijing_ABC        <span class="hljs-number">0</span>      <span class="hljs-number">1</span>      <span class="hljs-number">2</span><br>shanghai_ABC       <span class="hljs-number">3</span>      <span class="hljs-number">4</span>      <span class="hljs-number">5</span><br>guangzhou_ABC      <span class="hljs-number">6</span>      <span class="hljs-number">7</span>      <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>其中的<code>inplace</code>传入一个布尔值，默认为False。指定是否返回新的DataFrame。如果为True，则在原df上修改，返回值为None。</p><p><code>rename</code> 可以传⼊字典，为某个 index 单独修改名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df3 = df1.rename(index=&#123;<span class="hljs-string">&#x27;beijing_ABC&#x27;</span>:<span class="hljs-string">&#x27;beijing&#x27;</span>&#125;, columns = &#123;<span class="hljs-string">&#x27;a_ABC&#x27;</span>:<span class="hljs-string">&#x27;aa&#x27;</span>&#125;)<br><span class="hljs-built_in">print</span>(df3)<br><br>---<br>               aa  b_ABC  c_ABC<br>beijing         <span class="hljs-number">0</span>      <span class="hljs-number">1</span>      <span class="hljs-number">2</span><br>shanghai_ABC    <span class="hljs-number">3</span>      <span class="hljs-number">4</span>      <span class="hljs-number">5</span><br>guangzhou_ABC   <span class="hljs-number">6</span>      <span class="hljs-number">7</span>      <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>列转化为索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame(&#123;<span class="hljs-string">&#x27;X&#x27;</span>:<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>),<span class="hljs-string">&#x27;Y&#x27;</span>:<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>),<span class="hljs-string">&#x27;S&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;abcde&quot;</span>),<span class="hljs-string">&#x27;Z&#x27;</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]&#125;)<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>   X  Y  S  Z<br><span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  a  <span class="hljs-number">1</span><br><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  b  <span class="hljs-number">1</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  c  <span class="hljs-number">2</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  d  <span class="hljs-number">2</span><br><span class="hljs-number">4</span>  <span class="hljs-number">4</span>  <span class="hljs-number">4</span>  e  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>指定⼀列为索引 (<code>drop=False</code> 指定同时保留作为索引的列)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">result = df1.set_index(<span class="hljs-string">&#x27;S&#x27;</span>,drop=<span class="hljs-literal">False</span>)<br>result.index.name=<span class="hljs-literal">None</span><br><span class="hljs-built_in">print</span>(result)<br><br>---<br>   X  Y  S  Z<br>a  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  a  <span class="hljs-number">1</span><br>b  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  b  <span class="hljs-number">1</span><br>c  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  c  <span class="hljs-number">2</span><br>d  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  d  <span class="hljs-number">2</span><br>e  <span class="hljs-number">4</span>  <span class="hljs-number">4</span>  e  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>⾏转为列索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">result = df1.set_axis(df1.iloc[<span class="hljs-number">0</span>],axis=<span class="hljs-number">1</span>,inplace=<span class="hljs-literal">False</span>)<br>result.columns.name=<span class="hljs-literal">None</span><br><span class="hljs-built_in">print</span>(result)<br><br>---<br>   <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  a  <span class="hljs-number">1</span><br><span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  a  <span class="hljs-number">1</span><br><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span>  b  <span class="hljs-number">1</span><br><span class="hljs-number">2</span>  <span class="hljs-number">2</span>  <span class="hljs-number">2</span>  c  <span class="hljs-number">2</span><br><span class="hljs-number">3</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span>  d  <span class="hljs-number">2</span><br><span class="hljs-number">4</span>  <span class="hljs-number">4</span>  <span class="hljs-number">4</span>  e  <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="添加数据">添加数据</h3><p>先增加一组数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame([[<span class="hljs-string">&#x27;Snow&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">22</span>],[<span class="hljs-string">&#x27;Tyrion&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">32</span>],[<span class="hljs-string">&#x27;Sansa&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">18</span>], [<span class="hljs-string">&#x27;Arya&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">14</span>]],columns=[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>])<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender  age<br><span class="hljs-number">0</span>    Snow      M   <span class="hljs-number">22</span><br><span class="hljs-number">1</span>  Tyrion      M   <span class="hljs-number">32</span><br><span class="hljs-number">2</span>   Sansa      F   <span class="hljs-number">18</span><br><span class="hljs-number">3</span>    Arya      F   <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>在数据框最后加上score⼀列，注意增加列的元素个数要跟原数据列的个数⼀样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;score&#x27;</span>]=[<span class="hljs-number">80</span>,<span class="hljs-number">98</span>,<span class="hljs-number">67</span>,<span class="hljs-number">90</span>] <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender  age  score<br><span class="hljs-number">0</span>    Snow      M   <span class="hljs-number">22</span>     <span class="hljs-number">80</span><br><span class="hljs-number">1</span>  Tyrion      M   <span class="hljs-number">32</span>     <span class="hljs-number">98</span><br><span class="hljs-number">2</span>   Sansa      F   <span class="hljs-number">18</span>     <span class="hljs-number">67</span><br><span class="hljs-number">3</span>    Arya      F   <span class="hljs-number">14</span>     <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>在具体某个位置插⼊⼀列可以⽤<code>insert</code>的⽅法,语法格式：<code>列表.insert(index, obj)</code></p><p><code>index</code> ---&gt;对象 obj 需要插⼊的索引位置。</p><p><code>obj</code>---&gt; 要插⼊列表中的对象（列名）</p><p>将数据框的列名全部提取出来存放在列表⾥</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">col_name=df1.columns.tolist() <br><span class="hljs-built_in">print</span>(col_name)<br><br>---<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在列索引为2的位置插⼊⼀列,列名为:<code>city</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">col_name.insert(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;city&#x27;</span>)<br><span class="hljs-built_in">print</span>(col_name)<br><br>---<br>[<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;city&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>]<br></code></pre></td></tr></table></figure><p>刚插⼊时不会有值，整列都是NaN,我们使用<code>DataFrame.reindex()</code>对原⾏/列索引重新构建索引值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=df1.reindex(columns=col_name)<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender  city  age  score<br><span class="hljs-number">0</span>    Snow      M   NaN   <span class="hljs-number">22</span>     <span class="hljs-number">80</span><br><span class="hljs-number">1</span>  Tyrion      M   NaN   <span class="hljs-number">32</span>     <span class="hljs-number">98</span><br><span class="hljs-number">2</span>   Sansa      F   NaN   <span class="hljs-number">18</span>     <span class="hljs-number">67</span><br><span class="hljs-number">3</span>    Arya      F   NaN   <span class="hljs-number">14</span>     <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>给city列赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;city&#x27;</span>]=[<span class="hljs-string">&#x27;北京京&#x27;</span>,<span class="hljs-string">&#x27;⼭⻄西&#x27;</span>,<span class="hljs-string">&#x27;湖北北&#x27;</span>,<span class="hljs-string">&#x27;澳⻔门&#x27;</span>] <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender city  age  score<br><span class="hljs-number">0</span>    Snow      M  北京京   <span class="hljs-number">22</span>     <span class="hljs-number">80</span><br><span class="hljs-number">1</span>  Tyrion      M  ⼭⻄西   <span class="hljs-number">32</span>     <span class="hljs-number">98</span><br><span class="hljs-number">2</span>   Sansa      F  湖北北   <span class="hljs-number">18</span>     <span class="hljs-number">67</span><br><span class="hljs-number">3</span>    Arya      F  澳⻔门   <span class="hljs-number">14</span>     <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>df中的<code>insert</code>是插⼊⼀列。语法和关键参数为：</p><p><code>df.insert(iloc,column,value)</code></p><p><code>iloc</code>:要插⼊的位置</p><p><code>colunm</code>:列名</p><p><code>value</code>:值</p><p>刚才我们插入<code>city</code>列的时候省略了<code>value</code>,所以新建列值全部为<code>NaN</code>，这次我们加上再看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.insert(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;score2&#x27;</span>,[<span class="hljs-number">80</span>,<span class="hljs-number">98</span>,<span class="hljs-number">67</span>,<span class="hljs-number">90</span>]) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender  score2 city  age  score<br><span class="hljs-number">0</span>    Snow      M      <span class="hljs-number">80</span>  北京京   <span class="hljs-number">22</span>     <span class="hljs-number">80</span><br><span class="hljs-number">1</span>  Tyrion      M      <span class="hljs-number">98</span>  ⼭⻄西   <span class="hljs-number">32</span>     <span class="hljs-number">98</span><br><span class="hljs-number">2</span>   Sansa      F      <span class="hljs-number">67</span>  湖北北   <span class="hljs-number">18</span>     <span class="hljs-number">67</span><br><span class="hljs-number">3</span>    Arya      F      <span class="hljs-number">90</span>  澳⻔门   <span class="hljs-number">14</span>     <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>插⼊⼀⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 插⼊⼀⾏</span><br>row=[<span class="hljs-string">&#x27;111&#x27;</span>,<span class="hljs-string">&#x27;222&#x27;</span>,<span class="hljs-string">&#x27;333&#x27;</span>,<span class="hljs-string">&#x27;444&#x27;</span>,<span class="hljs-string">&#x27;555&#x27;</span>,<span class="hljs-string">&#x27;666&#x27;</span>] <br>df1.iloc[<span class="hljs-number">1</span>]=row<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>    name gender score2 city  age score<br><span class="hljs-number">0</span>   Snow      M     <span class="hljs-number">80</span>  北京京   <span class="hljs-number">22</span>    <span class="hljs-number">80</span><br><span class="hljs-number">1</span>    <span class="hljs-number">111</span>    <span class="hljs-number">222</span>    <span class="hljs-number">333</span>  <span class="hljs-number">444</span>  <span class="hljs-number">555</span>   <span class="hljs-number">666</span><br><span class="hljs-number">2</span>  Sansa      F     <span class="hljs-number">67</span>  湖北北   <span class="hljs-number">18</span>    <span class="hljs-number">67</span><br><span class="hljs-number">3</span>   Arya      F     <span class="hljs-number">90</span>  澳⻔门   <span class="hljs-number">14</span>    <span class="hljs-number">90</span><br></code></pre></td></tr></table></figure><p>插入行的时候，列个数必须对应才可以，否则会报错。</p><p>目前这组数据已经被我们玩乱了，我们再重新生成一组数据来看后面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame([[<span class="hljs-string">&#x27;Snow&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">22</span>],[<span class="hljs-string">&#x27;Tyrion&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-number">32</span>],[<span class="hljs-string">&#x27;Sansa&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">18</span>],[<span class="hljs-string">&#x27;Arya&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-number">14</span>]],columns=[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>])<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender  age<br><span class="hljs-number">0</span>    Snow      M   <span class="hljs-number">22</span><br><span class="hljs-number">1</span>  Tyrion      M   <span class="hljs-number">32</span><br><span class="hljs-number">2</span>   Sansa      F   <span class="hljs-number">18</span><br><span class="hljs-number">3</span>    Arya      F   <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>再继续创建一组数据，我们将尝试将两组数据进行合并,新创建的这组数据⽤来增加进数据框的最后⼀⾏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">new=pd.DataFrame(&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;lisa&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>:<span class="hljs-string">&#x27;F&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">19</span>&#125;,index=[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(new)<br><br>---<br>   name gender  age<br><span class="hljs-number">0</span>  lisa      F   <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>在原数据框df1最后⼀⾏新增⼀⾏，⽤<code>append</code>⽅法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=df1.append(new,ignore_index=<span class="hljs-literal">True</span>) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     name gender  age<br><span class="hljs-number">0</span>    Snow      M   <span class="hljs-number">22</span><br><span class="hljs-number">1</span>  Tyrion      M   <span class="hljs-number">32</span><br><span class="hljs-number">2</span>   Sansa      F   <span class="hljs-number">18</span><br><span class="hljs-number">3</span>    Arya      F   <span class="hljs-number">14</span><br><span class="hljs-number">4</span>    lisa      F   <span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p><code>ignore_index=False</code>,表示不按原来的索引，从0开始⾃动递增。</p><p><code>objs</code>:合并对象</p><p><code>axis</code>:合并⽅式，默认0表示按列合并，1表示按⾏合并</p><p><code>ignore_index</code>:是否忽略索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">df1 = pd.DataFrame(np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>),columns=[<span class="hljs-string">&#x27;four&#x27;</span>,<span class="hljs-string">&#x27;five&#x27;</span>])<br>df2 = pd.DataFrame(np.arange(<span class="hljs-number">6</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),columns=[<span class="hljs-string">&#x27;one&#x27;</span>,<span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-string">&#x27;three&#x27;</span>])<br><span class="hljs-built_in">print</span>(df1)<br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>   four  five<br><span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span><br><span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span><br><span class="hljs-number">2</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span><br>   one  two  three<br><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span><br><span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>      <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>按行合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result = pd.concat([df1,df2],axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>   four  five  one  two  three<br><span class="hljs-number">0</span>     <span class="hljs-number">0</span>     <span class="hljs-number">1</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span>    <span class="hljs-number">2.0</span><br><span class="hljs-number">1</span>     <span class="hljs-number">2</span>     <span class="hljs-number">3</span>  <span class="hljs-number">3.0</span>  <span class="hljs-number">4.0</span>    <span class="hljs-number">5.0</span><br><span class="hljs-number">2</span>     <span class="hljs-number">4</span>     <span class="hljs-number">5</span>  NaN  NaN    NaN<br></code></pre></td></tr></table></figure><p>按列合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">   four  five  one  two  three<br><span class="hljs-number">0</span>   <span class="hljs-number">0.0</span>   <span class="hljs-number">1.0</span>  NaN  NaN    NaN<br><span class="hljs-number">1</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">3.0</span>  NaN  NaN    NaN<br><span class="hljs-number">2</span>   <span class="hljs-number">4.0</span>   <span class="hljs-number">5.0</span>  NaN  NaN    NaN<br><span class="hljs-number">3</span>   NaN   NaN  <span class="hljs-number">0.0</span>  <span class="hljs-number">1.0</span>    <span class="hljs-number">2.0</span><br><span class="hljs-number">4</span>   NaN   NaN  <span class="hljs-number">3.0</span>  <span class="hljs-number">4.0</span>    <span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure><p>看结果我们能看出来，在合并的时候，如果对应不到值，那么就会默认添加<code>NaN</code>值。</p><p>DataFrame的删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">df2 = pd.DataFrame(np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),columns=[<span class="hljs-string">&#x27;one&#x27;</span>,<span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-string">&#x27;three&#x27;</span>])<br><span class="hljs-built_in">print</span>(df2)<br>df3=df2.drop([<span class="hljs-string">&#x27;one&#x27;</span>],axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(df2)<br><span class="hljs-built_in">print</span>(df3)<br><br>---<br>   one  two  three<br><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span><br><span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>      <span class="hljs-number">5</span><br><span class="hljs-number">2</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>      <span class="hljs-number">8</span><br>   two  three<br><span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span><br><span class="hljs-number">1</span>    <span class="hljs-number">4</span>      <span class="hljs-number">5</span><br><span class="hljs-number">2</span>    <span class="hljs-number">7</span>      <span class="hljs-number">8</span><br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><code>lables</code>：要删除数据的标签</p><p><code>axis</code>：0表示删除⾏，1表示删除列，默认0</p><p><code>inplace</code>:是否在当前df中执⾏此操作</p><p>最后的返回值为<code>None</code>，原因是我们设置<code>inplace</code>为<code>True</code>，在当前<code>df</code>中执行操作。如果我们将其设置为<code>False</code>，则会将操作后的值进行返回，生成一个新的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">df3=df2.drop([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],axis=<span class="hljs-number">0</span>, inplace=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(df2)<br><span class="hljs-built_in">print</span>(df3)<br><br>---<br>   one  two  three<br><span class="hljs-number">0</span>    <span class="hljs-number">0</span>    <span class="hljs-number">1</span>      <span class="hljs-number">2</span><br><span class="hljs-number">1</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span>      <span class="hljs-number">5</span><br><span class="hljs-number">2</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>      <span class="hljs-number">8</span><br>   one  two  three<br><span class="hljs-number">2</span>    <span class="hljs-number">6</span>    <span class="hljs-number">7</span>      <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h2 id="数据处理">数据处理</h2><p>在我们查看完DataFrame的基础操作之后，我们现在来正式开始数据处理。</p><p>我们可以通过通过<code>dropna()</code>滤除缺失数据，先让我们创建一组数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">se=pd.Series([<span class="hljs-number">4</span>,NaN,<span class="hljs-number">8</span>,NaN,<span class="hljs-number">5</span>]) <br><span class="hljs-built_in">print</span>(se)<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">4.0</span><br><span class="hljs-number">1</span>    NaN<br><span class="hljs-number">2</span>    <span class="hljs-number">8.0</span><br><span class="hljs-number">3</span>    NaN<br><span class="hljs-number">4</span>    <span class="hljs-number">5.0</span><br>dtype: float64<br></code></pre></td></tr></table></figure><p>尝试清除缺失数据，也就是<code>NaN</code>值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(se.dropna())<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">4.0</span><br><span class="hljs-number">2</span>    <span class="hljs-number">8.0</span><br><span class="hljs-number">4</span>    <span class="hljs-number">5.0</span><br>dtype: float64<br></code></pre></td></tr></table></figure><p>在清除数据之前，我们有两个方法可以判断当前数据中是否有缺失数据，不过这两个方法的判断方式是相反的，一个是判断不是缺失数据，一个判断是缺失数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(se.notnull())<br><span class="hljs-built_in">print</span>(se.isnull())<br><br>---<br><span class="hljs-number">0</span>     <span class="hljs-literal">True</span><br><span class="hljs-number">1</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">2</span>     <span class="hljs-literal">True</span><br><span class="hljs-number">3</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">4</span>     <span class="hljs-literal">True</span><br>dtype: <span class="hljs-built_in">bool</span><br><span class="hljs-number">0</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">1</span>     <span class="hljs-literal">True</span><br><span class="hljs-number">2</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">3</span>     <span class="hljs-literal">True</span><br><span class="hljs-number">4</span>    <span class="hljs-literal">False</span><br>dtype: <span class="hljs-built_in">bool</span><br></code></pre></td></tr></table></figure><p>那既然有方法可以进行判断当前数据是否为缺失数据，那么我们用之前的方法与其配合，一样可以做滤除操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(se[se.notnull()])<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">4.0</span><br><span class="hljs-number">2</span>    <span class="hljs-number">8.0</span><br><span class="hljs-number">4</span>    <span class="hljs-number">5.0</span><br>dtype: float64<br></code></pre></td></tr></table></figure><p>当然，除了Series对象之外，我们还需要进行处理DataFrame对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[NaN,NaN,<span class="hljs-number">2</span>],[NaN,NaN,NaN],[<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,NaN]]) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  NaN  NaN  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  NaN  NaN  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  NaN<br></code></pre></td></tr></table></figure><p>默认滤除所有包含<code>NaN</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.dropna())<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><p>传⼊<code>how=‘all’</code>滤除全为<code>NaN</code>的⾏：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.dropna(how=<span class="hljs-string">&#x27;all&#x27;</span>)) <br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  NaN  NaN  <span class="hljs-number">2.0</span><br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  NaN<br></code></pre></td></tr></table></figure><p>可以看到，除了下标为<code>2</code>的那一行之外，其余含<code>NaN</code>值的行都被保留了。</p><p>之前操作最后只留下一行，原因是<code>how</code>的默认值为<code>how='any'</code>。只要是<code>nan</code>就删除</p><p>传⼊axis=1滤除列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.dropna(axis=<span class="hljs-number">1</span>,how=<span class="hljs-string">&quot;all&quot;</span>))<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  NaN  NaN  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  NaN  NaN  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  NaN<br></code></pre></td></tr></table></figure><p>为什么没有变化？按列来查看，没有一列是全是<code>NaN</code>值的。</p><p>除了<code>how</code>值外，我们还可以可以使用<code>thresh</code>来精准操作，它可以传入一个数值<code>n</code>，会保留至少<code>n</code>个非<code>NaN</code>数据的行或列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.dropna(thresh=<span class="hljs-number">2</span>))<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  NaN<br></code></pre></td></tr></table></figure><p>仅有一个非<code>NaN</code>的行和全部为<code>NaN</code>的行就都被滤除了。</p><p>那<code>NaN</code>是不是就只能被删除了呢？并不是，还记得我们之前操作的时候我提到过，我们大多数遇到<code>NaN</code>值的时候，基本都是用平均值来进行填充，这是一个惯例操作。</p><p>那么，我们来看看如何填充缺失数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[NaN,NaN,<span class="hljs-number">2</span>],[NaN,NaN,NaN],[<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,NaN]]) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  NaN  NaN  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  NaN  NaN  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  NaN<br></code></pre></td></tr></table></figure><p>⽤常数填充<code>fillna</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.fillna(<span class="hljs-number">0</span>))<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>传⼊<code>inplace=True</code>直接修改原对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.fillna(<span class="hljs-number">0</span>,inplace=<span class="hljs-literal">True</span>) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>通过字典填充不同的常数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.fillna(&#123;<span class="hljs-number">0</span>:<span class="hljs-number">10</span>,<span class="hljs-number">1</span>:<span class="hljs-number">20</span>,<span class="hljs-number">2</span>:<span class="hljs-number">30</span>&#125;))<br><br>---<br>      <span class="hljs-number">0</span>     <span class="hljs-number">1</span>     <span class="hljs-number">2</span><br><span class="hljs-number">0</span>   <span class="hljs-number">1.0</span>   <span class="hljs-number">2.0</span>   <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">20.0</span>   <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">10.0</span>  <span class="hljs-number">20.0</span>  <span class="hljs-number">30.0</span><br><span class="hljs-number">3</span>   <span class="hljs-number">8.0</span>   <span class="hljs-number">8.0</span>  <span class="hljs-number">30.0</span><br></code></pre></td></tr></table></figure><p>还有我们之前提到过的，填充平均值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.fillna(df1.mean()))<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">4.5</span>  <span class="hljs-number">5.0</span>  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">4.5</span>  <span class="hljs-number">5.0</span>  <span class="hljs-number">2.5</span><br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">2.5</span><br></code></pre></td></tr></table></figure><p>当然，我们可以只填充某一列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.iloc[:,<span class="hljs-number">1</span>].fillna(<span class="hljs-number">5</span>,inplace = <span class="hljs-literal">True</span>)) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br><span class="hljs-literal">None</span><br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span><br><span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  NaN  <span class="hljs-number">5.0</span>  <span class="hljs-number">2.0</span><br><span class="hljs-number">2</span>  NaN  <span class="hljs-number">5.0</span>  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">8.0</span>  NaN<br></code></pre></td></tr></table></figure><p>传⼊<code>method=” “</code>会改变插值⽅式，先来一组数据，并在其中加上<code>NaN</code>值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">df2=pd.DataFrame(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))) <br>df2.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]=NaN<br>df2.iloc[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]=NaN<br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>   <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br><span class="hljs-number">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">9</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  NaN  <span class="hljs-number">8.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">6</span>  <span class="hljs-number">5</span>  <span class="hljs-number">8</span>  NaN  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">5</span>  NaN  NaN<br><span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>现在，我们用前面的值来填充， <code>method ='ffill'</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.fillna(method=<span class="hljs-string">&#x27;ffill&#x27;</span>))<br><br>---<br>   <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br><span class="hljs-number">0</span>  <span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">9</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">8.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">6</span>  <span class="hljs-number">5</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">8.0</span><br><span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">5</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">8.0</span><br><span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">3</span>  <span class="hljs-number">5</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>用后面的值来填充<code>method='bfill'</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.fillna(method=<span class="hljs-string">&#x27;bfill&#x27;</span>,limit=<span class="hljs-number">1</span>))<br><br>---<br>   <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br><span class="hljs-number">0</span>  <span class="hljs-number">7</span>  <span class="hljs-number">1</span>  <span class="hljs-number">8</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">6</span>  <span class="hljs-number">8</span>  <span class="hljs-number">4</span>  NaN  <span class="hljs-number">5.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">6</span>  <span class="hljs-number">2</span>  <span class="hljs-number">5</span>  NaN  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">8</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">3.0</span><br><span class="hljs-number">4</span>  <span class="hljs-number">8</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><p>以上代码中，我们还传入了<code>limit</code>， 用于限制填充行数。</p><p>当我们传入<code>axis</code>的时候，会修改填充方向：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.fillna(method=<span class="hljs-string">&quot;ffill&quot;</span>,limit=<span class="hljs-number">1</span>,axis=<span class="hljs-number">1</span>))<br><br>---<br>     <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span>    <span class="hljs-number">4</span><br><span class="hljs-number">0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">4.0</span>  <span class="hljs-number">7.0</span><br><span class="hljs-number">1</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">9.0</span><br><span class="hljs-number">2</span>  <span class="hljs-number">1.0</span>  <span class="hljs-number">8.0</span>  <span class="hljs-number">5.0</span>  <span class="hljs-number">5.0</span>  NaN<br><span class="hljs-number">3</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">3.0</span>  <span class="hljs-number">3.0</span>  NaN<br><span class="hljs-number">4</span>  <span class="hljs-number">2.0</span>  <span class="hljs-number">9.0</span>  <span class="hljs-number">4.0</span>  <span class="hljs-number">6.0</span>  <span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><p>接着，我们再来看看如何移除重复数据，俗称「去重」：</p><p>DataFrame中经常会出现重复⾏，利⽤<code>duplicated()</code>函数返回每⼀⾏判断是否重复的结果（重复则为True)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;B&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;aabbbca&quot;</span>)&#125;)<br><span class="hljs-built_in">print</span>(df1)<br><span class="hljs-built_in">print</span>(df1.duplicated())<br><br>---<br>   A  B<br><span class="hljs-number">0</span>  <span class="hljs-number">1</span>  a<br><span class="hljs-number">1</span>  <span class="hljs-number">1</span>  a<br><span class="hljs-number">2</span>  <span class="hljs-number">1</span>  b<br><span class="hljs-number">3</span>  <span class="hljs-number">2</span>  b<br><span class="hljs-number">4</span>  <span class="hljs-number">2</span>  b<br><span class="hljs-number">5</span>  <span class="hljs-number">3</span>  c<br><span class="hljs-number">6</span>  <span class="hljs-number">1</span>  a<br><br><span class="hljs-number">0</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">1</span>     <span class="hljs-literal">True</span><br><span class="hljs-number">2</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">3</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">4</span>     <span class="hljs-literal">True</span><br><span class="hljs-number">5</span>    <span class="hljs-literal">False</span><br><span class="hljs-number">6</span>     <span class="hljs-literal">True</span><br>dtype: <span class="hljs-built_in">bool</span><br></code></pre></td></tr></table></figure><p>去除全部的重复⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.drop_duplicates())<br><br>---<br>   A  B<br><span class="hljs-number">0</span>  <span class="hljs-number">1</span>  a<br><span class="hljs-number">2</span>  <span class="hljs-number">1</span>  b<br><span class="hljs-number">3</span>  <span class="hljs-number">2</span>  b<br><span class="hljs-number">5</span>  <span class="hljs-number">3</span>  c<br></code></pre></td></tr></table></figure><p>指定列去除重复行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.drop_duplicates([<span class="hljs-string">&#x27;A&#x27;</span>]))<br><br>---<br>   A  B<br><span class="hljs-number">0</span>  <span class="hljs-number">1</span>  a<br><span class="hljs-number">3</span>  <span class="hljs-number">2</span>  b<br><span class="hljs-number">5</span>  <span class="hljs-number">3</span>  c<br></code></pre></td></tr></table></figure><p>保留重复⾏中的最后⼀⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],<span class="hljs-string">&#x27;B&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;aabbbca&quot;</span>)&#125;)<br><span class="hljs-built_in">print</span>(df1.drop_duplicates([<span class="hljs-string">&#x27;A&#x27;</span>],keep=<span class="hljs-string">&#x27;last&#x27;</span>))<br><br>---<br>   A  B<br><span class="hljs-number">4</span>  <span class="hljs-number">2</span>  b<br><span class="hljs-number">5</span>  <span class="hljs-number">3</span>  c<br><span class="hljs-number">6</span>  <span class="hljs-number">1</span>  a<br></code></pre></td></tr></table></figure><p>去除重复的同时改变DataFrame对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df1.drop_duplicates([<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>],inplace=<span class="hljs-literal">True</span>) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>   A  B<br><span class="hljs-number">0</span>  <span class="hljs-number">1</span>  a<br><span class="hljs-number">2</span>  <span class="hljs-number">1</span>  b<br><span class="hljs-number">3</span>  <span class="hljs-number">2</span>  b<br><span class="hljs-number">5</span>  <span class="hljs-number">3</span>  c<br></code></pre></td></tr></table></figure><h3 id="数据合并">数据合并</h3><p>我们平时会与拿到的数据可能存储在不同的数据表中，这需要我们对数据进行合并，然后再进行操作。</p><p>使⽤<code>join</code>合并，着重关注的是<strong>⾏的合并</strong>。</p><p>简单合并（默认是left左连接,以左侧<code>df3</code>为基础）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">df3=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Red&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],<span class="hljs-string">&#x27;Green&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]&#125;,index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abc&#x27;</span>))<br>df4=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Blue&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>],<span class="hljs-string">&#x27;Yellow&#x27;</span>:[<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;,index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;cde&#x27;</span>)) <br><span class="hljs-built_in">print</span>(df3)<br><span class="hljs-built_in">print</span>(df4)<br>df3.join(df4,how=<span class="hljs-string">&#x27;left&#x27;</span>)<br><br>---<br>   Red  Green<br>a    <span class="hljs-number">1</span>      <span class="hljs-number">5</span><br>b    <span class="hljs-number">3</span>      <span class="hljs-number">0</span><br>c    <span class="hljs-number">5</span>      <span class="hljs-number">3</span><br>   Blue  Yellow<br>c     <span class="hljs-number">1</span>       <span class="hljs-number">6</span><br>d     <span class="hljs-number">9</span>       <span class="hljs-number">6</span><br>e     <span class="hljs-number">8</span>       <span class="hljs-number">7</span><br><br><br>RedGreenBlueYellow<br>a<span class="hljs-number">1</span><span class="hljs-number">5</span>NaNNaN<br>b<span class="hljs-number">3</span><span class="hljs-number">0</span>NaNNaN<br>c<span class="hljs-number">5</span><span class="hljs-number">3</span><span class="hljs-number">1.0</span><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure><p>右链接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df3.join(df4,how=<span class="hljs-string">&#x27;outer&#x27;</span>)<br><br>---<br>RedGreenBlueYellow<br>a<span class="hljs-number">1.0</span><span class="hljs-number">5.0</span>NaNNaN<br>b<span class="hljs-number">3.0</span><span class="hljs-number">0.0</span>NaNNaN<br>c<span class="hljs-number">5.0</span><span class="hljs-number">3.0</span><span class="hljs-number">1.0</span><span class="hljs-number">6.0</span><br>dNaNNaN<span class="hljs-number">9.0</span><span class="hljs-number">6.0</span><br>eNaNNaN<span class="hljs-number">8.0</span><span class="hljs-number">7.0</span><br></code></pre></td></tr></table></figure><p>合并多个DataFrame对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">df5=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Brown&#x27;</span>:[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-string">&#x27;White&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]&#125;,index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aed&#x27;</span>)) <br>df3.join([df4,df5])<br><br>---<br><br>RedGreenBlueYellowBrownWhite<br>a<span class="hljs-number">1.0</span><span class="hljs-number">5.0</span>NaNNaN<span class="hljs-number">3.0</span><span class="hljs-number">1.0</span><br>b<span class="hljs-number">3.0</span><span class="hljs-number">0.0</span>NaNNaNNaNNaN<br>c<span class="hljs-number">5.0</span><span class="hljs-number">3.0</span><span class="hljs-number">1.0</span><span class="hljs-number">6.0</span>NaNNaN<br></code></pre></td></tr></table></figure><p>使⽤<code>merge</code>，着重关注的是<strong>列的合并</strong>。</p><p>我们先来构建两组数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame(&#123;<span class="hljs-string">&#x27;名字&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;ABCDE&#x27;</span>),<span class="hljs-string">&#x27;性别&#x27;</span>:[<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;⼥&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;男&#x27;</span>,<span class="hljs-string">&#x27;⼥&#x27;</span>],<span class="hljs-string">&#x27;职称&#x27;</span>: [<span class="hljs-string">&#x27;副教授&#x27;</span>,<span class="hljs-string">&#x27;讲师&#x27;</span>,<span class="hljs-string">&#x27;助教&#x27;</span>,<span class="hljs-string">&#x27;教授&#x27;</span>,<span class="hljs-string">&#x27;助教&#x27;</span>]&#125;,index=<span class="hljs-built_in">range</span>(<span class="hljs-number">1001</span>,<span class="hljs-number">1006</span>))<br>df1.columns.name=<span class="hljs-string">&#x27;学院⽼师&#x27;</span><br>df1.index.name=<span class="hljs-string">&#x27;编号&#x27;</span><br>df1<br><br>---<br>学院⽼师名字性别职称<br>编号<br><span class="hljs-number">1001</span>A男副教授<br><span class="hljs-number">1002</span>B⼥讲师<br><span class="hljs-number">1003</span>C男助教<br><span class="hljs-number">1004</span>D男教授<br><span class="hljs-number">1005</span>E⼥助教<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">df2=pd.DataFrame(&#123;<span class="hljs-string">&#x27;名字&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;ABDAX&#x27;</span>),<span class="hljs-string">&#x27;课程&#x27;</span>:[<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;计算机导论&#x27;</span>,<span class="hljs-string">&#x27;汇编&#x27;</span>,<span class="hljs-string">&#x27;数据结构&#x27;</span>,<span class="hljs-string">&#x27;马克思原理&#x27;</span>],<span class="hljs-string">&#x27;职称&#x27;</span>:[<span class="hljs-string">&#x27;副教授&#x27;</span>,<span class="hljs-string">&#x27;讲师&#x27;</span>,<span class="hljs-string">&#x27;教授&#x27;</span>,<span class="hljs-string">&#x27;副教授&#x27;</span>,<span class="hljs-string">&#x27;讲师&#x27;</span>]&#125;,index= [<span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>,<span class="hljs-number">1004</span>,<span class="hljs-number">1001</span>,<span class="hljs-number">3001</span>])<br>df2.columns.name=<span class="hljs-string">&#x27;课程&#x27;</span><br>df2.index.name=<span class="hljs-string">&#x27;编号&#x27;</span><br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>课程名字课程职称<br>编号<br><span class="hljs-number">1001</span>AC++副教授<br><span class="hljs-number">1002</span>B计算机导论讲师<br><span class="hljs-number">1004</span>D汇编教授<br><span class="hljs-number">1001</span>A数据结构副教授<br><span class="hljs-number">3001</span>X马克思原理讲师<br></code></pre></td></tr></table></figure><p>默认下是根据左右对象中出现同名的列作为连接的键，且连接⽅式是<code>how=’inner’</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pd.merge(df1,df2)) <span class="hljs-comment"># 返回匹配的</span><br><br>---<br>  名字 性别   职称     课程<br><span class="hljs-number">0</span>  A  男  副教授    C++<br><span class="hljs-number">1</span>  A  男  副教授   数据结构<br><span class="hljs-number">2</span>  B  ⼥   讲师  计算机导论<br><span class="hljs-number">3</span>  D  男   教授     汇编<br></code></pre></td></tr></table></figure><p>指定列名合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.merge(df1,df2,on=<span class="hljs-string">&#x27;名字&#x27;</span>,suffixes=[<span class="hljs-string">&#x27;_1&#x27;</span>,<span class="hljs-string">&#x27;_2&#x27;</span>]) <span class="hljs-comment"># 返回匹配的</span><br><br>---<br><br>名字性别职称_1课程职称_2<br><span class="hljs-number">0</span>A男副教授C++副教授<br><span class="hljs-number">1</span>A男副教授数据结构副教授<br><span class="hljs-number">2</span>B⼥讲师计算机导论讲师<br><span class="hljs-number">3</span>D男教授汇编教授<br></code></pre></td></tr></table></figure><p>连接⽅式，根据左侧为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.merge(df1,df2,how=<span class="hljs-string">&#x27;left&#x27;</span>)<br><br>---<br>名字性别职称课程<br><span class="hljs-number">0</span>A男副教授C++<br><span class="hljs-number">1</span>A男副教授数据结构<br><span class="hljs-number">2</span>B⼥讲师计算机导论<br><span class="hljs-number">3</span>C男助教NaN<br><span class="hljs-number">4</span>D男教授汇编<br><span class="hljs-number">5</span>E⼥助教NaN<br></code></pre></td></tr></table></figure><p>根据右侧为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.merge(df1,df2,how=<span class="hljs-string">&#x27;right&#x27;</span>)<br><br>---<br>名字性别职称课程<br><span class="hljs-number">0</span>A男副教授C++<br><span class="hljs-number">1</span>B⼥讲师计算机导论<br><span class="hljs-number">2</span>D男教授汇编<br><span class="hljs-number">3</span>A男副教授数据结构<br><span class="hljs-number">4</span>XNaN讲师马克思原理<br></code></pre></td></tr></table></figure><p>所有的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.merge(df1,df2,how=<span class="hljs-string">&#x27;outer&#x27;</span>)<br><br>---<br><br>名字性别职称课程<br><span class="hljs-number">0</span>A男副教授C++<br><span class="hljs-number">1</span>A男副教授数据结构<br><span class="hljs-number">2</span>B⼥讲师计算机导论<br><span class="hljs-number">3</span>C男助教NaN<br><span class="hljs-number">4</span>D男教授汇编<br><span class="hljs-number">5</span>E⼥助教NaN<br><span class="hljs-number">6</span>XNaN讲师马克思原理<br></code></pre></td></tr></table></figure><p>根据多个键进⾏连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.merge(df1,df2,*on*=[<span class="hljs-string">&#x27;职称&#x27;</span>,<span class="hljs-string">&#x27;名字&#x27;</span>])<br><br>---<br>名字性别职称课程<br><span class="hljs-number">0</span>A男副教授C++<br><span class="hljs-number">1</span>A男副教授数据结构<br><span class="hljs-number">2</span>B⼥讲师计算机导论<br><span class="hljs-number">3</span>D男教授汇编<br></code></pre></td></tr></table></figure><p>除此之外，我们还有一种轴向连接的方式：<code>Concat</code></p><p>Series对象的连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">s1=pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;ab&#x27;</span>))<br>s2=pd.Series([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;bde&#x27;</span>)) <br><span class="hljs-built_in">print</span>(s1)<br><span class="hljs-built_in">print</span>(s2)<br>pd.concat([s1,s2])<br><br>---<br>a    <span class="hljs-number">1</span><br>b    <span class="hljs-number">2</span><br>dtype: int64<br>b    <span class="hljs-number">3</span><br>d    <span class="hljs-number">4</span><br>e    <span class="hljs-number">5</span><br>dtype: int64<br>a    <span class="hljs-number">1</span><br>b    <span class="hljs-number">2</span><br>b    <span class="hljs-number">3</span><br>d    <span class="hljs-number">4</span><br>e    <span class="hljs-number">5</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>横向连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([s1,s2],*axis*=<span class="hljs-number">1</span>)<br><br>---<br><span class="hljs-number">0</span><span class="hljs-number">1</span><br>a<span class="hljs-number">1.0</span>NaN<br>b<span class="hljs-number">2.0</span><span class="hljs-number">3.0</span><br>dNaN<span class="hljs-number">4.0</span><br>eNaN<span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure><p>⽤内连接求交集(连接⽅式，共有’<code>inner</code>’,’<code>left</code>’,<code>right</code>’,’<code>outer</code>’)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([s1,s2],axis=<span class="hljs-number">1</span>,join=<span class="hljs-string">&#x27;inner&#x27;</span>)<br><br>---<br><span class="hljs-number">0</span><span class="hljs-number">1</span><br>b<span class="hljs-number">2</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>创建层次化索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([s1,s2],keys=[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>])<br><br>---<br>A  a    <span class="hljs-number">1</span><br>   b    <span class="hljs-number">2</span><br>B  b    <span class="hljs-number">3</span><br>   d    <span class="hljs-number">4</span><br>   e    <span class="hljs-number">5</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>当纵向连接时keys为列名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat([s1,s2],keys=[<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>],axis=<span class="hljs-number">1</span>)<br><br>----<br>AD<br>a<span class="hljs-number">1.0</span>NaN<br>b<span class="hljs-number">2.0</span><span class="hljs-number">3.0</span><br>dNaN<span class="hljs-number">4.0</span><br>eNaN<span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure><p>DataFrame对象的连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">df3=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Red&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],<span class="hljs-string">&#x27;Green&#x27;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]&#125;,index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abd&#x27;</span>)) <br>df4=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Blue&#x27;</span>:[<span class="hljs-number">1</span>,<span class="hljs-number">9</span>],<span class="hljs-string">&#x27;Yellow&#x27;</span>:[<span class="hljs-number">6</span>,<span class="hljs-number">6</span>]&#125;,index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;ce&#x27;</span>))<br>pd.concat([df3,df4])<br><br>---<br><br>RedGreenBlueYellow<br>a<span class="hljs-number">1.0</span><span class="hljs-number">5.0</span>NaNNaN<br>b<span class="hljs-number">3.0</span><span class="hljs-number">0.0</span>NaNNaN<br>d<span class="hljs-number">5.0</span><span class="hljs-number">3.0</span>NaNNaN<br>cNaNNaN<span class="hljs-number">1.0</span><span class="hljs-number">6.0</span><br>eNaNNaN<span class="hljs-number">9.0</span><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure><p>⽤字典的⽅式连接同样可以创建层次化列索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.concat(&#123;<span class="hljs-string">&#x27;A&#x27;</span>:df3,<span class="hljs-string">&#x27;B&#x27;</span>:df4&#125;,axis=<span class="hljs-number">1</span>)<br><br>---<br>AB<br>RedGreenBlueYellow<br>a<span class="hljs-number">1.0</span><span class="hljs-number">5.0</span>NaNNaN<br>b<span class="hljs-number">3.0</span><span class="hljs-number">0.0</span>NaNNaN<br>d<span class="hljs-number">5.0</span><span class="hljs-number">3.0</span>NaNNaN<br>cNaNNaN<span class="hljs-number">1.0</span><span class="hljs-number">6.0</span><br>eNaNNaN<span class="hljs-number">9.0</span><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure><h3 id="多层索引拓展">多层索引（拓展）</h3><p>创建多层索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">s = Series(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,size=<span class="hljs-number">6</span>),index=<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;abcdef&#x27;</span>))<br><span class="hljs-built_in">print</span>(s)<br><br>---<br>a     <span class="hljs-number">40</span><br>b    <span class="hljs-number">122</span><br>c     <span class="hljs-number">95</span><br>d     <span class="hljs-number">40</span><br>e     <span class="hljs-number">35</span><br>f     <span class="hljs-number">27</span><br>dtype: int64<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s = Series(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,size=<span class="hljs-number">6</span>),<br>index=[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]]) <br><span class="hljs-built_in">print</span>(s)<br><br>---<br>a  期中    <span class="hljs-number">132</span><br>   期末    <span class="hljs-number">145</span><br>b  期中     <span class="hljs-number">33</span><br>   期末    <span class="hljs-number">149</span><br>c  期中     <span class="hljs-number">10</span><br>   期末    <span class="hljs-number">145</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>DataFrame也可以创建多层索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># DataFrame创建多层索引</span><br>df1 = df(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,size=(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)),<br>         columns = [<span class="hljs-string">&#x27;zs&#x27;</span>,<span class="hljs-string">&#x27;ls&#x27;</span>,<span class="hljs-string">&#x27;ww&#x27;</span>,<span class="hljs-string">&#x27;zl&#x27;</span>],<br>         index =[[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>],[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]])<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>            zs   ls   ww   zl<br>python 期中  <span class="hljs-number">123</span>    <span class="hljs-number">3</span>   <span class="hljs-number">98</span>   <span class="hljs-number">95</span><br>       期末    <span class="hljs-number">9</span>   <span class="hljs-number">36</span>   <span class="hljs-number">15</span>  <span class="hljs-number">126</span><br>math   期中   <span class="hljs-number">86</span>   <span class="hljs-number">86</span>   <span class="hljs-number">73</span>  <span class="hljs-number">115</span><br>       期末    <span class="hljs-number">3</span>  <span class="hljs-number">130</span>   <span class="hljs-number">52</span>   <span class="hljs-number">89</span><br>En     期中   <span class="hljs-number">75</span>   <span class="hljs-number">21</span>   <span class="hljs-number">84</span>   <span class="hljs-number">98</span><br>       期末   <span class="hljs-number">56</span>   <span class="hljs-number">46</span>  <span class="hljs-number">111</span>  <span class="hljs-number">147</span><br></code></pre></td></tr></table></figure><p>特定结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">class1=[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>]<br>class2=[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]<br>m_index2=pd.MultiIndex.from_arrays([class1,class2])<br>df2=df(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)),index=m_index2) <br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>             <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br>python 期中   <span class="hljs-number">94</span>   <span class="hljs-number">36</span>    <span class="hljs-number">6</span>   <span class="hljs-number">19</span><br>       期末   <span class="hljs-number">24</span>   <span class="hljs-number">41</span>  <span class="hljs-number">108</span>  <span class="hljs-number">120</span><br>math   期中   <span class="hljs-number">79</span>   <span class="hljs-number">69</span>  <span class="hljs-number">144</span>   <span class="hljs-number">32</span><br>       期末  <span class="hljs-number">138</span>  <span class="hljs-number">100</span>   <span class="hljs-number">42</span>   <span class="hljs-number">38</span><br>En     期中  <span class="hljs-number">110</span>   <span class="hljs-number">90</span>  <span class="hljs-number">123</span>   <span class="hljs-number">75</span><br>       期末   <span class="hljs-number">69</span>   <span class="hljs-number">59</span>   <span class="hljs-number">72</span>  <span class="hljs-number">109</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">class1=[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]<br>class2=[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>,<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>]<br>m_index2=pd.MultiIndex.from_arrays([class1,class2])<br>df2=df(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)),index=m_index2) <br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>             <span class="hljs-number">0</span>   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br>期中 python   <span class="hljs-number">96</span>  <span class="hljs-number">15</span>  <span class="hljs-number">135</span>    <span class="hljs-number">5</span><br>   math     <span class="hljs-number">66</span>  <span class="hljs-number">78</span>  <span class="hljs-number">143</span>   <span class="hljs-number">93</span><br>   En       <span class="hljs-number">70</span>  <span class="hljs-number">27</span>  <span class="hljs-number">120</span>   <span class="hljs-number">63</span><br>期末 python  <span class="hljs-number">147</span>  <span class="hljs-number">77</span>   <span class="hljs-number">92</span>   <span class="hljs-number">97</span><br>   math    <span class="hljs-number">121</span>  <span class="hljs-number">81</span>  <span class="hljs-number">137</span>  <span class="hljs-number">102</span><br>   En       <span class="hljs-number">18</span>  <span class="hljs-number">12</span>  <span class="hljs-number">134</span>  <span class="hljs-number">113</span><br></code></pre></td></tr></table></figure><p>product构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">class1=[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>]<br>class2=[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]<br>m_index2=pd.MultiIndex.from_product([class1,class2])<br>df2=df(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)),index=m_index2) <br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>             <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br>python 期中   <span class="hljs-number">12</span>   <span class="hljs-number">72</span>  <span class="hljs-number">115</span>   <span class="hljs-number">59</span><br>       期末   <span class="hljs-number">36</span>   <span class="hljs-number">51</span>   <span class="hljs-number">94</span>  <span class="hljs-number">111</span><br>math   期中   <span class="hljs-number">44</span>   <span class="hljs-number">14</span>    <span class="hljs-number">9</span>   <span class="hljs-number">61</span><br>       期末  <span class="hljs-number">115</span>  <span class="hljs-number">121</span>   <span class="hljs-number">65</span>   <span class="hljs-number">93</span><br>En     期中   <span class="hljs-number">29</span>   <span class="hljs-number">23</span>   <span class="hljs-number">16</span>   <span class="hljs-number">70</span><br>       期末   <span class="hljs-number">30</span>   <span class="hljs-number">73</span>   <span class="hljs-number">77</span>   <span class="hljs-number">53</span><br></code></pre></td></tr></table></figure><p>多层索引对象的索引</p><p>让我们先来看看Series的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s = Series(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,size=<span class="hljs-number">6</span>),<br>index=[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>],[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>,<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]])<br><span class="hljs-built_in">print</span>(s)<br><br>---<br>a  期中     <span class="hljs-number">31</span><br>   期末      <span class="hljs-number">4</span><br>b  期中    <span class="hljs-number">101</span><br>   期末     <span class="hljs-number">95</span><br>c  期中     <span class="hljs-number">54</span><br>   期末    <span class="hljs-number">126</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>取⼀个第⼀级索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s[<span class="hljs-string">&#x27;a&#x27;</span>])<br><br>---<br>期中    <span class="hljs-number">31</span><br>期末     <span class="hljs-number">4</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>取多个第⼀级索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]])<br><br>---<br>a  期中     <span class="hljs-number">31</span><br>   期末      <span class="hljs-number">4</span><br>b  期中    <span class="hljs-number">101</span><br>   期末     <span class="hljs-number">95</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>根据索引获取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>])<br><br>---<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>loc⽅法取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s.loc[<span class="hljs-string">&#x27;a&#x27;</span>])<br><span class="hljs-built_in">print</span>(s.loc[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>]]) <br><span class="hljs-built_in">print</span>(s.loc[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>])<br><br>---<br>期中    <span class="hljs-number">31</span><br>期末     <span class="hljs-number">4</span><br>dtype: int64<br>a  期中     <span class="hljs-number">31</span><br>   期末      <span class="hljs-number">4</span><br>b  期中    <span class="hljs-number">101</span><br>   期末     <span class="hljs-number">95</span><br>dtype: int64<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>iloc⽅法取值(iloc计算的事最内层索引)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s.iloc[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(s.iloc[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])<br><br>---<br><span class="hljs-number">4</span><br>a  期末      <span class="hljs-number">4</span><br>b  期中    <span class="hljs-number">101</span><br>   期末     <span class="hljs-number">95</span><br>dtype: int64<br></code></pre></td></tr></table></figure><p>然后再让我们来看看DataFrame的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># dataframe</span><br>class1=[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>,<span class="hljs-string">&#x27;En&#x27;</span>]<br>class2=[<span class="hljs-string">&#x27;期中&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>]<br>m_index2=pd.MultiIndex.from_product([class1,class2])<br>df2=df(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">150</span>,(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)),index=m_index2) <br><span class="hljs-built_in">print</span>(df2)<br><br>---<br>             <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br>python 期中   <span class="hljs-number">88</span>   <span class="hljs-number">69</span>   <span class="hljs-number">82</span>   <span class="hljs-number">28</span><br>       期末  <span class="hljs-number">110</span>   <span class="hljs-number">60</span>  <span class="hljs-number">130</span>  <span class="hljs-number">133</span><br>math   期中   <span class="hljs-number">64</span>  <span class="hljs-number">103</span>   <span class="hljs-number">24</span>   <span class="hljs-number">49</span><br>       期末   <span class="hljs-number">23</span>   <span class="hljs-number">41</span>   <span class="hljs-number">10</span>   <span class="hljs-number">61</span><br>En     期中  <span class="hljs-number">124</span>  <span class="hljs-number">139</span>   <span class="hljs-number">65</span>  <span class="hljs-number">115</span><br>       期末  <span class="hljs-number">114</span>   <span class="hljs-number">13</span>  <span class="hljs-number">117</span>   <span class="hljs-number">79</span><br></code></pre></td></tr></table></figure><p>获取列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2[<span class="hljs-number">0</span>])<br><br>---<br>python  期中     <span class="hljs-number">88</span><br>        期末    <span class="hljs-number">110</span><br>math    期中     <span class="hljs-number">64</span><br>        期末     <span class="hljs-number">23</span><br>En      期中    <span class="hljs-number">124</span><br>        期末    <span class="hljs-number">114</span><br>Name: <span class="hljs-number">0</span>, dtype: int64<br></code></pre></td></tr></table></figure><p>⼀级索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.loc[<span class="hljs-string">&#x27;python&#x27;</span>])<br><br>---<br>      <span class="hljs-number">0</span>   <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br>期中   <span class="hljs-number">88</span>  <span class="hljs-number">69</span>   <span class="hljs-number">82</span>   <span class="hljs-number">28</span><br>期末  <span class="hljs-number">110</span>  <span class="hljs-number">60</span>  <span class="hljs-number">130</span>  <span class="hljs-number">133</span><br><br></code></pre></td></tr></table></figure><p>多个⼀级索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.loc[[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;math&#x27;</span>]])<br><br>---<br>             <span class="hljs-number">0</span>    <span class="hljs-number">1</span>    <span class="hljs-number">2</span>    <span class="hljs-number">3</span><br>python 期中   <span class="hljs-number">88</span>   <span class="hljs-number">69</span>   <span class="hljs-number">82</span>   <span class="hljs-number">28</span><br>       期末  <span class="hljs-number">110</span>   <span class="hljs-number">60</span>  <span class="hljs-number">130</span>  <span class="hljs-number">133</span><br>math   期中   <span class="hljs-number">64</span>  <span class="hljs-number">103</span>   <span class="hljs-number">24</span>   <span class="hljs-number">49</span><br>       期末   <span class="hljs-number">23</span>   <span class="hljs-number">41</span>   <span class="hljs-number">10</span>   <span class="hljs-number">61</span><br></code></pre></td></tr></table></figure><p>取⼀⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.loc[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>])<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">110</span><br><span class="hljs-number">1</span>     <span class="hljs-number">60</span><br><span class="hljs-number">2</span>    <span class="hljs-number">130</span><br><span class="hljs-number">3</span>    <span class="hljs-number">133</span><br>Name: (python, 期末), dtype: int64<br></code></pre></td></tr></table></figure><p>取⼀值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.loc[<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;期末&#x27;</span>][<span class="hljs-number">0</span>])<br><br>---<br><span class="hljs-number">110</span><br></code></pre></td></tr></table></figure><p>iloc是只取最内层的索引的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df2.iloc[<span class="hljs-number">0</span>])<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">88</span><br><span class="hljs-number">1</span>    <span class="hljs-number">69</span><br><span class="hljs-number">2</span>    <span class="hljs-number">82</span><br><span class="hljs-number">3</span>    <span class="hljs-number">28</span><br>Name: (python, 期中), dtype: int64<br></code></pre></td></tr></table></figure><h3 id="时间序列">时间序列</h3><p>⽣成⼀段时间范围</p><p>该函数主要⽤于⽣成⼀个固定频率的时间索引，在调⽤构造⽅法时，必须指定<code>start</code>、<code>end</code>、<code>periods</code>中的两个参数值，否则报错。</p><table><thead><tr class="header"><th>时间序列频率</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>D</td><td>⽇历⽇的每天</td></tr><tr class="even"><td>B</td><td>⼯作⽇的每天</td></tr><tr class="odd"><td>H</td><td>每⼩时</td></tr><tr class="even"><td>T或min</td><td>每分钟</td></tr><tr class="odd"><td>S</td><td>每秒</td></tr><tr class="even"><td>L或ms</td><td>每毫秒</td></tr><tr class="odd"><td>U</td><td>每微秒</td></tr><tr class="even"><td>M</td><td>⽇历⽇的⽉底⽇期</td></tr><tr class="odd"><td>BM</td><td>⼯作⽇的⽉底⽇期</td></tr><tr class="even"><td>MS</td><td>⽇历⽇的⽉初⽇期</td></tr><tr class="odd"><td>BMS</td><td>⼯作⽇的⽉初⽇期</td></tr></tbody></table><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">date = pd.date_range(start=<span class="hljs-string">&#x27;20190501&#x27;</span>,end=<span class="hljs-string">&#x27;20190530&#x27;</span>)<br><span class="hljs-built_in">print</span>(date)<br><br>---<br>DatetimeIndex([<span class="hljs-string">&#x27;2023-05-01&#x27;</span>, <span class="hljs-string">&#x27;2023-05-02&#x27;</span>, <span class="hljs-string">&#x27;2023-05-03&#x27;</span>, <span class="hljs-string">&#x27;2023-05-04&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-05&#x27;</span>, <span class="hljs-string">&#x27;2023-05-06&#x27;</span>, <span class="hljs-string">&#x27;2023-05-07&#x27;</span>, <span class="hljs-string">&#x27;2023-05-08&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-09&#x27;</span>, <span class="hljs-string">&#x27;2023-05-10&#x27;</span>, <span class="hljs-string">&#x27;2023-05-11&#x27;</span>, <span class="hljs-string">&#x27;2023-05-12&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-13&#x27;</span>, <span class="hljs-string">&#x27;2023-05-14&#x27;</span>, <span class="hljs-string">&#x27;2023-05-15&#x27;</span>, <span class="hljs-string">&#x27;2023-05-16&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-17&#x27;</span>, <span class="hljs-string">&#x27;2023-05-18&#x27;</span>, <span class="hljs-string">&#x27;2023-05-19&#x27;</span>, <span class="hljs-string">&#x27;2023-05-20&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-21&#x27;</span>, <span class="hljs-string">&#x27;2023-05-22&#x27;</span>, <span class="hljs-string">&#x27;2023-05-23&#x27;</span>, <span class="hljs-string">&#x27;2023-05-24&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-25&#x27;</span>, <span class="hljs-string">&#x27;2023-05-26&#x27;</span>, <span class="hljs-string">&#x27;2023-05-27&#x27;</span>, <span class="hljs-string">&#x27;2023-05-28&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-05-29&#x27;</span>, <span class="hljs-string">&#x27;2023-05-30&#x27;</span>],<br>              dtype=<span class="hljs-string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="hljs-string">&#x27;D&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p><code>req</code>：⽇期偏移量，取值为string, 默认为'D'，</p><p><code>periods</code>：固定时期，取值为整数或None</p><p><code>freq</code>: 时间序列频率</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">date = pd.date_range(start=<span class="hljs-string">&#x27;20230501&#x27;</span>,periods=<span class="hljs-number">10</span>,freq=<span class="hljs-string">&#x27;10D&#x27;</span>)<br><span class="hljs-built_in">print</span>(date)<br><br>---<br>DatetimeIndex([<span class="hljs-string">&#x27;2023-05-01&#x27;</span>, <span class="hljs-string">&#x27;2023-05-11&#x27;</span>, <span class="hljs-string">&#x27;2023-05-21&#x27;</span>, <span class="hljs-string">&#x27;2023-05-31&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-06-10&#x27;</span>, <span class="hljs-string">&#x27;2023-06-20&#x27;</span>, <span class="hljs-string">&#x27;2023-06-30&#x27;</span>, <span class="hljs-string">&#x27;2023-07-10&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-07-20&#x27;</span>, <span class="hljs-string">&#x27;2023-07-30&#x27;</span>],<br>              dtype=<span class="hljs-string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="hljs-string">&#x27;10D&#x27;</span>)<br></code></pre></td></tr></table></figure><p>根据<code>closed</code>参数选择是否包含开始和结束时间<code>closed=None</code>，left包含开始时间，不包含结束时间，right与之相反。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">data_time =pd.date_range(start=<span class="hljs-string">&#x27;2023-08-09&#x27;</span>,end=<span class="hljs-string">&#x27;2023-08-14&#x27;</span>,closed=<span class="hljs-string">&#x27;left&#x27;</span>) <br><span class="hljs-built_in">print</span>(data_time)<br><br>---<br>DatetimeIndex([<span class="hljs-string">&#x27;2023-08-09&#x27;</span>, <span class="hljs-string">&#x27;2023-08-10&#x27;</span>, <span class="hljs-string">&#x27;2023-08-11&#x27;</span>, <span class="hljs-string">&#x27;2023-08-12&#x27;</span>,<br>               <span class="hljs-string">&#x27;2023-08-13&#x27;</span>],<br>              dtype=<span class="hljs-string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="hljs-string">&#x27;D&#x27;</span>)<br></code></pre></td></tr></table></figure><p>时间序列在dataFrame中的作⽤</p><p>可以将时间作为索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">index = pd.date_range(start=<span class="hljs-string">&#x27;20230801&#x27;</span>,periods=<span class="hljs-number">10</span>)<br>df = pd.Series(np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,size = <span class="hljs-number">10</span>),index=index) <br><span class="hljs-built_in">print</span>(df)<br><br>---<br><span class="hljs-number">2023</span>-08-01    <span class="hljs-number">7</span><br><span class="hljs-number">2023</span>-08-02    <span class="hljs-number">2</span><br><span class="hljs-number">2023</span>-08-03    <span class="hljs-number">5</span><br><span class="hljs-number">2023</span>-08-04    <span class="hljs-number">5</span><br><span class="hljs-number">2023</span>-08-05    <span class="hljs-number">2</span><br><span class="hljs-number">2023</span>-08-06    <span class="hljs-number">0</span><br><span class="hljs-number">2023</span>-08-07    <span class="hljs-number">2</span><br><span class="hljs-number">2023</span>-08-08    <span class="hljs-number">3</span><br><span class="hljs-number">2023</span>-08-09    <span class="hljs-number">6</span><br><span class="hljs-number">2023</span>-08-<span class="hljs-number">10</span>    <span class="hljs-number">5</span><br>Freq: D, dtype: int64<br></code></pre></td></tr></table></figure><p><code>truncate</code>这个函数将before指定⽇期之前的值全部过滤出去,after指定⽇期之前的值全部过滤出去.</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">after = df.truncate(after=<span class="hljs-string">&#x27;2023-08-8&#x27;</span>)<br><span class="hljs-built_in">print</span>(after)<br><br>---<br><span class="hljs-number">2023</span>-08-01    <span class="hljs-number">7</span><br><span class="hljs-number">2023</span>-08-02    <span class="hljs-number">2</span><br><span class="hljs-number">2023</span>-08-03    <span class="hljs-number">5</span><br><span class="hljs-number">2023</span>-08-04    <span class="hljs-number">5</span><br><span class="hljs-number">2023</span>-08-05    <span class="hljs-number">2</span><br><span class="hljs-number">2023</span>-08-06    <span class="hljs-number">0</span><br><span class="hljs-number">2023</span>-08-07    <span class="hljs-number">2</span><br><span class="hljs-number">2023</span>-08-08    <span class="hljs-number">3</span><br>Freq: D, dtype: int64<br></code></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">long_ts = pd.Series(np.random.randn(<span class="hljs-number">1000</span>),index=pd.date_range(<span class="hljs-string">&#x27;1/1/2021&#x27;</span>,periods=<span class="hljs-number">1000</span>)) <br><span class="hljs-built_in">print</span>(long_ts)<br><br>---<br><span class="hljs-number">2021</span>-01-01   -<span class="hljs-number">0.482811</span><br>...<br><span class="hljs-number">2023</span>-09-<span class="hljs-number">27</span>   -<span class="hljs-number">0.108047</span><br>Freq: D, Length: <span class="hljs-number">1000</span>, dtype: float64<br></code></pre></td></tr></table></figure><p>根据年份获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result = long_ts[<span class="hljs-string">&#x27;2022&#x27;</span>]<br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">2022</span>-01-01   -<span class="hljs-number">0.600007</span><br>...<br><span class="hljs-number">2022</span>-<span class="hljs-number">12</span>-<span class="hljs-number">31</span>    <span class="hljs-number">0.097874</span><br>Freq: D, Length: <span class="hljs-number">365</span>, dtype: float64<br></code></pre></td></tr></table></figure><p>年份和⽇期获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">result = long_ts[<span class="hljs-string">&#x27;2023-07&#x27;</span>] <br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">2023</span>-07-01   -<span class="hljs-number">1.797582</span><br>...<br><span class="hljs-number">2023</span>-07-<span class="hljs-number">31</span>    <span class="hljs-number">0.687787</span><br>Freq: D, dtype: float64<br></code></pre></td></tr></table></figure><p>使⽤切⽚</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使⽤切⽚</span><br>result = long_ts[<span class="hljs-string">&#x27;2023-05-01&#x27;</span>:<span class="hljs-string">&#x27;2023-05-06&#x27;</span>]<br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">2023</span>-05-01   -<span class="hljs-number">2.338218</span><br><span class="hljs-number">2023</span>-05-02   -<span class="hljs-number">2.130780</span><br><span class="hljs-number">2023</span>-05-03    <span class="hljs-number">0.582920</span><br><span class="hljs-number">2023</span>-05-04   -<span class="hljs-number">0.182540</span><br><span class="hljs-number">2023</span>-05-05    <span class="hljs-number">0.127363</span><br><span class="hljs-number">2023</span>-05-06   -<span class="hljs-number">0.032844</span><br>Freq: D, dtype: float64<br></code></pre></td></tr></table></figure><p>通过<code>between_time()</code>返回位于指定时间段的数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">index=pd.date_range(<span class="hljs-string">&quot;2023-03-17&quot;</span>,<span class="hljs-string">&quot;2023-03-30&quot;</span>,freq=<span class="hljs-string">&quot;2H&quot;</span>)<br>ts = pd.Series(np.random.randn(<span class="hljs-number">157</span>),index=index) <br><span class="hljs-built_in">print</span>(ts.between_time(<span class="hljs-string">&quot;7:00&quot;</span>,<span class="hljs-string">&quot;17:00&quot;</span>))<br><br>---<br><span class="hljs-number">2023</span>-03-<span class="hljs-number">17</span> 08:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   -<span class="hljs-number">0.532254</span><br>...<br><span class="hljs-number">2023</span>-03-<span class="hljs-number">29</span> <span class="hljs-number">16</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>    <span class="hljs-number">0.437697</span><br>Length: <span class="hljs-number">65</span>, dtype: float64<br></code></pre></td></tr></table></figure><p>这些操作也都适⽤于dataframe</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">index=pd.date_range(<span class="hljs-string">&#x27;1/1/2023&#x27;</span>,periods=<span class="hljs-number">100</span>)<br>df = pd.DataFrame(np.random.randn(<span class="hljs-number">100</span>,<span class="hljs-number">4</span>),index=index) <br><span class="hljs-built_in">print</span>(df.loc[<span class="hljs-string">&#x27;2023-04&#x27;</span>])<br><br>---<br>                   <span class="hljs-number">0</span>         <span class="hljs-number">1</span>         <span class="hljs-number">2</span>         <span class="hljs-number">3</span><br><span class="hljs-number">2023</span>-04-01 -<span class="hljs-number">0.220090</span>  <span class="hljs-number">0.335770</span> -<span class="hljs-number">0.086181</span> -<span class="hljs-number">0.046045</span><br><span class="hljs-number">2023</span>-04-02 -<span class="hljs-number">1.046423</span> -<span class="hljs-number">0.347116</span>  <span class="hljs-number">0.367099</span> -<span class="hljs-number">0.979354</span><br><span class="hljs-number">2023</span>-04-03 -<span class="hljs-number">0.720944</span> -<span class="hljs-number">1.478932</span>  <span class="hljs-number">0.220948</span>  <span class="hljs-number">0.801831</span><br><span class="hljs-number">2023</span>-04-04  <span class="hljs-number">1.359946</span> -<span class="hljs-number">1.239004</span>  <span class="hljs-number">0.309747</span> -<span class="hljs-number">0.047959</span><br><span class="hljs-number">2023</span>-04-05 -<span class="hljs-number">0.256502</span>  <span class="hljs-number">2.224782</span>  <span class="hljs-number">0.494740</span> -<span class="hljs-number">1.322490</span><br><span class="hljs-number">2023</span>-04-06  <span class="hljs-number">1.488119</span>  <span class="hljs-number">0.244942</span>  <span class="hljs-number">0.614101</span> -<span class="hljs-number">0.156201</span><br><span class="hljs-number">2023</span>-04-07 -<span class="hljs-number">1.815019</span> -<span class="hljs-number">1.935966</span>  <span class="hljs-number">0.239024</span> -<span class="hljs-number">1.388502</span><br><span class="hljs-number">2023</span>-04-08  <span class="hljs-number">1.106623</span>  <span class="hljs-number">1.148805</span>  <span class="hljs-number">2.120405</span> -<span class="hljs-number">0.799290</span><br><span class="hljs-number">2023</span>-04-09 -<span class="hljs-number">1.902216</span>  <span class="hljs-number">0.625965</span> -<span class="hljs-number">0.102506</span> -<span class="hljs-number">0.430550</span><br><span class="hljs-number">2023</span>-04-<span class="hljs-number">10</span> -<span class="hljs-number">0.876382</span> -<span class="hljs-number">2.034205</span> -<span class="hljs-number">0.060846</span>  <span class="hljs-number">2.442651</span><br></code></pre></td></tr></table></figure><p>移位⽇期</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">ts = pd.Series(np.random.randn(<span class="hljs-number">10</span>),index=pd.date_range(<span class="hljs-string">&#x27;1/1/2023&#x27;</span>,periods=<span class="hljs-number">10</span>)) <br><span class="hljs-built_in">print</span>(ts)<br><br>---<br><span class="hljs-number">2023</span>-01-01   -<span class="hljs-number">0.976958</span><br><span class="hljs-number">2023</span>-01-02   -<span class="hljs-number">0.487439</span><br><span class="hljs-number">2023</span>-01-03    <span class="hljs-number">0.143104</span><br><span class="hljs-number">2023</span>-01-04   -<span class="hljs-number">0.964236</span><br><span class="hljs-number">2023</span>-01-05    <span class="hljs-number">0.758326</span><br><span class="hljs-number">2023</span>-01-06   -<span class="hljs-number">1.650818</span><br><span class="hljs-number">2023</span>-01-07    <span class="hljs-number">0.709231</span><br><span class="hljs-number">2023</span>-01-08    <span class="hljs-number">0.198714</span><br><span class="hljs-number">2023</span>-01-09   -<span class="hljs-number">1.043443</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">10</span>    <span class="hljs-number">0.220834</span><br>Freq: D, dtype: float64<br></code></pre></td></tr></table></figure><p>移动数据，索引不变，默认由<code>NaN</code>填充</p><p><code>periods</code>: 移动的位数 负数是向上移动</p><p><code>fill_value</code>: 移动后填充数据</p><p><code>freq</code>： ⽇期偏移量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.shift(periods=<span class="hljs-number">2</span>,fill_value=<span class="hljs-number">100</span>, freq=<span class="hljs-string">&#x27;D&#x27;</span>)<br><br>---<br><span class="hljs-number">2023</span>-01-03   -<span class="hljs-number">0.976958</span><br><span class="hljs-number">2023</span>-01-04   -<span class="hljs-number">0.487439</span><br><span class="hljs-number">2023</span>-01-05    <span class="hljs-number">0.143104</span><br><span class="hljs-number">2023</span>-01-06   -<span class="hljs-number">0.964236</span><br><span class="hljs-number">2023</span>-01-07    <span class="hljs-number">0.758326</span><br><span class="hljs-number">2023</span>-01-08   -<span class="hljs-number">1.650818</span><br><span class="hljs-number">2023</span>-01-09    <span class="hljs-number">0.709231</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">10</span>    <span class="hljs-number">0.198714</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">11</span>   -<span class="hljs-number">1.043443</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">12</span>    <span class="hljs-number">0.220834</span><br>Freq: D, dtype: float64<br></code></pre></td></tr></table></figure><p>通过<code>tshift()</code>将索引移动指定的时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">ts.tshift(<span class="hljs-number">2</span>)<br><br>---<br><span class="hljs-number">2023</span>-01-03   -<span class="hljs-number">0.976958</span><br><span class="hljs-number">2023</span>-01-04   -<span class="hljs-number">0.487439</span><br><span class="hljs-number">2023</span>-01-05    <span class="hljs-number">0.143104</span><br><span class="hljs-number">2023</span>-01-06   -<span class="hljs-number">0.964236</span><br><span class="hljs-number">2023</span>-01-07    <span class="hljs-number">0.758326</span><br><span class="hljs-number">2023</span>-01-08   -<span class="hljs-number">1.650818</span><br><span class="hljs-number">2023</span>-01-09    <span class="hljs-number">0.709231</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">10</span>    <span class="hljs-number">0.198714</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">11</span>   -<span class="hljs-number">1.043443</span><br><span class="hljs-number">2023</span>-01-<span class="hljs-number">12</span>    <span class="hljs-number">0.220834</span><br>Freq: D, dtype: float64<br></code></pre></td></tr></table></figure><p>将时间戳转化成时间根式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_datetime(<span class="hljs-number">1688570740000</span>,unit=<span class="hljs-string">&#x27;ms&#x27;</span>)<br><br>---<br>Timestamp(<span class="hljs-string">&#x27;2023-07-05 15:25:40&#x27;</span>)<br></code></pre></td></tr></table></figure><p>utc是协调世界时,时区是以UTC的偏移量的形式表示的,但是注意设置<code>utc=True</code>,是让pandas对象具有时区性质,对于⼀列进⾏转换的,会造成转换错误。</p><p><code>unit='ms'</code>设置粒度是到毫秒级别的。</p><p>时区名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytz<br><span class="hljs-built_in">print</span>(pytz.common_timezones)<br><br>---<br>[<span class="hljs-string">&#x27;Africa/Abidjan&#x27;</span>, ..., <span class="hljs-string">&#x27;US/Pacific&#x27;</span>, <span class="hljs-string">&#x27;UTC&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_datetime(<span class="hljs-number">1688570740000</span>,unit=<span class="hljs-string">&#x27;ms&#x27;</span>).tz_localize(<span class="hljs-string">&#x27;UTC&#x27;</span>).tz_convert(<span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>)<br><br>---<br>Timestamp(<span class="hljs-string">&#x27;2023-07-05 23:25:40+0800&#x27;</span>, tz=<span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>)<br></code></pre></td></tr></table></figure><p>一个处理的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame([<span class="hljs-number">1688570740000</span>, <span class="hljs-number">1688570800000</span>, <span class="hljs-number">1688570860000</span>],columns = [<span class="hljs-string">&#x27;time_stamp&#x27;</span>])<br>pd.to_datetime(df[<span class="hljs-string">&#x27;time_stamp&#x27;</span>],unit=<span class="hljs-string">&#x27;ms&#x27;</span>).dt.tz_localize(<span class="hljs-string">&#x27;UTC&#x27;</span>).dt.tz_convert (<span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>)<br><br>---<br><span class="hljs-number">0</span>   <span class="hljs-number">2023</span>-07-05 <span class="hljs-number">23</span>:<span class="hljs-number">25</span>:<span class="hljs-number">40</span>+08:<span class="hljs-number">00</span><br><span class="hljs-number">1</span>   <span class="hljs-number">2023</span>-07-05 <span class="hljs-number">23</span>:<span class="hljs-number">26</span>:<span class="hljs-number">40</span>+08:<span class="hljs-number">00</span><br><span class="hljs-number">2</span>   <span class="hljs-number">2023</span>-07-05 <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">40</span>+08:<span class="hljs-number">00</span><br>Name: time_stamp, dtype: datetime64[ns, Asia/Shanghai]<br></code></pre></td></tr></table></figure><p>先赋予标准时区,再转换到东⼋区。</p><p>处理中⽂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.to_datetime(<span class="hljs-string">&#x27;2023年7⽉5⽇&#x27;</span>,<span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%Y年%m⽉%d⽇&#x27;</span>)<br><br>---<br>Timestamp(<span class="hljs-string">&#x27;2023-07-05 00:00:00&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="分组聚合">分组聚合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">df=pd.DataFrame(&#123;<br><span class="hljs-string">&#x27;name&#x27;</span>:[<span class="hljs-string">&#x27;BOSS&#x27;</span>,<span class="hljs-string">&#x27;Lilei&#x27;</span>,<span class="hljs-string">&#x27;Lilei&#x27;</span>,<span class="hljs-string">&#x27;Han&#x27;</span>,<span class="hljs-string">&#x27;BOSS&#x27;</span>,<span class="hljs-string">&#x27;BOSS&#x27;</span>,<span class="hljs-string">&#x27;Han&#x27;</span>,<span class="hljs-string">&#x27;BOSS&#x27;</span>], <span class="hljs-string">&#x27;Year&#x27;</span>:[<span class="hljs-number">2016</span>,<span class="hljs-number">2016</span>,<span class="hljs-number">2016</span>,<span class="hljs-number">2016</span>,<span class="hljs-number">2017</span>,<span class="hljs-number">2017</span>,<span class="hljs-number">2017</span>,<span class="hljs-number">2017</span>],<br><span class="hljs-string">&#x27;Salary&#x27;</span>:[<span class="hljs-number">999999</span>,<span class="hljs-number">20000</span>,<span class="hljs-number">25000</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">9999999</span>,<span class="hljs-number">999999</span>,<span class="hljs-number">3500</span>,<span class="hljs-number">999999</span>],<br><span class="hljs-string">&#x27;Bonus&#x27;</span>:[<span class="hljs-number">100000</span>,<span class="hljs-number">20000</span>,<span class="hljs-number">20000</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">200000</span>,<span class="hljs-number">300000</span>,<span class="hljs-number">3000</span>,<span class="hljs-number">400000</span>]<br>&#125;)<br>df<br><br>---<br><br>nameYearSalaryBonus<br><span class="hljs-number">0</span>BOSS<span class="hljs-number">2016</span><span class="hljs-number">999999</span><span class="hljs-number">100000</span><br><span class="hljs-number">1</span>Lilei<span class="hljs-number">2016</span><span class="hljs-number">20000</span><span class="hljs-number">20000</span><br><span class="hljs-number">2</span>Lilei<span class="hljs-number">2016</span><span class="hljs-number">25000</span><span class="hljs-number">20000</span><br><span class="hljs-number">3</span>Han<span class="hljs-number">2016</span><span class="hljs-number">3000</span><span class="hljs-number">5000</span><br><span class="hljs-number">4</span>BOSS<span class="hljs-number">2017</span><span class="hljs-number">9999999</span><span class="hljs-number">200000</span><br><span class="hljs-number">5</span>BOSS<span class="hljs-number">2017</span><span class="hljs-number">999999</span><span class="hljs-number">300000</span><br><span class="hljs-number">6</span>Han<span class="hljs-number">2017</span><span class="hljs-number">3500</span><span class="hljs-number">3000</span><br><span class="hljs-number">7</span>BOSS<span class="hljs-number">2017</span><span class="hljs-number">999999</span><span class="hljs-number">400000</span><br></code></pre></td></tr></table></figure><p>根据name这⼀列进⾏分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">group_by_name=df.groupby(<span class="hljs-string">&#x27;name&#x27;</span>) <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(group_by_name))<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;pandas.core.groupby.generic.DataFrameGroupBy&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>查看分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(group_by_name.groups) <span class="hljs-comment"># 分组后的数量</span><br><span class="hljs-built_in">print</span>(group_by_name.count())<br><br>---<br>&#123;<span class="hljs-string">&#x27;BOSS&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>], <span class="hljs-string">&#x27;Han&#x27;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">6</span>], <span class="hljs-string">&#x27;Lilei&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;<br>       Year  Salary  Bonus<br>name                      <br>BOSS      <span class="hljs-number">4</span>       <span class="hljs-number">4</span>      <span class="hljs-number">4</span><br>Han       <span class="hljs-number">2</span>       <span class="hljs-number">2</span>      <span class="hljs-number">2</span><br>Lilei     <span class="hljs-number">2</span>       <span class="hljs-number">2</span>      <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>查看分组的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> name,group <span class="hljs-keyword">in</span> group_by_name: <br>    <span class="hljs-built_in">print</span>(name)<br>    <br>---<br>BOSS<br>Han<br>Lilei<br></code></pre></td></tr></table></figure><p>组的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(group) <span class="hljs-comment"># 组具体内容</span><br><br>---<br>    name  Year  Salary  Bonus<br><span class="hljs-number">1</span>  Lilei  <span class="hljs-number">2016</span>   <span class="hljs-number">20000</span>  <span class="hljs-number">20000</span><br><span class="hljs-number">2</span>  Lilei  <span class="hljs-number">2016</span>   <span class="hljs-number">25000</span>  <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>可以选择分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(group_by_name.get_group(<span class="hljs-string">&#x27;BOSS&#x27;</span>))<br><br>---<br>   name  Year   Salary   Bonus<br><span class="hljs-number">0</span>  BOSS  <span class="hljs-number">2016</span>   <span class="hljs-number">999999</span>  <span class="hljs-number">100000</span><br><span class="hljs-number">4</span>  BOSS  <span class="hljs-number">2017</span>  <span class="hljs-number">9999999</span>  <span class="hljs-number">200000</span><br><span class="hljs-number">5</span>  BOSS  <span class="hljs-number">2017</span>   <span class="hljs-number">999999</span>  <span class="hljs-number">300000</span><br><span class="hljs-number">7</span>  BOSS  <span class="hljs-number">2017</span>   <span class="hljs-number">999999</span>  <span class="hljs-number">400000</span><br></code></pre></td></tr></table></figure><p>按照某⼀列进⾏分组, 将name这⼀列作为分组的键，对year进⾏分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">group_by_name=df[<span class="hljs-string">&#x27;Year&#x27;</span>].groupby(df[<span class="hljs-string">&#x27;name&#x27;</span>])<br><span class="hljs-built_in">print</span>(group_by_name.count())<br><br>---<br>name<br>BOSS     <span class="hljs-number">4</span><br>Han      <span class="hljs-number">2</span><br>Lilei    <span class="hljs-number">2</span><br>Name: Year, dtype: int64<br></code></pre></td></tr></table></figure><p>按照多列进⾏分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">group_by_name_year=df.groupby([<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;Year&#x27;</span>])<br><span class="hljs-keyword">for</span> name,group <span class="hljs-keyword">in</span> group_by_name_year: <br>    <span class="hljs-built_in">print</span>(name) <span class="hljs-comment"># 组的名字</span><br>    <span class="hljs-built_in">print</span>(group) <span class="hljs-comment"># 组具体内容</span><br>    <br>---<br>(<span class="hljs-string">&#x27;BOSS&#x27;</span>, <span class="hljs-number">2016</span>)<br>   name  Year  Salary   Bonus<br><span class="hljs-number">0</span>  BOSS  <span class="hljs-number">2016</span>  <span class="hljs-number">999999</span>  <span class="hljs-number">100000</span><br>(<span class="hljs-string">&#x27;BOSS&#x27;</span>, <span class="hljs-number">2017</span>)<br>   name  Year   Salary   Bonus<br><span class="hljs-number">4</span>  BOSS  <span class="hljs-number">2017</span>  <span class="hljs-number">9999999</span>  <span class="hljs-number">200000</span><br><span class="hljs-number">5</span>  BOSS  <span class="hljs-number">2017</span>   <span class="hljs-number">999999</span>  <span class="hljs-number">300000</span><br><span class="hljs-number">7</span>  BOSS  <span class="hljs-number">2017</span>   <span class="hljs-number">999999</span>  <span class="hljs-number">400000</span><br>(<span class="hljs-string">&#x27;Han&#x27;</span>, <span class="hljs-number">2016</span>)<br>  name  Year  Salary  Bonus<br><span class="hljs-number">3</span>  Han  <span class="hljs-number">2016</span>    <span class="hljs-number">3000</span>   <span class="hljs-number">5000</span><br>(<span class="hljs-string">&#x27;Han&#x27;</span>, <span class="hljs-number">2017</span>)<br>  name  Year  Salary  Bonus<br><span class="hljs-number">6</span>  Han  <span class="hljs-number">2017</span>    <span class="hljs-number">3500</span>   <span class="hljs-number">3000</span><br>(<span class="hljs-string">&#x27;Lilei&#x27;</span>, <span class="hljs-number">2016</span>)<br>    name  Year  Salary  Bonus<br><span class="hljs-number">1</span>  Lilei  <span class="hljs-number">2016</span>   <span class="hljs-number">20000</span>  <span class="hljs-number">20000</span><br><span class="hljs-number">2</span>  Lilei  <span class="hljs-number">2016</span>   <span class="hljs-number">25000</span>  <span class="hljs-number">20000</span><br></code></pre></td></tr></table></figure><p>可以选择分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(group_by_name_year.get_group((<span class="hljs-string">&#x27;BOSS&#x27;</span>,<span class="hljs-number">2016</span>)))<br><br>---<br>   name  Year  Salary   Bonus<br><span class="hljs-number">0</span>  BOSS  <span class="hljs-number">2016</span>  <span class="hljs-number">999999</span>  <span class="hljs-number">100000</span><br></code></pre></td></tr></table></figure><p>将某列数据按数据值分成不同范围段进⾏分组（groupby）运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Age&#x27;</span>: np.random.randint(<span class="hljs-number">20</span>, <span class="hljs-number">70</span>, <span class="hljs-number">100</span>),<br> <span class="hljs-string">&#x27;Sex&#x27;</span>: np.random.choice([<span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;F&#x27;</span>], <span class="hljs-number">100</span>),<br> &#125;)<br>age_groups = pd.cut(df[<span class="hljs-string">&#x27;Age&#x27;</span>], bins=[<span class="hljs-number">19</span>,<span class="hljs-number">40</span>,<span class="hljs-number">65</span>,<span class="hljs-number">100</span>])<br><span class="hljs-built_in">print</span>(df.groupby(age_groups).count())<br><br>---<br>           Age  Sex<br>Age                <br>(<span class="hljs-number">19</span>, <span class="hljs-number">40</span>]    <span class="hljs-number">35</span>   <span class="hljs-number">35</span><br>(<span class="hljs-number">40</span>, <span class="hljs-number">65</span>]    <span class="hljs-number">54</span>   <span class="hljs-number">54</span><br>(<span class="hljs-number">65</span>, <span class="hljs-number">100</span>]   <span class="hljs-number">11</span>   <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>按‘Age’分组范围和性别（sex）进⾏制作交叉表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.crosstab(age_groups, df[<span class="hljs-string">&#x27;Sex&#x27;</span>])<br><br>---<br><br>SexFM<br>Age<br>(<span class="hljs-number">19</span>, <span class="hljs-number">40</span>]<span class="hljs-number">18</span><span class="hljs-number">22</span><br>(<span class="hljs-number">40</span>, <span class="hljs-number">65</span>]<span class="hljs-number">25</span><span class="hljs-number">27</span><br>(<span class="hljs-number">65</span>, <span class="hljs-number">100</span>]<span class="hljs-number">3</span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="聚合">聚合</h3><p>我们先来看聚合函数的表格</p><table><thead><tr class="header"><th>聚合函数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>mean</td><td>计算分组平均值</td></tr><tr class="even"><td>count</td><td>分组中⾮NA值的数量</td></tr><tr class="odd"><td>sum</td><td>⾮NA值的和</td></tr><tr class="even"><td>median</td><td>⾮NA值的算术中位数</td></tr><tr class="odd"><td>std</td><td>标准差</td></tr><tr class="even"><td>var</td><td>⽅差</td></tr><tr class="odd"><td>min</td><td>⾮NA值的最⼩值</td></tr><tr class="even"><td>max</td><td>⾮NA值的最⼤值</td></tr><tr class="odd"><td>prod</td><td>⾮NA值的积</td></tr><tr class="even"><td>first</td><td>第⼀个⾮NA值</td></tr><tr class="odd"><td>last</td><td>最后⼀个⾮NA值</td></tr><tr class="even"><td>mad</td><td>平均绝对偏差</td></tr><tr class="odd"><td>mode</td><td>模</td></tr><tr class="even"><td>abs</td><td>绝对值</td></tr><tr class="odd"><td>sem</td><td>平均值的标准误差</td></tr><tr class="even"><td>skew</td><td>样品偏斜度（三阶矩）</td></tr><tr class="odd"><td>kurt</td><td>样品峰度（四阶矩）</td></tr><tr class="even"><td>quantile</td><td>样本分位数（百分位上的值）</td></tr><tr class="odd"><td>cumsum</td><td>累积总和</td></tr><tr class="even"><td>cumprod</td><td>累积乘积</td></tr><tr class="odd"><td>cummax</td><td>累积最⼤值</td></tr><tr class="even"><td>cummin</td><td>累积最⼩值</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame(&#123;<span class="hljs-string">&#x27;Data1&#x27;</span>:np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>),<br> <span class="hljs-string">&#x27;Data2&#x27;</span>:np.random.randint(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">5</span>),<br> <span class="hljs-string">&#x27;key1&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;aabba&#x27;</span>),<br> <span class="hljs-string">&#x27;key2&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;xyyxy&#x27;</span>)&#125;)<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>   Data1  Data2 key1 key2<br><span class="hljs-number">0</span>      <span class="hljs-number">4</span>     <span class="hljs-number">17</span>    a    x<br><span class="hljs-number">1</span>      <span class="hljs-number">4</span>     <span class="hljs-number">13</span>    a    y<br><span class="hljs-number">2</span>      <span class="hljs-number">0</span>     <span class="hljs-number">12</span>    b    y<br><span class="hljs-number">3</span>      <span class="hljs-number">5</span>     <span class="hljs-number">16</span>    b    x<br><span class="hljs-number">4</span>      <span class="hljs-number">8</span>     <span class="hljs-number">10</span>    a    y<br></code></pre></td></tr></table></figure><p>按key1分组，进⾏聚合计算</p><p>⚠️注意：当分组后进⾏数值计算时，不是数值类的列（即麻烦列）会被清除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).<span class="hljs-built_in">sum</span>())<br><br>---<br>      Data1  Data2<br>key1              <br>a        <span class="hljs-number">16</span>     <span class="hljs-number">40</span><br>b         <span class="hljs-number">5</span>     <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>只算data1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1[<span class="hljs-string">&#x27;Data1&#x27;</span>].groupby(df1[<span class="hljs-string">&#x27;key1&#x27;</span>]).<span class="hljs-built_in">sum</span>()) <br><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>)[<span class="hljs-string">&#x27;Data1&#x27;</span>].<span class="hljs-built_in">sum</span>())<br><br>---<br>key1<br>a    <span class="hljs-number">16</span><br>b     <span class="hljs-number">5</span><br>Name: Data1, dtype: int64<br>key1<br>a    <span class="hljs-number">16</span><br>b     <span class="hljs-number">5</span><br>Name: Data1, dtype: int64<br></code></pre></td></tr></table></figure><p>使⽤<code>agg()</code>函数做聚合运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).agg(<span class="hljs-string">&#x27;sum&#x27;</span>))<br><br>---<br>      Data1  Data2<br>key1              <br>a        <span class="hljs-number">16</span>     <span class="hljs-number">40</span><br>b         <span class="hljs-number">5</span>     <span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>可以同时做多个聚合运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).agg([<span class="hljs-string">&#x27;sum&#x27;</span>,<span class="hljs-string">&#x27;mean&#x27;</span>,<span class="hljs-string">&#x27;std&#x27;</span>]))<br><br>---<br>     Data1                     Data2                     <br>       <span class="hljs-built_in">sum</span>      mean       std   <span class="hljs-built_in">sum</span>       mean       std<br>key1                                                     <br>a       <span class="hljs-number">16</span>  <span class="hljs-number">5.333333</span>  <span class="hljs-number">2.309401</span>    <span class="hljs-number">40</span>  <span class="hljs-number">13.333333</span>  <span class="hljs-number">3.511885</span><br>b        <span class="hljs-number">5</span>  <span class="hljs-number">2.500000</span>  <span class="hljs-number">3.535534</span>    <span class="hljs-number">28</span>  <span class="hljs-number">14.000000</span>  <span class="hljs-number">2.828427</span><br></code></pre></td></tr></table></figure><p>可⾃定义函数，传⼊agg⽅法中 <code>grouped.agg(func)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">peak_range</span>(<span class="hljs-params">df</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    返回数值范围</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> df.<span class="hljs-built_in">max</span>() - df.<span class="hljs-built_in">min</span>()<br><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).agg(peak_range))<br><br>---<br>      Data1  Data2<br>key1              <br>a         <span class="hljs-number">4</span>      <span class="hljs-number">7</span><br>b         <span class="hljs-number">5</span>      <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>同时应⽤多个聚合函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).agg([<span class="hljs-string">&#x27;mean&#x27;</span>, <span class="hljs-string">&#x27;std&#x27;</span>, <span class="hljs-string">&#x27;count&#x27;</span>, peak_range])) <span class="hljs-comment"># 默认列名为函数名</span><br><br>---<br>         Data1                                 Data2                  \<br>          mean       std count peak_range       mean       std count   <br>key1                                                                   <br>a     <span class="hljs-number">5.333333</span>  <span class="hljs-number">2.309401</span>     <span class="hljs-number">3</span>          <span class="hljs-number">4</span>  <span class="hljs-number">13.333333</span>  <span class="hljs-number">3.511885</span>     <span class="hljs-number">3</span>   <br>b     <span class="hljs-number">2.500000</span>  <span class="hljs-number">3.535534</span>     <span class="hljs-number">2</span>          <span class="hljs-number">5</span>  <span class="hljs-number">14.000000</span>  <span class="hljs-number">2.828427</span>     <span class="hljs-number">2</span>   <br><br>                 <br>     peak_range  <br>key1             <br>a             <span class="hljs-number">7</span>  <br>b             <span class="hljs-number">4</span>  <br></code></pre></td></tr></table></figure><p>通过元组提供新的列名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).agg([<span class="hljs-string">&#x27;mean&#x27;</span>, <span class="hljs-string">&#x27;std&#x27;</span>, <span class="hljs-string">&#x27;count&#x27;</span>, (<span class="hljs-string">&#x27;range&#x27;</span>, peak_range)])) <br><br>---<br>         Data1                            Data2                      <br>          mean       std count <span class="hljs-built_in">range</span>       mean       std count <span class="hljs-built_in">range</span><br>key1                                                                 <br>a     <span class="hljs-number">5.333333</span>  <span class="hljs-number">2.309401</span>     <span class="hljs-number">3</span>     <span class="hljs-number">4</span>  <span class="hljs-number">13.333333</span>  <span class="hljs-number">3.511885</span>     <span class="hljs-number">3</span>     <span class="hljs-number">7</span><br>b     <span class="hljs-number">2.500000</span>  <span class="hljs-number">3.535534</span>     <span class="hljs-number">2</span>     <span class="hljs-number">5</span>  <span class="hljs-number">14.000000</span>  <span class="hljs-number">2.828427</span>     <span class="hljs-number">2</span>     <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>给每列作⽤不同的聚合函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_mapping = &#123;<br>    <span class="hljs-string">&#x27;Data1&#x27;</span>:[<span class="hljs-string">&#x27;mean&#x27;</span>,<span class="hljs-string">&#x27;max&#x27;</span>],<br>    <span class="hljs-string">&#x27;Data2&#x27;</span>:<span class="hljs-string">&#x27;sum&#x27;</span><br>&#125;<br>df1.groupby(<span class="hljs-string">&#x27;key1&#x27;</span>).agg(dict_mapping)<br><br>---<br>Data1Data2<br>mean<span class="hljs-built_in">max</span><span class="hljs-built_in">sum</span><br>key1<br>a<span class="hljs-number">5.333333</span><span class="hljs-number">8</span><span class="hljs-number">40</span><br>b<span class="hljs-number">2.500000</span><span class="hljs-number">5</span><span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>拓展<code>apply()</code>函数</p><p>apply函数是pandas⾥⾯所有函数中⾃由度最⾼的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">df1=pd.DataFrame(&#123;<span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;FFMFMMF&#x27;</span>),<span class="hljs-string">&#x27;smoker&#x27;</span>:<span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;YNYYNYY&#x27;</span>),<span class="hljs-string">&#x27;age&#x27;</span>: [<span class="hljs-number">21</span>,<span class="hljs-number">30</span>,<span class="hljs-number">17</span>,<span class="hljs-number">37</span>,<span class="hljs-number">40</span>,<span class="hljs-number">18</span>,<span class="hljs-number">26</span>],<span class="hljs-string">&#x27;weight&#x27;</span>:[<span class="hljs-number">120</span>,<span class="hljs-number">100</span>,<span class="hljs-number">132</span>,<span class="hljs-number">140</span>,<span class="hljs-number">94</span>,<span class="hljs-number">89</span>,<span class="hljs-number">123</span>]&#125;)<br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>  sex smoker  age  weight<br><span class="hljs-number">0</span>   F      Y   <span class="hljs-number">21</span>     <span class="hljs-number">120</span><br><span class="hljs-number">1</span>   F      N   <span class="hljs-number">30</span>     <span class="hljs-number">100</span><br><span class="hljs-number">2</span>   M      Y   <span class="hljs-number">17</span>     <span class="hljs-number">132</span><br><span class="hljs-number">3</span>   F      Y   <span class="hljs-number">37</span>     <span class="hljs-number">140</span><br><span class="hljs-number">4</span>   M      N   <span class="hljs-number">40</span>      <span class="hljs-number">94</span><br><span class="hljs-number">5</span>   M      Y   <span class="hljs-number">18</span>      <span class="hljs-number">89</span><br><span class="hljs-number">6</span>   F      Y   <span class="hljs-number">26</span>     <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>抽烟的年龄⼤于等18的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">bin_age</span>(<span class="hljs-params">age</span>):<br>    <span class="hljs-keyword">if</span> age &gt;=<span class="hljs-number">18</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>      <br><span class="hljs-built_in">print</span>(df1[<span class="hljs-string">&#x27;age&#x27;</span>].apply(bin_age))<br><br>---<br><span class="hljs-number">0</span>    <span class="hljs-number">1</span><br><span class="hljs-number">1</span>    <span class="hljs-number">1</span><br><span class="hljs-number">2</span>    <span class="hljs-number">0</span><br><span class="hljs-number">3</span>    <span class="hljs-number">1</span><br><span class="hljs-number">4</span>    <span class="hljs-number">1</span><br><span class="hljs-number">5</span>    <span class="hljs-number">1</span><br><span class="hljs-number">6</span>    <span class="hljs-number">1</span><br>Name: age, dtype: int64<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">df1[<span class="hljs-string">&#x27;age&#x27;</span>] = df1[<span class="hljs-string">&#x27;age&#x27;</span>].apply(bin_age) <br><span class="hljs-built_in">print</span>(df1)<br><br>---<br>  sex smoker  age  weight<br><span class="hljs-number">0</span>   F      Y    <span class="hljs-number">1</span>     <span class="hljs-number">120</span><br><span class="hljs-number">1</span>   F      N    <span class="hljs-number">1</span>     <span class="hljs-number">100</span><br><span class="hljs-number">2</span>   M      Y    <span class="hljs-number">0</span>     <span class="hljs-number">132</span><br><span class="hljs-number">3</span>   F      Y    <span class="hljs-number">1</span>     <span class="hljs-number">140</span><br><span class="hljs-number">4</span>   M      N    <span class="hljs-number">1</span>      <span class="hljs-number">94</span><br><span class="hljs-number">5</span>   M      Y    <span class="hljs-number">1</span>      <span class="hljs-number">89</span><br><span class="hljs-number">6</span>   F      Y    <span class="hljs-number">1</span>     <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p>取出抽烟和不抽烟的体重前⼆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">top</span>(<span class="hljs-params">smoker,col,n=<span class="hljs-number">5</span></span>):<br>    <span class="hljs-keyword">return</span> smoker.sort_values(by=col)[-n:]<br>df1.groupby(<span class="hljs-string">&#x27;smoker&#x27;</span>).apply(top,col=<span class="hljs-string">&#x27;weight&#x27;</span>,n=<span class="hljs-number">2</span>)<br><br>---<br>sexsmokerageweight<br>smoker<br>N<span class="hljs-number">4</span>MN<span class="hljs-number">1</span><span class="hljs-number">94</span><br><span class="hljs-number">1</span>FN<span class="hljs-number">1</span><span class="hljs-number">100</span><br>Y<span class="hljs-number">2</span>MY<span class="hljs-number">0</span><span class="hljs-number">132</span><br><span class="hljs-number">3</span>FY<span class="hljs-number">1</span><span class="hljs-number">140</span><br></code></pre></td></tr></table></figure><p>按理来说，我们最后展示数据的时候，在用完<code>age</code>上<code>0,1</code>作为判断之后，要恢复成原本的年龄的数据。不过...就这样吧。因为马上，我们要做一个完整的分组案例，从一个<code>csv</code>文件获取数据，然后分组，最后进行数据可视化展示：</p><h2 id="分组案例">分组案例</h2><p>我们先来读取数据，案例中使用到的数据会上传到我的<code>Github</code>仓库中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">data = pd.read_csv(<span class="hljs-string">&#x27;./data/movie_metadata.csv&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数据的形状：&#x27;</span>, data.shape) <br><span class="hljs-built_in">print</span>(data.head())<br><br>---<br>数据的形状： (<span class="hljs-number">5043</span>, <span class="hljs-number">28</span>)<br>                                        movie_title language country  \<br><span class="hljs-number">0</span>                                            Avatar   English     USA   <br><span class="hljs-number">1</span>          Pirates of the Caribbean: At World<span class="hljs-string">&#x27;s End   English     USA   </span><br><span class="hljs-string">2                                           Spectre   English      UK   </span><br><span class="hljs-string">3                             The Dark Knight Rises   English     USA   </span><br><span class="hljs-string">4  Star Wars: Episode VII - The Force Awakens    ...      NaN     NaN   </span><br><span class="hljs-string"></span><br><span class="hljs-string">  content_rating title_year  color  duration                           genres  \</span><br><span class="hljs-string">0          PG-13    2009-02  Color     178.0  Action|Adventure|Fantasy|Sci-Fi   </span><br><span class="hljs-string">1          PG-13    2007-09  Color     169.0         Action|Adventure|Fantasy   </span><br><span class="hljs-string">2          PG-13    2015-11  Color     148.0        Action|Adventure|Thriller   </span><br><span class="hljs-string">3          PG-13    2012-08  Color     164.0                  Action|Thriller   </span><br><span class="hljs-string">4            NaN        NaN    NaN       NaN                      Documentary   </span><br><span class="hljs-string"></span><br><span class="hljs-string">                                       plot_keywords       budget  ...  \</span><br><span class="hljs-string">0             avatar|future|marine|native|paraplegic  237000000.0  ...   </span><br><span class="hljs-string">1  goddess|marriage ceremony|marriage proposal|pi...  300000000.0  ...   </span><br><span class="hljs-string">2                bomb|espionage|sequel|spy|terrorist  245000000.0  ...   </span><br><span class="hljs-string">3  deception|imprisonment|lawlessness|police offi...  250000000.0  ...   </span><br><span class="hljs-string">4                                                NaN          NaN  ...   </span><br><span class="hljs-string"></span><br><span class="hljs-string">   actor_2_facebook_likes          actor_3_name  actor_3_facebook_likes  \</span><br><span class="hljs-string">0                   936.0             Wes Studi                   855.0   </span><br><span class="hljs-string">1                  5000.0        Jack Davenport                  1000.0   </span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>然后让我们来处理缺失值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">data = data.dropna(how=<span class="hljs-string">&#x27;any&#x27;</span>)<br><span class="hljs-built_in">print</span>(data.head())<br><br>---<br>                                 movie_title language country content_rating  \<br><span class="hljs-number">0</span>                                    Avatar   English     USA          PG-<span class="hljs-number">13</span>   <br><span class="hljs-number">1</span>  Pirates of the Caribbean: At World<span class="hljs-string">&#x27;s End   English     USA          PG-13   </span><br><span class="hljs-string">2                                   Spectre   English      UK          PG-13   </span><br><span class="hljs-string">3                     The Dark Knight Rises   English     USA          PG-13   </span><br><span class="hljs-string">5                               John Carter   English     USA          PG-13   </span><br><span class="hljs-string"></span><br><span class="hljs-string">  title_year  color  duration                           genres  \</span><br><span class="hljs-string">0    2009-02  Color     178.0  Action|Adventure|Fantasy|Sci-Fi   </span><br><span class="hljs-string">1    2007-09  Color     169.0         Action|Adventure|Fantasy   </span><br><span class="hljs-string">2    2015-11  Color     148.0        Action|Adventure|Thriller   </span><br><span class="hljs-string">3    2012-08  Color     164.0                  Action|Thriller   </span><br><span class="hljs-string">5    2012-07  Color     132.0          Action|Adventure|Sci-Fi   </span><br><span class="hljs-string"></span><br><span class="hljs-string">                                       plot_keywords       budget  ...  \</span><br><span class="hljs-string">0             avatar|future|marine|native|paraplegic  237000000.0  ...   </span><br><span class="hljs-string">1  goddess|marriage ceremony|marriage proposal|pi...  300000000.0  ...   </span><br><span class="hljs-string">2                bomb|espionage|sequel|spy|terrorist  245000000.0  ...   </span><br><span class="hljs-string">3  deception|imprisonment|lawlessness|police offi...  250000000.0  ...   </span><br><span class="hljs-string">5  alien|american civil war|male nipple|mars|prin...  263700000.0  ...   </span><br><span class="hljs-string"></span><br><span class="hljs-string">   actor_2_facebook_likes          actor_3_name  actor_3_facebook_likes  \</span><br><span class="hljs-string">0                   936.0             Wes Studi                   855.0   </span><br><span class="hljs-string">1                  5000.0        Jack Davenport                  1000.0   </span><br><span class="hljs-string">2                   393.0      Stephanie Sigman                   161.0   </span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>接着，我们来查看一下票房收入统计</p><p>导演vs票房总收⼊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">group_director = data.groupby(*by*=<span class="hljs-string">&#x27;director_name&#x27;</span>)[<span class="hljs-string">&#x27;gross&#x27;</span>].<span class="hljs-built_in">sum</span>()<br></code></pre></td></tr></table></figure><p>ascending升降序排列，True升序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">result = group_director.sort_values() <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(result))<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;pandas.core.series.Series&#x27;</span>&gt;<br>director_name<br>Ekachai Uekrongtham    <span class="hljs-number">1.620000e+02</span><br>Frank Whaley           <span class="hljs-number">7.030000e+02</span><br>Ricki Stern            <span class="hljs-number">1.111000e+03</span><br>Alex Craig Mann        <span class="hljs-number">1.332000e+03</span><br>Paul Bunnell           <span class="hljs-number">2.436000e+03</span><br>                           ...     <br>Sam Raimi              <span class="hljs-number">2.049549e+09</span><br>Tim Burton             <span class="hljs-number">2.071275e+09</span><br>Michael Bay            <span class="hljs-number">2.231243e+09</span><br>Peter Jackson          <span class="hljs-number">2.592969e+09</span><br>Steven Spielberg       <span class="hljs-number">4.114233e+09</span><br>Name: gross, Length: <span class="hljs-number">1660</span>, dtype: float64<br></code></pre></td></tr></table></figure><p><strong>电影产量年份趋势</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> font_manager<br><br>movie_years = data.groupby(<span class="hljs-string">&#x27;title_year&#x27;</span>)[<span class="hljs-string">&#x27;movie_title&#x27;</span>]<br><span class="hljs-built_in">print</span>(movie_years.count().index.tolist()) <br><span class="hljs-built_in">print</span>(movie_years.count().values)<br><br>---<br>[<span class="hljs-string">&#x27;1927-02&#x27;</span>, ..., <span class="hljs-string">&#x27;2016-12&#x27;</span>]<br>[ <span class="hljs-number">1</span>  ... <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>最后，我们利用之前学过的<code>matplotlib</code>进行数据可视化展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = movie_years.count().index.tolist()<br>y = movie_years.count().values<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>),dpi=<span class="hljs-number">80</span>)<br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-Pandas/image-20230822200739326.png" class="" title="plt.show"><h2 id="结尾">结尾</h2><p>那小伙伴们，到今天为止，我们《AI秘籍》系列课程中的「Python部分」也就完全讲完了。就如我一开始向大家承诺的，这部分内容将完全免费。</p><p>而我们的《AI秘籍》课程也才刚刚开始，未来很长一段时间内，我们都将继续和这些基础内容频繁打交道。用它们来呈现我们之后要用到的所有课程。包括AI基础，CV，BI，NLP等课程。</p><p>不过在结束了一个阶段之后，我需要花点时间休整一下，也是为了好好的备课，找到最好的结构和顺序为大家编写后面的课程。本次课程的最后这两节课我都有些疲劳，为了赶快完成进度，编写过程当中可能有些粗糙或者遗漏，也请大家多包涵。日后，我可能会对这两节课进行更新，将一些细节的讲解补充完整。</p><p>免费部分结束了，日后的收费课程，也期望大家能一如即往的支持。</p><p>在这里，我也给大家推荐一些比较好的书籍，希望看到小伙伴们能够快速成长起来。</p><p>感谢大家，好了。本节课到此结束，下课了。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/AI-Python-Pandas/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>26. NumPy</title>
    <link href="https://hivan.me/AI-Python-numpy/"/>
    <id>https://hivan.me/AI-Python-numpy/</id>
    <published>2023-08-21T00:41:45.000Z</published>
    <updated>2023-08-21T17:28:31.578Z</updated>
    
    <content type="html"><![CDATA[<img src="/AI-Python-numpy/cover.png" class="" title="img"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>上一节课中，我们学习了matplotlib.实际上，我们已经进入了数据可视化阶段。</p><p>可是在上一节课中，所有的数据都是我们固定写好的，包括两个电影的数据展示的案例（柱状图和直方图），都是我们将数据手动写成了数据列表，然后直接使用。</p><p>在我们平时的工作中，不太有那么多的机会使用现成的数据，除非你跟我一样是一个数据产品经理，那倒是会有程序员们会将数据整理好递到你手上。可是即便如此，很多时候我还是需要自己亲手去处理数据，因为我不能为了一次数据验证或者一个什么想法就去惊动程序员为你服务。</p><p>更何况，我们现在的课程面向的是人工智能，那么处理数据就成了必须要有的手段，也是家常便饭常有的事。</p><p>那么今天，我们就来学习一下Python中科学计算的基础第三方库：「numpy」。</p><h2 id="简单介绍一下numpy">简单介绍一下NumPy</h2><img src="/AI-Python-numpy/image-20230821085422148.png" class="" title="img"><p>Numpy的全称是：Numerical Python,是一个开源的Python科学计算库，用于快速处理任意维度的数组。</p><p>Numpy支持常见的数组和矩阵操作，对于同样的数值计算任务，使用Numpy比直接使用Python要简洁的多。其中的<code>ndarray</code>对象用于处理多维数组，该对象是一个快速而灵活的大数据容器。</p><p>相对于直接使用Python，NumPy具有一下优势：</p><ul><li><p>对于同样的数值计算任务，使用NumPy要比直接编写Python代码便捷得多；</p></li><li><p>NumPy中的数组的存储效率和输入输出性能均远远优于Python中等价的基本数据结构，且其能够提升的性能是与数组中的元素成比例的；</p></li><li><p>NumPy的大部分代码都是用C语言写的，其底层算法在设计时就有着优异的性能，这使得NumPy比纯Python代码高效得多.</p></li></ul><p>说那么多我们不如直接来一次对比显得更直接一点，让我们来计算<code>100000000</code>个数字的加法运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000000</span>):<br>    a.append(random.random())<br>t1 = time.time()<br><br><span class="hljs-comment"># Python 处理</span><br>sum_py = <span class="hljs-built_in">sum</span>(a)<br>t2 = time.time()<br><br>b = np.array(a)<br>t4 = time.time()<br><br><span class="hljs-comment"># NumPy 处理</span><br>sum_np = np.<span class="hljs-built_in">sum</span>(b)<br>t5 = time.time()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Python:<span class="hljs-subst">&#123;t2-t1&#125;</span>, NumPy:<span class="hljs-subst">&#123;t5-t4&#125;</span>&#x27;</span>)<br><br>---<br>Python:<span class="hljs-number">1.782839059829712</span>, NumPy:<span class="hljs-number">0.2144303321838379</span><br></code></pre></td></tr></table></figure><p>在以上代码中，t2-t1为使用python自带的求和函数消耗的时间，t5-t4为使用numpy求和消耗的时间。我们看到了时间对比，是不是为<code>NumPy</code>效率的提升感到惊讶？实际上，在一些更早一些配置差一点的电脑上，这个差距还会更大。记得我以前曾经做过一样的事情，时间大概为<code>Python: 5s, NumPy:0.5s</code>。差了有10倍左右。那么我们也能看出来了，<code>ndarray</code>的计算速度快了很多，为我们节约了大量时间。</p><h2 id="ndarray对象">ndarray对象</h2><p>N维数组对象<code>ndarray</code>可以说是NumPy中最重要的一个特点了，它是一个系列同类型数据的集合，以0下标为开始进行集合中元素的索引。<code>ndarray</code>对象是用于存放同类型元素的多维数组。</p><p>让我尝试创建一些一维数组，<code>Numpy</code>创建数组有三种不同的方式，1.直接传入列表的方式； 2. 传入range生成序列； 3.直接使用<code>np.arange()</code>生成数组。让我们一一来实现下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建数组的多种形式</span><br><span class="hljs-comment"># 1. 直接传入列表的方式</span><br>list1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>oneArray = np.array(list1)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;oneArray: <span class="hljs-subst">&#123;oneArray, <span class="hljs-built_in">type</span>(oneArray)&#125;</span>&#x27;</span>)<br><br>t1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;t1: <span class="hljs-subst">&#123;t1, <span class="hljs-built_in">type</span>(t1)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 2. 传入range生成序列</span><br>t2 = np.array(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;t2: <span class="hljs-subst">&#123;t2, <span class="hljs-built_in">type</span>(t2)&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 3. 使用numpy自带的np.arange()生成数组</span><br>t3 = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;t3: <span class="hljs-subst">&#123;t3, <span class="hljs-built_in">type</span>(t3)&#125;</span>&#x27;</span>)<br><br>---<br>oneArray: (array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]), &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.ndarray&#x27;</span>&gt;)<br>t1: (array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]), &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.ndarray&#x27;</span>&gt;)<br>t2: (array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]), &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.ndarray&#x27;</span>&gt;)<br>t3: (array([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]), &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;numpy.ndarray&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>无论用哪种方式，我们可以看到最终打印的类型都是<code>numpy.ndarray</code>。</p><p>那以上是一维数组的创建，我们再来看看二维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二维数组</span><br>list2 = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br>twoArray = np.array(list2)<br><span class="hljs-built_in">print</span>(twoArray)<br><br>---<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p>对于二位数组的理解，我们可以将其看成行跟列。如果是在Excel中，那么<code>1,2</code>就是一行，<code>3,4</code>是一行，<code>5,6</code>是一行。而<code>[1,3,5]</code>就是一列，<code>[2,4,6]</code>也是一列。</p><p>那么，我们在看到数据之前怎么知道这组数据的维度呢？可以使用方法<code>ndim</code>，顺便，我们来学习一下一些常用属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取数组的维度</span><br><span class="hljs-built_in">print</span>(twoArray.ndim)<br><br><span class="hljs-comment"># 获取数据的形状（行、列）</span><br><span class="hljs-built_in">print</span>(twoArray.shape)<br><br><span class="hljs-comment"># 获取数组的元素个数</span><br><span class="hljs-built_in">print</span>(twoArray.size)<br><br>---<br><span class="hljs-number">2</span><br>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>这样，我们就可以看到数组的一些相关属性，拿来在处理数据前做参考。其中，获取到的<code>shape</code>是一个元组数据，而我们获取到的<code>size</code>可以看成是元组内的数据相乘。</p><p>现在我们来看，我们能否在numpy中调整数组的形状呢？来，尝试一下，当前我们有一组二维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p>将其转变为<code>ndarray</code>并赋值给一个变量<code>arr_1</code>，既然我们前面知道获取数据的形状是用<code>shape</code>，那我们尝试直接更改它的<code>shape</code>看看是否可行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr_1 = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br>arr_1.shape = (<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr_1)<br><br>---<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p>居然可以。</p><p>不过虽然这样能够对数组形状进行修改，不过在NumPy中正确的修改方式应该是使用<code>reshape</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回一个新的数组</span><br>arr_1 = arr_1.reshape(arr_1.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\narr_1:\n<span class="hljs-subst">&#123;arr_1&#125;</span>&#x27;</span>)<br><br>---<br>arr_1:<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p>这次我们使用了数组第一次修改后的形状，所以整个和之前没有差别，让我们再试试其他的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将多维变成一维数组</span><br>arr_2 = arr_1.reshape((arr_1.size), order=<span class="hljs-string">&#x27;F&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\narr_2:\n<span class="hljs-subst">&#123;arr_2&#125;</span>&#x27;</span>)<br>arr_3 = arr_1.flatten(order=<span class="hljs-string">&#x27;F&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\narr_3:\n<span class="hljs-subst">&#123;arr_3&#125;</span>&#x27;</span>)<br><br>---<br>arr_2:<br>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>]<br><br>arr_3:<br>[<span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>后方那个形参<code>order</code>是一个可选参数，是读取元素的索引顺序，有<code>C, F, A</code>三个固定值。<code>C</code>为行有限，<code>F</code>为列有限,<code>A</code>为按数据存储顺序。</p><p>如果只是转为一维数组，使用<code>reshape</code>还需要知道数组的元素个数，不如<code>flatten</code>来的方便。这是一个专门用于将数组折叠成一维数组的方法。</p><p>让我们来看看<code>reshape</code>转换数组形状的其他几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组的形状</span><br>t = np.arange(<span class="hljs-number">24</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;t:\n<span class="hljs-subst">&#123;t&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(t.shape)<br><br><span class="hljs-comment"># 转换成二维</span><br>t1 = t.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nt1:\n<span class="hljs-subst">&#123;t1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(t1.shape)<br><br><span class="hljs-comment"># 转换成三维</span><br>t2 = t1.reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nt2:\n<span class="hljs-subst">&#123;t2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(t2.shape)<br><br><br>---<br>t:<br>[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]<br>(<span class="hljs-number">24</span>,)<br><br>t1:<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>)<br><br>t2:<br>[[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br>  [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br>  [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br><br> [[<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br>  [<span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span>][<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">88</span>, <span class="hljs-number">14</span>, <span class="hljs-number">25</span>] &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br>  [<span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]]<br>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>在数据转为了<code>ndarray</code>之后，方便了我们在<code>NumPy</code>中进行计算等操作，不过很多时候，最终我们还是要转回Python内的List。如果需要进行转换，直接使用<code>tolist()</code>就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数组转为list</span><br>a = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">88</span>, <span class="hljs-number">14</span>, <span class="hljs-number">25</span>])<br>items = a.tolist()<br><span class="hljs-built_in">print</span>(items, <span class="hljs-built_in">type</span>(items))<br><br>---<br>[<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">88</span>, <span class="hljs-number">14</span>, <span class="hljs-number">25</span>] &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;list&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="numpy的数据类型">NumPy的数据类型</h2><p>在之前的Python基础课程中，我用几节课给大家讲了一遍Python中的数据类型。同样的，在NumPy中也有一些不同的数据类型，大多数时候，他们都可以进行转换。</p><p>来直接上代码看几个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], dtype=np.int16)<br></code></pre></td></tr></table></figure><p>这样，我们就在Numpy中生成了一个<code>int16</code>类型的数组。我们来看看这组数据的元素长度和类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 返回数组中每个元素的直接单位长度</span><br><span class="hljs-built_in">print</span>(arr.itemsize)<br><span class="hljs-comment"># 获取数据类型</span><br><span class="hljs-built_in">print</span>(arr.dtype)<br><br>---<br><span class="hljs-number">2</span><br>int16<br></code></pre></td></tr></table></figure><p>当然，就如我们之前说的，数据的类型之间是可以进行转换的，转换也十分方便，直接使用类型方法就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 调整数据类型</span><br>arr_2 = arr.astype(np.int64)<br><span class="hljs-built_in">print</span>(arr_2.dtype)<br><br>---<br>int64<br></code></pre></td></tr></table></figure><p>这里给大家多讲一个小技巧，让我们看看如何生成随机小数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用Python语法，保留两位</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(random.random(), <span class="hljs-number">2</span>))<br><span class="hljs-comment"># Numpy生成数组</span><br>arr_3 = np.<span class="hljs-built_in">round</span>([random.random() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)],<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(arr_3)<br><br>---<br><span class="hljs-number">0.47</span><br>[<span class="hljs-number">0.97</span> <span class="hljs-number">0.81</span> <span class="hljs-number">0.1</span>  <span class="hljs-number">0.23</span> <span class="hljs-number">0.66</span> <span class="hljs-number">0.98</span> <span class="hljs-number">0.06</span> <span class="hljs-number">0.44</span> <span class="hljs-number">0.33</span> <span class="hljs-number">0.14</span>]<br></code></pre></td></tr></table></figure><p>既然我们知道了<code>dtype</code>是<code>numpy</code>中的数据类型，那么对于数组来说，都有哪些类型呢？这里给大家一个表：</p><table><colgroup><col style="width: 21%" /><col style="width: 71%" /><col style="width: 7%" /></colgroup><thead><tr class="header"><th>名称</th><th>描述</th><th>简写</th></tr></thead><tbody><tr class="odd"><td><code>np.bool</code></td><td>用一个字节存储的布尔类型（True或False）</td><td>'b'</td></tr><tr class="even"><td><code>np.int8</code></td><td>一个字节大小，-128 至 127 （一个字节）</td><td>'i'</td></tr><tr class="odd"><td><code>np.int16</code></td><td>整数，-32768 至 32767 （2个字节）</td><td>'i2'</td></tr><tr class="even"><td><code>np.int32</code></td><td>整数，-2 <strong>31</strong> <strong>至</strong> <strong>2</strong>32 -1 （4个字节）</td><td>'i4'</td></tr><tr class="odd"><td><code>np.int64</code></td><td>整数，-2 <strong>63</strong> <strong>至</strong> <strong>2</strong>63 - 1 （8个字节）</td><td>'i8'</td></tr><tr class="even"><td><code>np.uint8</code></td><td>无符号整数，0 至 255</td><td>'u'</td></tr><tr class="odd"><td><code>np.uint16</code></td><td>无符号整数，0 至 65535</td><td>'u2'</td></tr><tr class="even"><td><code>np.uint32</code></td><td>无符号整数，0 至 2 ** 32 - 1</td><td>'u4'</td></tr><tr class="odd"><td><code>np.uint64</code></td><td>无符号整数，0 至 2 ** 64 - 1</td><td>'u8'</td></tr><tr class="even"><td><code>np.ﬂoat16</code></td><td>半精度浮点数：16位，正负号1位，指数5位，精度10位</td><td>'f2'</td></tr><tr class="odd"><td><code>np.ﬂoat32</code></td><td>单精度浮点数：32位，正负号1位，指数8位，精度23位</td><td>'f4'</td></tr><tr class="even"><td><code>np.ﬂoat64</code></td><td>双精度浮点数：64位，正负号1位，指数11位，精度52位</td><td>'f8'</td></tr><tr class="odd"><td><code>np.complex64</code></td><td>复数，分别用两个32位浮点数表示实部和虚部</td><td>'c8'</td></tr><tr class="even"><td><code>np.complex128</code></td><td>复数，分别用两个64位浮点数表示实部和虚部</td><td>'c16'</td></tr><tr class="odd"><td><code>np.object_</code></td><td>python对象</td><td>'O'</td></tr><tr class="even"><td><code>np.string_</code></td><td>字符串</td><td>'S'</td></tr><tr class="odd"><td><code>np.unicode_</code></td><td>unicode类型</td><td>'U'</td></tr></tbody></table><h3 id="数组的计算">数组的计算</h3><p>numpy的广播机制在运算过程中，加减乘除的值被广播到所有的元素上面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">6</span>,<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;原数组：\n&#x27;</span>, t1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;加2:\n&#x27;</span>, t1+<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;乘2:\n&#x27;</span>, t1*<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;除2:\n&#x27;</span>, t1/<span class="hljs-number">2</span>)<br><br>---<br>原数组：<br> [[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br> [<span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span>]<br> [<span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br>加<span class="hljs-number">2</span>:<br> [[ <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>]<br> [<span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span>]<br> [<span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span>]<br> [<span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span>]]<br>乘<span class="hljs-number">2</span>:<br> [[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>]<br> [ <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">12</span> <span class="hljs-number">14</span>]<br> [<span class="hljs-number">16</span> <span class="hljs-number">18</span> <span class="hljs-number">20</span> <span class="hljs-number">22</span>]<br> [<span class="hljs-number">24</span> <span class="hljs-number">26</span> <span class="hljs-number">28</span> <span class="hljs-number">30</span>]<br> [<span class="hljs-number">32</span> <span class="hljs-number">34</span> <span class="hljs-number">36</span> <span class="hljs-number">38</span>]<br> [<span class="hljs-number">40</span> <span class="hljs-number">42</span> <span class="hljs-number">44</span> <span class="hljs-number">46</span>]]<br>除<span class="hljs-number">2</span>:<br> [[ <span class="hljs-number">0.</span>   <span class="hljs-number">0.5</span>  <span class="hljs-number">1.</span>   <span class="hljs-number">1.5</span>]<br> [ <span class="hljs-number">2.</span>   <span class="hljs-number">2.5</span>  <span class="hljs-number">3.</span>   <span class="hljs-number">3.5</span>]<br> [ <span class="hljs-number">4.</span>   <span class="hljs-number">4.5</span>  <span class="hljs-number">5.</span>   <span class="hljs-number">5.5</span>]<br> [ <span class="hljs-number">6.</span>   <span class="hljs-number">6.5</span>  <span class="hljs-number">7.</span>   <span class="hljs-number">7.5</span>]<br> [ <span class="hljs-number">8.</span>   <span class="hljs-number">8.5</span>  <span class="hljs-number">9.</span>   <span class="hljs-number">9.5</span>]<br> [<span class="hljs-number">10.</span>  <span class="hljs-number">10.5</span> <span class="hljs-number">11.</span>  <span class="hljs-number">11.5</span>]]<br></code></pre></td></tr></table></figure><p>除了和数字进行计算之外，同种形状的数组之间也是可以进行计算（对应位置进行计算操作）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)<br>t2 = np.arange(<span class="hljs-number">100</span>, <span class="hljs-number">124</span>).reshape(<span class="hljs-number">6</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;相加:\n&#x27;</span>,t1+t2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;相乘:\n&#x27;</span>,t1*t2)<br><br>---<br>相加:<br> [[<span class="hljs-number">100</span> <span class="hljs-number">102</span> <span class="hljs-number">104</span> <span class="hljs-number">106</span>]<br> [<span class="hljs-number">108</span> <span class="hljs-number">110</span> <span class="hljs-number">112</span> <span class="hljs-number">114</span>]<br> [<span class="hljs-number">116</span> <span class="hljs-number">118</span> <span class="hljs-number">120</span> <span class="hljs-number">122</span>]<br> [<span class="hljs-number">124</span> <span class="hljs-number">126</span> <span class="hljs-number">128</span> <span class="hljs-number">130</span>]<br> [<span class="hljs-number">132</span> <span class="hljs-number">134</span> <span class="hljs-number">136</span> <span class="hljs-number">138</span>]<br> [<span class="hljs-number">140</span> <span class="hljs-number">142</span> <span class="hljs-number">144</span> <span class="hljs-number">146</span>]]<br>相乘:<br> [[   <span class="hljs-number">0</span>  <span class="hljs-number">101</span>  <span class="hljs-number">204</span>  <span class="hljs-number">309</span>]<br> [ <span class="hljs-number">416</span>  <span class="hljs-number">525</span>  <span class="hljs-number">636</span>  <span class="hljs-number">749</span>]<br> [ <span class="hljs-number">864</span>  <span class="hljs-number">981</span> <span class="hljs-number">1100</span> <span class="hljs-number">1221</span>]<br> [<span class="hljs-number">1344</span> <span class="hljs-number">1469</span> <span class="hljs-number">1596</span> <span class="hljs-number">1725</span>]<br> [<span class="hljs-number">1856</span> <span class="hljs-number">1989</span> <span class="hljs-number">2124</span> <span class="hljs-number">2261</span>]<br> [<span class="hljs-number">2400</span> <span class="hljs-number">2541</span> <span class="hljs-number">2684</span> <span class="hljs-number">2829</span>]]<br></code></pre></td></tr></table></figure><p>那么，不同形状的多维数组能否可以计算呢？来，一起试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">4</span>,<span class="hljs-number">6</span>))<br>t2 = np.arange(<span class="hljs-number">18</span>).reshape((<span class="hljs-number">3</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(t1)<br><span class="hljs-built_in">print</span>(t2)<br><span class="hljs-built_in">print</span>(t1-t2)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]]<br><br>ValueError: operands could <span class="hljs-keyword">not</span> be broadcast together <span class="hljs-keyword">with</span> shapes (<span class="hljs-number">4</span>,<span class="hljs-number">6</span>) (<span class="hljs-number">3</span>,<span class="hljs-number">6</span>) <br></code></pre></td></tr></table></figure><p>做相加操作的时候报错了，所以我们平时在处理数据的时候一定要多注意这种情况发生。不同形状的多维数组是不能进行计算的。</p><p>我们继续来往后做实验看看，行数或者列数相同的一维数组和多维数组可以进行计算吗？</p><p>先看看行形状相同的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t2 = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(t1 - t2)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">6</span>  <span class="hljs-number">6</span>  <span class="hljs-number">6</span>  <span class="hljs-number">6</span>  <span class="hljs-number">6</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span> <span class="hljs-number">12</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">18</span> <span class="hljs-number">18</span>]]<br></code></pre></td></tr></table></figure><p>看到结果我们就明白了，多维数组中的每一行数组都分别和一维数组中的数据进行操作，也就是会与每一行数组的对应位相操作。</p><p>那么列形状相同是否也是相同情况？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t2 = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(t1-t2)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span>]<br> [<span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br> [<span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span>]]<br></code></pre></td></tr></table></figure><p>就跟预料的一样，每一列的数组的对应位都进行了操作。</p><h3 id="数组的轴">数组的轴</h3><p>在理解了一维数组和二维数组之后，我们来看看数组中的轴。</p><p>什么是轴？在Numpy中，我们可以讲轴理解为方向，使用0,1,2数字来表示，对于一个一维数组，只有一个0轴。二维数组（shape(2,2)）呢，就有0轴和1轴，那同理向上推断，三维数组(shape(2,2,3))会有0，1，2三个轴。</p><p>那么我们到底为什么要了解和学习轴呢？有了轴的概念之后，我们计算讲会更加方便，比如计算一个二维数组的平均值，必须制定是计算哪个方向上面的数字的平均值。</p><p>下图中，我列出了不同数组的轴，看着图相信会好理解很多：</p><p><strong>一维数组：</strong></p><img src="/AI-Python-numpy/image-20230821173218362.png" class="" title="img"><p><strong>二维数组：</strong></p><img src="/AI-Python-numpy/image-20230821173619879.png" class="" title="img"><p>三维数组：</p><img src="/AI-Python-numpy/image-20230821174850984.png" class="" title="img"><p>看完图之后，让我们再放到代码里去理解一下轴的概念,我们先创建一个二维数组，然后用数组内的数据分别从0轴和1轴进行相加计算总和，得出的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(a, axis=<span class="hljs-number">0</span>))<br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(a, axis=<span class="hljs-number">1</span>))<br><br>---<br>[<span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]<br>[ <span class="hljs-number">6</span> <span class="hljs-number">15</span>]<br></code></pre></td></tr></table></figure><p>也就是说，我们按0轴算总和的时候，是列相加(<code>1+4,2+5,3+6</code>)，我们按1轴相加算总和的时候，是行相加(<code>1+2+3, 4+5+6</code>)</p><p>再让我们看看后面形参上我们不给行列值，计算的总和会是多少？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(a))<br><br>---<br><span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>也就是这个数组内的所有数字相加得到的结果。</p><p>在理解了二维数组行列相加的不同之后，我们再来看看三维数组，让我们先创建一个三维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">27</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(a)<br><br>---<br>[[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>]<br>  [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br>  [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>]]<br><br> [[ <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br>  [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]<br>  [<span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]]<br><br> [[<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span>]<br>  [<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]<br>  [<span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span>]]]<br></code></pre></td></tr></table></figure><p>接着，我们来分别按不同数轴进行计算来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># axis = 0</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(a, axis=<span class="hljs-number">0</span>))<br><br>---<br>[[<span class="hljs-number">27</span> <span class="hljs-number">30</span> <span class="hljs-number">33</span>]<br> [<span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span>]<br> [<span class="hljs-number">45</span> <span class="hljs-number">48</span> <span class="hljs-number">51</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># axis =  1</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(a, axis=<span class="hljs-number">1</span>))<br><br>---<br>[[ <span class="hljs-number">9</span> <span class="hljs-number">12</span> <span class="hljs-number">15</span>]<br> [<span class="hljs-number">36</span> <span class="hljs-number">39</span> <span class="hljs-number">42</span>]<br> [<span class="hljs-number">63</span> <span class="hljs-number">66</span> <span class="hljs-number">69</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># axis = 2</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(a, axis=<span class="hljs-number">2</span>))<br><br>---<br>[[ <span class="hljs-number">3</span> <span class="hljs-number">12</span> <span class="hljs-number">21</span>]<br> [<span class="hljs-number">30</span> <span class="hljs-number">39</span> <span class="hljs-number">48</span>]<br> [<span class="hljs-number">57</span> <span class="hljs-number">66</span> <span class="hljs-number">75</span>]]<br></code></pre></td></tr></table></figure><p>虽然最后相加之后得到的都是3X3的二维数组，但是计算结果大相径庭。我们就不一一分析，只拿计算结果的第一个数字来看，就能明白，其他数字都是一样的计算方法：</p><p><code>axis=0</code>,第一行的第一个数字得到过程为：<code>0+9+18</code>；</p><p><code>axis=1</code>, 第一行的第一个数字得到的过程为：<code>0+3+6</code>；</p><p><code>axis=2</code>,第一行的第一个数字得到的过程为:<code>0+1+2</code>；</p><p>那现在，我们是不是对于轴相加的计算过程就比较理解了？</p><p>最后总结一下，在计算的时候可以想象成是每一个坐标轴，分别计算这个轴上面的每一个刻度上的值，或者在二维数组中记住0表示列1表示行。</p><h3 id="索引和切片">索引和切片</h3><p>在学习Python基础课程的时候，我们应该已经了解过索引和切片的概念，在Numpy数组中这个概念也并无不同，一样也是开始值，结束值，步进值(<code>start:stop:step</code>)来进行切片操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>:<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>我们创建了一个一维数组，然后从索引2开始到索引7停止，间隔为2。</p><p>和Python中的下标索引方式相同，在这个以为数组中，我们使用<code>[2]</code>一样可以获取到下标为2的那个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a[<span class="hljs-number">2</span>], a)<br><br>---<br><span class="hljs-number">2</span> [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>还记得<code>[2:]</code>代表的含义吗？不太记得的话，我们来看看在Numpy的数组中操作会怎么样，其结果和Python对列表进行操作一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a[<span class="hljs-number">2</span>:])<br><br>---<br>[<span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>那以上这些操作我们都是对一维数组进行操作，大家可能还相对比较好理解。因为我们可以将其代入成一个Python列表，那对列表进行索引和切片的操作我们之前已经学过。</p><p>可是如果是多维数组进行操作，又和一维数组有什么不同呢？我们先来创建一个4行6列的二维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>然后我们现在来一样对其使用<code>[2]</code>来进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br></code></pre></td></tr></table></figure><p>是不是和一维数组不太一样？在<code>t1</code>数组中，我们打印的数据应该是它按行往下数第3行，那其实就是行下标的2,按行数从上往下数的下标分别为<code>[0, 1, 2]</code></p><p>那么我们如果使用切片的话，以这种方式去思考，应该是从当前下标的行往后取，对吧？对不对我们直接来试试就知道了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">2</span>:])<br><br>---<br>[[<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>这是从当前行开始向下连续取多行。</p><p>那如果是取中间的连续部分呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><br>---<br>[[ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]]<br></code></pre></td></tr></table></figure><p>这样，我们就取到了第二和第三行。</p><p>有的时候，我们可能需要隔行取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]])<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>我们现在是知道了如何按行来获取数组中的数据，同样，我们还可以按列来获取。</p><p>在学习如何按列获取数据之前，我们先来看看如何获取到某行某列的那单个数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><br>---<br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>这样，表示的意思就是第二行第三列，我们如愿取到了15这个值。</p><p>而从这种方式我们基本就可以看的出来，在获取数据的时候，我们用到了<code>[axis1,axis0]</code>这样的形式去准确的定位。知道了这个，就简单了。</p><p>既然<code>,</code>号之前的数值代表行下标，那<code>,</code>之后的数值应该就是列下标。一样，从0开始。和取行不同的地方在于，我们在取行的时候可以在<code>,</code>号之后加<code>:</code>这个符号来表示所有列，当然也可以不加，这是一种默认的方式。而取列的时候，我们必须在前面加上行的下标，如果是全取值，得加上<code>:</code>。</p><p>比方说，我们之前按行取值的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(t1[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,:])<br></code></pre></td></tr></table></figure><p>这两种方式实际上是一样的。因为默认方式列上<code>:</code>的取值方式。</p><p>就如我们刚才说到的，按列取值的时候，行就必须加上<code>:</code>才行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[,<span class="hljs-number">2</span>])<br><br>---<br>SyntaxError: invalid syntax<br></code></pre></td></tr></table></figure><p>看，报错了。我们只有在前面将取所有行加上才行，又或者加上某一行的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[:,<span class="hljs-number">2</span>])<br><br>---<br>[ <span class="hljs-number">2</span>  <span class="hljs-number">8</span> <span class="hljs-number">14</span> <span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><p>这样，我们就取到了第三列的值。</p><p>和取行一样，列也可以连续取值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[:, <span class="hljs-number">2</span>:])<br><br>---<br>[[ <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>我们如愿从第三列开始向后连续取值。</p><p>那如果是不连续的呢？也和行是一样的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[:,[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]])<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span>]]<br></code></pre></td></tr></table></figure><p>有没有发现，当我们了解了行列关系和取值方式代表的意义之后，那这个多维数组就任我们拿捏了。其原理显得非常简单。</p><p>好，让我们多加一个难度稍微高一点的取值，我们需要从行，从列都取不连续的值。那还不简单，不就是[[行,行,行...],[列,列,列...]]的方式吗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]])<br><br>---<br>[<span class="hljs-number">0</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>这，其实就是一种定点取值的方式了。</p><h3 id="修改数组的值">修改数组的值</h3><p>在了解完如何进行查询查找之后，我们现在在来学习一下如何对其中的值进行修改。在平时我们处理数据的时候，替换修改数值是常有的事情,我们每次修改之后，都会将之前的值复原。</p><p>我们从修改行的值开始，因为这个比较好理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改一行的值</span><br>t1[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>就是如此简单，定位好数值后，直接用<code>=</code>赋值就可以了。</p><p>那同理，修改某一列的数据也是如此操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t1[:,<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">0</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span>  <span class="hljs-number">0</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span>  <span class="hljs-number">0</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>修改连续多行和修改连续多列的方式也是一样，这次让我们来一次联动操作，将其中的连续多行多列一起修改掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t1[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>当然，既然可以连续多行多列进行修改，那我们肯定也能够进行定点修改值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t1[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>]] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">0</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>那基本上，如何按照行列寻找值并修改也就这么多内容，大家多操作完全可以轻易掌握。</p><p>别着急，还没结束，按行按列并不能完全满足我们平时的要求，有的时候，我们是要对数值按条件进行修改的。打个比方说，我们需要对所有大于2小于12的值进行修改，那么这又该如何实现？总不会在数组中可以用比较运算符来判断吧？嗯，没错，就是要用比较运算符符来判断，完全可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t1[<span class="hljs-number">2</span>&lt;t1 <span class="hljs-keyword">and</span> t1&lt;<span class="hljs-number">12</span>] = <span class="hljs-number">0</span><br><br>---<br>ValueError: The truth value of an array <span class="hljs-keyword">with</span> more than one element <span class="hljs-keyword">is</span> ambiguous. Use a.<span class="hljs-built_in">any</span>() <span class="hljs-keyword">or</span> a.<span class="hljs-built_in">all</span>()<br></code></pre></td></tr></table></figure><p>报错了，怎么回事，不是说好的可以用比较运算符判断吗？</p><p>原因其实就是，我们不能使用<code>and</code>,<code>or</code>这样的方式，我们来改变一下逻辑运算符的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t1[(<span class="hljs-number">2</span>&lt;t1)&amp;(t1&lt;<span class="hljs-number">12</span>)] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br> [ <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>成功了，从3到11我们全部替换成了0。</p><p>其实，在NumPy中，也有相应的方法名来替代<code>&amp;, |, ~</code>这种逻辑运算符，我们来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>t1[(np.logical_and(t1&gt;<span class="hljs-number">2</span>, t1&lt;<span class="hljs-number">12</span>))] = <span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(t1)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br> [ <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>这就是在NumPy中特殊的逻辑运算方法。「与、或、非」对应的方法如下：</p><ul><li><code>np.logical_and</code>: 与<code>&amp;</code></li><li><code>np.logical_or</code>: 或<code>|</code></li><li><code>np.logical_not</code>: 非<code>~</code></li></ul><p>大家可以依次去试试，我这里另外给大家拓展一个方式,就是三目运算方式，这种方式在今后的数据处理中，我们会经常看到，其形式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">三目运算 np.where(condition, x, y)，满足条件(condition)输出x, 不满足输出y<br></code></pre></td></tr></table></figure><p>我们来看个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">score = np.array([[<span class="hljs-number">80</span>,<span class="hljs-number">88</span>],[<span class="hljs-number">82</span>,<span class="hljs-number">81</span>],[<span class="hljs-number">75</span>,<span class="hljs-number">81</span>]])<br>result = np.where(score&gt;<span class="hljs-number">80</span>, <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[[<span class="hljs-literal">False</span>  <span class="hljs-literal">True</span>]<br> [ <span class="hljs-literal">True</span>  <span class="hljs-literal">True</span>]<br> [<span class="hljs-literal">False</span>  <span class="hljs-literal">True</span>]]<br></code></pre></td></tr></table></figure><p>在我们平时处理数据的过程当中，数据并不是如此完美，除了修改之外，更多的时候是需要我们去添加、删除以及去重。接下来，就让我们看看这部分该如何操作：</p><p><strong>数组的添加</strong></p><p><code>numpy.append</code>函数在数组的末尾添加值。追加操作会分配整个数组，并把原来的数组复制到新数组中。此外，输入数组的维度必须匹配否则将生成ValueError。</p><p>在其中的参数意义如下：</p><p><code>arr</code>: 输入数组</p><p><code>values</code>：要向arr添加的值，需要和arr形状相同（除了要添加的轴）。</p><p><code>axis</code>：默认为None。当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为0和1的时候。当axis有定义的时候，分别为0和1的时候（列数要相同）。当axis为1时，数组是加在右边（行数要相同）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数组的添加</span><br>a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个数组:\n<span class="hljs-subst">&#123;a&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;向数组添加元素:\n<span class="hljs-subst">&#123;np.append(a, [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>])&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;沿轴0添加元素:\n<span class="hljs-subst">&#123;np.append(a, [[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]], axis=<span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;沿轴1添加元素:\n<span class="hljs-subst">&#123;np.append(a, [[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]], axis=<span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><br>---<br>第一个数组:<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br><br>向数组添加元素:<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]<br><br>沿轴<span class="hljs-number">0</span>添加元素:<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br> [<span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]<br><br>沿轴<span class="hljs-number">1</span>添加元素:<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span>]<br> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]]<br></code></pre></td></tr></table></figure><p>除了<code>append</code>之外，我们还可以使用<code>insert</code>进行添加。</p><p><code>numpy.insert</code>：函数在给定索引之前，沿给定轴在输入数组中插入值。如果值的类型转换为要插入，则它与输入数组不同。插入没有原地的，函数会返回一个新数组。此外，如果未提供轴，则输入数组会被展开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个数组:\n<span class="hljs-subst">&#123;a&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;未传递Axis参数,在插入之前输入数组会被展开:\n<span class="hljs-subst">&#123;np.insert(a,<span class="hljs-number">3</span>,[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>])&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n传递了Axis参数,会广播值数组来配输入数组&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;沿轴0广播:\n<span class="hljs-subst">&#123;np.insert(a,<span class="hljs-number">1</span>,[<span class="hljs-number">11</span>], axis=<span class="hljs-number">0</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;沿轴1广播:\n<span class="hljs-subst">&#123;np.insert(a,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>, axis=<span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><br>---<br>第一个数组:<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br><br>未传递Axis参数,在插入之前输入数组会被展开:<br>[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]<br><br><br>传递了Axis参数,会广播值数组来配输入数组<br>沿轴<span class="hljs-number">0</span>广播:<br>[[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>]<br> [<span class="hljs-number">11</span> <span class="hljs-number">11</span>]<br> [ <span class="hljs-number">3</span>  <span class="hljs-number">4</span>]<br> [ <span class="hljs-number">5</span>  <span class="hljs-number">6</span>]]<br><br>沿轴<span class="hljs-number">1</span>广播:<br>[[ <span class="hljs-number">1</span> <span class="hljs-number">11</span>  <span class="hljs-number">2</span>]<br> [ <span class="hljs-number">3</span> <span class="hljs-number">11</span>  <span class="hljs-number">4</span>]<br> [ <span class="hljs-number">5</span> <span class="hljs-number">11</span>  <span class="hljs-number">6</span>]]<br></code></pre></td></tr></table></figure><p>从代码中我们可以看出来，<code>insert</code>相比较而言在<code>arr</code>和<code>values</code>之间多了一个形参，用于指示插入数据的下标位置。</p><p>接着，我们来看看如何在数组中操作删除。</p><p><code>npmpy.delete</code>:函数返回从输入数组中删除指定子数组的新数组。 与<code>insert()</code>函数的情况一样，如果未提供轴参数，则输入数组将展开。</p><p>参数说明：</p><p><code>arr</code>：输入数组</p><p><code>obj</code>：可以被切片，整数或者整数数组，表明要从输入数组删除的子数组</p><p><code>axis</code>：沿着它删除给定子数组的轴，如果未提供，则输入数组会被展开。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个数组:\n<span class="hljs-subst">&#123;a&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;未传递Axis参数。在删除之前输入数组会被展开:\n<span class="hljs-subst">&#123;np.delete(a, <span class="hljs-number">5</span>)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;删除每一行中的第二列：\n<span class="hljs-subst">&#123;np.delete(a,<span class="hljs-number">1</span>,axis=<span class="hljs-number">1</span>)&#125;</span>\n&#x27;</span>)<br><br>---<br>第一个数组:<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br><br>未传递Axis参数。在删除之前输入数组会被展开:<br>[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br><br>删除每一行中的第二列：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br> [ <span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><p>接下来，估计是我们清洗数据最常用到的操作，就是「去重」。</p><p><code>numpy.unique</code>: 函数用于去除数组中的重复元素。</p><p>参数说明：</p><p><code>arr</code>：输入数组，如果不是一维数组则会展开.</p><p><code>return_index</code>：如果为true，返回新列表元素在旧列表中的位置（下标），并以列表形式储.</p><p><code>return_inverse</code>：如果为true，返回旧列表元素在新列表中的位置（下标），并以列表形式储.</p><p><code>return_counts</code>：如果为true，返回去重数组中的元素在原数组中的出现次数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">7</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个数组:\n<span class="hljs-subst">&#123;a&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个数组的去重值：\n<span class="hljs-subst">&#123;np.unique(a)&#125;</span>\n&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;去重数组对应原数组的索引下标数组：&#x27;</span>)<br>u,indices = np.unique(a, return_index = <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(indices)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n我们可以看到每个和原数组下标对应的数值：&#x27;</span>)<br><span class="hljs-built_in">print</span>(u)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n原数组对应去重数组的下标数组：&#x27;</span>)<br>u,indices = np.unique(a, return_inverse = <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(u)<br><span class="hljs-built_in">print</span>(indices)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;\n返回去重元素的重复数量：&#x27;</span>)<br>u,indices = np.unique(a,return_counts = <span class="hljs-literal">True</span>) <br><span class="hljs-built_in">print</span> (u)<br><span class="hljs-built_in">print</span> (indices)<br><br>---<br>第一个数组:<br>[<span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">9</span>]<br><br>第一个数组的去重值：<br>[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]<br><br>去重数组对应原数组的索引下标数组：<br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span>]<br><br>我们可以看到每个和原数组下标对应的数值：<br>[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]<br><br>原数组对应去重数组的下标数组：<br>[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]<br>[<span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span>]<br><br>返回去重元素的重复数量：<br>[<span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]<br>[<span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>我用图形来解释一下「第一个数组的去重值」和「去重数组的索引数组」，至于其他的，也是类似的分析方式。</p><img src="/AI-Python-numpy/image-20230821223248026.png" class="" title="img"><p>在去重的方法中，我们都有两个变量去接收返回值，也就是方法返回了两个值，其中<code>u</code>这个变量就代表的是改变之后的数组，而<code>indices</code>则是重新组成的数组中的数值在原数组中第一次出现的下标位置，又或者是出现次数。以方法不同，但是<code>u</code>肯定是去重后的重新组成的数组。</p><p>我标识了一下原数组中的下标，并且用颜色区分了一下。在重新组成的去重的数组中，可以看到已经没有重复的数值了，然后对比原数组，每一个不重复的数值也都还在。而默认的排序方式就是从小到大的排序。所以重新组成的数值中的排序和原数组中不太一样。</p><p>然后我们再来看最下面「去重下标」部分，虽然这也是一个数组，但是实际上它是一个完全由下标位置组成的数组，然后我们来看去重数组，我们是拿第一次出现的下标来算。其中<code>2</code>对应原数组就的下标就是<code>1</code>，<code>5</code>第一次出现是<code>0</code>的位置，<code>6</code>是<code>2</code>,<code>7</code>是<code>4</code>，<code>9</code>这是最后一位，也就是下标<code>9</code>。</p><p>所以对重新组成的数组稍微一分析，就能明白每个方法的返回值说代表的意义。</p><p>相信到这里，大家应该也都能理解了。</p><p>接下来，我们要来看看重头戏，NumPy的计算。</p><h3 id="numpy的计算">NumPy的计算</h3><p>NumPy原本就是一个科学计算的第三方库，所以计算能力应该算是NumPy里的重点。在原始方法中，有许许多多的方法用于数据的计算。包括求最大值，求最小值，平均值，累计和等等。除了计算整体之外，还支持在不同轴上进行计算。下面我们来看看，NumPy到底为我们都提供了哪些好用的方法，最开始，还是让我们来生成一组新的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">score = np.array([[<span class="hljs-number">80</span>,<span class="hljs-number">88</span>],[<span class="hljs-number">82</span>,<span class="hljs-number">81</span>],[<span class="hljs-number">75</span>,<span class="hljs-number">81</span>]])<br>score<br><br>---<br>array([[<span class="hljs-number">80</span>, <span class="hljs-number">88</span>],<br>       [<span class="hljs-number">82</span>, <span class="hljs-number">81</span>],<br>       [<span class="hljs-number">75</span>, <span class="hljs-number">81</span>]])<br></code></pre></td></tr></table></figure><p><strong>获取所有数据最大值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.<span class="hljs-built_in">max</span>(score)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">88</span><br></code></pre></td></tr></table></figure><p><strong>获取某一个轴上的数据最大值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.<span class="hljs-built_in">max</span>(score,axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">82</span> <span class="hljs-number">88</span>]<br></code></pre></td></tr></table></figure><p><strong>获取最小值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.<span class="hljs-built_in">min</span>(score)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">75</span><br></code></pre></td></tr></table></figure><p><strong>获取某一个轴上的数据最小值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.<span class="hljs-built_in">min</span>(score,axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">80</span> <span class="hljs-number">81</span> <span class="hljs-number">75</span>]<br></code></pre></td></tr></table></figure><p><strong>数据的比较</strong></p><p>第一个参数中的每一个数与第二个参数比较返回大的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.maximum([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>第一个参数中的每一个数与第二个参数比较返回小的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.minimum([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[-<span class="hljs-number">2</span> -<span class="hljs-number">1</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>以上两组代码中，当方法内接受两个参数，当然也可以大小一致;当第二个参数只是一个单独的值时，其实是用到了维度的广播机制。如果第二个参数是一个同样长度的数组，会分别比较不同位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.maximum([-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]) <br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>咱们在这里稍微讲一下NumPy中的<strong>广播机制</strong>，其实是有点晦涩难懂。大家尝试理解一下看看。</p><p>广播机制是Numpy让两个不同shape的数组能够做一些运算，需要对参与运算的两个数组做一些处理或者说扩展，最终是参与运算的两个数组的shape一样，然后广播计算(对应位置数据进行某运算)得到结果。</p><p>以我们做数据比较的第一组为例，当我们去对比第一个参数和第二个参数返回大的，这个时候我们给到的两个参数分别是：</p><p><code>[-2,-1,0,1,2]</code>和<code>0</code>，但是由于广播机制的存在，在<code>NumPy</code>中实际上是这么处理的，第一个参数还是<code>[-2,-1,0,1,2]</code>，而第二个参数实际上是<code>[0,0,0,0,0]</code>。</p><p><strong>获取所有数据的平均值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.mean(score)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">81.16666666666667</span><br></code></pre></td></tr></table></figure><p><strong>获取某一行或一列的平均值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.mean(score, axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">79.</span>         <span class="hljs-number">83.33333333</span>]<br></code></pre></td></tr></table></figure><p><strong>返回给定<code>axis</code>上的累计和</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br><span class="hljs-built_in">print</span>(t1)<br><span class="hljs-built_in">print</span>(t1.cumsum(<span class="hljs-number">0</span>))<br><br>---<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br> [<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span>]]<br></code></pre></td></tr></table></figure><p>在来看值为<code>axis=1</code>时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t1.cumsum(<span class="hljs-number">1</span>))<br><br>---<br>[[ <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">9</span> <span class="hljs-number">15</span>]]<br></code></pre></td></tr></table></figure><p>我们可以这样认为，当<code>cumsum(0)</code>，也就是<code>axis=0</code>时，是这样计算的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-punctuation">]</span> --------&gt; |<span class="hljs-number">1</span>  |<span class="hljs-number">2</span> |<span class="hljs-number">3</span>|<br><span class="hljs-punctuation">[</span><span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span><span class="hljs-punctuation">]</span> --------&gt; |<span class="hljs-number">5</span>=<span class="hljs-number">1</span>+<span class="hljs-number">4</span> |<span class="hljs-number">7</span>=<span class="hljs-number">2</span>+<span class="hljs-number">5</span> |<span class="hljs-number">9</span>=<span class="hljs-number">3</span>+<span class="hljs-number">6</span>|<br></code></pre></td></tr></table></figure><p>当<code>cumsum(1)</code>，也就是<code>axis=1</code>时，是这样计算的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[ <span class="hljs-number">1</span>  <span class="hljs-number">3</span>  <span class="hljs-number">6</span>] ------&gt; |<span class="hljs-number">1</span>|<span class="hljs-number">3</span>=<span class="hljs-number">2</span>+<span class="hljs-number">1</span>|<span class="hljs-number">6</span>=<span class="hljs-number">3</span>+<span class="hljs-number">2</span>+<span class="hljs-number">1</span>|<br>[ <span class="hljs-number">4</span>  <span class="hljs-number">9</span> <span class="hljs-number">15</span>] ------&gt; |<span class="hljs-number">4</span>|<span class="hljs-number">9</span>=<span class="hljs-number">4</span>+<span class="hljs-number">5</span>|<span class="hljs-number">15</span>=<span class="hljs-number">4</span>+<span class="hljs-number">5</span>+<span class="hljs-number">6</span>|<br></code></pre></td></tr></table></figure><p><strong><code>argmin</code>求最小值索引</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.argmin(score, axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">2</span> <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>我们看<code>score</code>这组数据中，<code>75</code>是第一列最小值，<code>81</code>是第二列最小值。当然，第二列的数据中有两个<code>81</code>。现在让我们讲数组的值换一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">score[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] = <span class="hljs-number">64</span><br>result = np.argmin(score, axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[<span class="hljs-number">2</span> <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>很显然，我们第二列的最小值变成了<code>64</code>，在那一列中，它的坐标为<code>2</code>。</p><p><strong>求每一列的标准差</strong></p><p>标准差是一组数据平均值分散程度的一种度量。一个较大的标准差，代表大部分数值和其平均值之间差异较大；一个较小的标准差，代表这些数据较接近平均值反应出数据的波动稳定情况，越大表示波动越大，越不稳定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.std(score, axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[ <span class="hljs-number">2.94392029</span> <span class="hljs-number">10.07747764</span>]<br></code></pre></td></tr></table></figure><p>从结果中可以看出来，我们第二列的波动较大。其原因正是因为我把<code>[2,2]</code>这个位置的值替换成了<code>64</code>。和其他值拉大了差距。</p><p><strong>极值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.ptp(score,axis=<span class="hljs-literal">None</span>) <br><span class="hljs-built_in">print</span>(result)<br><br>---<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>计算极值，其实也就是最大值和最小值的差。在<code>score</code>中，最大值为<code>88</code>，最小值为<code>64</code>。</p><p>除了我们目前测试的这些方法之外，NumPy中还有很多其他方法。比如，计算反差的<code>var</code>，协方差<code>cov</code>，平均值<code>average</code>，中位数<code>median</code>。在这里，我们就不一一测试了，方法都比较简单，拿来直接用的那种。</p><p>我将通用函数和解释在这里列一个表：</p><table><colgroup><col style="width: 57%" /><col style="width: 42%" /></colgroup><thead><tr class="header"><th>通用函数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td>numpy.sqrt(array)</td><td>平方根函数</td></tr><tr class="even"><td>numpy.exp(array)</td><td>e^array[i]的数组</td></tr><tr class="odd"><td>numpy.abs/fabs(array)</td><td>计算绝对值</td></tr><tr class="even"><td>numpy.square(array)</td><td>计算各元素的平方 等于 array**2</td></tr><tr class="odd"><td>numpy.log/log10/log2(array)</td><td>计算各元素的各种对数</td></tr><tr class="even"><td>numpy.sign(array)</td><td>计算各元素正负号</td></tr><tr class="odd"><td>numpy.isnan(array</td><td>计算各元素是否为NaN</td></tr><tr class="even"><td>numpy.isinf(array)</td><td>计算各元素是否为NaN</td></tr><tr class="odd"><td>numpy.cos/cosh/sin/sinh/tan/tanh(array)</td><td>三角函数</td></tr><tr class="even"><td>numpy.modf(array)</td><td>将array中值得整数和小数 分离，作两个数组返回</td></tr><tr class="odd"><td>numpy.ceil(array)</td><td>向上取整,也就是取比这个 数大的整数</td></tr><tr class="even"><td>numpy.ﬂoor(array)</td><td>向下取整,也就是取比这个 数小的整数</td></tr><tr class="odd"><td>numpy.rint(array)</td><td>四舍五入</td></tr><tr class="even"><td>numpy.trunc(array)</td><td>向0取整</td></tr><tr class="odd"><td>numpy.cos(array)</td><td>正弦值</td></tr><tr class="even"><td>numpy.sin(array)</td><td>余弦值</td></tr><tr class="odd"><td>numpy.tan(array)</td><td>正切值</td></tr><tr class="even"><td>numpy.add(array1,array2)</td><td>元素级加法</td></tr><tr class="odd"><td>numpy.subtract(array1,array2)</td><td>元素级减法</td></tr><tr class="even"><td>numpy.multiply(array1,array2)</td><td>元素级乘法</td></tr><tr class="odd"><td>numpy.divide(array1,array2)</td><td>元素级除法 array1./array2</td></tr><tr class="even"><td>numpy.power(array1,array2)</td><td>元素级指数 array1.^array2</td></tr><tr class="odd"><td>numpy.maximum/minimum(array1,aray2)</td><td>元素级最大值</td></tr><tr class="even"><td>numpy.fmax/fmin(array1,array2)</td><td>元素级最大值，忽略NaN</td></tr><tr class="odd"><td>numpy.mod(array1,array2)</td><td>元素级求模</td></tr><tr class="even"><td>numpy.copysign(array1,array2)</td><td>将第二个数组中值得符号复 制给第一个数组中值</td></tr><tr class="odd"><td>numpy.greater/greater_equal/less/less_equal/equal/not_equal(array1,array2)</td><td>元素级比较运算，产生布尔 数组</td></tr><tr class="even"><td>numpy.logical_end/logical_or/logic_xor(array1,array2)</td><td>元素级的真值逻辑运算</td></tr></tbody></table><h3 id="数组的拼接">数组的拼接</h3><p>有的时候我们需要将两个数据加起来一起研究分析，我们就可以将其进行拼接然后分析。</p><p>我们先创建两组数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]])<br>b = np.array([[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]])<br></code></pre></td></tr></table></figure><p>然后我们现在先<strong>根据轴连接的数组序列</strong></p><p>先沿轴0连接两个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.concatenate((a,b), axis=<span class="hljs-number">0</span>))<br><br>---<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br> [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br> [<span class="hljs-number">7</span> <span class="hljs-number">8</span>]]<br></code></pre></td></tr></table></figure><p>再沿轴1连接两个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.concatenate((a,b), axis=<span class="hljs-number">1</span>))<br><br>---<br>[[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br> [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>]]<br></code></pre></td></tr></table></figure><p><strong>根据轴进行堆叠</strong></p><p>沿轴0堆叠两个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.stack((a,b), axis=<span class="hljs-number">0</span>))<br><br>---<br>[[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br>  [<span class="hljs-number">3</span> <span class="hljs-number">4</span>]]<br><br> [[<span class="hljs-number">5</span> <span class="hljs-number">6</span>]<br>  [<span class="hljs-number">7</span> <span class="hljs-number">8</span>]]]<br></code></pre></td></tr></table></figure><p>沿轴1堆叠两个数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.stack((a,b), axis=<span class="hljs-number">1</span>))<br><br>---<br>[[[<span class="hljs-number">1</span> <span class="hljs-number">2</span>]<br>  [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]]<br><br> [[<span class="hljs-number">3</span> <span class="hljs-number">4</span>]<br>  [<span class="hljs-number">7</span> <span class="hljs-number">8</span>]]]<br></code></pre></td></tr></table></figure><p><strong>矩阵垂直拼接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">v1 = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], [<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]]<br>v2 = [[<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>],[<span class="hljs-number">18</span>,<span class="hljs-number">19</span>,<span class="hljs-number">20</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>]]<br>result = np.vstack((v1, v2))<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p><strong>矩阵水平拼接</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">result = np.hstack((v1, v2))<br><span class="hljs-built_in">print</span>(result)<br><br>---<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><h3 id="数组的分割">数组的分割</h3><p><strong>将一个数组分割为多个子数组</strong></p><p>参数说明：</p><p><code>ary</code>：被分割的数组</p><p><code>indices_or_sections</code>：果是一个整数，就用该数平均切分，如果是一个数组，为沿轴切分的位置（左开右闭）</p><p><code>axis</code>：沿着哪个维度进行切向，默认为0，横向切分。为1时，纵向切分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;将数组分成三个大小相等的子数组：&#x27;</span>)<br>b = np.split(arr,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(b)<br><br>---<br>将数组分成三个大小相等的子数组：<br>[array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]]), array([[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]), array([[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])]<br></code></pre></td></tr></table></figure><p><code>numpy.hsplit</code>函数用于水平分割数组，通过指定要返回的相同形状的数组数量来拆分原数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">harr = np.floor(<span class="hljs-number">10</span> * np.random.random((<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;原array:\n<span class="hljs-subst">&#123;harr&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\n水平分割后:\n<span class="hljs-subst">&#123;np.hsplit(harr, <span class="hljs-number">3</span>)&#125;</span>&#x27;</span>)<br><br>---<br>原array:<br>[[<span class="hljs-number">1.</span> <span class="hljs-number">1.</span> <span class="hljs-number">8.</span> <span class="hljs-number">2.</span> <span class="hljs-number">3.</span> <span class="hljs-number">9.</span>]<br> [<span class="hljs-number">3.</span> <span class="hljs-number">1.</span> <span class="hljs-number">6.</span> <span class="hljs-number">6.</span> <span class="hljs-number">5.</span> <span class="hljs-number">6.</span>]]<br><br>水平分割后:<br>[array([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],<br>       [<span class="hljs-number">3.</span>, <span class="hljs-number">1.</span>]]), array([[<span class="hljs-number">8.</span>, <span class="hljs-number">2.</span>],<br>       [<span class="hljs-number">6.</span>, <span class="hljs-number">6.</span>]]), array([[<span class="hljs-number">3.</span>, <span class="hljs-number">9.</span>],<br>       [<span class="hljs-number">5.</span>, <span class="hljs-number">6.</span>]])]<br></code></pre></td></tr></table></figure><p>这里我们说一下<code>floor()</code>,这个方法会返回数值的下舍整数（舍去小数点求整型）。</p><p><code>numpy.vsplit</code>会沿垂直轴分割</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">16</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个数组：\n<span class="hljs-subst">&#123;a&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\n垂直分割之后：\n<span class="hljs-subst">&#123;np.vsplit(a,<span class="hljs-number">2</span>)&#125;</span>&#x27;</span>)<br><br>---<br>第一个数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span>]]<br><br>垂直分割之后：<br>[array([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]]), array([[ <span class="hljs-number">8</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>],<br>       [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]])]<br></code></pre></td></tr></table></figure><h3id="nan和inf"><strong><code>nan</code>和<code>inf</code></strong></h3><p>C语言中表示最大的正整数值是<code>0x7FFFFFFF</code>，最小的负整数是<code>0x80000000</code>。<code>inf</code>表示无穷大，需要使用 <code>ﬂoat(‘inf’)</code>函数来转化，那么对应的就有<code>ﬂoat('-inf')</code>表示无穷小了。这样你就可以使用任意数来判断和它的关系了。</p><p>那什么时候会出现<code>inf</code>呢？比如一个数字除以<code>0</code>，Python中会报错，但是numpy中会是一个<code>inf</code>或者<code>-inf</code></p><p>另外还有<code>nan</code>，这种写法在<code>pandas</code>中常见，表示缺失的数据，所以一般用<code>nan</code>来表示。任何与其做运算结果都是<code>nan</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.nan<br>b = np.inf<br><span class="hljs-built_in">print</span>(a, <span class="hljs-built_in">type</span>(a))<br><span class="hljs-built_in">print</span>(b, <span class="hljs-built_in">type</span>(b))<br><br>---<br>nan &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br>inf &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>判断数组中为<code>nan</code>的个数(注意：float类型的数据才能赋值<code>nan</code>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">t = np.arange(<span class="hljs-number">24</span>,dtype=<span class="hljs-built_in">float</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>可以使用<code>np.count_nonzero()</code>来判断非零的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.count_nonzero(t))<br><br>---<br><span class="hljs-number">23</span><br></code></pre></td></tr></table></figure><p>将三行四列的数改成nan</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">t[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] = np.nan<br><span class="hljs-built_in">print</span>(t[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] != np.nan)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>注意到没有，<code>np.nan != np.nan</code>居然是<code>True</code>。难道我们更改数据失败了？我们打出来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(t)<br><br>---<br>[[ <span class="hljs-number">0.</span>  <span class="hljs-number">1.</span>  <span class="hljs-number">2.</span>  <span class="hljs-number">3.</span>  <span class="hljs-number">4.</span>  <span class="hljs-number">5.</span>]<br> [ <span class="hljs-number">6.</span>  <span class="hljs-number">7.</span>  <span class="hljs-number">8.</span>  <span class="hljs-number">9.</span> <span class="hljs-number">10.</span> <span class="hljs-number">11.</span>]<br> [<span class="hljs-number">12.</span> <span class="hljs-number">13.</span> <span class="hljs-number">14.</span> <span class="hljs-number">15.</span> <span class="hljs-number">16.</span> <span class="hljs-number">17.</span>]<br> [<span class="hljs-number">18.</span> <span class="hljs-number">19.</span> <span class="hljs-number">20.</span> <span class="hljs-number">21.</span> nan <span class="hljs-number">23.</span>]]<br></code></pre></td></tr></table></figure><p>没错，<code>t[3,4]</code>确实被改变了，那只能说明<code>np.nan != np.nan</code>是确实存在的。</p><p>所以，我们就可以使用这两个结合使用判断<code>nan</code>的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.count_nonzero(t != t))<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>我们之前讲过，<code>nan</code>和任何数计算都为<code>nan</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(t,axis=<span class="hljs-number">0</span>))<br><br>---<br>[<span class="hljs-number">36.</span> <span class="hljs-number">40.</span> <span class="hljs-number">44.</span> <span class="hljs-number">48.</span> nan <span class="hljs-number">56.</span>]<br></code></pre></td></tr></table></figure><p>接下来，让我们做一个具体的练习，在练习中，我们将处理数组中的<code>nan</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 练习，处理数组中的nan</span><br>t = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>).astype(<span class="hljs-string">&#x27;float&#x27;</span>)<br><br><span class="hljs-comment"># 将数组中的一部分替换nan</span><br>t[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>:] = np.nan<br><span class="hljs-built_in">print</span>(t)<br><br>---<br>[[ <span class="hljs-number">0.</span>  <span class="hljs-number">1.</span>  <span class="hljs-number">2.</span>  <span class="hljs-number">3.</span>  <span class="hljs-number">4.</span>  <span class="hljs-number">5.</span>]<br> [ <span class="hljs-number">6.</span>  <span class="hljs-number">7.</span>  <span class="hljs-number">8.</span> nan nan nan]<br> [<span class="hljs-number">12.</span> <span class="hljs-number">13.</span> <span class="hljs-number">14.</span> <span class="hljs-number">15.</span> <span class="hljs-number">16.</span> <span class="hljs-number">17.</span>]<br> [<span class="hljs-number">18.</span> <span class="hljs-number">19.</span> <span class="hljs-number">20.</span> <span class="hljs-number">21.</span> <span class="hljs-number">22.</span> <span class="hljs-number">23.</span>]]<br></code></pre></td></tr></table></figure><p>现在我们得到了一组包含<code>nan</code>的数组，接着我们来处理这组数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试便利每一列，然后判断每一列是否有`nan`</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t.shape[<span class="hljs-number">1</span>]):<br>    <span class="hljs-comment"># 获取当前列数据</span><br>    temp_col = t[:, i]<br>    <span class="hljs-comment"># 判断当前列的数据中是否含有nan</span><br>    nan_num = np.count_nonzero(temp_col != temp_col)<br><br>    <span class="hljs-comment"># 条件成立说明含有nan</span><br>    <span class="hljs-keyword">if</span> nan_num != <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 将这一列部位nan的数据拿出来</span><br>        temp_col_not_nan = temp_col[temp_col == temp_col]<br><br>        <span class="hljs-comment"># 将nan替换成这一列的平均值</span><br>        temp_col[np.isnan(temp_col)] = np.mean(temp_col_not_nan)<br><br><span class="hljs-built_in">print</span>(t)<br><br>---<br>[[ <span class="hljs-number">0.</span>  <span class="hljs-number">1.</span>  <span class="hljs-number">2.</span>  <span class="hljs-number">3.</span>  <span class="hljs-number">4.</span>  <span class="hljs-number">5.</span>]<br> [ <span class="hljs-number">6.</span>  <span class="hljs-number">7.</span>  <span class="hljs-number">8.</span> <span class="hljs-number">13.</span> <span class="hljs-number">14.</span> <span class="hljs-number">15.</span>]<br> [<span class="hljs-number">12.</span> <span class="hljs-number">13.</span> <span class="hljs-number">14.</span> <span class="hljs-number">15.</span> <span class="hljs-number">16.</span> <span class="hljs-number">17.</span>]<br> [<span class="hljs-number">18.</span> <span class="hljs-number">19.</span> <span class="hljs-number">20.</span> <span class="hljs-number">21.</span> <span class="hljs-number">22.</span> <span class="hljs-number">23.</span>]]<br></code></pre></td></tr></table></figure><p>这样，我们就处理了这组数据中的<code>nan</code>，至于替换成平均值填补空缺数据，这个是清洗数据的通用做法。</p><h3 id="二维数组的转置">二维数组的转置</h3><p>针对二维数组的转置，也就是对换数组的维度。说的直白一点，就是行转列，列转行。</p><p>这在处理数据的时候，也是我们经常要做的操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">f&#x27;原数组：\n<span class="hljs-subst">&#123;a&#125;</span>&#x27;</span>) <br><span class="hljs-built_in">print</span> (<span class="hljs-string">f&#x27;\n对换数组：\n<span class="hljs-subst">&#123;np.transpose(a)&#125;</span>&#x27;</span>) <br><br>---<br>原数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br><br>对换数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">4</span>  <span class="hljs-number">8</span>]<br> [ <span class="hljs-number">1</span>  <span class="hljs-number">5</span>  <span class="hljs-number">9</span>]<br> [ <span class="hljs-number">2</span>  <span class="hljs-number">6</span> <span class="hljs-number">10</span>]<br> [ <span class="hljs-number">3</span>  <span class="hljs-number">7</span> <span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><p>让我们再来看一种处理方式，与<code>transpose</code>方法一致：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">f&#x27;原数组：\n<span class="hljs-subst">&#123;a&#125;</span>&#x27;</span>) <br><span class="hljs-built_in">print</span> (<span class="hljs-string">f&#x27;\n转置数组：\n<span class="hljs-subst">&#123;a.T&#125;</span>&#x27;</span>) <br><br>---<br>原数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [ <span class="hljs-number">4</span>  <span class="hljs-number">5</span>  <span class="hljs-number">6</span>  <span class="hljs-number">7</span>]<br> [ <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]]<br><br>转置数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">4</span>  <span class="hljs-number">8</span>]<br> [ <span class="hljs-number">1</span>  <span class="hljs-number">5</span>  <span class="hljs-number">9</span>]<br> [ <span class="hljs-number">2</span>  <span class="hljs-number">6</span> <span class="hljs-number">10</span>]<br> [ <span class="hljs-number">3</span>  <span class="hljs-number">7</span> <span class="hljs-number">11</span>]]<br></code></pre></td></tr></table></figure><p>接着我们尝试一个函数用于交换数组的两个轴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">t1 = np.arange(<span class="hljs-number">24</span>).reshape(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>)<br>re = t1.swapaxes(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span> (<span class="hljs-string">f&#x27;\n原数组：\n<span class="hljs-subst">&#123;t1&#125;</span>&#x27;</span>) <br><span class="hljs-built_in">print</span> (<span class="hljs-string">f&#x27;\n调用 swapaxes 函数后的数组：\n<span class="hljs-subst">&#123;re&#125;</span>&#x27;</span>) <br><br>---<br><br>原数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>  <span class="hljs-number">4</span>  <span class="hljs-number">5</span>]<br> [ <span class="hljs-number">6</span>  <span class="hljs-number">7</span>  <span class="hljs-number">8</span>  <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>]<br> [<span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span>]<br> [<span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span>]]<br><br>调用 swapaxes 函数后的数组：<br>[[ <span class="hljs-number">0</span>  <span class="hljs-number">6</span> <span class="hljs-number">12</span> <span class="hljs-number">18</span>]<br> [ <span class="hljs-number">1</span>  <span class="hljs-number">7</span> <span class="hljs-number">13</span> <span class="hljs-number">19</span>]<br> [ <span class="hljs-number">2</span>  <span class="hljs-number">8</span> <span class="hljs-number">14</span> <span class="hljs-number">20</span>]<br> [ <span class="hljs-number">3</span>  <span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">21</span>]<br> [ <span class="hljs-number">4</span> <span class="hljs-number">10</span> <span class="hljs-number">16</span> <span class="hljs-number">22</span>]<br> [ <span class="hljs-number">5</span> <span class="hljs-number">11</span> <span class="hljs-number">17</span> <span class="hljs-number">23</span>]]<br></code></pre></td></tr></table></figure><p>这几种方式都完成了转置操作，平时工作中，我们可以都尝试一下。</p><h2 id="总结">总结</h2><p>最后，我们还是对NumPy整个的做一个总结：</p><img src="/AI-Python-numpy/numpy.png" class="" title="img"><p>然后，让我们留点作业吧：</p><ol type="1"><li>练习矩阵相乘</li><li>练习数组索引</li><li>练习数组形状修改</li></ol><p>大家要好好的完成作业。那本节课就到这里了，下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/AI-Python-numpy/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>25. matplotlib</title>
    <link href="https://hivan.me/AI-Python-matplotlib/"/>
    <id>https://hivan.me/AI-Python-matplotlib/</id>
    <published>2023-08-19T12:42:01.000Z</published>
    <updated>2023-08-20T11:33:07.096Z</updated>
    
    <content type="html"><![CDATA[<img src="/AI-Python-matplotlib/cover.png" class="" title="img"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>在上一节课中，我们结束了Python正式的所有内容，但是咱们的Python课程还未结束。从这节课开始，我们要来学习一下Python的第三方库。</p><p>Python的生态非常完善也非常活跃，我们不太可能讲目前所有的第三方库全部都介绍一遍，只介绍几个有影响力并且和处理数据相关的。那今天第一Part，我们就先来学习<code>matplotlib</code>。</p><p>在之后的课程中，Python的基础理论我就不会细讲了，咱们重点是要快速的认识和学会第三方库。有什么语法上的问题，可以翻看前面几节的教程。</p><h2 id="matplotlib是什么">matplotlib是什么？</h2><img src="/AI-Python-matplotlib/image-20230819204937166.png" class="" title="img"><p>Matplotlib是一个Python2D绘图库，它可以在各种平台上以各种硬拷贝格式和交互式环境生成出具有出版品质的图形。 Matplotlib可用于Python脚本，Python和IPythonshell，Jupyter笔记本，Web应用 程序服务器和四个图形用户界面工具包。</p><p>Matplotlib试图让简单的事情变得更简单，让无法实现的事情变得可能实现。只需几行代码即可生成绘图，直方图，功率谱，条形图，错误图，散点图等。</p><p>为了简单绘图，pyplot模块提供了类似于MATLAB的界面，特别是与IPython结合使用时。对于高级用户，您可以通过面向对象的界面或MATLAB用户熟悉的一组函数完全控制线条样式，字体属性，轴属性等。</p><p>那么，我们<strong>为什么要学习matplotlib</strong>呢？</p><p>可视化是在整个数据挖掘的关键辅助工具，可以清晰的理解数据，从而调整我们的分析方法。</p><p>能将数据进行可视化,更直观的呈现 使数据更加客观、更具说服力</p><p>例如下面两个图为数字展示和图形展示：</p><img src="/AI-Python-matplotlib/image-20230819205308459.png" class="" title="img"><p>以上两个图形中，第一组是完全的数据。我们基本很难看出这组数据到底谁大谁小，当然，从位数上我们还是可以比较容易辨认，但是比起第二张图呢？是不是第二张图就非常清晰的展示了数据的大小，一目了然？</p><p>那既然我们要学习的是数据可视化，我们首先要做的，必定是要先了解一下常见数据图表，知道其种类和意义。</p><h2 id="常见图形种类及意义">常见图形种类及意义</h2><p>我们首先要先了解具体的图形，才能知道我们在什么情况下使用什么图形来表示。</p><ul><li>折线图：以折线的上升或下降来表示统计数量的增减变化的统计图。特点是：<strong>能够显示数据的变化趋势，反映事物的变化情况。(变化)</strong></li></ul><img src="/AI-Python-matplotlib/image-20230819205608633.png" class="" title="img"><ul><li>散点图：用两组数据构成多个坐标点，考察坐标点的分布,判断两变量之间是否存在某种关联或总结坐标点的分布模式。特点是：<strong>判断变量之间是否存在数量关联趋势,展示离群点(分布规律)</strong></li></ul><img src="/AI-Python-matplotlib/image-20230819205934703.png" class="" title="img"><ul><li>柱状图：排列在工作表的列或行中的数据可以绘制到柱状图中。特点是：<strong>绘制连离散的数据,能够一眼看出各个数据的大小,比较数据之间的差别。(统计/对比)</strong></li></ul><img src="/AI-Python-matplotlib/image-20230819210021816.png" class="" title="img"><ul><li>直方图：由一系列高度不等的纵向条纹或线段表示数据分布的情况。一般用横轴表示数据范围，纵轴表示分布情况。特点是：<strong>绘制连续性的数据展示一组或者多组数据的分布状况(统计)</strong></li></ul><img src="/AI-Python-matplotlib/image-20230819210324955.png" class="" title="img"><ul><li>饼图：用于表示不同分类的占比情况，通过弧度大小来对比各种分类。特点是：<strong>分类数据的占比情况(占比)。</strong></li></ul><img src="/AI-Python-matplotlib/image-20230819210438887.png" class="" title="img"><h2 id="matplotlib画图实现">matplotlib画图实现</h2><p>首先我们要知道，Python的第三方库几乎全部都需要额外安装才行。我们之前在讲Python环境的时候有提到如何创建虚拟环境以及如何安装第三方库。那我们现在，就来直接安装一下，还记得么？我用的环境是<code>conda</code>，所以我的安装命令都是使用<code>conda</code>的，不过你将其咱们课程中还是要使用最普遍的方式，所以以下我都会替换成<code>pip</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install motplotlib<br></code></pre></td></tr></table></figure><p>执行完毕后，<code>motplotlib</code>就安装到您的Python环境内了。</p><p>建议在Python环境内安装好Jupyter来进行学习，你会发现简直太方便了。如果是在Jupyter内，那么会在代码执行之后的下方直接显示出结果，而如果我们是使用<code>python xx.py</code>来执行，那Python会调用内部的绘图器来进行显示。</p><p><strong>Jupyter for vscode</strong></p><img src="/AI-Python-matplotlib/image-20230819211528967.png" class="" title="img"><p><strong>Python绘图器</strong></p><img src="/AI-Python-matplotlib/image-20230819211619014.png" class="" title="img"><p>当然，你也可以自己在命令行内起一个<code>Jupyter notebook</code>服务，那就可以直接在浏览器上进行操作了。</p><p><strong>Jupyter Notebook</strong></p><img src="/AI-Python-matplotlib/image-20230819212226663.png" class="" title="img"><p>当然几种方法中，我还是最推崇在VSCode中进行。毕竟我们还是需要代码提示的。</p><p>在正式开始之前，让我们对matplotlib的图像结构建立一个认识：</p><img src="/AI-Python-matplotlib/image-20230819212541651.png" class="" title="img"><p>现在让我们来具体的实现一下，做一个简单的图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入模块</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># 这段代码会让之后的代码在Jupyter内执行的时候显示图片</span><br>%matplotlib inline<br><span class="hljs-comment"># 传入x,y, 通过plot画图</span><br>plt.plot([<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br><span class="hljs-comment"># 在执行程序的时候显示图形</span><br>plt.show()<br></code></pre></td></tr></table></figure><p>在这段代码中，我们使用<code>plot</code>来进行了绘制，<code>x</code>和<code>y</code>分别是<code>plot</code>的两个参数，代表了<code>x</code>轴和<code>y</code>轴。那么这两个轴分别接受了一个列表，那就是有三个点，第一个点是<code>(1,4)</code>,第二个点是<code>(0,5)</code>，第三个点是<code>(9,6)</code>。最后，我们使用<code>show()</code>函数来进行最终呈现。</p><img src="/AI-Python-matplotlib/image-20230819213941191.png" class="" title="img"><h2 id="绘图折线图">绘图折线图</h2><p>首先，我们来绘制一个折线图，这次我们用变量存储数据的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制折线图</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>) <span class="hljs-comment"># x轴的位置</span><br>y = [<span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br><span class="hljs-comment"># 传入x,y，plot绘图</span><br>plt.plot(x, y)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230819214509745.png" class="" title="img"><p>然后，我们对这个折线图进行一下设置，修改颜色和形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制折线图</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>) <span class="hljs-comment"># x轴的位置</span><br>y = [<span class="hljs-number">17</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>]<br><span class="hljs-comment"># 传入x,y，plot绘图</span><br>plt.plot(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, alpha=<span class="hljs-number">0.5</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">3</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230819214629033.png" class="" title="img"><p>我们对<code>plot</code>函数传递了几个参数修改了折线的样式，其中<code>color</code>是折线的颜色，<code>alpha</code>是折线的透明度（0-1），<code>linestyle</code>是折线的样式，<code>linewidth</code>是折线的宽度。</p><p><code>linestyle</code>的几个值分别是：<code>-</code>实线(solid)，这个也是默认值；<code>--</code>短线(dashed)；<code>-.</code>短点相间线(dashdot)； <code>:</code>虚线点(dotted)。</p><h4 id="关键点样式">关键点样式</h4><p>让我们接着进行修改这段折线样式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br><span class="hljs-comment"># 传入x,y，plot绘图</span><br>plt.plot(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, alpha=<span class="hljs-number">0.5</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">3</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230819215036723.png" class="" title="img"><p>我们这次只增加了一个参数，很明显，<code>marker</code>就是关键点的样式。</p><p>折线和关键点到底有哪些值呢？我们看一下下面这个表：</p><table><thead><tr class="header"><th>值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>-</code></td><td>solid line style</td></tr><tr class="even"><td><code>--</code></td><td>dashed line style</td></tr><tr class="odd"><td><code>-.</code></td><td>dash-dot line style</td></tr><tr class="even"><td><code>:</code></td><td>dotted line style</td></tr><tr class="odd"><td><code>.</code></td><td>point marker</td></tr><tr class="even"><td><code>,</code></td><td>pixel marker</td></tr><tr class="odd"><td><code>o</code></td><td>circle marker</td></tr><tr class="even"><td><code>v</code></td><td>triangle_down marker</td></tr><tr class="odd"><td><code>^</code></td><td>triangle_up marker</td></tr><tr class="even"><td><code>&lt;</code></td><td>triangle_left marker</td></tr><tr class="odd"><td><code>&gt;</code></td><td>triangle_right marker</td></tr><tr class="even"><td><code>1</code></td><td>tri_down marker</td></tr><tr class="odd"><td><code>2</code></td><td>tri_up marker</td></tr><tr class="even"><td><code>3</code></td><td>tri_left marker</td></tr><tr class="odd"><td><code>4</code></td><td>tri_right marker</td></tr><tr class="even"><td><code>s</code></td><td>square marker</td></tr><tr class="odd"><td><code>p</code></td><td>pentagon marker</td></tr><tr class="even"><td><code>*</code></td><td>star marker</td></tr><tr class="odd"><td><code>h</code></td><td>hexagon1 marker</td></tr><tr class="even"><td><code>H</code></td><td>hexagon2 marker</td></tr><tr class="odd"><td><code>+</code></td><td>plus marker</td></tr><tr class="even"><td><code>x</code></td><td>x marker</td></tr><tr class="odd"><td><code>D</code></td><td>diamond marker</td></tr><tr class="even"><td><code>d</code></td><td>thin_diamond marker</td></tr><tr class="odd"><td><code>|</code></td><td>vline marker</td></tr><tr class="even"><td><code>_</code></td><td>hline marker</td></tr></tbody></table><p>如果看不懂描述的小伙伴，最直接的办法就是放到代码里直接运行一下看看。</p><p>当然，我们还可以改变关键点的大小等参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(x, y, color=<span class="hljs-string">&#x27;red&#x27;</span>, alpha=<span class="hljs-number">0.5</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">3</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>, markersize=<span class="hljs-string">&#x27;10&#x27;</span>,markeredgecolor=<span class="hljs-string">&#x27;blue&#x27;</span>, markeredgewidth=<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>那这里面，<code>markersize</code>是表示关键点的大小，<code>markeredgecolor</code>是关键点边框的颜色，<code>markeredgewidth</code>就是关键点边框的宽度。</p><img src="/AI-Python-matplotlib/image-20230819221804809.png" class="" title="img"><p>既然图片渲染出来了，那我们总是需要进行保存的。那么下面，我们就看看如何将图片保存下来，在保存之前，我们还会根据需要设置一下图片的大小。</p><h4 id="设置图片大小和保存">设置图片大小和保存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> random<br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">26</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># x轴的位置</span><br>y = [random.randint(<span class="hljs-number">15</span>, <span class="hljs-number">30</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br><br><span class="hljs-comment"># 设置图片大小</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br>plt.plot(x,y)<br><span class="hljs-comment"># plt.show()</span><br><span class="hljs-comment"># 保存</span><br>plt.savefig(<span class="hljs-string">&#x27;./data/img/t1.png&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们依次来看这段代码，里面有我们认识的也有我们不认识的。其中的<code>random</code>是为了生成随机数，这个我们就先不管了。直接看设置部分。</p><p><code>figsize</code>这参数是为了指定<code>figure</code>的宽和高，单位为英寸。</p><p><code>dpi</code>参数指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80，1英寸等于2.5cm,A4纸为21*30cm的纸张。</p><p>然后我们继续往下看，<code>savefig</code>就是指定目录进行保存。这里我们需要注意两点：</p><ol type="1"><li>如果保存的目录有路径不存在，则会报错无法保存。</li><li>我们需要<code>savefig</code>的时候尽量不要使用<code>show</code>方法，因为<code>savefig</code>也具备了展示图片的功能，并且，如果<code>show</code>存在的话，在展示完图片之后，会释放<code>figuer</code>资源，那么<code>savefig</code>保存下来的图片将会是空白的。就好比我们<code>open('file', 'a+') as fp</code>一个文件，在使用<code>fp.write</code>的时候没有往里面写入内容。因为这些内容被上面一个方法清空了，但是文件我还是会保存的，只是文件内没有任何内容。</li></ol><p>然后我们回过头来继续看我们写的这段代码，其实<code>savefig</code>能存储的文件格式很多，包括能够存储<code>svg</code>格式的矢量图。只需要<code>plt.savefig('./t1.svg')</code>，保存的时候换一下后缀名就可以了。</p><p>现在让我们看下保存好的图片：</p><img src="/AI-Python-matplotlib/image-20230819222918242.png" class="" title="img"><h4 id="绘制轴上的刻度">绘制轴上的刻度</h4><p>有没有发现，虽然我们折线图是正常的，但是似乎x轴上的刻度区间太大了，并不是所有关键点都明显展示出来了。那现在我们就来设置一下x轴和y轴的刻度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br><span class="hljs-comment"># 设置x轴的刻度</span><br>plt.xticks(x)<br><span class="hljs-comment"># # 设置y轴的刻度</span><br>plt.yticks(y)<br><br><span class="hljs-comment"># 设置图片大小</span><br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><p>这段代码中我们将保存文件的代码去掉了。因为主要是进行设置，所以我们展示一下看看正确与否就行了。</p><img src="/AI-Python-matplotlib/image-20230819230152978.png" class="" title="img"><p>我们看到现在的图片，刻度上<code>x</code>轴遵循了我们之前对<code>x</code>的设定，(2,26, 2)， 从2开始，到25，并且步进值为2.<code>y</code>轴呢？因为是随机数，所以关键点的分布并不均匀。</p><p>这个时候，我就又需要进行修改了，一个是<code>y</code>轴的刻度要分配的更均匀，再有就是<code>x</code>轴上，我希望区间为1，而不是2。让我们来对其进行下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br><span class="hljs-comment"># 设置x轴的刻度</span><br>plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>))<br><span class="hljs-comment"># 设置y轴的刻度</span><br>plt.yticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(y), <span class="hljs-built_in">max</span>(y)+<span class="hljs-number">1</span>))<br><br><span class="hljs-comment"># 设置图片大小</span><br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230819223327871.png" class="" title="img"><p>似乎图不太一样，原因是因为我在代码中使用的是随机数函数<code>random.randint</code>来差生<code>y</code>轴的数据，所以每次生成的图片都会有些不同。</p><p>我们来好好看看轴线上的刻度。确实和关键点都对应上了。并且比起关键点来说更密集一点。原因就在于，我们将<code>x</code>的刻度点范围改为<code>(1, 25)</code>，无步进值。<code>y</code>轴在绘制的时候也做了定义，范围设置为<code>(最小的y值, 最大的y值+1)</code>，同样，也是没有步进值。这样，两个轴上的刻度分布就非常均匀了。</p><p><strong>这里的关键知识点</strong>就是：我们可以使用<code>xticks</code>和<code>yticks</code>来生成<code>x</code>轴刻度或者<code>y</code>轴刻度，并且，在其中可以传递参数来对<code>x</code>轴上的刻度和<code>y</code>轴上的刻度进行定义。</p><p>不过我们现在这个还是无法满足需求，原因就在于我们这个折线图是为了显示不同时间点上的温度变化。那么我们就必须要让x轴显示时间，而y轴显示温度。</p><p>让我们继续修改一下,这里我们就只展示轴线代码的修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构造x轴刻度标签</span><br>x_ticks_label = [<span class="hljs-string">&quot;&#123;&#125;:00&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br><span class="hljs-comment"># 让字旋转45度</span><br>plt.xticks(x, x_ticks_label, rotation=<span class="hljs-number">45</span>)<br><br><span class="hljs-comment"># 构造y轴的刻度标签</span><br>y_ticks_label = [<span class="hljs-string">&quot;&#123;&#125;℃&quot;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(y), <span class="hljs-built_in">max</span>(y)+<span class="hljs-number">1</span>)]<br>plt.yticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(y), <span class="hljs-built_in">max</span>(y)+<span class="hljs-number">1</span>), y_ticks_label)<br></code></pre></td></tr></table></figure><p>最后生成的图片：</p><img src="/AI-Python-matplotlib/image-20230819224031604.png" class="" title="img"><p>这里，我们使用了<code>x_ticks_label</code>来设置了<code>x</code>轴的刻度上显示的信息。当然，<code>y</code>轴也是相同的方式。然后将<code>label</code>传入轴刻度生成方法<code>xticks</code>中进行刻度生成，在生成的时候，我们还使用了<code>xticks</code>的参数<code>rotation</code>设置为<code>45</code>来完成了<code>label</code>的旋转。</p><h4 id="设置显示中文">设置显示中文</h4><p>不过这并未结束，<code>matplotlib</code>默认是只显示英文的，无法显示中文。但是我们无论是刻度，图标题，很多时候都必须显示中文。该怎么办呢？</p><p>接下来就让我们来看看如何修改matplotlib的默认字体。这一段，我们重新写一个需求，来看看2个小时内每分钟跳动变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> font_manager<br><span class="hljs-keyword">import</span> random<br><br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">120</span>)<br>y = [random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">120</span>)]<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br>plt.plot(x,y)<br><br><br><span class="hljs-comment"># 设置字体和Label</span><br>my_font = font_manager.FontProperties(fname=<span class="hljs-string">&#x27;/System/Library/Fonts/PingFang.ttc&#x27;</span>, size=<span class="hljs-number">18</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;时间&#x27;</span>, fontproperties=my_font)<br>plt.ylabel(<span class="hljs-string">&#x27;次数&#x27;</span>, fontproperties=my_font)<br><br><span class="hljs-comment"># 设置标题</span><br>plt.title(<span class="hljs-string">&#x27;每分钟跳动次数&#x27;</span>, fontproperties=my_font, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820020311620.png" class="" title="img"><p>我们引入了<code>font_manager</code>，然后利用它设置了我们需要用到的字体（必须是中文字体）给到一个变量<code>my_font</code>内。最后在设置label的时候，将字体设置为这个变量。</p><p>这样，我们就完成了中文字体的显示。</p><p>作为对比，我们来看看这样设置的是什么样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>plt.xlabel(<span class="hljs-string">&#x27;时间&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;次数&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;每分钟跳动次数&#x27;</span>,color=<span class="hljs-string">&#x27;red&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820020609834.png" class="" title="img"><h4 id="一图多线">一图多线</h4><p>大多数时候，我们的一张图表上可能不仅需要一条线。而是两条线相互交错。这就形成了两组数据的对比，我们打个比方来说：我们正在和一位同事竞争销售额，需要查看去年（2022年）全年的数据对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 销售额数据对比</span><br>y1 = [<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">40</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">50</span>,<span class="hljs-number">40</span>]<br>y2 = [<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">30</span>,<span class="hljs-number">80</span>,<span class="hljs-number">30</span>,<span class="hljs-number">20</span>]<br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">13</span>)<br><br><span class="hljs-comment"># 设置图形</span><br>plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br><br>plt.plot(x, y1, color=<span class="hljs-string">&#x27;orange&#x27;</span>, label=<span class="hljs-string">&quot;茶桁&quot;</span>)<br>plt.plot(x, y2, color=<span class="hljs-string">&#x27;green&#x27;</span>, label=<span class="hljs-string">&#x27;同事&#x27;</span>)<br><br><span class="hljs-comment"># 设置x轴刻度</span><br>xtick_labels = [<span class="hljs-string">&#x27;&#123;&#125;月&#x27;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br>my_font = font_manager.FontProperties(fname=<span class="hljs-string">&#x27;/System/Library/Fonts/PingFang.ttc&#x27;</span>, size=<span class="hljs-number">24</span>)<br><br>plt.xticks(x, xtick_labels, fontproperties=my_font, rotation=<span class="hljs-number">45</span>)<br><br><span class="hljs-comment"># 绘制网格</span><br>plt.grid(alpha=<span class="hljs-number">0.4</span>) <span class="hljs-comment">#网格也可以设置样式，这里透明度为0.4</span><br><br><span class="hljs-comment"># 添加图例(注意：只有在这里需要添加prop参数是显示中文，其他的都用fontproperties)</span><br><span class="hljs-comment"># 设置位置loc : upper left、 lower left、 center left、 upper center</span><br>plt.legend(prop=my_font, loc=<span class="hljs-string">&#x27;upper right&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>我们在代码中设置两两组数据，分别为<code>y1, y2</code>。这两组数据一共12个，对应了12个月份。然后我们在<code>plot</code>方法中设置了线条的颜色，设置了这条线条对应的数据，并且添加了<code>label</code>。意在对这个线条写个说明。</p><p>在之后，我们添加了<code>grid</code>网格，意图让线条上的关键点更明显。</p><p>最后使用<code>legend</code>来完成<code>plot</code>中设置的<code>label</code>的显示，并在其中设置了显示所用字体。这里需要注意的是，在<code>legend</code>方法中设置字体所用的形参是<code>prop</code>而非<code>fontproperties</code>。在最后，我们使用<code>loc</code>设置了这两个<code>label</code>显示的位置，其中的关键字<code>upper right</code>代表的是两个方位「上，右」，来确定显示位置为右上角。</p><p>最后，我们绘制的图片显示如图：</p><img src="/AI-Python-matplotlib/image-20230820022347761.png" class="" title="img"><p>从图上能明显看出来，我的销售数据是在稳步上升的，而同事起伏比较大。大部分时候我占优势，可是旺季时顶峰数据同事比我高很多，所以说基本上是各有千秋。</p><p>基于折线图，我们再来看几个拓展的部分。</p><p>首先，我们在绘图的时候，实际上是支持<strong>多个坐标系绘制在一张图上</strong>的。这也经常是数据图对比经常用到的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多个坐标系子图 add_subplot方法，给figure新增子图</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>x = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>fig = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">10</span>), dpi=<span class="hljs-number">80</span>)<br><br><span class="hljs-comment"># 子图1</span><br>ax1 = fig.add_subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>ax1.plot(x,x)<br><span class="hljs-comment"># 子图2</span><br>ax2 = fig.add_subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br>ax2.plot(x, x**<span class="hljs-number">2</span>)<br>ax2.grid(color=<span class="hljs-string">&#x27;r&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, linewidth=<span class="hljs-number">1</span>, alpha=<span class="hljs-number">0.3</span>)<br><span class="hljs-comment"># 子图3</span><br>ax3 = fig.add_subplot(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>ax3.plot(x, np.log(x))<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>我们利用<code>add_subplot</code>方法，在一个<code>figure</code>上添加了三个子图。</p><p>其次，有一些时候，我们需要<strong>对坐标轴范围进行设定</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设定坐标轴范围</span><br>x = np.arange(-<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">1</span>)<br>y = x ** <span class="hljs-number">2</span><br>plt.plot(x,y)<br><br><span class="hljs-comment"># plt.xlim([-5,5])</span><br><br><span class="hljs-comment"># 单边调整</span><br><span class="hljs-comment"># plt.xlim(xmin=-4)</span><br><span class="hljs-comment"># plt.xlim(xmax=4)</span><br><br>plt.ylim(ymin=<span class="hljs-number">0</span>)<br>plt.xlim(xmin=<span class="hljs-number">0</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>在这段代码中，我展示了三个调整范围的方式。</p><p>第一个是使用数组划定范围来进行调整。</p><p>第二个方式是分别设定一边的值（最小值或者最大值）。</p><p>最后一个方式是只设定x轴和y轴的最小值。下图展示的是第三个方式绘制的图：</p><img src="/AI-Python-matplotlib/image-20230820131938320.png" class="" title="img"><p>当然，坐标轴并不会是一成不变的。有的时候我们可能需要y轴在x轴的正中间。所以我们需要<strong>改变坐标轴的默认显示方式</strong></p><p>我们先来看看原本的图默认样式是什么样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 改变坐标轴的默认显示方式</span><br>y = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">2</span>)<br>x = [-<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br><br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820132820743.png" class="" title="img"><p>然后我们对这张图进行修改，获取图像之后设置四周边线，并且移动底边，移动到y轴的0位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 改变坐标轴的默认显示方式</span><br>y = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">2</span>)<br>x = [-<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br><br><span class="hljs-comment"># 获得当前图表的图像</span><br>ax = plt.gca()<br><br><span class="hljs-comment"># 设置图形四周的边线</span><br>ax.spines[<span class="hljs-string">&#x27;right&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>ax.spines[<span class="hljs-string">&#x27;top&#x27;</span>].set_color(<span class="hljs-string">&#x27;none&#x27;</span>)<br>ax.spines[<span class="hljs-string">&#x27;bottom&#x27;</span>].set_color(<span class="hljs-string">&#x27;blue&#x27;</span>)<br>ax.spines[<span class="hljs-string">&#x27;left&#x27;</span>].set_color(<span class="hljs-string">&#x27;red&#x27;</span>)<br><br><span class="hljs-comment"># 设置底边的移动范围，移动到y轴的0位置，`data`: 移动轴的位置到交叉轴的指定坐标</span><br>ax.spines[<span class="hljs-string">&#x27;bottom&#x27;</span>].set_position((<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-number">0</span>))<br>ax.spines[<span class="hljs-string">&#x27;left&#x27;</span>].set_position((<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-number">0</span>))<br><br>plt.plot(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><p>代码中，我们使用<code>gca()</code>获取了图像赋值给变量<code>ax</code>，然后对其进行修改，<code>spines</code>可以修改四周边线，包括颜色和位置等。分别设置完颜色之后，我们分别对底边和左边使用了<code>set_position</code>进行了位移。移动到<code>0</code>点位置。那其实，底边对应的就是x轴，左边对应的就是y轴。</p><img src="/AI-Python-matplotlib/image-20230820133403884.png" class="" title="img"><h3 id="绘制散点图">绘制散点图</h3><p>我们拿到了一组数据，就是今年3月份每天的最高气温，现在我想在图表上进行展示。为了展示气温的分布，我们准备使用散点图进行展示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制散点图</span><br>y = [<span class="hljs-number">11</span>,<span class="hljs-number">17</span>,<span class="hljs-number">16</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">20</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>, <span class="hljs-number">22</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>]<br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>),dpi=<span class="hljs-number">80</span>)<br><span class="hljs-comment"># 使用scatter绘制散点图</span><br>plt.scatter(x, y, label=<span class="hljs-string">&#x27;3月份&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820134012303.png" class="" title="img"><p>本来这样就已经完成绘制了。不过我们看一下图表，虽然散点是绘制完成了，但是整张图上我们看不出太多信息，包括刻度值，月份等等，另外，我记得咱们之前加过图例，现在我们都加上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> font_manager<br><span class="hljs-comment"># 绘制散点图</span><br>y = [<span class="hljs-number">11</span>,<span class="hljs-number">17</span>,<span class="hljs-number">16</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span>,<span class="hljs-number">15</span>,<span class="hljs-number">14</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>,<span class="hljs-number">21</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">20</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">15</span>,<span class="hljs-number">19</span>,<span class="hljs-number">21</span>,<span class="hljs-number">22</span>, <span class="hljs-number">22</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>]<br>x = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">32</span>)<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>),dpi=<span class="hljs-number">80</span>)<br><span class="hljs-comment"># 使用scatter绘制散点图</span><br>plt.scatter(x, y, label=<span class="hljs-string">&#x27;3月份&#x27;</span>)<br><br>my_font = font_manager.FontProperties(fname=<span class="hljs-string">&#x27;/System/Library/Fonts/PingFang.ttc&#x27;</span>, size=<span class="hljs-number">12</span>)<br>_xticks_labels = [<span class="hljs-string">&#x27;3月&#123;&#125;日&#x27;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x]<br><br>plt.xticks(x[::<span class="hljs-number">3</span>], _xticks_labels[::<span class="hljs-number">3</span>], fontproperties=my_font, rotation=<span class="hljs-number">45</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;日期&#x27;</span>, fontproperties=my_font)<br>plt.ylabel(<span class="hljs-string">&#x27;温度&#x27;</span>, fontproperties=my_font)<br><br><span class="hljs-comment"># 图例</span><br>plt.legend(prop=my_font)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>以上代码中的内容，基本都是咱们之前学过的内容，我就不多做解释了。其中，我们可以看到，<code>plt.</code>之后的方法就是绘制不同的图形，之前我们看到的<code>plot</code>是折线图，这次我们学到<code>scatter</code>是散点图。在图形绘制之后，剩下的就是对其进行修饰和设置。</p><img src="/AI-Python-matplotlib/image-20230820134928955.png" class="" title="img"><h3 id="绘制条形图">绘制条形图</h3><p>今天刷到一条新闻，说目前2023年暑期档电影的票房基本已经定型，目前全部累计票房已经超过2019年称为历史最高暑期档，而最引人瞩目的是，国产电影全线压制好莱坞大片。这真是一个值的骄傲的事情。那现在，我们就来展现一下暑期档电影票房的对比吧,我们一步一步来，最开始当然是拿到数据。</p><blockquote><p>本数据<ahref="https://piaofang.maoyan.com/dashboard/movie?movieId=1374349">来源于猫眼</a>，2023年8月20日14:00的实时数据，后期未下线的电影数据可能会有变化。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;消失的她&#x27;</span>,<span class="hljs-string">&#x27;碟中谍7:致命清算&#x27;</span>,<span class="hljs-string">&#x27;芭比&#x27;</span>,<span class="hljs-string">&#x27;八角笼中&#x27;</span>,<span class="hljs-string">&#x27;茶啊二中&#x27;</span>,<span class="hljs-string">&#x27;热烈&#x27;</span>,<span class="hljs-string">&#x27;长安三万里&#x27;</span>,<span class="hljs-string">&#x27;巨齿鲨2:深渊&#x27;</span>,<span class="hljs-string">&#x27;封神第一部&#x27;</span>,<span class="hljs-string">&#x27;孤注一掷&#x27;</span>]<br>b = [<span class="hljs-string">&#x27;35.22&#x27;</span>,<span class="hljs-string">&#x27;3.46&#x27;</span>,<span class="hljs-string">&#x27;2.47&#x27;</span>,<span class="hljs-string">&#x27;21.92&#x27;</span>,<span class="hljs-string">&#x27;3.66&#x27;</span>,<span class="hljs-string">&#x27;8.69&#x27;</span>,<span class="hljs-string">&#x27;17.56&#x27;</span>,<span class="hljs-string">&#x27;7.53&#x27;</span>,<span class="hljs-string">&#x27;22.36&#x27;</span>,<span class="hljs-string">&#x27;26.48&#x27;</span>]<br></code></pre></td></tr></table></figure><p>然后我们就可以开始绘制柱状图了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br>plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)), [<span class="hljs-built_in">float</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b], width=<span class="hljs-number">0.3</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820141009212.png" class="" title="img"><p>现在图形是绘制出来了，但是完全无法让人满意。我们并不知道哪个柱子是哪个电影的，并且对比之下，我们只能看出大概高低，并不知道具体的票房。那我们现在来进行修改,先加上x轴和y轴上的刻度标识，并且将y轴刻度范围放大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)), a, fontproperties=my_font)<br>plt.yticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">51</span>,<span class="hljs-number">5</span>), <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">51</span>,<span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820141238046.png" class="" title="img"><p>目前的图我们是能看出谁是谁了，而且比起刚才看起来y轴上也舒服了很多，没有顶天立地。</p><p>接下来，我们继续修改。给柱子加上颜色，好做区分。并且将绘制的图形赋值给到变量<code>rects</code>，在下面我们好对每一根柱子上写一个数字，将票房数值写上去。这样，具体的票房我们就能一目了然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;消失的她&#x27;</span>,<span class="hljs-string">&#x27;碟中谍7:致命清算&#x27;</span>,<span class="hljs-string">&#x27;芭比&#x27;</span>,<span class="hljs-string">&#x27;八角笼中&#x27;</span>,<span class="hljs-string">&#x27;茶啊二中&#x27;</span>,<span class="hljs-string">&#x27;热烈&#x27;</span>,<span class="hljs-string">&#x27;长安三万里&#x27;</span>,<span class="hljs-string">&#x27;巨齿鲨2:深渊&#x27;</span>,<span class="hljs-string">&#x27;封神第一部&#x27;</span>,<span class="hljs-string">&#x27;孤注一掷&#x27;</span>]<br>b = [<span class="hljs-string">&#x27;35.22&#x27;</span>,<span class="hljs-string">&#x27;3.46&#x27;</span>,<span class="hljs-string">&#x27;2.47&#x27;</span>,<span class="hljs-string">&#x27;21.92&#x27;</span>,<span class="hljs-string">&#x27;3.66&#x27;</span>,<span class="hljs-string">&#x27;8.69&#x27;</span>,<span class="hljs-string">&#x27;17.56&#x27;</span>,<span class="hljs-string">&#x27;7.53&#x27;</span>,<span class="hljs-string">&#x27;22.36&#x27;</span>,<span class="hljs-string">&#x27;26.48&#x27;</span>]<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br>rects = plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)), [<span class="hljs-built_in">float</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b], width=<span class="hljs-number">0.3</span>, color=[<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>])<br>plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)), a, fontproperties=my_font)<br>plt.yticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">51</span>,<span class="hljs-number">5</span>), <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">51</span>,<span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 加标注(水平居中)</span><br><span class="hljs-keyword">for</span> rect <span class="hljs-keyword">in</span> rects:<br>    height = rect.get_height()<br>    plt.text(rect.get_x()+rect.get_width() / <span class="hljs-number">2</span>, height+<span class="hljs-number">1</span>, <span class="hljs-built_in">str</span>(height), ha=<span class="hljs-string">&#x27;center&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p>这段代码中其他的都好理解，就是加标注这一段。我们使用<code>for</code>从<code>rects</code>中分别获取到每一根柱子，然后设定了一个高，这个高度就是柱子的实际高度。再设定一个<code>text</code>给到这根柱子，<code>text</code>的高度为柱子的定位为每根柱子的<code>x</code>轴位置+其宽度的二分之一，高度为柱子高度+1，字符串为柱子高度本身，设置水平居中。</p><p>来，让我们看看效果：</p><img src="/AI-Python-matplotlib/image-20230820141820356.png" class="" title="img"><p>现在，我们的显示虽然还是不完美，但是已经非常清晰了。</p><p>当然，柱状图除了竖向的，还有横向，但是横向就不能称之为柱状图，而是条形图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 横向条形图</span><br>a = [<span class="hljs-string">&#x27;消失的她&#x27;</span>,<span class="hljs-string">&#x27;碟中谍7:致命清算&#x27;</span>,<span class="hljs-string">&#x27;芭比&#x27;</span>,<span class="hljs-string">&#x27;八角笼中&#x27;</span>,<span class="hljs-string">&#x27;茶啊二中&#x27;</span>,<span class="hljs-string">&#x27;热烈&#x27;</span>,<span class="hljs-string">&#x27;长安三万里&#x27;</span>,<span class="hljs-string">&#x27;巨齿鲨2:深渊&#x27;</span>,<span class="hljs-string">&#x27;封神第一部&#x27;</span>,<span class="hljs-string">&#x27;孤注一掷&#x27;</span>]<br>b = [<span class="hljs-string">&#x27;35.22&#x27;</span>,<span class="hljs-string">&#x27;3.46&#x27;</span>,<span class="hljs-string">&#x27;2.47&#x27;</span>,<span class="hljs-string">&#x27;21.92&#x27;</span>,<span class="hljs-string">&#x27;3.66&#x27;</span>,<span class="hljs-string">&#x27;8.69&#x27;</span>,<span class="hljs-string">&#x27;17.56&#x27;</span>,<span class="hljs-string">&#x27;7.53&#x27;</span>,<span class="hljs-string">&#x27;22.36&#x27;</span>,<span class="hljs-string">&#x27;26.48&#x27;</span>]<br><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br>rects = plt.barh(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)), [<span class="hljs-built_in">float</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b], height=<span class="hljs-number">0.5</span>, color=[<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>])<br>plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">51</span>,<span class="hljs-number">5</span>), <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">51</span>,<span class="hljs-number">5</span>))<br>plt.yticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)), a, rotation=<span class="hljs-number">45</span>, fontproperties=my_font)<br><br><span class="hljs-comment"># 加标注(水平居中)</span><br><span class="hljs-keyword">for</span> rect <span class="hljs-keyword">in</span> rects:<br>    width = rect.get_width()<br>    plt.text(width+<span class="hljs-number">1</span>, rect.get_y()+<span class="hljs-number">0.5</span>/<span class="hljs-number">2</span>, <span class="hljs-built_in">str</span>(width)+<span class="hljs-string">&#x27; 亿&#x27;</span>, va=<span class="hljs-string">&#x27;center&#x27;</span>, fontproperties=my_font)<br><br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820142759226.png" class="" title="img"><p>其方法和原理都和柱状图是一样的，不同的点就在于柱状图的方法是<code>bar</code>，横向条形图的方法为<code>barh</code>。另外，别忘了切换<code>x,y</code>轴。</p><blockquote><p><strong>在这里，恭喜《封神》破22亿，加油...</strong></p></blockquote><p>我们平时看到的柱状图或者条形图，一定不只是这样一根一根的，还有那种两根或两根以上并列的对吧？其形式也很简单，就是在当前的柱子旁边多加一根而已：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 多条并列</span><br>index = np.arange(<span class="hljs-number">4</span>)<br>BJ = [<span class="hljs-number">50</span>,<span class="hljs-number">55</span>,<span class="hljs-number">53</span>,<span class="hljs-number">60</span>]<br>SH = [<span class="hljs-number">44</span>,<span class="hljs-number">66</span>,<span class="hljs-number">55</span>,<span class="hljs-number">41</span>]<br><span class="hljs-comment"># 并列</span><br>plt.bar(index,BJ, width=<span class="hljs-number">0.3</span>)<br>plt.bar(index+<span class="hljs-number">0.3</span>, SH, width=<span class="hljs-number">0.3</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)<br><br>plt.xticks(index+<span class="hljs-number">0.3</span>/<span class="hljs-number">2</span>, index)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820143246407.png" class="" title="img"><h3 id="直方图">直方图</h3><p>这个图形的学习，我们还是拿电影数据来做，但是这次我们不拿刚才用过的数据了，我们拿到一个250部电影的时长数据，现在我们要统计处这些电影时长的分布状态。（比如，市场为100分钟到120分钟的电影数量，出现频率等），我们该如何去做呢？</p><p>来，让咱们尝试一下，还是老样子，先落位数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">times = [<span class="hljs-number">131</span>,<span class="hljs-number">98</span>,<span class="hljs-number">125</span>,<span class="hljs-number">131</span>,<span class="hljs-number">124</span>,<span class="hljs-number">139</span>,<span class="hljs-number">131</span>,<span class="hljs-number">117</span>,<span class="hljs-number">128</span>,<span class="hljs-number">108</span>,<span class="hljs-number">135</span>,<span class="hljs-number">138</span>,<span class="hljs-number">131</span>,<span class="hljs-number">102</span>,<span class="hljs-number">107</span>,<span class="hljs-number">114</span>,<span class="hljs-number">119</span>,<span class="hljs-number">128</span>,<span class="hljs-number">121</span>,<span class="hljs-number">142</span>,<span class="hljs-number">127</span>,<span class="hljs-number">130</span>,<span class="hljs-number">124</span>,<span class="hljs-number">101</span>,<span class="hljs-number">110</span>,<span class="hljs-number">116</span>,<span class="hljs-number">117</span>,<span class="hljs-number">110</span>,<span class="hljs-number">128</span>,<span class="hljs-number">128</span>,<span class="hljs-number">115</span>,<span class="hljs-number">99</span>,<span class="hljs-number">95</span>,<span class="hljs-number">138</span>,<span class="hljs-number">117</span>,<span class="hljs-number">111</span>,<span class="hljs-number">78</span>,<span class="hljs-number">132</span>,<span class="hljs-number">124</span>,<span class="hljs-number">113</span>,<span class="hljs-number">150</span>,<span class="hljs-number">110</span>,<span class="hljs-number">117</span>,<span class="hljs-number">136</span>,<span class="hljs-number">126</span>,<span class="hljs-number">134</span>,<span class="hljs-number">95</span>,<span class="hljs-number">144</span>,<span class="hljs-number">105</span>,<span class="hljs-number">126</span>,<span class="hljs-number">130</span>,<span class="hljs-number">126</span>,<span class="hljs-number">130</span>,<span class="hljs-number">126</span>,<span class="hljs-number">116</span>,<span class="hljs-number">123</span>,<span class="hljs-number">106</span>,<span class="hljs-number">112</span>,<span class="hljs-number">138</span>,<span class="hljs-number">123</span>,<span class="hljs-number">99</span>,<span class="hljs-number">136</span>,<span class="hljs-number">123</span>,<span class="hljs-number">117</span>,<span class="hljs-number">119</span>,<span class="hljs-number">105</span>,<span class="hljs-number">137</span>,<span class="hljs-number">123</span>,<span class="hljs-number">128</span>,<span class="hljs-number">125</span>,<span class="hljs-number">104</span>,<span class="hljs-number">109</span>,<span class="hljs-number">134</span>,<span class="hljs-number">125</span>,<span class="hljs-number">127</span>,<span class="hljs-number">105</span>,<span class="hljs-number">120</span>,<span class="hljs-number">107</span>,<span class="hljs-number">129</span>,<span class="hljs-number">116</span>,<span class="hljs-number">108</span>,<span class="hljs-number">132</span>,<span class="hljs-number">103</span>,<span class="hljs-number">136</span>,<span class="hljs-number">118</span>,<span class="hljs-number">102</span>,<span class="hljs-number">120</span>,<span class="hljs-number">114</span>,<span class="hljs-number">105</span>,<span class="hljs-number">115</span>,<span class="hljs-number">132</span>,<span class="hljs-number">145</span>,<span class="hljs-number">119</span>,<span class="hljs-number">121</span>,<span class="hljs-number">112</span>,<span class="hljs-number">139</span>,<span class="hljs-number">125</span>,<span class="hljs-number">138</span>,<span class="hljs-number">109</span>,<span class="hljs-number">132</span>,<span class="hljs-number">134</span>,<span class="hljs-number">156</span>,<span class="hljs-number">106</span>,<span class="hljs-number">117</span>,<span class="hljs-number">127</span>,<span class="hljs-number">144</span>,<span class="hljs-number">139</span>,<span class="hljs-number">139</span>,<span class="hljs-number">119</span>,<span class="hljs-number">140</span>,<span class="hljs-number">83</span>,<span class="hljs-number">110</span>,<span class="hljs-number">102</span>,<span class="hljs-number">123</span>,<span class="hljs-number">107</span>,<span class="hljs-number">143</span>,<span class="hljs-number">115</span>,<span class="hljs-number">136</span>,<span class="hljs-number">118</span>,<span class="hljs-number">139</span>,<span class="hljs-number">123</span>,<span class="hljs-number">112</span>,<span class="hljs-number">118</span>,<span class="hljs-number">125</span>,<span class="hljs-number">109</span>,<span class="hljs-number">119</span>,<span class="hljs-number">133</span>,<span class="hljs-number">112</span>,<span class="hljs-number">114</span>,<span class="hljs-number">122</span>,<span class="hljs-number">109</span>,<span class="hljs-number">106</span>,<span class="hljs-number">123</span>,<span class="hljs-number">116</span>,<span class="hljs-number">131</span>,<span class="hljs-number">127</span>,<span class="hljs-number">115</span>,<span class="hljs-number">118</span>,<span class="hljs-number">112</span>,<span class="hljs-number">135</span>,<span class="hljs-number">115</span>,<span class="hljs-number">146</span>,<span class="hljs-number">137</span>,<span class="hljs-number">116</span>,<span class="hljs-number">103</span>,<span class="hljs-number">144</span>,<span class="hljs-number">83</span>,<span class="hljs-number">123</span>,<span class="hljs-number">111</span>,<span class="hljs-number">110</span>,<span class="hljs-number">111</span>,<span class="hljs-number">100</span>,<span class="hljs-number">154</span>,<span class="hljs-number">136</span>,<span class="hljs-number">100</span>,<span class="hljs-number">118</span>,<span class="hljs-number">119</span>,<span class="hljs-number">133</span>,<span class="hljs-number">134</span>,<span class="hljs-number">106</span>,<span class="hljs-number">129</span>,<span class="hljs-number">126</span>,<span class="hljs-number">110</span>,<span class="hljs-number">111</span>,<span class="hljs-number">109</span>,<span class="hljs-number">141</span>,<span class="hljs-number">120</span>,<span class="hljs-number">117</span>,<span class="hljs-number">106</span>,<span class="hljs-number">149</span>,<span class="hljs-number">122</span>,<span class="hljs-number">122</span>,<span class="hljs-number">110</span>,<span class="hljs-number">118</span>,<span class="hljs-number">127</span>,<span class="hljs-number">121</span>,<span class="hljs-number">114</span>,<span class="hljs-number">125</span>,<span class="hljs-number">126</span>,<span class="hljs-number">114</span>,<span class="hljs-number">140</span>,<span class="hljs-number">103</span>,<span class="hljs-number">130</span>,<span class="hljs-number">141</span>,<span class="hljs-number">117</span>,<span class="hljs-number">106</span>,<span class="hljs-number">114</span>,<span class="hljs-number">121</span>,<span class="hljs-number">114</span>,<span class="hljs-number">133</span>,<span class="hljs-number">137</span>,<span class="hljs-number">92</span>,<span class="hljs-number">121</span>,<span class="hljs-number">112</span>,<span class="hljs-number">146</span>,<span class="hljs-number">97</span>,<span class="hljs-number">137</span>,<span class="hljs-number">105</span>,<span class="hljs-number">98</span>,<span class="hljs-number">117</span>,<span class="hljs-number">112</span>,<span class="hljs-number">81</span>,<span class="hljs-number">97</span>,<span class="hljs-number">139</span>,<span class="hljs-number">113</span>,<span class="hljs-number">134</span>,<span class="hljs-number">106</span>,<span class="hljs-number">144</span>,<span class="hljs-number">110</span>,<span class="hljs-number">137</span>,<span class="hljs-number">137</span>,<span class="hljs-number">111</span>,<span class="hljs-number">104</span>,<span class="hljs-number">117</span>,<span class="hljs-number">100</span>,<span class="hljs-number">111</span>,<span class="hljs-number">101</span>,<span class="hljs-number">110</span>,<span class="hljs-number">105</span>,<span class="hljs-number">129</span>,<span class="hljs-number">137</span>,<span class="hljs-number">112</span>,<span class="hljs-number">120</span>,<span class="hljs-number">113</span>,<span class="hljs-number">133</span>,<span class="hljs-number">112</span>,<span class="hljs-number">83</span>,<span class="hljs-number">94</span>,<span class="hljs-number">146</span>,<span class="hljs-number">133</span>,<span class="hljs-number">101</span>,<span class="hljs-number">131</span>,<span class="hljs-number">116</span>,<span class="hljs-number">111</span>,<span class="hljs-number">84</span>,<span class="hljs-number">137</span>,<span class="hljs-number">115</span>,<span class="hljs-number">122</span>,<span class="hljs-number">106</span>,<span class="hljs-number">144</span>,<span class="hljs-number">109</span>,<span class="hljs-number">123</span>,<span class="hljs-number">116</span>,<span class="hljs-number">111</span>,<span class="hljs-number">111</span>,<span class="hljs-number">133</span>,<span class="hljs-number">150</span>,<span class="hljs-number">134</span>,<span class="hljs-number">76</span>,<span class="hljs-number">104</span>] <br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(times))<br><br>---<br><span class="hljs-number">250</span><br></code></pre></td></tr></table></figure><p>没问题，250个数据齐了。现在让我们来开始绘图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">80</span>)<br><span class="hljs-comment"># 设置组距</span><br>distance = <span class="hljs-number">2</span><br><span class="hljs-comment"># 计算组距</span><br>group_num = <span class="hljs-built_in">int</span>((<span class="hljs-built_in">max</span>(times) - <span class="hljs-built_in">min</span>(times)) / distance)<br>plt.hist(times, bins=group_num)<br><br>plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(times), <span class="hljs-built_in">max</span>(times))[::<span class="hljs-number">2</span>])<br>plt.grid(linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, alpha=<span class="hljs-number">0.5</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;电影时长大小&#x27;</span>, fontproperties=my_font)<br>plt.ylabel(<span class="hljs-string">&#x27;电影的数据量&#x27;</span>, fontproperties=my_font)<br>plt.show()<br></code></pre></td></tr></table></figure><p>从代码中看，直方图的方法是<code>hist</code>,其中参数为需要展示的数据和组距。</p><p>x轴刻度上，我们将最小的电影时长和最大的电影时长顺序分布，步进值为2。</p><img src="/AI-Python-matplotlib/image-20230820145703094.png" class="" title="img"><p>现在我们从图中能看到，<code>110 ～ 112</code>这个时间段的电影数量是最多的，其次就是<code>116 ~ 118</code>分钟的。</p><p>现在，我们更清晰的感受了i库55起1422</p><p>直方图的作用。</p><h3 id="饼状图">饼状图</h3><p>最后我们来看看饼状图，饼状图相信大家平时看的也很多。基本上，我们遇到比例，份额对比的时候会使用这个图形。</p><p>来，让我们先绘制一个基本图形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">size = [<span class="hljs-number">55</span>, <span class="hljs-number">35</span>, <span class="hljs-number">10</span>]  <span class="hljs-comment"># 各部分大小</span><br><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">100</span>)<br>plt.pie(size)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820172856962.png" class="" title="img"><p>现在让我们在这个基础的饼状图上进行设置和修改，首先，我们需要这个图形各个区域都有个名称，然后是我们自己设定下他们的颜色，而不是用默认的，接着，我们需要将其中一部分突出显示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改生成饼图代码</span><br>plt.pie(size, <br>        explode=[<span class="hljs-number">0</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>],<br>        colors = [<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>],<br>        labels = [<span class="hljs-string">&#x27;第一部分&#x27;</span>,<span class="hljs-string">&#x27;第二部分&#x27;</span>,<span class="hljs-string">&#x27;第三部分&#x27;</span>])<br></code></pre></td></tr></table></figure><img src="/AI-Python-matplotlib/image-20230820173231264.png" class="" title="img"><p>现在是按照我刚才希望的去变化了，但是并不让人满意。我们需要将文字设置成中文显示，然后整个图形旋转一下，让突出的部分部要向下，接着我们希望显示出百分比，并且有一个图例，分别标识出颜色和区域的文字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">size = [<span class="hljs-number">55</span>, <span class="hljs-number">35</span>, <span class="hljs-number">10</span>]  <span class="hljs-comment"># 各部分大小</span><br><br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">8</span>), dpi=<span class="hljs-number">100</span>)<br><br>label_list = [<span class="hljs-string">&#x27;第一部分&#x27;</span>,<span class="hljs-string">&#x27;第二部分&#x27;</span>,<span class="hljs-string">&#x27;第三部分&#x27;</span>] <span class="hljs-comment"># 各部分标签</span><br>color = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>] <span class="hljs-comment"># 各部分颜色</span><br>explode = [<span class="hljs-number">0</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>] <span class="hljs-comment"># 各部分突出值</span><br>patches, l_text, p_text = plt.pie(size,<br>                                  explode = explode,<br>                                  colors = color,<br>                                  labels = label_list,<br>                                  labeldistance=<span class="hljs-number">1.1</span>,<br>                                  autopct=<span class="hljs-string">&#x27;%1.1f%%&#x27;</span>,<br>                                  shadow=<span class="hljs-literal">False</span>,<br>                                  startangle=<span class="hljs-number">150</span>,<br>                                  pctdistance=<span class="hljs-number">0.6</span>)<br><br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> l_text:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">dir</span>(t))<br>    t.set_fontproperties(my_font)<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> p_text:<br>    t.set_size(<span class="hljs-number">18</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> patches:<br>    i.set_color(<span class="hljs-string">&#x27;pink&#x27;</span>)<br>    <span class="hljs-keyword">break</span><br><br>plt.legend(prop=my_font)<br>plt.show()<br></code></pre></td></tr></table></figure><p>我们在这段代码中，将之前在<code>pie</code>方法中的三组列表数据拿出来赋值给了三个变量，然后增加了一些其他参数用于标签距离、设置旋转、百分比距离等。</p><p>然后将生成的图赋值给到三个变量，<code>patches, l_text, p_text</code>，这三个变量分别接受的参数为「饼的区域」、「饼的外部说明文字」、「饼的内部标识文字」。</p><p>然后，对这三个变量分别进行设置。</p><p>最后，将图例的字体设置一下，然后显示出来。</p><img src="/AI-Python-matplotlib/image-20230820184059753.png" class="" title="img"><h2 id="总结">总结</h2><p>今天的课程到这里也就结束了。最后让我们来总结一下</p><img src="/AI-Python-matplotlib/Matplotlib.png" class="" title="img"><p>最后，我们留个作业吧，好久没留作业了。将咱们之前做的这个饼图加上阴影，扩大分离的那块区域的分离距离。如图：</p><img src="/AI-Python-matplotlib/image-20230820185156935.png" class="" title="img"><p>小伙伴们，记得认真学习并且完成作业。</p><p>好，下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/AI-Python-matplotlib/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>24. 装饰器语法与应用</title>
    <link href="https://hivan.me/Decorator-syntax-and-application/"/>
    <id>https://hivan.me/Decorator-syntax-and-application/</id>
    <published>2023-08-19T03:58:10.000Z</published>
    <updated>2023-08-19T11:54:04.361Z</updated>
    
    <content type="html"><![CDATA[<img src="/Decorator-syntax-and-application/cover.png" class="" title="img"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>在最近几期的课程中，相信小伙伴们都频繁的看到一个词：「装饰器」，那到底什么是装饰器，又有什么作用呢？我们这节课，就来好好的来了解一下。</p><h2 id="装饰器定义">装饰器定义</h2><p>装饰器就是在<strong>不改变原有函数代码，且保持原函数调用方法不变的情况下，给原函数增加新的功能（或者给类增加属性和方法）。</strong></p><p><strong>核心思想：</strong>用一个函数（或者类）去装饰一个旧函数（或者类），造出一个新函数（或者新类）。</p><p><strong>应用场景：</strong>引入日子，函数执行时间的统计，执行函数钱的准备工作，执行函数后的处理工作，权限校验，缓存等。</p><p><strong>语法规则：</strong>在原有的函数上加上<code>@</code>符，装饰器会把下面的函数当作参数传递到装饰器中，<code>@</code>符又被称为「语法糖」。</p><h3 id="装饰器原型">装饰器原型</h3><p>装饰器其实就是利用闭包，把函数当作参数传递，并在在函数内去调用传递进来的函数，并返回一个函数。</p><p>来，我们还是用代码来学习，先让我们定义一个普通函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个普通函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">old</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个普通的函数&#x27;</span>)<br><br>old() <span class="hljs-comment"># 作为普通函数直接调用</span><br><br>---<br>我是一个普通的函数<br></code></pre></td></tr></table></figure><p>现在让我们定义一个嵌套函数，分为外函数和内函数两部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义外函数，接受一个函数作为参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-comment"># 定义内函数， 并且在内函数中调用了外函数的参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是外函数中的内函数1&#x27;</span>)<br>        f()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是外函数中的内函数2&#x27;</span>)<br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>这里面我们在内函数中打印了两句话，在两句话中间执行了一次外函数的参数（传递进来一个函数）。最后讲内函数作为参数返回。</p><p>然后我们讲刚才的普通函数<code>old</code>作为参数传进去，然后再用外函数返回的<code>inner</code>内函数重新赋值普通函数<code>old</code>，最后让我们再执行一遍<code>old</code>函数,这个时候，因为<code>old</code>被重新赋值，其实等同于调用了<code>inner</code>函数。来，我们看看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">old = outer(old) <span class="hljs-comment"># outer返回了inner函数，赋值给了old</span><br>old()<br><br>---<br>我是外函数中的内函数<span class="hljs-number">1</span><br>我是一个普通的函数<br>我是外函数中的内函数<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>是不是稍显繁杂？那让我们换个思路，现在我们已经先定义好了<code>outer</code>he<code>inter</code>，两者关系不变。还是之前那些代码，那么我们如何利用装饰器来进行调用呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装饰器用法</span><br><span class="hljs-meta">@outer </span><span class="hljs-comment"># 此处将outer作为了装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">old</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个普通的函数&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们在定义<code>old</code>函数的时候，直接加上一个<code>@</code>语法糖，就将<code>outer</code>作为了装饰器。这个装饰器的作用就等同于<code>old = outer(old)</code>。那让我们打印看看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">old()<br><br>---<br>我是外函数中的内函数<span class="hljs-number">1</span><br>我是一个普通的函数<br>我是外函数中的内函数<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>那我们现在完成了装饰器的用法，按照定义，我们在不改变<code>old</code>函数的代码，且保持了<code>old</code>函数调用方法不变的情况下，增加了新的方法<code>outer</code>。</p><p><code>old</code>函数经过<code>outer</code>装饰器进行了装饰，代码和调用方法不变，但是函数的功能发生了改变。</p><p>你是不是这个时候又有疑问了，那装饰器要用在什么地方呢？让我们来实现一个应用：</p><h3id="装饰器应用统计函数的执行时间">装饰器应用：统计函数的执行时间</h3><p>在正式写代码之前，我还是习惯带着大家先思考一遍。我们需要统计函数的执行时间，那我们需要什么关键点？</p><ol type="1"><li>开始时间，</li><li>结束时间</li><li>开始时间和结束时间之间，就是程序在运行的过程。</li></ol><p>好的，让我们来开始写代码，先来一段简单的需要运行的程序，为了能顺利统计时间，我们给它设定两个东西，一个循环，一个停止运行时长。这样，我们不会因为程序运行过快而看不到结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 定义一个普通函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>函数写完之后，让我们来执行一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">func()<br><br>---<br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><img src="/Decorator-syntax-and-application/5sec_func.gif" class="" title="img"><p>没问题，确实是一秒打印一次。</p><p>现在，再来让我们完成要称为装饰器的统计函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 定义一个统计函数执行时间的装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">runtime</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        start = time.perf_counter()<br>        f()<br>        end = time.perf_counter() - start<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\n函数的调用执行时间为：<span class="hljs-subst">&#123;end&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>在函数<code>inner</code>中，我们最终是打印了最终的时间<code>end</code>，然后将整个<code>inner</code>函数返回。</p><p>那么，让我们来尝试执行一下看看吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">func = runtime(func)<br>func()<br><br>---<br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br>函数的调用执行时间为：<span class="hljs-number">5.017943917075172</span><br></code></pre></td></tr></table></figure><p>这样，我们就得到了<code>func</code>这个函数最后执行的时间，那现在的问题是，统计时间的函数是一个通用函数，我们很多函数中都需要用到它进行统计。但是我们总不能所有的函数都要用这种方法重新赋值之后再调用吧？</p><p>那我们就用装饰器来解决就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个普通函数</span><br><span class="hljs-meta">@runtime</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <br>func()<br><br>---<br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <br>函数的调用执行时间为：<span class="hljs-number">5.017888417001814</span><br></code></pre></td></tr></table></figure><p>当然，最终这种函数的调用执行时间并不会像现在这样打印到前台，而是会写进<code>log</code>变为日志存储起来，便于之后分析使用。</p><h3 id="装饰器嵌套语法">装饰器嵌套语法</h3><p>在这一段代码中，我们来约个妹子，完成一场约会。从哪开始呢？就从找妹子要微信开始吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">begin</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">begin_inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;找妹子要微信，成功...&#x27;</span>)<br>        f()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;送妹子回家...&#x27;</span>)<br>    <span class="hljs-keyword">return</span> begin_inner<br>    <br><span class="hljs-meta">@begin</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;跟妹子畅谈人生和理想...&#x27;</span>)<br><br>love()<br><br>---<br>找妹子要微信，成功...<br>跟妹子畅谈人生和理想...<br>送妹子回家...<br></code></pre></td></tr></table></figure><p>那这样，我们实现了一段最普通装饰器的定义。现在让我们在下面再定义一个装饰器函数，为什么呢？因为我渐渐不满足于只谈理想和人生了，要有点实际的行动了,顺便，我们写了一个列表，把和妹子要做的事情都列了个顺序，再来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">begin</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">begin_inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;找妹子要微信，成功... 1&#x27;</span>)<br>        f()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;送妹子回家... 5&#x27;</span>)<br>    <span class="hljs-keyword">return</span> begin_inner<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evolve</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">evolve_inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;和妹子一起吃了个大餐.. 2&#x27;</span>)<br>        f()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;和妹子看了一场夜场电影... 4&#x27;</span>)<br>    <span class="hljs-keyword">return</span> evolve_inner<br><br><span class="hljs-meta">@evolve</span><br><span class="hljs-meta">@begin</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;跟妹子畅谈人生和理想... 3&#x27;</span>)<br><br>love()<br><br>---<br>和妹子一起吃了个大餐.. <span class="hljs-number">2</span><br>找妹子要微信，成功... <span class="hljs-number">1</span><br>跟妹子畅谈人生和理想... <span class="hljs-number">3</span><br>送妹子回家... <span class="hljs-number">5</span><br>和妹子看了一场夜场电影... <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个...顺序似乎不太对啊。让我们改变一下装饰器的顺序试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@begin</span><br><span class="hljs-meta">@evolve</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;跟妹子畅谈人生和理想... 3&#x27;</span>)<br><br>love()<br><br>---<br>找妹子要微信，成功... <span class="hljs-number">1</span><br>和妹子一起吃了个大餐.. <span class="hljs-number">2</span><br>跟妹子畅谈人生和理想... <span class="hljs-number">3</span><br>和妹子看了一场夜场电影... <span class="hljs-number">4</span><br>送妹子回家... <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>这回没错了，我们在最开始要妹子微信和最后送妹子回家中间，又进行了点什么。也算是有些进展了。那么，我们怎么去理解这个程序运行顺序呢？</p><ol type="1"><li>先使用离得最近的<code>begin</code>装饰器，装饰<code>love</code>函数，返回了一个<code>begin_inner</code>函数</li><li>在使用上面的<code>evolve</code>,装饰了上一次返回的<code>begin_inner</code>函数，又返回了一个<code>evolve_inner</code>函数。</li></ol><p>在调用完成之后，就是需要顺序执行了，其执行的嵌套关系和顺序如下：</p><img src="/Decorator-syntax-and-application/love_func.png" class="" title="img"><p>那这，就是我们嵌套装饰器的用法。当然，这种嵌套装饰器的用法并不常见，可是一旦我们遇到了，要理解他的运行机制和顺序，避免不必要的麻烦。</p><h4 id="装饰带有参数的函数">装饰带有参数的函数</h4><p>上一个部分，我们做了一个约会妹子的函数，并且使用装饰器进行了装饰。使的我们成功的按照进度依次执行了自己的计划。</p><p>但是问题来了，我们到目前为止约会了那么多妹子，都不知道谁是谁（海王体质），这可怎么办。这次，我们吸取教训，先要名字，既然之前的流程很成功，我们直接拿来使用就行了。但是繁杂的步骤我们都去掉，直奔主题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 带有参数的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;跟<span class="hljs-subst">&#123;name&#125;</span>妹子在___畅谈人生...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>一个简单的函数，并且是一个填空题，你愿意待谁去哪里畅谈人生，随便。比如我，找「露思」去，去了哪里，恕不奉告了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">love(<span class="hljs-string">&#x27;露思&#x27;</span>)<br><br>---<br>跟露思妹子在___畅谈人生...<br></code></pre></td></tr></table></figure><p>可是即便如此，该有的流程还是不能丢，总不能凭空变出个妹子吧，还是得把必要的流程加上，原本定义的装饰器函数似乎不能使用了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;找到妹子，成功的拿到了微信...&#x27;</span>)<br>        f()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;约妹子去看一场午夜电影...&#x27;</span>)<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@outer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;跟<span class="hljs-subst">&#123;name&#125;</span>妹子在___畅谈人生...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>流程上现在是没问题了，可是我们执行一下发现，报错了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">love(<span class="hljs-string">&#x27;露思&#x27;</span>)<br><br>---<br>TypeError: outer..inner() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p>进行不下去了吧？那没办法，谁叫你之前和之后都把人家名字忘了呢，海王也得有点职业道德才行。既然我们在执行的时候有参数，那你整个过程中都得带上才行。不能玩着玩着忘记人家名字，对吧。让我们改进一下，既然我们已经知道，在使用装饰器装饰过后的<code>love()</code>执行实际上是执行装饰器<code>inner</code>，那我们尝试给<code>inner</code>加上参数进行传递，还有很重要的，我们之前和之后，得把妹子名字记清楚才行，所以执行的时候也记得加上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义装饰器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">var</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;找到<span class="hljs-subst">&#123;var&#125;</span>妹子，成功的拿到了微信...&#x27;</span>)<br>        f(var)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;约<span class="hljs-subst">&#123;var&#125;</span>妹子去看一场午夜电影...&#x27;</span>)<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-comment"># 带有参数的函数</span><br><span class="hljs-meta">@outer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>(<span class="hljs-params">name</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;跟<span class="hljs-subst">&#123;name&#125;</span>妹子在___畅谈人生...&#x27;</span>)<br><br>love(<span class="hljs-string">&#x27;露思&#x27;</span>)<br><br>---<br>找到露思妹子，成功的拿到了微信...<br>跟露思妹子在___畅谈人生...<br>约露思妹子去看一场午夜电影...<br></code></pre></td></tr></table></figure><p>嗯，这样一场和「露思」妹子之间完美的从认识到约会流程就完成了。我们总结一下：</p><p><strong>如果装饰器带有参数的函数，需要在内函数中定义形参，并传递给调用的函数。因为调用原函数等于调用内函数。</strong></p><h3 id="装饰多参数的函数">装饰多参数的函数</h3><p>上一个流程跑完之后呢，我觉得还是不太妥当。主要是其中有两个选择题，一个是谁，一个是去哪里。对吧。再说了，我也得跟妹子自我介绍一下，加强一点印象。</p><p>好，我们这次再多设置几个参数，让整个约会过程更完善一些，那我们从最初就要规划一下，需要的参数包括：<code>我，妹子，地点，行为</code>等等。还蛮多的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装饰带有多参数的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">f</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">man,name,*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;man&#125;</span>要到了<span class="hljs-subst">&#123;name&#125;</span>妹子的微信...&#x27;</span>)<br>        f(man, name, *args, **kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;天色渐晚...&#x27;</span>)<br>    <span class="hljs-keyword">return</span> inner<br><br><span class="hljs-comment"># 定义多参数的函数</span><br><span class="hljs-meta">@outer</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>(<span class="hljs-params">man, name, *args, **kwargs</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;man&#125;</span>跟<span class="hljs-subst">&#123;name&#125;</span>畅谈人生...&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;带<span class="hljs-subst">&#123;name&#125;</span>妹子去吃了很多美食：&#x27;</span>, args)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;和<span class="hljs-subst">&#123;name&#125;</span>妹子看了夜场电影:&#x27;</span>, kwargs)<br></code></pre></td></tr></table></figure><p>这样我们就定义好了，至于<code>*args</code>以及<code>**kwargs</code>是什么，可以翻看之前的教程。</p><p>让我们现在来执行一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">love(<span class="hljs-string">&#x27;茶桁&#x27;</span>,<span class="hljs-string">&#x27;露思&#x27;</span>, <span class="hljs-string">&#x27;火锅&#x27;</span>, <span class="hljs-string">&#x27;海鲜&#x27;</span>, <span class="hljs-string">&#x27;饭后甜点&#x27;</span>, mov=<span class="hljs-string">&#x27;封神第一部&#x27;</span>)<br><br>---<br>茶桁要到了露思妹子的微信...<br>茶桁跟露思畅谈人生...<br>带着露思妹子去吃了很多美食： (<span class="hljs-string">&#x27;火锅&#x27;</span>, <span class="hljs-string">&#x27;海鲜&#x27;</span>, <span class="hljs-string">&#x27;饭后甜点&#x27;</span>)<br>和露思妹子看了夜场电影: &#123;<span class="hljs-string">&#x27;mov&#x27;</span>: <span class="hljs-string">&#x27;封神第一部&#x27;</span>&#125;<br>天色渐晚...<br></code></pre></td></tr></table></figure><p>这样，多道选择题就被我们一一的化解了。相信「露思」妹子对我们的整体安排也是相当的满意了。</p><h3 id="带有参数的装饰器">带有参数的装饰器</h3><p>在我们平时使用Python各种第三方库的时候，不可避免的会遇到带有参数的装饰器。比如说，<code>Django</code>框架中的<ahref="https://docs.djangoproject.com/en/4.2/topics/auth/default/#how-to-log-a-user-in"><code>@login_required(redirect_field_name="my_redirect_field")</code></a>。</p><img src="/Decorator-syntax-and-application/image-20230819183310594.png" class="" title="img"><p>这种带有参数的装饰器是干嘛的呢？还是拿我们之前的<del>海王</del>约会流程来举例。之前的流程是都没有什么问题，可是有没有发现，所有事情都是我们自己做主了，似乎妹子一直都没有反对过，也没有说自己想要什么。这是不是不太符合现实？</p><p>没错，我们也要给妹子装上一个会思考的大脑，也要学会做判断，好，让我们来实现一下：</p><p>既然我们这节是学习带有参数的装饰器，那么必然装饰器上是带参数的。呃，不要认为这句话是废话，我们看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@put(<span class="hljs-params">var</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;畅谈人生...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>就像这样，我们给装饰器加上了参数。</p><p>那么现在问题就来了，我们来看看我们之前写的装饰器函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">f</span>):<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>    <span class="hljs-keyword">pass</span><br>  <span class="hljs-keyword">return</span> inner<br></code></pre></td></tr></table></figure><p>发现有什么问题了么？虽然我们的外层函数<code>outer</code>是有形参的，但是我们之前的过程中了解到，这个形参<code>f</code>是为了接收当前执行函数的。那还有什么其他地方接收非函数的普通参数嘛？</p><p>既然<code>outer</code>中很重要的作用，除了接收函数在内函数内执行，还有一个就是返回<code>inner</code>内函数，那么我们在不改变<code>outer</code>的基础之上，再加一个接收普通参数的函数不就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">var</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner1</span>():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;妹子给了你微信&#x27;</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner2</span>():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;妹子给了你她闺蜜的微信&#x27;</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner3</span>():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;妹子送了你一句感人肺腑的话：滚...&#x27;</span>)<br><br>        <span class="hljs-comment"># 装饰器壳的参数，可以用于在函数内去做流程控制。</span><br>        <span class="hljs-keyword">if</span> var == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> inner1<br>        <span class="hljs-keyword">elif</span> var == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> inner2<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> inner3<br>    <span class="hljs-keyword">return</span> outer<br><br><span class="hljs-meta">@put(<span class="hljs-params"><span class="hljs-number">2</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;畅谈人生...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>定义完成之后，我们来执行一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">love()<br><br>---<br>妹子给了你她闺蜜的微信<br></code></pre></td></tr></table></figure><p>家人们谁懂啊，妹子真把我当海王了嘛？最后，我还是老老实实的接受了妹子的好意。</p><p>从整段代码中我们可以看出来，如果装饰器中有参数，需要有一个外壳函数来接收参数，传参之后就会进入到下一层函数中，并且传递当前对象。再然后才会再进入下一层中去。当然，我们在这里，利用传递的参数写了一段<code>if</code>判断，用于确定妹子的决定是什么。然后我们就返回哪个决定的函数。最后别忘记，在外壳函数中，我们还需要讲<code>outer</code>函数返回出去。此时虽然<code>love</code>函数是<code>outer</code>函数，但是在之前，<code>put</code>装饰器已经将参数传递给了外壳函数<code>put(var)</code>。在装饰器函数的争端代码中，我们都没有再执行过传进来的参数，也就是函数<code>love()</code>，所以此段代码中<code>love</code>函数中的打印方法并未执行。</p><p>其执行步骤为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">put(var) =&gt; outer() =&gt; outer(love) =&gt; inner2()<br></code></pre></td></tr></table></figure><h3 id="用类装饰器装饰函数">用类装饰器装饰函数</h3><p>之前我们所有的代码中，装饰器一直使用的都是函数装饰器。那我们能否用类来当装饰器装饰函数呢？</p><p>试试不就知道了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类装饰器装饰函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):<br>        self.func = func<br>        <span class="hljs-keyword">return</span> self.inner<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">self, who</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;拿到妹子的微信...&#x27;</span>)<br>        self.func(who)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;看一场午夜电影...&#x27;</span>)<br><span class="hljs-meta">@Outer()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>(<span class="hljs-params">who</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;who&#125;</span>和妹子谈理想与人生...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>写完了，这下我们省略了那么多杂七杂八的流程，因为我发现，那么多流程下来，最终感动的人只有自己。妹子愿意，怎么都愿意，不愿意的，无论做多少都不愿意。</p><p>来，让我们跑一下程序试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">love(<span class="hljs-string">&#x27;茶桁&#x27;</span>)<br><br>---<br>拿到妹子的微信...<br>茶桁和妹子谈理想与人生...<br>看一场午夜电影...<br></code></pre></td></tr></table></figure><p>没问题，正确的执行。那这个时候的<code>love</code>函数到底是什么呢？我们来打印出来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(love)<br><br>---<br>&lt;bound method Outer.inner of &lt;__main__.Outer <span class="hljs-built_in">object</span> at <span class="hljs-number">0x106646c80</span>&gt;&gt;<br></code></pre></td></tr></table></figure><p>可以看到，此时的<code>love</code>函数就是<code>Outer</code>类中的<code>inner</code>函数。那我们怎么理解整个代码呢？</p><p>我们在<code>love</code>函数上使用了装饰器<code>Outer</code>,那么这个时候<code>Outer</code>就会实例化出来一个对象<code>obj</code>，然后这个<code>@obj</code>就等同于<code>obj(love)</code>。</p><p>然后我们实例化对象进入<code>Outer()</code>内部，进入之后遇到了魔术方法<code>__call__</code>,它会把该类的对象当作函数调用时自动触发。也就是<code>obj()</code>触发。</p><p>还记得类的实例化么？会传入一个参数，也就是实例化对象本身：<code>obj</code>。并且，第二个参数<code>func</code>用来接收了传递进来的函数<code>love</code>，设置了<code>self.func = func</code>,把传进来的函数作为对象的成员方法。最后返回了一个函数<code>inner</code>，这个返回的函数是类中定义好的，于是作为实例化对象也将这个成员方法继承了下来，所以<code>self.inner</code>可以直接被返回出去。</p><p>这个定义好的<code>inner</code>接收了两个形参，一个是实例化对象本身，一个就是传递进来的函数<code>love</code>的参数<code>who</code>。然后，中间执行了一下魔术方法<code>__call__</code>内定义好的<code>self.func(who)</code>，实际上也就是<code>obj.love(who)</code>。</p><p>看着迷糊？这样，我写一个注释过的完整版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 类装饰器装饰函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>():<br><br>    <span class="hljs-comment"># 魔术方法：当把该类的对象当作函数调用时，自动触发obj()</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, func</span>):<br>        <span class="hljs-comment"># 把传进来的函数作为对象的成员方法</span><br>        self.func = func <br>        <span class="hljs-comment"># 返回一个函数</span><br>        <span class="hljs-keyword">return</span> self.inner<br>    <br>    <span class="hljs-comment"># 在定义的需要返回的新方法中，去进行装饰和处理</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">self, who</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;拿到妹子的微信...&#x27;</span>)<br>        self.func(who)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;看一场午夜电影...&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Outer() 实例化对象 =&gt; obj</span><br><span class="hljs-string">@obj 就等于 obj(love)</span><br><span class="hljs-string">进入类后 =&gt; __call__(love)</span><br><span class="hljs-string">接收返回参数`inner()`</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-meta">@Outer()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>(<span class="hljs-params">who</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;who&#125;</span>和妹子谈理想与人生...&#x27;</span>)<br><br><span class="hljs-comment"># inner(&#x27;茶桁&#x27;)</span><br>love(<span class="hljs-string">&#x27;茶桁&#x27;</span>)<br><span class="hljs-comment"># 此时的love就是属于`Outer`类这个对象中的inner方法</span><br><span class="hljs-built_in">print</span>(love)<br></code></pre></td></tr></table></figure><p>不知道这段注释代码加上刚才的解说，大家能否看懂？有没有发现，用类做装饰器比起函数装饰器反而更清晰一点？不需要写那么多外层函数和内层函数。</p><p>让我们继续...</p><h3 id="类方法装饰函数">类方法装饰函数</h3><p>刚才我们将整个类都用作了一个装饰器，那我们思考一下，是不是我们还可以用类中的方法来做装饰器呢？</p><p>说干就干，直接上代码测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用类方法装饰函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">newinner</span>(<span class="hljs-params">f</span>):<br>        <span class="hljs-comment"># 把传递进来的函数定义为类方法</span><br>        Outer.func = f<br>        <span class="hljs-comment"># 同时返回一个新的类方法</span><br>        <span class="hljs-keyword">return</span> Outer.inner<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;拿到妹子微信...&#x27;</span>)<br>        Outer.func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;看一场午夜电影...&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">Outer.newinner(love) </span><br><span class="hljs-string">接收返回参数：Outer.inner</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-meta">@Outer.newinner</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">love</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;和妹子谈谈人生喝喝茶...&#x27;</span>)<br><span class="hljs-comment"># love() 等于 Outer.inner()</span><br>love()<br><br>---<br>拿到妹子微信...<br>和妹子谈谈人生喝喝茶...<br>看一场午夜电影...<br></code></pre></td></tr></table></figure><p>在经历了几场约会之后，我们的耐心也渐渐没了。连是谁都不管，也没耐心去谈理想了。喝点茶聊聊天就直奔主题了都是。</p><p>到目前为止以上所有形式的装饰器，包括「函数装饰器」、「类装饰器」、「类方法装饰器」，都有一个共同特点：<strong>都是在给函数去进行装饰，增加功能</strong>。</p><p>那我们这个时候就不满足了，既然能装饰函数，那是否也能装饰类呢？</p><h3 id="用装饰器装饰类">用装饰器装饰类</h3><p>还真有一种装饰器是专门装饰类的，也就是在类的定义的前面使用<code>@</code>装饰器这种语法。和装饰函数并无什么区别，只是放在了类前面而已：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@装饰器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>  <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>装饰器给函数进行装饰，目的是不改变函数调用和代码的情况下给原函数增加新的功能。</p><p>装饰器给类进行装饰，目的是不改变类的定义和调用的情况下给类增加新的成员（属性或者方法）。</p><p>来，让我们具体的看看：</p><h3 id="函数装饰器装饰类">函数装饰器装饰类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义函数，接收一个类。返回修改后的类</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">expand</span>(<span class="hljs-params">cls</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是在装饰器中追加的新方法，func2&#x27;</span>)<br>    cls.func2 = func2 <span class="hljs-comment"># 把刚才定义的方法赋值给 类</span><br>    cls.name = <span class="hljs-string">&#x27;我是在装饰器中追加的新属性 name&#x27;</span><br><br>    <span class="hljs-comment"># 返回时，把追加类新成员的类返回去</span><br>    <span class="hljs-keyword">return</span> cls<br><br><br><span class="hljs-meta">@expand   </span><span class="hljs-comment"># expand(Demo) ==&gt; cls ==&gt; Demo</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是Demo类中定义的func方法&#x27;</span>)<br><br>Demo.func() <span class="hljs-comment"># 此时在调用的Demo类是通过装饰器，更新过的Demo类</span><br>Demo.func2()<br><span class="hljs-built_in">print</span>(Demo.name)<br><br>---<br>我是Demo类中定义的func方法<br>我是在装饰器中追加的新方法，func2<br>我是在装饰器中追加的新属性 name<br></code></pre></td></tr></table></figure><p>这样，我们在原来的<code>Demo</code>这个类中，使用装饰器增加了一个成员方法<code>func2</code>，并且增加了一个成员属性<code>name</code>，并最终返回到原始类中。从而扩展了这个原始类<code>Demo</code>中的方法和属性。</p><h3 id="类装饰器装饰类">类装饰器装饰类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用类装饰器装饰类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">expand</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, cls</span>):<br>        <span class="hljs-comment"># 把接收的类，赋值给当前对象，作为一个属性</span><br>        self.cls = cls<br>        <span class="hljs-comment"># 返回一个函数</span><br>        <span class="hljs-keyword">return</span> self.newfunc<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">newfunc</span>(<span class="hljs-params">self</span>):<br>        self.cls.name = <span class="hljs-string">&#x27;我是在类装饰器中追加的新属性 name&#x27;</span><br>        self.cls.func2 = self.func2<br>        <span class="hljs-comment"># 返回传递进来的类的实例化结果，obj</span><br>        <span class="hljs-keyword">return</span> self.cls()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是在类装饰器中追加的新方法 func2&#x27;</span>)<br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">expand() ==&gt; obj ==&gt; @obj(Demo) ==&gt; __call__(Demo) ==&gt; newfunc</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-meta">@expand() </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是Demo类中定义的func方法&#x27;</span>)<br><br>obj = Demo()  <span class="hljs-comment"># Demo() ==&gt; newfunc() ==&gt; obj</span><br>obj.func()<br>obj.func2()<br><span class="hljs-built_in">print</span>(obj.name)<br></code></pre></td></tr></table></figure><p>在之前那么多案例过后，相信大家这一段代码应该能看的出来吧。</p><p>那我这个地方要处一个思考题了，请问：此时的<code>obj</code>这个对象，是哪个类的对象。<code>Demo</code>还是<code>expand</code>?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(obj)<br><br>---<br>???<br></code></pre></td></tr></table></figure><p>这个问题的答案，我放在源码中了，大家要记得思考之后再去看答案。</p><p>那么，本节课的内容到这里也就结束了。</p><p>课程进行到这里，我们Python本身的所有内容就已经介绍完了。下节课开始，我们就要考试讲第三方库。</p><p>好，下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Decorator-syntax-and-application/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>23. 描述符和设计模式</title>
    <link href="https://hivan.me/OOP-Descriptor-and-design-patterns/"/>
    <id>https://hivan.me/OOP-Descriptor-and-design-patterns/</id>
    <published>2023-08-17T16:54:10.000Z</published>
    <updated>2023-08-18T09:53:33.330Z</updated>
    
    <content type="html"><![CDATA[<img src="/OOP-Descriptor-and-design-patterns/cover.png" class="" title="cover"><p>Hi， 大家好，我是茶桁。</p><span id="more"></span><p>上一节课中，我们讲解了面向对象中的一些高阶应用，给大家介绍了一些魔术方法。并在最后，我们预告这节课内容会讲解描述符和设计模式。</p><p>好了，让我们开始吧。</p><h2 id="描述符">描述符</h2><p>这个玩意，怎么讲合适呢？这么说吧，当某一个类中，包含了三个魔术方法（<code>__get__, __set__, __delete__</code>)中的任意一个，或者全部都有时，那么这个类就被称为是「描述符类」。</p><p>描述符的作用就是对一个类中的某一个成员进行一个详细的惯例操作，包括获取、赋值以及删除。也就是，描述符代理了一个类中的成员的操作，描述符属于类，只能定义为类的属性。</p><p>魔术方法咱们前面有提到，这里让咱们先来看看三个特殊的魔术方法，：</p><ol type="1"><li><code>__get__(self, instance, owner)</code></li></ol><p><strong>触发机制</strong>：在访问对象成员属性时自动触发(当该成员已经交给描述符管理时)<strong>作用</strong>：设置当前属性获取的值 <strong>参数</strong>：1.<code>self</code> 描述符对象 2.被管理成员的类的对象。3.被管理成员的类<strong>返回值</strong>：返回值作为成员属性获取的值<strong>注意事项</strong>：无</p><ol start="2" type="1"><li><code>__set__(self, instance, value)</code></li></ol><p><strong>触发机制</strong>：在设置对象成员属性时自动触发(当该成员已经交给描述符管理时)<strong>作用</strong>：对成员的赋值进行管理 <strong>参数</strong>：1.<code>self</code> 描述符对象 2.被管理成员的类的对象。3.要设置的值<strong>返回值：</strong>无 <strong>注意事项</strong>：无</p><ol start="3" type="1"><li><code>__delete__(self, instance)</code></li></ol><p><strong>触发机制</strong>：在删除对象成员属性时自动触发(当该成员已经交给描述符管理时)<strong>作用</strong>：对成员属性的删除进行管理<strong>参数</strong>：1. <code>self</code> 描述符对象2.被管理成员的类的对象。 <strong>返回值</strong>：无<strong>注意事项</strong>：无</p><p>让我们先来看一个基本的类和实例化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>name<br></code></pre></td></tr></table></figure><p>然后我们定义一个「描述符类」</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>():<br>    __name = <span class="hljs-string">&#x27;abc&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>接着我们重新更改一下刚才定义的普通类，将其中的<code>name</code>成员属性交给刚定义的描述符类来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义的普通类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 把类中的一个成员属性交给一个描述符类来实现</span><br>    name = PersonName()<br></code></pre></td></tr></table></figure><p>这个时候我们实例化之后打印其中的成员属性会如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>我们可以看到，结果为<code>None</code>。</p><p>现在让我们依次将类中的<code>__get__</code>方法的参数都打印出来观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改其中的`__get__`方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>    <span class="hljs-built_in">print</span>(self)<br>    <span class="hljs-built_in">print</span>(instance)<br>    <span class="hljs-built_in">print</span>(owner)<br>     <br><span class="hljs-comment"># 实例化后打印</span><br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>&lt;__main__.PersonName <span class="hljs-built_in">object</span> at <span class="hljs-number">0x108931d20</span>&gt;<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x108930250</span>&gt;<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Person&#x27;</span>&gt;<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>现在，具体<code>self, instance, owner</code>各自分别是什么，就非常清楚了。</p><p>那，既然<code>self</code>是<code>PersonName</code>类本身，那我们在其中定义的<code>name</code>成员属性是不是就可以拿到了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>():<br>    __name = <span class="hljs-string">&#x27;abc&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self.__name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义的普通类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 把类中的一个成员属性交给一个描述符类来实现</span><br>    name = PersonName()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>abc<br></code></pre></td></tr></table></figure><p>没错，我们确实拿到了<code>PersonName</code>中的<code>__name</code>。</p><p>我们现在可以这么理解，普通类中的一个成员属性交给了一个描述符类来实现，类中的成员的值是另一个描述符类的对象，那么当对这个类中的成员进行操作时，可以理解为就是对另一个对象的操作。现在的<code>PersonName</code>这个描述符类，相对于一个代理人的角色。把当前的描述符类赋值给了一个需要代理的类中的成员属性。</p><p>既然我们看到了<code>get</code>方法的结果之后，那么剩下两个魔术方法的作用也就很容易想到了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span>():<br>  ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        self.__name = value<br>    ...<br><span class="hljs-comment"># 定义的普通类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>  ...<br>    <br><span class="hljs-comment"># 实例化对象</span><br>...<br>zs.name = <span class="hljs-string">&#x27;张三丰&#x27;</span><br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>abc<br>张三丰<br></code></pre></td></tr></table></figure><p>这里容易理解吧？当我们执行<code>zs.name = ‘张三丰’</code>这个赋值操作的时候，其就是走到了<code>__set__</code>方法内。其中的<code>self</code>不言而喻，就是<code>PersonName</code>，而<code>value</code>就是刚才我们进行赋值操作的那个值。这个时候，我们可以设置<code>self.__name = value</code>，那就是满足了这个赋值操作。当然，我们也可以不这样给，来让我们调戏一下这个赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只改动`__set__`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-comment"># self.__name = value</span><br>        self.__name = <span class="hljs-string">&#x27;茶桁&#x27;</span><br><br>zs.name = <span class="hljs-string">&#x27;张三丰&#x27;</span><br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>茶桁<br></code></pre></td></tr></table></figure><p>当我们这样去改的时候，那么无论我们怎样去赋值，最终的结果都是打印出<code>茶桁</code>。</p><p>那么<code>__del__</code>怎么用呢？我们接着看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前面的代码都不做改动</span><br><br><span class="hljs-keyword">del</span> zs.name<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>茶桁<br>茶桁<br></code></pre></td></tr></table></figure><p>那么第一个茶桁是刚才我们赋值后的打印结果，第二个茶桁呢？就是我们在执行<code>del zs.name</code>之后的打印结果。按道理来说，我们执行了<code>del</code>命令之后。<code>zs</code>这个对象的<code>name</code>成员已经被删除了，现在应该是打印出类中的原始值，也就是<code>abc</code>,那为什么这里打印出来的还是<code>茶桁</code>呢？</p><p>原因就在于我们的<code>__del__</code>方法内没有任何操作。我们来改一下<code>__del__</code>内部：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只改动`__del__`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-comment"># print(&#x27;我就是不行删除，气死你&#x27;)</span><br>        <span class="hljs-keyword">del</span> self.__name<br><br><span class="hljs-keyword">del</span> zs.name<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>abc<br></code></pre></td></tr></table></figure><p>这样我们就执行了<code>del</code>本该有的操作。不过大家也看到了，我中间有一段代码注释了，现在让我们替换一下注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只改动`__del__`</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我就是不行删除，气死你&#x27;</span>)<br>        <span class="hljs-comment"># del self.__name</span><br><br><span class="hljs-keyword">del</span> zs.name<br><br>---<br>我就是不行删除，气死你<br></code></pre></td></tr></table></figure><p>当我们执行<code>del zs.name</code>的时候，触发方法内的打印命令。那么，这个时候再让我们打印一下<code>zs.name</code>来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>茶桁<br></code></pre></td></tr></table></figure><p>毫无意外的，茶桁还在，并没有变成<code>abc</code>。</p><p>需要注意的是，同时具备三个魔术方法的类才是「数据描述符类」，没有同时具备三个魔术方法的类呢？很简单，就是「非数据描述符类」。两者的区别就是一个是完整的，一个是不完整的。可以不可以应用呢？部分可以，但是不完整，<code>__get__</code>,<code>__set__</code>,<code>__delete__</code>中总有某些功能无法实现。</p><h3 id="一个描述符应用">一个描述符应用</h3><p>了解了描述符的概念以及怎么使用之后，我们来试试实现一个应用：<code>定义一个学生类，需要记录学员的id, 名字和分数。</code></p><p>让我们先来起一个框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self.score = score<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>    <br><span class="hljs-comment"># 实例化对象</span><br>zs = Student(<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">98</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>学员编号:<span class="hljs-number">37</span><br>学员姓名:张三丰<br>学员分数:<span class="hljs-number">98</span><br></code></pre></td></tr></table></figure><p>这里，我们对这个方法有一个要求，就是学员的分数只能在0-100范围中,那其实很简单了对吧？</p><p>我们先来看看第一种最普通的实现方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        <span class="hljs-comment"># 检测分数范围</span><br>        <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> score &lt;= <span class="hljs-number">100</span>:<br>            self.score = score<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前分数不符号要求。&#x27;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>    <br><span class="hljs-comment"># 实例化对象</span><br>zs = Student(<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">101</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>当前分数不符号要求。<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;score&#x27;</span><br></code></pre></td></tr></table></figure><p>尝试一下，确实打印了“分数不符合要求”，同时报错。</p><p>先不说怎么解决报错的问题，这简单的解决方案只能适用于对象初始化的时候有效。如果我们是中间单独对成员属性进行赋值，那么就会失效了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>zs.score = -<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>学员编号:<span class="hljs-number">37</span><br>学员姓名:张三丰<br>学员分数:-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>那这个时候，大家还记不记得咱们之前学过的一个魔术方法<code>setattr</code>?我们来给中间加一个<code>__setattr__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>    <span class="hljs-comment"># 检测是否给score进行赋值操作</span><br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">&#x27;score&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(key, value)<br>        <span class="hljs-comment"># 检测分数范围</span><br>        <span class="hljs-keyword">if</span> value &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> value &lt;= <span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">object</span>.__setattr__(self, key, value)    <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前分数不符号要求。&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">object</span>.__setattr__(self, key, value)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>    info = <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>    <span class="hljs-keyword">return</span> info<br><br>...<br>zs.score = -<span class="hljs-number">1</span><br><br>---<br>score -<span class="hljs-number">1</span><br>当前分数不符合要求<br></code></pre></td></tr></table></figure><p>我们这样就使用<code>__setattr__</code>方法，检测如果<code>score</code>分数进行赋值时候，进行了分数的检测判断。</p><p>那我们在看，现在的一个问题是，假如学员的分数不止一个，我需要赋值多个分数怎么办？当前学员有：语文，数学，英语分数。</p><p>另外就是当前这个类中的代码是否比较繁杂？</p><p>现在，我们再来看，思考一下使用描述符来代理我们的分数这个成员属性。让我们先来实现一下框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>():<br>    __score = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">del</span> self.__score<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    score = Score()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">returnSelf</span>(<span class="hljs-params">self</span>):<br>        info = <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>        <span class="hljs-keyword">return</span> info<br></code></pre></td></tr></table></figure><p>框架就实现好了，我们将原始的普通类中的<code>score</code>代理给了描述符类<code>Score()</code>。</p><p>那现在让我们来完善一下整个类中的方法。</p><p>首先，当我们进行获取的时候，直接<code>return</code>现有的值就可以了，当我们进行设置的时候，就需要进行判断，如果不符合要求就打印一个不符合要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义描述符类，代理分数的管理</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span>():<br>    __score = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">return</span> self.__score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">if</span> value &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> value &lt;= <span class="hljs-number">100</span>:<br>            self.__score = value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;分数不符合要求&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">del</span> self.__score<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    score = Score()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self.score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">returnSelf</span>(<span class="hljs-params">self</span>):<br>        info = <span class="hljs-string">f&#x27;学员编号:<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>\n学员姓名:<span class="hljs-subst">&#123;self.name&#125;</span>\n学员分数:<span class="hljs-subst">&#123;self.score&#125;</span>&#x27;</span> <br>        <span class="hljs-keyword">return</span> info<br></code></pre></td></tr></table></figure><p>让我们对其进行一下检测，看看是不是符合要求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化对象</span><br>zs = Student(<span class="hljs-number">37</span>, <span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">132</span>)<br>zs.returnSelf()<br><br>---<br>分数不符合要求<br><span class="hljs-string">&#x27;学员编号:37\n学员姓名:张三丰\n学员分数:None&#x27;</span><br></code></pre></td></tr></table></figure><p>没毛病，被告知了当前赋值不符合要求，并且最后分数上也为<code>None</code>，并未进行赋值。</p><p>在看看单独赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">zs.score = -<span class="hljs-number">1</span><br>zs.score = <span class="hljs-number">88</span><br>zs.returnSelf()<br><br>---<br>分数不符合要求<br><br><span class="hljs-string">&#x27;学员编号:37\n学员姓名:张三丰\n学员分数:88&#x27;</span><br></code></pre></td></tr></table></figure><p>当赋值为<code>-1</code>的时候也是提示不符合要求，再次赋值<code>88</code>之后，正确赋值。然后我们打印出来的结果也正确。</p><p>那么我们的代理就正确的完成了它的工作。基本工作流程如下：</p><ol type="1"><li>定义<code>Score</code>描述符类</li><li>把学生类中的<code>score</code>这个成员交给描述符类进行代理</li><li>只要在代理的描述符中对分数进行判断和赋值就可以了。</li></ol><p>那么现在，我们就完成了一个描述符的应用案例。不知道大家是否都理解了？那么在下面，我给大家介绍一下描述符的三种定义格式：</p><ul><li><strong>格式一： 通过定义描述符来实现（推荐）</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScoreManage</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self, instance, owner</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__set__</span>(<span class="hljs-params">self, instance, value</span>):<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delete__</span>(<span class="hljs-params">self, instance</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    score = ScoreManage()<br></code></pre></td></tr></table></figure><ul><li>格式二： 使用<code>property</code>函数来实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, <span class="hljs-built_in">id</span>, name, score</span>):<br>        self.<span class="hljs-built_in">id</span> = <span class="hljs-built_in">id</span><br>        self.name = name<br>        self._score = score<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getScore</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._score<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setScore</span>(<span class="hljs-params">self, score</span>):<br>        self._score = score<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delScore</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">del</span> self._score<br><br>    <span class="hljs-comment"># 在 property 函数中指定对应的三个方法</span><br>    <span class="hljs-comment"># 对应的方法 1. `__get__`，2. `__set__`, 3. `__delete__`</span><br>    <span class="hljs-comment"># 当然，名称不是固定的，也可以定义成其他的方法名</span><br>    <span class="hljs-comment"># 不管定义成什么，`property`中的方法名必须一致。</span><br>    <span class="hljs-comment"># 注意在类中将成员属性重新定义，可以为受保护的或者私有属性，避免递归调用。</span><br>    score = <span class="hljs-built_in">property</span>(getscore,setscore,delscore)<br><br></code></pre></td></tr></table></figure><ul><li>格式三：使用<code>@property</code>装饰器语法来实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>():<br>    __score = <span class="hljs-literal">None</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;get&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.__score<br><br><span class="hljs-meta">    @score.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self,value</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;set&#x27;</span>)<br>        self.__score = value<br><br><span class="hljs-meta">    @score.deleter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;delete&#x27;</span>)<br>        <span class="hljs-keyword">del</span> self.__score<br></code></pre></td></tr></table></figure><h2 id="设计模式">设计模式</h2><p>我们谈设计模式的时候，实际上是一个比较抽象的东西。</p><blockquote><p>设计模式，就是前人完成某个功能或者需求，根据经验和总结，对实现的代码步骤和代码设计进行了总结及归纳。成为了实现某个需求的经典模式。</p></blockquote><p>设计模式可以说并不是什么固定的代码格式，而是一种面向对象编程的设计。</p><p>让我们先从单例开始。</p><h3 id="单例单态设计模式">单例（单态）设计模式</h3><p>在当前脚本中，同一个类只能创建一个对象去使用，这种情况就称为单例（单态）。</p><p>我们以一个实际的思考案例来进行讲解，现在让我们来想：</p><p>单例和婚姻法的关系，特别像，就是一个人只能有一个结婚对象。在社会中是如何完成一夫一妻制的？如果想要结婚，必须要到民政局登记，民政局需要检测两个人的户口本，看看上面是否属于已婚的状态。如果是已婚，肯定就被撵出去了对吧。如果没有结婚，就可以盖章登记了。</p><p>那么按照这样的思路，我们又该如何去实现Python中的单例设计模式呢？来看哈：</p><ol type="1"><li><p>需要一个方法，可以去控制当前对象的创建过程：构建方法<code>__new__</code></p></li><li><p>需要有一个标识来存储和表示是否有对象：创建一个私有属性进行存储，默认为<code>None</code>；</p></li><li><p>在创建对象的方法中去检测和判断是否有对象：如果没有对象，则创建对象，并且将对象存储起来，返回对象。那如果存储的是对象，则直接返回对象，就不需要创建新的对象了。</p></li></ol><p>让我们依照这样一个思路来完成代码，让我们还是从框架开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> cls.obj<br></code></pre></td></tr></table></figure><p>第一步我们完成了，现在让我们来看第二部，我们需要定义一个私有属性用于存储对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 定义私有属性存储对象</span><br>    __obj = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> cls.__obj<br></code></pre></td></tr></table></figure><p>接着，就要进入判断了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 定义私有属性存储对象</span><br>    __obj = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 定义构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 创建对象的过程中，判断是否有对象</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__obj:<br>            <span class="hljs-comment"># 如果没有，则创建，并且存储起来</span><br>            cls.__obj = <span class="hljs-built_in">object</span>.__new__(cls)<br>        <span class="hljs-keyword">return</span> cls.__obj<br></code></pre></td></tr></table></figure><p>类完成了，让我们来证实一下看看，是否只会创建一个对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化对象</span><br>a = Demo()<br>b = Demo()<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10434e950</span>&gt;<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10434e950</span>&gt;<br></code></pre></td></tr></table></figure><p>看到打印结果中，两次实例化对象不同，但是地址相同。可以证明确实为一个对象。</p><h3 id="mixin类">Mixin类</h3><ul><li><code>Mixin</code> 必须是表示一种功能，而不是一个对象。</li><li><code>Mixin</code>的功能必须单一，如果有多个功能，那就多定义<code>Mixin</code>类</li><li>python 中的<code>Mixin</code>是通过多继承实现的</li><li><code>Mixin</code>这个类通常不单独使用，而是混合到其它类中，去增加功能的</li><li><code>Mixin</code>类不依赖子类的实现，即便子类没有继承这个<code>Mixin</code>,子类也能正常运行，可能就是缺少了一些功能。。</li></ul><p>那使用<code>Mixin</code>混入类有什么好处呢？</p><p>这个混入类的设计模式，在不对类的内容修改的前提下，扩展了类的功能。也提高代码的重用性，使的代码结构更加的简单清晰。可以根据开发需要任意调整功能（也就是创建新的<code>Mixin</code>混入类），避免设计多层次的复杂的继承关系。</p><p>我们之前学习继承，知道继承需要有一个必要的前提，就是继承应该是一个<code>is-a</code>的关系。</p><p>比如，苹果可以去继承水果，因为苹果<code>is a</code>水果，那苹果是不能继承午饭的，因为午饭可以有苹果，也可以没有。</p><p>再比如，汽车可以继承交通工具，又是因为汽车本身<code>is a</code>交通工具。</p><p>遵循这样的一个规律，我们来思考，交通工具都有哪些呢？</p><p>汽车、飞机、直升飞机，这些都属于交通工具对吧？当然，高铁什么的也是，我们无法穷举出来，那样就太多了。</p><p>那么如何去设计这些类的关系呢？我们可以创建一个交通工具类，然后属于交通工具的都来继承，再去实现...等等，我们再来思考一个问题：飞机、直升飞机都可以飞，可是汽车呢？汽车并不能飞行。那么交通工具中如果去定义飞行这个功能，是不是就不合适了？</p><p>你们现在是不是在想：那就在飞机和直升飞机类中分别实现飞行这个功能。可以是可以，但是重复代码是不是过多了？代码无法重用。</p><p>那该怎么办？其实，让我们分别去定义交通工具和飞行器这两个父类，这样飞机和直升飞机就可以去继承这两个类。对吧？</p><p>来，让我们开始实现，一样的，先来个框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义交通工具</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vehicle</span>():<br>    <span class="hljs-comment"># 运输货物</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cargo</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;货物&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 搭载乘客</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人&#x27;</span>)<br><br><span class="hljs-comment"># 定义飞行器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">flying</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;可以飞&#x27;</span>)<br></code></pre></td></tr></table></figure><p>现在刚才的思考得以实现，我们定义了两个父类。接着是不是就要考虑继承了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义飞机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">airplane</span>(vehicle, flying):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义直升机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">helicopter</span>(vehicle, flying):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义汽车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>(<span class="hljs-title class_ inherited__">vehicle</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>根据我们之前学习的继承关系，这样就完成了子类对父类的继承关系。来让我们分析下：</p><p>此时去定义一个飞行器的类Flying,让需要飞行的交通工具直接继承这个类，可以解决问题。但是又两个问题，出现的类多继承，就违背了<code>is-a</code>，飞行器这个类很容易被误解。那怎么办？</p><p>其实解决方案还是使用多继承，但是给飞行器这个类定义为一个<code>Mixin</code>混合类，此时就是等于把飞行器这个类，作为一个扩展的功能，来扩展其他类。</p><p>让我们来改一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义交通工具</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vehicle</span>():<br>    <span class="hljs-comment"># 运输货物</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cargo</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;货物&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 搭载乘客</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人&#x27;</span>)<br><br><span class="hljs-comment"># 定义飞行器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">flyingMixin</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;可以飞&#x27;</span>)<br><br><span class="hljs-comment"># 定义飞机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">airplane</span>(vehicle, flyingMixin):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义直升机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">helicopter</span>(vehicle, flyingMixin):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义汽车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">car</span>(<span class="hljs-title class_ inherited__">vehicle</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>嗯，你没看错，就是这么简单，改一下名称。</p><p>那么在这段代码中，虽然直升机和飞机都是用了多继承，也就是继承了<code>flyingMixin</code>，但是由于<code>flyingMixin</code>类加了<code>Mixin</code>这个名，就告诉了后面阅读代码的人，这个类是一个<code>Mixin</code>类。</p><p>我知道你们在想什么，这个是不是太随便了？其实并不是，我们目前在谈论的是「设计模式」，这个<code>flyingMixin</code>类中除了名称之外，还要遵循一些特定的惯例规则，就是这个类中的功能必须是单一的。</p><p>在名称的含义上，<code>Mixin</code>表示混入(mix-in)，<code>Mixin</code>必须是表示一种功能，而不是一个对象。<code>Mixin</code>的功能必须单一，如果有多个功能，那就需要多定义几个<code>Mixin</code>类。在Python中的<code>Mixin</code>是通过多继承实现的。<code>Mixin</code>类通常不单独使用，而是混合到其他类中，去增加功能的。<code>Mixin</code>类不依赖子类的实现，即便子类没有继承这个<code>Mixin</code>类，子类也能正常运行，只是可能缺少一些功能。</p><h3 id="抽象类">抽象类</h3><p>首先我们要明白，抽象类也是一个类。但是，这又是一个特殊的类，抽象类不能用，不能直接实例化称为一个对象。抽象类包含了抽象方法，抽象方法就是没有实现代码的方法。抽象类需要子类继承，并重写父类的抽象方法，才可以使用。</p><p>抽象类，一般应用在程序设计，程序设计中一般是要对功能和需求进行规划，其中有一些需求是明确的并且可以完成的，但是也可能会有一些需求是不明确的，或者不确定具体需要怎么实现，此时就可以把这个不确定怎么实现或者需要后面再去实现的方法，定义为抽象方法（只定义方法名，不写具体代码）。</p><p>我们还是拿一个实例来讲解：</p><p>比如公司有一项新的产品需要开发，交给了开发部门的大拿，也就是你。那么你就开始去规划设计怎么去完成这个产品的开发。比如项目需要用到不同的技术，不同的人来完成。这样，你作为老大，自己完成了一部分功能，但是依然有一部分定义了需求，但是还没有具体实现，需要其他人来进行实现。</p><p>那么此时，你已经写完的部分就是普通方法，定义了需求但是未完成的就可以理解为是抽象方法。</p><p>还是来直接看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> abc<br><br><span class="hljs-comment"># 必须使用metaclass, 属性必须是abc.ABCMeta</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteCode</span>(metaclass=abc.ABCMeta):<br><br>    <span class="hljs-comment"># 需要抽象方法，使用装饰器进行装饰</span><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_swift</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_java</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实现了Java代码的开发&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_python</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实现了Python代码的开发&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样我们就在一个抽象类中定义好了一个抽象方法，和几个普通方法。至于为什么必须<code>metaclass=abc.ABCMeta</code>，那就又要扩展着去讲了。这里先记住，就跟背单词一样，到这里了就这么用就可以了。</p><p>前面我们讲了，抽象类是不能直接实例化的，让我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 抽象类不能直接实例化对象</span><br>obj = WriteCode()<br><br>---<br>TypeError: Can<span class="hljs-string">&#x27;t instantiate abstract class WriteCode with abstract method write_swift</span><br></code></pre></td></tr></table></figure><p>报错了，直接告诉我们无法实例化抽象类。</p><p>那么我们到底要怎么用呢？</p><p>我们可以定义一个子类来继承，并实现抽象类中的抽象方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义子类，继承抽象类，并实现抽象类中的抽象方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>(<span class="hljs-title class_ inherited__">WriteCode</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_swift</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;实现了swift代码的开发&#x27;</span>)<br></code></pre></td></tr></table></figure><p>好了，现在让我们实例化子类试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = Demo()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x104ade8c0</span>&gt;<br></code></pre></td></tr></table></figure><p>没有报错，似乎是完成了继承和实现。接着当然是一次执行子类中的方法来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.write_java()<br>obj.write_python()<br>obj.write_swift()<br><br>---<br>实现了Java代码的开发<br>实现了Python代码的开发<br>实现了swift代码的开发<br></code></pre></td></tr></table></figure><p>没毛病，现在我们完成了整个代码。</p><p>那小伙伴们现在估计最大的疑问是：抽象类我要应用在什么地方呢？</p><p>比如说，我们现在要开发一个框架，这个框架要有一大堆的功能，包括<code>a,b,c</code>（哎，我忽然理解导入的为什么是<code>abc</code>这样起名了）。但是呢，具体用这个框架开发什么样的产品我们并不清楚，因此这个框架中能否知道你要做什么样的开发吗？肯定不知道。</p><p>框架具备了一定的功能即可，剩下的，需要具体开发项目的人来实现自己的业务逻辑。</p><p>那这个时候，我们就要用到抽象类了。</p><p>好了，到目前为止，我们关于面向对象编程也就介绍的差不多了。而我们的Python课程基本上也到了尾声，在后面的课程中，我们会介绍一下Python中的装饰器。然后去学习一下几个用的特别广的库，包括<code>matplotlib</code>,<code>numpy</code>以及<code>pandas</code>。</p><p>小伙伴们，大家对于此前的Python基础一定要好好的理解，好好练习。这样，越往后我们才能越轻松的开展后面的学习。</p><p>行，本节课到这里就结束了，下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/OOP-Descriptor-and-design-patterns/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi， 大家好，我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>22. 面向对象 - 高阶</title>
    <link href="https://hivan.me/Object-Oriented-Programming-Higher-Level/"/>
    <id>https://hivan.me/Object-Oriented-Programming-Higher-Level/</id>
    <published>2023-08-17T03:38:54.000Z</published>
    <updated>2023-08-17T17:59:14.124Z</updated>
    
    <content type="html"><![CDATA[<img src="/Object-Oriented-Programming-Higher-Level/cover.png" class="" title="img"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>之前的课程里面，我们简单的接触了面向对象编程，也和大家讲解了其思想，优缺点。相信上节课程结束之后，大家对面向对象都有了一定的理解。</p><p>那么我们这节课，就进入面向对象的一些高阶部分，让我们继续来学习一些魔术方法以及Python的内置成员，然后再来学习一下描述符与设计模式。</p><ol type="1"><li>内置成员</li><li>魔术方法</li><li>描述符</li><li>设计模式</li></ol><p>好，正课走起。让我们开始。</p><h2 id="内置成员">内置成员</h2><p>当我们创建一个类之后，即便我们还什么都没做，这个类里面就已经有内容了，我们来看一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 获取类/对象的所属成员</span><br>res = Demo.__dict__<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><p>上节课我们学过了<code>__dict__</code>，这个是获取类或者对象的成员的方法。打印结果我们看到其中的成员。</p><p>让我们添加些内容再来观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    name = <span class="hljs-string">&#x27;a&#x27;</span><br>    age = <span class="hljs-number">20</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;say something&#x27;</span>)<br><br><span class="hljs-comment"># 获取类/对象的所属成员</span><br>res = Demo.__dict__<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Demo.say at <span class="hljs-number">0x1117a3e20</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Demo&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure><p>看到我们刚才定义的成员属性和成员方法也都在列了。我们还可以实例化之后获取对象的成员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = Demo()<br><span class="hljs-built_in">print</span>(obj.__dict__)<br><br>---<br>&#123;&#125;<br></code></pre></td></tr></table></figure><p>当我们实例化一个对象<code>obj</code>之后，打印发现其成员是空的。这是为什么？</p><p>原因就在于，这个方法用处其实是打印其对象的专有成员。我们再来为这个实例化对象创建一些成员再来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.sex = <span class="hljs-string">&#x27;female&#x27;</span><br><span class="hljs-built_in">print</span>(obj.__dict__)<br><br>---<br>&#123;<span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们获取了刚才创建的成员属性。</p><p>以上，就是我们使用<code>__dict__</code>获取了类和对象的所属成员，方法为：<code>类/对象.__dict__</code>。</p><p>除了获取所属成员，我们还有其他方法，比如获取「文档信息」，获取「类名称」，获取「所在文件名称」，获取「当前类的父类列表」以及获取「当前类的『继承链』。来让我们依次看一下：</p><p>还记得我们之前在创建函数的时候可以添加文档吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">obj</span>():<br>  <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">  这里是文档内容</span><br><span class="hljs-string">  &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>同样的，类当中我们一样可以添加文档内容。然后我们可以通过<code>__doc__</code>来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    这里是一个Demo类，主要用于测试</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(Demo.__doc__)<br><br>---<br>这里是一个Demo类，主要用于测试<br></code></pre></td></tr></table></figure><p>同样的，<code>__doc__</code>不仅可以获取类的文档信息，同样可以获取到对象的。</p><p>我们使用<code>__name__</code>来获取类名称「组成的字符串」,<strong>这个方法无法对对象使用。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Demo.__name__)<br><br>---<br>Demo<br></code></pre></td></tr></table></figure><p><code>__module__</code>可以用来获取类/对象所在的文件名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(Demo.__module__)<br><span class="hljs-built_in">print</span>(obj.__module__)<br><br>---<br>__main__<br>__main__<br></code></pre></td></tr></table></figure><p>如果其所在文件为当前文件，那么这里就会显示为<code>__main__</code>。</p><p>然后是<code>__base__</code>，这个方法是用来获取当前类的父类列表。这个方法有两个版本，一个是<code>__base__</code>,一个是<code>__bases__</code>。这两个方法的区别在于一个是获取继承的第一个父类，一个是继承所有的父类的列表，为了呈现的更明显，我们建立一个继承类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">Demo</span>):<br>    <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(A, Demo):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-built_in">print</span>(B.__base__)<br><span class="hljs-built_in">print</span>(B.__bases__)<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>还有一个就是我们上节课讲过的，MRO列表，也就是<code>__mro__</code>方法，用于获取当前类的继承链。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(B.__mro__)<br><br>---<br>(&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><p>到此为止，我们介绍的就是常用的一些内置成员获取的一些方法。当然，这里不是全部，除此之外还有很多，因为并不是常用，所以这里我们就不多介绍了。</p><img src="/Object-Oriented-Programming-Higher-Level/image-20230817144318246.png" class="" title="img"><h2 id="方法的分类">方法的分类</h2><p>接下来呢，我们来看下面向对象的分类，包括：</p><ol type="1"><li>对象方法</li><li>类方法</li><li>绑定类方法</li><li>静态方法</li></ol><p><strong>对象方法</strong></p><p>其特征为： 1. 在类中定义方法，含有<code>self</code>参数 2.含有<code>self</code>的方法，只能使用对象进行调用。 3.该方法会把调用的对象传给进来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-comment"># 对象方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">objFunc</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is objFunc&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.objFunc()<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1171460e0</span>&gt;<br>this <span class="hljs-keyword">is</span> objFunc<br></code></pre></td></tr></table></figure><p>这个方法不能直接使用类直接调用，但是其实也不是绝对的。当我们使用类直接调用的时候，需要传递一个参数，也就是必须要<code>self</code>有参数可接收。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Demo.objFunc(<span class="hljs-string">&#x27;a&#x27;</span>)<br><br>---<br>a<br>this <span class="hljs-keyword">is</span> objFunc<br></code></pre></td></tr></table></figure><p><strong>类方法</strong></p><p>类方法呢，和对象方法有不一样的地方，也有相同的地方。两者定义十分相似，不同之处是使用装饰器材：</p><p>其特征为：</p><ol type="1"><li>在类中定义的方法，使用了<code>@classmethod</code>进行了装饰</li><li>方法中有形参<code>cls</code></li><li>可以不用实例化对象，直接使用类进行调用</li><li>会把调用这个方法的类或对象传递进来</li></ol><p>来直接看代码理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <br>    <span class="hljs-comment"># 类方法</span><br><span class="hljs-meta">    @classmethod </span><span class="hljs-comment"># 装饰器</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">clsFunc</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(cls)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is cls function: clsFunc&#x27;</span>)<br><br>Demo.clsFunc()<br>obj.clsFunc()<br><br>---<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;<br>this <span class="hljs-keyword">is</span> cls function: clsFunc<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Demo&#x27;</span>&gt;<br>this <span class="hljs-keyword">is</span> cls function: clsFunc<br></code></pre></td></tr></table></figure><p>看结果可以看到，我们用类进行调用的时候并没有像对象方法一样传递一个参数进去，这是因为调用的时候会直接传递调用的类给到<code>cls</code>参数。而我们说不需要实例化对象，并不是实例化对象不可调用。对象调用也是可以的。</p><p>至于什么是「装饰器」，我们以后会详细讲到，这里先记住这种形式就可以了。</p><p><strong>绑定类方法</strong></p><p>这个方法不传递任何对象和类。在定义的时候，不设定任何的形参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># 绑定类方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bindClassFunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is bind Class function: bindClassFunc&#x27;</span>)<br><br><span class="hljs-comment"># 调用</span><br>Demo.bindClassFunc()<br><br>---<br>this <span class="hljs-keyword">is</span> bind Class function: bindClassFunc<br></code></pre></td></tr></table></figure><p>那么绑定类方法既然没有定义形参，那么这个方法是无法使用实例化对象来调用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">obj.bindClassFunc()<br><br>---<br>TypeError: Demo.bindClassFunc() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p>其特征如下： 1. 在类中定义的方法，不必须设置形参。 2.只能使用类进行调用。 3.可以传递任意参数，但是不会将类作为参数传递进来。</p><p><strong>静态方法</strong></p><p>「静态类方法」和「类方法」相似，也需要一个装饰器。并且，静态类方法也是不需要设置形参的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    <span class="hljs-comment"># 静态类方法</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">staticFunc</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is static method func&#x27;</span>)<br><br>Demo.staticFunc()<br>obj.staticFunc()<br><br>---<br>this <span class="hljs-keyword">is</span> static method func<br>this <span class="hljs-keyword">is</span> static method func<br></code></pre></td></tr></table></figure><p>那从结果中我们可以看到，「静态类方法」可以使用类和对象进行调用，并且调用的时候不需要传递任何参数。</p><p>其特征如下： 1. 在类中定义的方法，使用装饰器<code>@staticmethod</code> 进行了装饰 2. 可以使用对象或者类进行调用 3.不会将对象或者类作为参数传递进来</p><blockquote><p>⚠️注意：这里我们需要注意的，「静态类方法」只是可以不设置参数，并不是不能设置参数，并且，就算是设置了参数之后，也是不接受类和对象作为参数传递的。比如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@staticmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">staticFunc</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a:<span class="hljs-subst">&#123;a&#125;</span>, b:<span class="hljs-subst">&#123;b&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;this is static method func&#x27;</span>)<br><br><span class="hljs-comment"># 调用</span><br>Demo.staticFunc(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;class&#x27;</span>)<br>obj.staticFunc(<span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;obj&#x27;</span>)<br><br>---<br>a:static, b:<span class="hljs-keyword">class</span><br><span class="hljs-title class_">this</span> <span class="hljs-keyword">is</span> static method func<br>a:static, b:obj<br>this <span class="hljs-keyword">is</span> static method func<br></code></pre></td></tr></table></figure><p>我们分别用类和对象进行了调用并传递了两个参数进行打印，而打印结果正常，并且没有对象或者类被传递。</p><p>相应的，「绑定类方法」也是这种特性，只是「绑定类方法」只支持类调用，不支持对象调用。</p><h2 id="常用函数">常用函数</h2><p>其实在之前，关于「常用函数」我们已经接触过了一些，比如：<code>issubclass(子类，父类)</code>。有些小伙伴可能还记得，这个函数是用于检测一个类是否为另一个类的子类。</p><p>那除了这个之外，Python中还有很多其他的一些针对类和对象的常用函数，下面让我们来详细看一下。</p><p><code>isinstance(对象，类)</code>，用于检测一个对象是否是该类或者该类的子类的实例化结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">obj = D()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, D))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>这个结果显而易见，那么我们思考一下，既然<code>D</code>类继承了<code>B</code>类和<code>C</code>类，那么<code>obj</code>对象是否也是<code>B</code>或者<code>C</code>的实例化结果呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>(obj, B))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>可见，对于继承了父类的子类，其实例化对象和父类之间也会被检测为<code>True</code>。</p><p><code>hasattr(对象/类,'成员名称')</code>，这个函数是用于检测类/对象是否包含指定名称的成员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">B.name = <span class="hljs-string">&#x27;张三&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>))<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在这段代码中，我们给父类<code>B</code>添加了一个成员属性<code>name</code>，因为<code>obj</code>是<code>D</code>的实例化对象（之前的代码中）。而<code>D</code>类是继承自<code>B</code>类的，所以自然<code>obj</code>中也是包含了<code>name</code>这个成员属性的。所以我们的检测结果必然为<code>True</code>。</p><p>来，我们做另外一个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">objB = B()<br>D.age = <span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(D.age)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hasattr</span>(objB, <span class="hljs-string">&#x27;age&#x27;</span>))<br><br>---<br><span class="hljs-number">20</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>我们重新用<code>B</code>类实例化了一个对象<code>objB</code>，然后我们给<code>D</code>类添加了一个成员属性<code>age</code>，并且打印了一遍证实其存在。这个时候我们检测了一下<code>objB</code>中是否含有<code>age</code>，因为<code>D</code>为<code>B</code>的子类，它说添加的成员属性为独有属性，并不会更改到<code>B</code>类里，那自然<code>B</code>的实例化对象<code>objB</code>中是不可能存在这个成员属性的，结果自然为<code>False</code>。</p><p>``</p><p><code>getattr(对象/类,'成员名称')</code>,用于获取类/对象的成员的值</p><p>那这个函数就好理解了，我们可以用之前建立好的实例化对象<code>objB</code>和<code>obj</code>来获取一下试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;age&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(objB, <span class="hljs-string">&#x27;name&#x27;</span>))<br><br>---<br><span class="hljs-number">20</span><br>张三<br></code></pre></td></tr></table></figure><p>没问题，结果如我们所料一般。那如果是获取<code>objB</code>中的<code>age</code>的值会如何？我们前面已经知道，<code>objB</code>中并未存在<code>age</code>这个成员属性，所以必然会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getattr</span>(objB, <span class="hljs-string">&#x27;age&#x27;</span>))<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><p><code>setattr(对象/类,'成员名称','成员的值')</code>,这个函数用于设置类/对象的成员的属性值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>))<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br>du<br></code></pre></td></tr></table></figure><p>如结果所见，这个方法的返回值为<code>None</code>，但是我们通过打印<code>obj.name</code>可知，方法确实更改了<code>obj</code>中<code>name</code>的值。</p><p><code>delattr(类/对象,'成员名称')</code>这个函数可以删除类/对象的成员属性，和<code>del</code>直接删除对象的成员是一样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">delattr</span>(obj, <span class="hljs-string">&#x27;name&#x27;</span>))<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br>张三<br></code></pre></td></tr></table></figure><p>可见，这个方法也是没有返回值的，返回了<code>None</code>。不过，既然我们已经删除了<code>obj</code>中的<code>name</code>，为啥还能打印出<code>张三</code>呢？有没有小伙伴知道为什么？其实，我们删除的<code>name</code>是之前使用<code>setattr</code>为<code>obj</code>设定的专有成员，当它被删除之后，我们的<code>obj</code>的继承类<code>D</code>中还存在着<code>name</code>这个成员属性，所以现在打印出来的<code>张三</code>是从<code>D</code>类中继承过来的。</p><p>那如果是我们新添加的但是其他类中没有的属性就会直接报错了，来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;size&#x27;</span>, <span class="hljs-string">&#x27;small&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.size)<br><span class="hljs-built_in">delattr</span>(obj, <span class="hljs-string">&#x27;size&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.size)<br><br>---<br>small<br>AttributeError: <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;size&#x27;</span><br></code></pre></td></tr></table></figure><p>我们分别打印了两次，第一次<code>setattr</code>了一个成员属性<code>size</code>，并且打印验证了。然后我们执行<code>delattr</code>，删除了刚才设置的成员属性<code>size</code>，这次再打印来看，报错了。</p><p><code>dir()</code>这个函数可以获取当前对象所有可以访问的成员的列表。正好，让我们来看看是否从还存在从<code>B</code>类中继承的成员属性<code>name</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">dir</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到打印结果的最后面，确实还存在着<code>name</code>这个成员属性。</p><p>以上函数在讲解的过程中，我们使用的都是成员属性，而成员方法其实是一样的。因为这几个函数说针对的对象都是「成员」。</p><p>另外需要注意的一点是，以上所有这些常用函数，都是在可访问的情况下才可执行。我们还有一些不可访问的情况，比如说「私有成员属性」，这种成员是无法被访问或者操作的，我们随便拿个函数来举一个例子看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>():<br>    name = <span class="hljs-string">&#x27;张三&#x27;</span><br>    _age = <span class="hljs-number">25</span><br>    __sex = <span class="hljs-string">&#x27;female&#x27;</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Sex:<span class="hljs-subst">&#123;__sex&#125;</span>&#x27;</span>)<br><br>obj = D()<br><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;__sex&#x27;</span>)<br><br>---<br>Sex:female<br>AttributeError: <span class="hljs-string">&#x27;D&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__sex&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，当我们意图用<code>getattr</code>来获取实例化对象<code>obj</code>中的<code>__sex</code>属性时报错了。无法正确访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">dir</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_D__sex&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>, <span class="hljs-string">&#x27;__delattr__&#x27;</span>, <span class="hljs-string">&#x27;__dict__&#x27;</span>, <span class="hljs-string">&#x27;__dir__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__eq__&#x27;</span>, <span class="hljs-string">&#x27;__format__&#x27;</span>, <span class="hljs-string">&#x27;__ge__&#x27;</span>, <span class="hljs-string">&#x27;__getattribute__&#x27;</span>, <span class="hljs-string">&#x27;__gt__&#x27;</span>, <span class="hljs-string">&#x27;__hash__&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>, <span class="hljs-string">&#x27;__init_subclass__&#x27;</span>, <span class="hljs-string">&#x27;__le__&#x27;</span>, <span class="hljs-string">&#x27;__lt__&#x27;</span>, <span class="hljs-string">&#x27;__module__&#x27;</span>, <span class="hljs-string">&#x27;__ne__&#x27;</span>, <span class="hljs-string">&#x27;__new__&#x27;</span>, <span class="hljs-string">&#x27;__reduce__&#x27;</span>, <span class="hljs-string">&#x27;__reduce_ex__&#x27;</span>, <span class="hljs-string">&#x27;__repr__&#x27;</span>, <span class="hljs-string">&#x27;__setattr__&#x27;</span>, <span class="hljs-string">&#x27;__sizeof__&#x27;</span>, <span class="hljs-string">&#x27;__str__&#x27;</span>, <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;__weakref__&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><p>当我们使用<code>dir()</code>来查看的时候，其中也并没有<code>__sex</code>这个成员属性，有的只是类的私有成员属性:<code>_D__sex</code>，我们需要借助类从内部才可访问到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;_D__sex&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;female&#x27;</span><br></code></pre></td></tr></table></figure><p>这样是可以的。</p><h2 id="魔术方法">魔术方法</h2><p>我们在这节课之前，讲到过「魔术方法」，那我们已经了解，魔术方法是不需要手动调用就可以自动执行的方法。</p><p>那我们之前已经讲解过<code>__init__</code>，这是一个初始化方法。然后还有一个<code>__del__</code>方法，是一个销毁方法。</p><p>这两个方法除了功能上的不同之外，还有一个最大的不同点就是被触发的机制是不一样的。其实，魔术方法中，最重要的一点就是要了解方法的触发机制是什么。</p><p>让我们先列出来常用的魔术方法，包括其触发机制，作用以及参数等等...</p><ol type="1"><li><code>__init__</code>， 初始化方法, <code>*****</code></li></ol><p><strong>触发机制：</strong>当实例化对象之后就会立即触发的方法<strong>作用：</strong>为当前创建的对象完成一些初始化的操作，比如：成员属性的赋值，方法的调用， 打开或者创建一些资源等等。<strong>参数：</strong>一个<code>self</code>，接收当前对象，其他参数根据需求进行定义即可。 <strong>返回值：</strong>无<strong>注意事项：</strong>无</p><ol start="2" type="1"><li><code>__new__</code>，构造方法, <code>****</code></li></ol><p><strong>触发机制：</strong>实例化对象时自动触发（在<code>__init__</code>之前触发）<strong>作用：</strong>管理控制对象创建的过程<strong>参数：</strong>一个<code>cls</code>接收当前类，其它参数根据初始化方法的参数进行决定<strong>返回值：</strong>必须返回<code>object.__new__(cls)</code>进行对象的创建，如果没有返回值，则实例化对象的结果为<code>None</code><strong>注意事项：</strong><code>__new__</code>方法的参数和<code>__init__</code>方法的参数要保持一致，除了第一个参数。必须返回<code>object.__new__(cls)</code>进行对象的创建，如果没有返回值，则实例化对象的结果为<code>None</code><strong>应用场景：</strong>设计模式中的单例设计模式。</p><ol start="3" type="1"><li><code>__del__</code>，析构方法, <code>*****</code></li></ol><p><strong>触发机制：</strong>当该类对象被销毁时，自动触发<strong>作用：</strong> 关闭或释放对象创建时打开或创建的一些资源<strong>参数：</strong> 一个<code>self</code>，接受当前的对象<strong>返回值：</strong>无 <strong>注意事项：</strong> 无</p><ol start="4" type="1"><li><code>__call__</code> , <code>***</code></li></ol><p><strong>触发机制:</strong> 把对象当作函数直接调用时自动触发<strong>作用:</strong> 一般用于归纳类或对象的操作步骤，方便调用<strong>参数</strong>：一个<code>self</code>接收当前对象，其它参数根据调用需求缺点<strong>返回值</strong>：可有可无</p><p>5.<code>__len__</code></p><p><strong>触发机制:</strong>当使用<code>len</code>函数去检测当前对象的时候自动触发<strong>作用:</strong>可以使用<code>len</code>函数检测当前对象中某个数据的信息<strong>参数</strong>: 一个<code>self</code>接收当前对象<strong>返回值</strong>：必须有，并且必须是一个整型<strong>注意事项</strong>：<code>len</code>要获取什么属性的值，就在返回值中返回哪个属性的长度即可</p><p>6.<code>__str__</code></p><p><strong>触发机制:</strong>当使用<code>str</code>或者<code>print</code>函数对对象进行操作时自动触发<strong>作用:</strong> 代码对象进行字符串的返回，可以自定义打印的信息<strong>参数</strong>：一个<code>self</code>，接收当前对象<strong>返回值</strong>：必须有，而去必须是字符串类型的值</p><p>7.<code>__repr__</code></p><p><strong>触发机制:</strong>在使用<code>repr</code>方法对当前对象进行转换时自动触发<strong>作用:</strong> 可以设置<code>repr</code>函数操作对象的结果<strong>参数</strong>： 一个<code>self</code>，接收当前对象<strong>返回值</strong>： 必须有，而去必须是字符串类型的值<strong>注意</strong>：正常情况下，如果没有<code>__str__</code>这个魔术方法，<code>__repr__</code>方法就会代替<code>__str__</code>魔术方法</p><p>8.<code>__bool__</code></p><p><strong>触发机制:</strong>当前使用<code>bool</code>函数转换当前对象时，自动触发.默认情况下，对象会转为<code>True</code><strong>作用:</strong>可以代替对象进行<code>bool</code>类型的转换，可以转换任何数据<strong>参数</strong>: 一个<code>self</code>接收对象<strong>返回值</strong>： 必须是一个布尔类型的返回值</p><p>以上，我们把常用魔术方法都列出来之后，然后我们来些代码进行讲解。让我们先创建一个<code>Person</code>类，然后在其中协商构造方法，初始化方法和析构方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-built_in">print</span>(kwargs)<br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发初始化方法:__init__&#x27;</span>)<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发了析构方法:__del__&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>&#123;&#125;<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>当我们完成实例化的时候，「构造方法」先是用<code>*args</code>接收了所有传递的参数，并且使用存储了元组。我们可以看到，<code>**kwargs</code>什么都没接收到，所以打印为空。</p><p>当「构造方法」执行完之后，也并没有去执行「初始化方法」和「析构方法」，这又是为什么呢？这是因为如果在「构造方法」中没有返回对象，这对象无法创建。要想对象进行创建，这我们必须返回<code>object.__new__(cls)</code>进行对象的创建。这在之前「构造方法」的说明里有说明。这个<code>cls</code>参数是什么呢？我们直接来看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br><br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(args)<br>        <span class="hljs-comment"># print(kwargs)</span><br>        <span class="hljs-built_in">print</span>(cls)<br>        <span class="hljs-comment"># 如果该方法中没有返回对象，则无法创建对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__new__(cls)<br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发初始化方法:__init__&#x27;</span>)<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;触发了析构方法:__del__&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(zs)<br><br>---<br>(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">210</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Person&#x27;</span>&gt;<br>触发初始化方法:__init__<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107f3c070</span>&gt;<br></code></pre></td></tr></table></figure><p>现在可以看到，我们打印了<code>cls</code>，实际上就是<code>Person</code>这个类。当我们返回<code>object.__new__(cls)</code>之后，可以看到<code>__init__</code>初始化方法正确运行了，执行了方法内的打印方法。然后最后，我们打印了<code>zs</code>这个实例化对象。那为什么<code>__del__</code>析构方法没有触发？因为我们是在<code>Jupyter</code>中执行，并未执行释放，此时我们如果<code>del zs</code>，则会触发析构方法，或者，我们讲上述代码保存为一个<code>22.py</code>文件，然后单独执行，这个时候Python的垃圾回收机制会执行，就会进行释放，从而触发析构方法。如下图：</p><img src="/Object-Oriented-Programming-Higher-Level/image-20230817210119680.png" class="" title="img"><p>我们接着上面写的代码在<code>22.py</code>中继续写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">zs()<br><br>---<br>TypeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">callable</span><br></code></pre></td></tr></table></figure><p>报警，告知我们这个类当中没有cllable。那如果我们讲这个类改造下，加上<code>__call__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 魔术方法</span><br><span class="hljs-comment"># 定义一个人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 构造方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        ...<br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">slef, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你把对象当成了函数进行调用。&#x27;</span>)<br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        ...<br><br><span class="hljs-comment"># 实例化对象</span><br>...<br>zs()<br><br>---<br>...<br>你把对象当成了函数进行调用。<br>触发了析构方法:__del__<br></code></pre></td></tr></table></figure><p>这样，我们直接执行<code>zs()</code>就没问题了，可以把对象当作函数直接调用时自动触发。</p><p>让我们继续，返回到<code>22.ipynb</code>笔记本文件中，让我们重新定义一个类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">len</span>(obj)<br><br>---<br>TypeError: <span class="hljs-built_in">object</span> of <span class="hljs-built_in">type</span> <span class="hljs-string">&#x27;Demo&#x27;</span> has no <span class="hljs-built_in">len</span>()<br></code></pre></td></tr></table></figure><p>报错信息中可以看出，这个实例化对象是没有<code>len()</code>方法的。我们如果给它加上<code>__len__</code>之后就会让其拥有<code>len()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>因为当前我们在类中定义的<code>items</code>里面没有数据，所以返回的长度必然也是<code>0</code>。但是这个返回值是必须要有的，需要返回一个整型才行。</p><p>来，我们看看如果这个方法的返回值写死会如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>很明显，我们重新给<code>obj.items</code>进行了赋值，目前其长度是<code>7</code>,可是返回值依然是<code>1</code>。说明<code>__len__</code>的返回值只要四个整型就行。那我们就需要注意了，<code>len</code>需要获取什么属性的值，就在返回值中返回哪个属性的长度即可。当我们用正确的方式返回的时候就会是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.items)<br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>obj.items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(obj))<br><br>---<br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>让我们继续接着这段代码来玩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">...<br>res = <span class="hljs-built_in">str</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;__main__.Demo <span class="hljs-built_in">object</span> at <span class="hljs-number">0x110631270</span>&gt;<br></code></pre></td></tr></table></figure><p>发现没有，虽然我们使用了<code>str()</code>方法，可是最后返回的结果，和直接打印<code>obj</code>的结果是一样的。那为什么会这样呢？这是因为我们这个当前的方法其实是对<code>obj</code>对象进行了一个转化字符串操作，而其本身就返回了一个<code>&lt;__main__.Demo object at 0x110631270&gt;</code>的字符串。</p><p>其实这个返回的字符串我们也是可以自定义的,使用<code>__str__</code>方法给一个返回值就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;__Demo__, 此字符串返回的是茶桁自定义的结果。&gt;&#x27;</span><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>...<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;__Demo__, 此字符串返回的是茶桁自定义的结果。&gt;<br></code></pre></td></tr></table></figure><p>我们直接打印了<code>obj</code>对象，因为<code>__str__</code>方法的存在，所以现在直接打印了返回的字符串。也就是说，该方法可以代替对象进行<code>str</code>或者<code>print</code>的字符串信息返回。</p><p>继续来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br><br>    <span class="hljs-comment"># def __str__(self):</span><br>        <span class="hljs-comment"># ...</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是一个repr返回的内容&#x27;</span><br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>这是一个<span class="hljs-built_in">repr</span>返回的内容<br></code></pre></td></tr></table></figure><p>可以看到我在类中注释了<code>__str__</code>方法，这是因为只有其不存在的情况下，<code>__repr__</code>方法才会起作用，可以替代<code>__str__</code>方法。</p><p>那么到底<code>__str__</code>和<code>__repr__</code>两个到底有什么区别呢？让我们直接在代码里找答案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">521</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(num))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">repr</span>(num))<br><br>---<br><span class="hljs-number">521</span><br><span class="hljs-number">521</span><br></code></pre></td></tr></table></figure><p>这个时候两个的结果都是一样的，似乎并看不出两者到底有什么区别。别急，让我们继续往后做这个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">num = <span class="hljs-number">521</span><br>r1 = <span class="hljs-built_in">str</span>(num)<br>r2 = <span class="hljs-built_in">repr</span>(num)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r1: <span class="hljs-subst">&#123;r1&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r1)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r2: <span class="hljs-subst">&#123;r2&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r2)&#125;</span>&#x27;</span>)<br><br>---<br>r1: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>r2: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>两者的类型都是一样的，返回了一个字符串类。难道这两者就正的毫无区别吗？Python得创建者吃饱了撑的没事做两个功能一模一样但是名字不同的方法？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&#x27;521&#x27;</span><br>r1 = <span class="hljs-built_in">str</span>(s)<br>r2 = <span class="hljs-built_in">repr</span>(s)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r1: <span class="hljs-subst">&#123;r1&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r1)&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r2: <span class="hljs-subst">&#123;r2&#125;</span>, <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(r2)&#125;</span>&#x27;</span>)<br><br>---<br>r1: <span class="hljs-number">521</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>r2: <span class="hljs-string">&#x27;521&#x27;</span>, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>仔细看，两者似乎有了细微的差别。<code>repr</code>解析的结果带着引号。</p><p>那么，<code>str</code>和<code>repr</code>函数都可以把其他类型的数据转为字符串类型。<code>str</code>函数会把对象转为更适合人阅读的形式，<code>repr</code>函数会把对象转为解释器读取的形式。</p><p>如果数据对象并没有更明显的区别的话，<code>str</code>和<code>repr</code>的转化结果还真没什么区别。</p><p>这两者的区别，其实只要了解一下就可以了。大部分时候，并不需要那么较真。</p><p>接着让我继续来看看<code>__bool__</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">bool</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>当我们对<code>obj</code>使用<code>bool()</code>方法的时候，返回值为<code>True</code>。那说明其中包含了一个<code>bool</code>机制，并且默认返回值为<code>True</code>。</p><p>这个时候让我们来定义一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>():<br>    items = []<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__bool__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(self.items)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Demo()<br>res = <span class="hljs-built_in">bool</span>(obj)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>由于我们的<code>items</code>中设置为空值，而我们将前面定义<code>obj</code>的<code>items</code>的那段代码删掉了，所以这个时候，传入方法的<code>self.items</code>的值也为空，必然返回值就是<code>False</code>。也证明了，<code>bool(obj)</code>拿到的返回值就是类里定义的的<code>__bool__</code>中返回的对象。</p><p>介绍完常用的一些魔术方法之后，我们再来看一些其他的魔术方法。同样是魔术方法，为什么我要明显的区别开来讲呢？那是因为现在开始说讲的魔术方法都是针对成员的，是一些成员相关魔术方法。</p><ol type="1"><li><code>__getattribute__</code>: 优先级最高</li></ol><p><strong>触发机制</strong>:当访问对象成员时，自动触发，无论当前成员是否存在 <strong>作用</strong>:可以在获取对象成员时，对数据进行一些处理 <strong>参数</strong>: 1.<code>self</code>接收对象，2. <code>item</code>接收当前访问的成员名称<strong>返回值</strong>: 可有可无，返回的值就是访问的结果<strong>注意事项</strong>:在当前的魔术方法中，禁止对当前对象的成员进行访问，会触发递归。如果想要在当前魔术方法中访问对象的成员必须使用<code>object</code>来进行访问。格式：<code>object.__getattribute__(self,item)</code></p><ol start="2" type="1"><li><code>__getattr__</code></li></ol><p><strong>触发机制</strong>：当访问对象中不存在的成员时，自动触发<strong>作用</strong>：防止访问不存在的成员时报错，也可以为不存在的成员进行赋值操作<strong>参数</strong>: 1. <code>self</code>接收当前对象，2.<code>item</code>接收当前访问的成员名称<strong>返回值</strong>：可有可无 <strong>注意事项</strong>：当存在<strong>getattribute</strong> 方法时，会去执行<strong>getattribute</strong>方法。也要注意，不要在当前的方法中再次去访问这个不存在的成员，会触发递归操作</p><ol start="3" type="1"><li><code>__setattr__</code></li></ol><p><strong>触发机制</strong>：当给对象的成员进行赋值操作时会自动触发（包括添加，修改）<strong>作用</strong>： 可以限制或管理对象成员的添加和修改操作<strong>参数</strong>： 1. <code>self</code>接收当前对象 2.<code>key</code>设置的成员名 3. <code>val</code>设置的成员值<strong>返回值</strong>： 无<strong>注意事项</strong>：在当前的魔术方法中禁止给当前对象的成员直接进行赋值操作，会触发递归操作。如果想要给当前对象的成员进行赋值，需要借助<code>object</code> <strong>格式</strong>：<code>object.__setattr__(self,key,value)</code></p><ol start="4" type="1"><li><code>__delattr__</code></li></ol><p><strong>触发机制</strong>： 当删除对象成员时自动触发<strong>作用</strong>：可以去限制对象成员的删除，还可以删除不存在成员时防止报错<strong>参数</strong>：1. <code>self</code>接收当前对象 2.<code>item</code>删除的成员名称 <strong>返回值</strong>： 无<strong>注意事项</strong>：在当前魔术方法中禁止直接删除对象的成员，会触发递归操作。如果想要删除当前对象的成员，那么需要借助<code>object</code>。 <strong>格式</strong>：<code>object.__delattr__(self,item)</code></p><p>好了，按照惯例，让我们上代码,先让我们来定义一个最正常的类，并且实例化它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    sex = <span class="hljs-string">&#x27;male&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;say something...&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br>张三丰<br></code></pre></td></tr></table></figure><p>这个时候，让我们在类中定义一个方法：<code>__getattrbute__()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>可以看到，虽然我们在实例化对象的时候传入了成员值，但是当我们打印的时候返回值为<code>None</code>。如果我们这个时候修改一下这个魔术方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;abc&#x27;</span><br><br>...<br><span class="hljs-built_in">print</span>(obj.name)<br><span class="hljs-built_in">print</span>(obj.sex)<br>---<br>abc<br>abc<br></code></pre></td></tr></table></figure><p>那我们拿到的就是得到的内容。不仅是<code>name</code>，任意我们传入的成员，返回的值都为<code>__getattribute__</code>返回的值。当获取对象成员时，这个方法进行处罚，其中的<code>item</code>形参就是我们想要获取的成员属性。第一次是<code>obj.name</code>,第二次是<code>obj.sex</code>，但是无论你调用的是什么成员，拿到的都是这个方法的返回值<code>abc</code>。</p><p>那既然这样，是不是我们返回对象的成员属性就可以了？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> self.name<br><br></code></pre></td></tr></table></figure><p>千万不要这么做，这样会引起方法的无限递归调用，最终导致栈溢出。那么是不是我们就没办法了？也不是，我们需要使用<code>object.__getattribute__(self, item)</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    ...<br>    <br>    <span class="hljs-comment"># 获取对象成员的时候触发</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">object</span>.__getattribute__(self, item)<br><br><span class="hljs-comment"># 实例化对象</span><br>obj = Person(<span class="hljs-string">&#x27;张三丰&#x27;</span>, <span class="hljs-number">280</span>, <span class="hljs-string">&#x27;男&#x27;</span>)<br><span class="hljs-built_in">print</span>(obj.name)<br><span class="hljs-built_in">print</span>(obj.sex)<br><br>---<br>张三丰<br>男<br></code></pre></td></tr></table></figure><p>这样，我们就获取到了正确的返回值。我们这里讲解一个<code>__getattribute__</code>方法，限于篇幅的原因，我们其他的几个方法就不细致讲了。在我们先前的列表内，每一个方法的触发机制，作用，参数和注意事项我们都有写清楚。大家可以执行去看看，并做一些测试。让我们赶紧进入下一个阶段，不过在这之前呢，我们还是需要讲访问成员的顺序给大家强调一下，这个还是比较重要：</p><ol type="1"><li>调用 <code>__getattribute__</code>魔术方法</li><li>调用数据描述符</li><li>调用当前对象的成员</li><li>调用当前类的成员</li><li>调用非数据描述符</li><li>调用父类的成员</li><li>调用<code>__getattr__</code>魔术方法</li></ol><blockquote><p>以上步骤是调用某个成员时的顺序，前面的能够调用成功，后面则不再执行。至于描述符，咱们下节课来详细讲。</p></blockquote><p>好了，本节课到这里就结束了，让我们先预告一下，下节课呢，我们来讲讲面向对象中的「描述符和设计模式」。大家期待一下吧。</p><p>记得课后好好做练习，目前我们的课程稍微有些难度了，只有保持一定的练习量，才能理解并记住。</p><p>小伙伴们，下节课再见了。下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Object-Oriented-Programming-Higher-Level/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>21. 面向对象及特性</title>
    <link href="https://hivan.me/Object-Oriented-Programming/"/>
    <id>https://hivan.me/Object-Oriented-Programming/</id>
    <published>2023-08-16T03:41:18.000Z</published>
    <updated>2023-08-16T18:01:35.602Z</updated>
    
    <content type="html"><![CDATA[<img src="/Object-Oriented-Programming/cover.png" class="" title="cover"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>今天开始，我们要迈向Python的另外一个台阶了，那就是面向对象。</p><p>面向对象编程（Object OrientedProgramming)，简称为OOP，是一种<strong>以对象为中心</strong>的程序设计思想。</p><p>与之相对的，就是面向过程编程（Procedure Oriented Programming),简称为POP, 是一种<strong>以过程为中心</strong>的程序设计思想。</p><h2 id="面向对象和面向过程">面向对象和面向过程</h2><p>接下来，让我们先了解一下这两个编程思想到底有什么不同。还记得咱们之前讲过宋丹丹老师小品里的经典的「把大象装进冰箱分几步」吗？小品给出的答案是三步对吧？</p><ol type="1"><li>第一步：打开冰箱门</li><li>第二步：把大象装进去</li><li>第三步：关上冰箱门</li></ol><h3 id="设计思想的不同">设计思想的不同</h3><p>那么这个答案，就是一种面向过程的思维，遇到问题之后，分析解决问题的步骤，然后一步步的去实现。</p><p>那么如果是面向对象的话，又该如何去做？</p><p>面向对象是通过分析问题中需要的抽象模型，然后根据需要的功能分别去创建模型对象，最终由模型对象来完成程序。那这个「把大象装进冰箱分几步」的问题我们该如何去考虑呢？</p><p>首先，面向对象要解决这个问题，需要先建立出抽象模型，比如：</p><ul><li>打开冰箱门和关闭冰箱门，这都属于一个冰箱的功能，</li><li>大象走进去，这就是大象的功能。</li><li>到此时我们就出现了<strong>两个抽象模型，一个是冰箱，一个是大象</strong>。</li></ul><p>冰箱具有 打开和关闭的功能，大象具有走路的能力。</p><p>分析到这里，就是面向对象的思想，具体完成的话，就是去创建冰箱和大象这两个对象，最终完成这个程序</p><p>冰箱对象-开门，大象对象-走进冰箱，冰箱对象-关门</p><p>这个问题解决了，我们再来思考一个新的问题：「想吃清蒸鱼怎么办？」</p><p>当然是按照做菜的顺序一步一步来对吧？<strong>这就是典型的面向过程思维：</strong></p><ol type="1"><li>买鱼，买料</li><li>杀鱼和清理，并且腌制</li><li>锅里烧水</li><li>把鱼放进去，开始蒸鱼。</li><li>十分钟后开盖，把鱼端出来，然后浇汁。</li></ol><p>这样，一步一步的完成这个愿望，就是面向过程所作的事情。</p><p><strong>轮到面向对象，又该如何呢？</strong></p><ul><li>需要一个对象：大厨。</li><li>告诉大厨，我想吃清蒸鱼。</li></ul><p>那么大厨呢，有可能是我们自己训练的，也有可能是其他五星酒店挖过来的。不管如何，这是一个已经完善建立好的对象，我们直接拿来用就可以了。面向对象呢，就是这样寻找具体的对象去解决问题。对于我们来说，调用了对象，而对象完成了这个过程。</p><p>当然，具体大厨这个对象里肯定还是一步一步的去完成过程，也就是说，最终面向对象中是由面向过程的体现的。但是思维方式，也就是设计思想是完全不同的。</p><h3 id="优缺点">优缺点</h3><p>既然有不同之处，那必然是有优缺点的。因为有对比嘛。面向过程有其优点，当然，面向对象也有其缺点。</p><p>面向过程的核心是过程，过程就是指几觉问题的步骤。其优缺点非常明显：</p><ul><li>优点： 将负责的问题流程化，进而实现简答。</li><li>缺点： 扩展性差（更新、维护、迭代）</li></ul><p>而面向对象的核心是对象，是一个特征和功能的综合体，其优缺点如下：</p><ul><li>优点：可扩展性高</li><li>缺点：编程复杂度相对面向过程高一些，这里的复杂度指的是计算机在执行面向对象的程序时性能表现一般。</li></ul><p>那总结起来呢，在去完成一些简单的程序时，可以使用面向过程去解决。但是如果有复杂的程序或任务，而且需要不断的进行迭代和维护，那么肯定是优先选择面向对象的编程思想</p><h3 id="如何学习面向对象编程">如何学习面向对象编程</h3><p>那我们后面<strong>如何去学习面向对象编程</strong>呢？其实就两步：</p><ol type="1"><li>学习面向对象编程的思想</li><li>学习面向对象编程的语法</li></ol><p>这两步中，其实难的是第一步，学习面向对象编程的思想。</p><p>不管如何，什么事情都需要有个开头，那我们就从类和对象的基本概念开始好了。</p><h3 id="认识类与对象">认识类与对象</h3><p>类： 类是对象的一个抽象的概念</p><p>对象（实例）：对象就是由类创建的实例</p><p>那么这两者的关系其实就是「模具和铸件」之间的关系。</p><ol type="1"><li>类是由对象总结而来的，总结的这个过程叫做抽象。</li><li>对象是由类具体实施出来的，这个过程叫做实例化。</li></ol><p>是不是听着有些迷糊了？这里我们还是用实际例子来解释一下的好，我们思考下面的问题：</p><ul><li>水果是一个对象还是一个类？</li><li>汽车是一个对象还是一个类？</li><li>手机是一个对象还是一个类？</li></ul><p>我们在说水果的时候，你能想到什么？香蕉、苹果、西瓜、榴莲等等。对吧？那我们想了这么多不一样的东西，是不是这些所有的都称为是「水果」？那么我们将这些内容都叫做水果的过程就称为「归类」的过程。这个「水果」就是一个类，刚才我们总结的这个过程就叫做抽象，我们想到的香蕉、苹果...等等，就是对象。</p><p>汽车其实是一个概念，你能想到什么？奔驰、野马、奥迪、别摸我？那我们见过的车，就会在我们脑海中浮现，而这些具体的车总结出来一个类的过程就是「抽象的过程」，我们最后总结出来的「汽车」就是一个类。那些在我们脑海里浮现的具体的汽车，就是对象。</p><p>单我们去开车上班的时候，那么我们就是应用一个具体的对象去发生特定的功能。</p><p>再来想一个问题，我现在给大家写这个教程，用的是MacbookPro，那么请问我当前正在使用的这个MBP是对象还是一个类？</p><p>MBP的特征：金属外壳，优美的外观。</p><p>MBP的功能：给大家写教程，编辑代码，听音乐，作曲，画画....</p><p>当我描述了这么多之后，这个MBP到底是一个类还是一个对象？</p><h2 id="面向对象的基本实现">面向对象的基本实现</h2><p>如果我们需要实例一个对象，那么我们就需要先抽象一个类。</p><p>举了栗子：</p><p>我们现在需要创建一个汽车，或者千千万万个汽车用于销售。那在这之前我们要做什么？</p><p>首先，我们需要抽象一个汽车类，也就是我们要在一个设计图纸上设计处这个汽车。</p><p>然后，我们由这个设计图纸去创建（实例）出来的真实汽车就是一个对象。</p><p>那么接下来，就让我们具体到代码里去实现看看。</p><p>还记得我们之前介绍的怎么去创建一个类嘛？有没有小伙伴还记得？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个汽车的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cart</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>没错，就是使用<code>class</code>关键字来定义一个类。其书写规范如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">类名的书写规范，建议使用驼峰命名法</span><br><span class="hljs-string">    大驼峰：MyCar ChaHeng</span><br><span class="hljs-string">    小驼峰：myCar chaHeng</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>那么我们在类里需要声明些什么内容呢？一个类需要有「特征」和「功能」两个内容组成：</p><ul><li><p>特征就是一个描述：颜色：黑色， 品牌：野马，排量：2.4...；特征在编程中就是<strong>一个变量</strong>，在类中称为属性</p></li><li><p>功能就是某一项能力： 拉货，代步，上班....；功能在编程中就是<strong>一个函数</strong>，在类中称为方法</p></li></ul><p>在类中，属性一般定义在前面，方法定义在后面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个汽车的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>():<br>    <span class="hljs-comment"># 属性 =&gt; 特征 =&gt; 变量</span><br>    color = <span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-comment"># 表示颜色属性</span><br>    brand = <span class="hljs-string">&#x27;mustang&#x27;</span> <span class="hljs-comment">#表示品牌属性</span><br>    displacement = <span class="hljs-number">2.4</span> <span class="hljs-comment"># 表示排量属性</span><br><br>    <span class="hljs-comment"># 方法 =&gt; 功能 =&gt; 函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">pulling</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能拉货。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rode</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能代步。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">onDuty</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小汽车能上班。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>现在，我们拥有了一个具体的类，里面包含了特征和功能。那么我们如何通过类实例化对象并最终使用它们呢？</p><p>很简单，将其赋值给一个具体的变量就可以了，比如，我们现在去4S店实际购买一个野马汽车：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化一个对象</span><br>buyNewCar = Car()<br></code></pre></td></tr></table></figure><p>这样，就简单的实例化了一个购买的新车，让我们查看一下它的类别和各项属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(buyNewCar, <span class="hljs-built_in">type</span>(buyNewCar))<br><br><span class="hljs-comment"># 查看对象的品牌</span><br><span class="hljs-built_in">print</span>(buyNewCar.brand)<br><br><span class="hljs-comment"># 调用对象的方法</span><br>buyNewCar.rode()<br><br>---<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105e6fbb0</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.Car&#x27;</span>&gt;<br>mustang<br>小汽车能代步。。<br></code></pre></td></tr></table></figure><p>这样，我们就能看到这个对象是由类<code>Car</code>实例化得来的。并且查看到了品牌属性，试用了一下其“代步”这个功能。</p><h3 id="成员属性和方法的操作">成员属性和方法的操作</h3><p>一个对象通过实例化之后，在类中定义的属性和方法，可以使用实例化的对象进行操作。</p><p>类中定义的属性也称为成员属性，类中定义的方法，也称为成员方法。</p><p>我们直接拿之前定义的类来实例化两个对象观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">a = Car()<br>b = Car()<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><br>---<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105d37190</span>&gt;<br>&lt;__main__.Car <span class="hljs-built_in">object</span> at <span class="hljs-number">0x105d36fe0</span>&gt;<br></code></pre></td></tr></table></figure><p>我们来看，<code>a,b</code>分别实例化之后，我们将其打印出来。看到两个对象都是通过<code>Car</code>来实例化的，但是后面不同。就是说，这两者在实例化之后，完全就是两个不同的对象。那我们可以这么说，<strong>一个类可以实例化处多个对象。</strong></p><h4 id="对象的成员操作">对象的成员操作</h4><p>在类的外部，使用对象操作成员，比如，我们可以通过对象访问类中的属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = a.color<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>black<br></code></pre></td></tr></table></figure><p>还可以通过对象访问类中的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.rode()<br><br>---<br>小汽车能代步。<br></code></pre></td></tr></table></figure><p>那除了访问，我们是否可以对其进行修改呢？来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a.color = <span class="hljs-string">&#x27;red&#x27;</span><br>res = a.color<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>red<br></code></pre></td></tr></table></figure><p>可以看到，我们修改了对象的属性。那么，这个时候我们另外一个实例化对象<code>b</code>里是什么情况？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(b.color)<br><br>---<br>black<br></code></pre></td></tr></table></figure><p>依然还是<code>black</code>，并未收到<code>a</code>内属性变化的影响。</p><p>也就是说，我们操作单个对象进行属性修改，并不影响最初的类，也不会影响同一个类实例化出来的其他对象。</p><p>我们还可以给对象添加本来没有的属性来丰富这个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a.name = <span class="hljs-string">&#x27;AE86&#x27;</span><br><span class="hljs-built_in">print</span>(a.name)<br><br>---<br>AE86<br></code></pre></td></tr></table></figure><p>同样的，我们对单个对象进行的操作，一样不会影响原本的类以及其他实例化对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(b.name)<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure><p>不出所料的报错了，错误类型为属性错误。告知我们并没有<code>name</code>这个属性。</p><p>好，再让我们来看看删除这个动作。我们就直接删除<code>a</code>对象刚创建的<code>name</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.name)<br><span class="hljs-keyword">del</span> a.name<br><span class="hljs-built_in">print</span>(a.name)<br><br>---<br>AE86<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;name&#x27;</span><br></code></pre></td></tr></table></figure><p>程序显示打印了一次<code>name</code>的值，说明我们能正常获取，然后删除<code>a</code>对象中的这个属性，然后再打印来看，警告我们<code>AttributeError</code>类型错误。说明，这个时候的<code>name</code>已经不存在了。</p><p>好，让我们删除<code>a</code>继承下来的属性<code>brand</code>,不过这次为了让后续程序还能正常运行，我们使用<code>try</code>来捕获一下错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">del</span> a.brand<br><span class="hljs-keyword">except</span> AttributeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AttributeError:&#x27;</span>, e)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a.brand: &#x27;</span>, a.brand)<br><br>---<br>AttributeError: brand<br>a.brand:  mustang<br></code></pre></td></tr></table></figure><p>可以看到，我们在执行删除<code>a.brand</code>的时候报错了，后面打印的结果也证明了<code>a.brand</code>这个属性还存在，可以被打印出来。</p><p>那么问题来了，为什么之前的<code>a.name</code>可以被删除，而<code>a.brand</code>不行？这两个属性到底有什么区别？</p><p>其实，单我们执行删除一个对象的属性时，只能删除当前这个对象自己的属性才可以。而我们执行的操作中，<code>brand</code>并不是<code>a</code>自己的属性，而是属于<code>Car</code>这个类的。因为无法进行删除。</p><p><code>a.name</code>则不一样，是单独在<code>a</code>对象内创建的属性，因此可以删除。</p><p>访问成员属性，会先访问对象自己的属性，如果没有，则去访问这个对象的类的属性。</p><p>修改对象的属性值时，实际上等于给这个对象创建了一个对象自己的属性。</p><p>添加对象的属性，是给对象创建了自己独有的属性。</p><p>删除属性，只能删除这个对象自己的属性，包括给对象添加的和修改的。</p><p>接着，我们来看看在类的外部，操作对象的方法。</p><p>访问对象的方法：实际上如果这个对象没有自己独立的方法，那么会访问这个对象的类的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.rode()<br><br>---<br>小汽车能代步<br></code></pre></td></tr></table></figure><p>我们来进行修改对象的方法：给这个对象的方法重新定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是重新定义的一个方法&#x27;</span>)<br><br>a.rode = func<br>a.rode()<br><br>---<br>这里是重新定义的一个方法<br></code></pre></td></tr></table></figure><p>这样，我们就完成了方法的重新定义。</p><p>访问、修改之后，我们能不能给对象添加新的方法呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">a.func2 = func<br>a.func2()<br><br>---<br>这里是重新定义的一个方法<br></code></pre></td></tr></table></figure><p>看来也是可以的，我们现在给这个对象自己新创建了一个方法。</p><p>来，删除一下方法试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> a.func2<br></code></pre></td></tr></table></figure><p>并未报错，我们继续执行下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a.func2()<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;Car&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;func2&#x27;</span><br></code></pre></td></tr></table></figure><p>看报错，说明我们删除成功了。</p><p>方法实际上和属性一样，我们可以删除对象自己的方法，但是无法删除对象的类的方法。</p><p>至此，我们可以总结如下：</p><p>一个类定义类成员属性和成员方法，那么通过这个类实例化的对象，也具备了这些方法和属性。</p><p>实际上，创建对象的时候，并不会把类中的属性的属性和方法复制一份给对象，而是在对象中应用父类的方法。因此在访问对象的属性时，会先去找对象自己的属性，如果没有就去找这个类的属性和方法。</p><p>一个对象由类创建以后，是一个独立的对象，会应用父类中的属性和方法。如果在对象创建后，给对象的属性或方法，进行修改或添加，那么此时等于给这个对象创建了一个自己的属性和方法。所以在删除时，只能删除对象呗修改或添加的成员。</p><p>除了在类的实例化对象中对类的成员进行操作之外，我们还可以直接在类上进行操作。比如，我们可以执行下列操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Car.brand = <span class="hljs-string">&#x27;BMW&#x27;</span><br></code></pre></td></tr></table></figure><p>那现在提一个问题，在原始类的成员修改之后，这个类创建的实例化对象会如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(a.brand) <span class="hljs-comment"># 先执行一次打印，原始属性</span><br>Car.brand = <span class="hljs-string">&#x27;BMW&#x27;</span><br>b = Car() <span class="hljs-comment"># 新创建一个实例化对象</span><br><span class="hljs-built_in">print</span>(b.brand) <span class="hljs-comment"># 打印新创建的对象的属性</span><br><span class="hljs-built_in">print</span>(a.brand) <span class="hljs-comment"># 打印修改之前创建的对象的属性</span><br><br>---<br>mustang<br>BMW<br>BMW<br></code></pre></td></tr></table></figure><p>很明显，我们直接在类上进行操作修改成员之后，不管是hi新创建的实例化对象，还是早已存在的实例化对象，其中的成员属性都被修改了。删除和新加都遵循着这样一个特性。</p><p>对成员属性和方法的操作，我们也就可以总结成两种，一是「对象操作成员」，一种是「类操作成员」。当然，由于类修改后会影响具体的实例化对象，所以并不推荐这么去做。</p><h4 id="对象操作成员">对象操作成员</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">成员属性：<br>  访问：  对象.成员属性名<br>  修改：  对象.成员属性名法 <span class="hljs-operator">=</span> 新值。（此时等于给这个对象创建了一个自己的属性）<br>  添加：  对象.新成员属性 <span class="hljs-operator">=</span> 值 (此时是给这个对象自己新建了一个属性)<br>  删除：  del 对象.成员属性 (注意：只能删除这个对象自己的属性)<br>  <br>成员方法：<br>  访问：  对象.成员方法名()<br>  修改：  对象.成员方法名 <span class="hljs-operator">=</span> func（此时等于给这个对象创建了一个自己的方法）<br>  添加：  对象.方法名 <span class="hljs-operator">=</span> func (此时是给这个对象自己新建了一个方法)<br>  删除：  del 对象.方法名 (注意：只能删除这个对象自己的方法)<br></code></pre></td></tr></table></figure><h4 id="类操作成员不推荐">类操作成员（不推荐）</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">成员属性：<br>  访问：  类名.成员属性名<br>  修改：  类名.成员属性名法 <span class="hljs-operator">=</span> 新值。（此时通过这个类创建的对象都具有这个属性）<br>  添加：  类名.新成员属性 <span class="hljs-operator">=</span> 值 (此时通过这个类创建的对象都具有这个属性)<br>  删除：  del 类名.成员属性 (注意：删除这个类的属性后，这个类创建的对象也没有这几个属性了)<br>  <br>成员方法：<br>  访问：  类名.成员方法名()<br>  修改：  类名.成员方法名 <span class="hljs-operator">=</span> func（此时通过类创建的对象都被修改）<br>  添加：  类名.方法名 <span class="hljs-operator">=</span> func (此时通过类创建的对象都被修改)<br>  删除：  del 类名.方法名 (注意：此时通过类创建的对象都被修改)<br></code></pre></td></tr></table></figure><p><strong>最终总结一下如下：</strong></p><ul><li>一个类可以实例化出多个对象，每个对象在内存中都独立存在的</li><li>当通过类实例化对象时，并不会把类中的成员复制一份给对象，而去给对象了一个引用</li><li>访问对象成员的时候，如果对象自己没有这个成员，对象会向实例化它的类去查找</li><li>对象成员的添加和修改，都只会影响当前对象自己，不会影响类和其它对象</li><li>删除对象的成员时，必须是该对象自己具备的成员才可以，不能删除类中引用的成员</li><li>对类的成员操作，会影响通过这个类创建的对象，包括之前创建的。</li></ul><h3 id="成员方法中的self">成员方法中的<code>self</code></h3><p><code>self</code>在方法中只是一个形参，并不是关键字。从它本身的意义上来说，是可以用其他的关键字去替换的，但是长久以来的惯例大家都一直在使用<code>self</code>。</p><p>其作为英文单词的本意是：自己。那么在类的方法中则代表的是「当前这个对象」。不太明白？让我们来看一个实际的例子：</p><p>让我们先定义一个「Person」类，然后实例化一个「张三」：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    age = <span class="hljs-number">0</span><br>    sex = <span class="hljs-string">&#x27;sex&#x27;</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会唱歌&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dance</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会跳舞&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rap</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;会饶舌&#x27;</span>)<br><br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-built_in">print</span>(zs.name)<br><br>---<br>name<br></code></pre></td></tr></table></figure><p>成功打印出了<code>name</code>， 说明我们成功实例化了。</p><p>通过实例化的对象，我们可以在类的外部去访问成员属性和成员方法。（对象.成员）。</p><p>同样的，我们其实也可以在类的内部去访问成员属性和成员方法。让我们做一个实验，来说明一下<code>self</code>到底是什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    ...<br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><span class="hljs-comment"># print(zs.name)</span><br><span class="hljs-built_in">print</span>(zs)<br>zs.func()<br><br>---<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a048c10</span>&gt;<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a048c10</span>&gt;<br></code></pre></td></tr></table></figure><p>我们修改了这个类，在内部创建了一个方法<code>func(self)</code>，然后打印了<code>self</code>这个参数。</p><p>然后我们在外面打印了实例化的<code>zs</code>，还通过这个具体的实例化对象执行了类内部的<code>func</code>方法。实际上就是打印了一下此刻的<code>self</code>。可以看到，两个打印结果完全一样，那说明，这两者本身就是一个东西。</p><p><code>self</code>代表调用这个方法的对象，谁调用了这个方法，<code>self</code>就代表的是谁。<code>self</code>就可以在类的内部代替对象进行各种操作。</p><p>我们通过<code>self</code>来进行的操作，其实完全就是实例化的对象所作的操作。我们在类中修改<code>func</code>这个方法，让其打印<code>name</code>，修改<code>name</code>， 调用方法<code>rap</code>来试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    ...<br><br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(self.name)<br>        self.name = <span class="hljs-string">&#x27;茶桁&#x27;</span><br>        <span class="hljs-built_in">print</span>(self.name)<br>        self.rap()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br>zs.name = <span class="hljs-string">&quot;张三&quot;</span><br>zs.func() <br><br>---<br>&lt;__main__.Person <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10a06bf40</span>&gt;<br>张三<br>茶桁<br>会饶舌<br></code></pre></td></tr></table></figure><p>我们就可以很清晰的看到<code>self</code>代表的含义，谁调用，<code>self</code>就代表谁。也就是说，只要是对象能干的事情，<code>self</code>就可以代表对象去完成，比如成员的添加、删除、更新、访问、调用等等。</p><p>我们再来修改一下类里的方法，让其更清晰的显示这个特性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-string">&#x27;name&#x27;</span><br>    ...<br><br>    <span class="hljs-comment"># 成员方法</span><br>    ...<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rap</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;self.name&#125;</span>, 我会饶舌&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>       ...<br>        self.rap()<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br>zs.name = <span class="hljs-string">&quot;张三&quot;</span><br>zs.func() <br><br>---<br>我是张三, 我会饶舌<br></code></pre></td></tr></table></figure><p>在类中，我们修改了一下<code>rap</code>方法，让其调用<code>self.name</code>，在类被定义的时候，这个类中的<code>name</code>是被赋值为<code>name</code>的。然后，我们在<code>func</code>方法中调用了一下<code>self.rap()</code>,我们对其进行实例化一个对象<code>zs</code>，并且在这个实例中对<code>name</code>进行了重新赋值<code>张三</code>,接着，调用了实例化对象中的<code>func()</code>方法。</p><p>我们清晰的看到，<code>func()</code>调用了<code>self.rap()</code>，然后将<code>张三</code>打印在了屏幕上。充分说明了，这个时候的<code>self</code>代表的就是调用它的<code>zs</code>这个实例化对象。</p><p>我们直接调用类中的方法试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">Person.func()<br><br>---<br>TypeError: Person.func() missing <span class="hljs-number">1</span> required positional argument: <span class="hljs-string">&#x27;self&#x27;</span><br></code></pre></td></tr></table></figure><p>我们收到了报错，被告知缺少必须的位置参数<code>self</code>。</p><p>好，那让我们再来做两个实验，第一个实验中，我们测试一下如果在类中的方法没有使用<code>self</code>接受参数会怎样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个没有`self`的方法。&#x27;</span>)<br><br>Person.func()<br><br>a = Person()<br>a.func()<br><br>---<br>我是一个没有`self`的方法。<br>TypeError: Person.func() takes <span class="hljs-number">0</span> positional arguments but <span class="hljs-number">1</span> was given<br></code></pre></td></tr></table></figure><p>可以看到，我们可以使用类直接调用这个方法有效，但是我们创建一个实例化对象之后，利用实例化对象去调用则会报错。这个是因为，我们在用实例化对象去调用类中的方法的时候会传入一个参数。但是现在类中的<code>func()</code>方法并没有可以接受的参数，那么必定会报错。</p><p>第二个实验，我们试试不用<code>self</code>，而是其他的参数是否可以成功：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"><span class="hljs-built_in">vars</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我是<span class="hljs-subst">&#123;<span class="hljs-built_in">vars</span>.name&#125;</span>, 我使用了vars来接受参数。&#x27;</span>)<br><br>a = Person()<br>a.name = <span class="hljs-string">&#x27;admin&#x27;</span><br>a.func()<br><br>---<br>我是admin, 我使用了<span class="hljs-built_in">vars</span>来接受参数。<br></code></pre></td></tr></table></figure><p>可以看到，完全没有问题。也就是说，用实例化对象调用类中的方法时，是一定会将自己作为一个参数传给这个方法，需要一个具体的参数去接受。而参数的名称是什么则无所谓，只是大家在习惯上都是用<code>self</code>。区别如下：</p><ul><li>含有<code>self</code>或者可以接受对象作为参数的方法：非绑定类方法</li><li>不含<code>self</code>或者不能接受对象作为参数的方法：绑定类方法</li></ul><p>非绑定类方法，可以使用对象去访问, 绑定类方法，只能通过类去访问。</p><h3 id="魔术方法">魔术方法</h3><p>魔术方法是什么呢？</p><p>魔术方法也和普通方法一样都是类中定义的成员方法。这是一种不需要去手动调用的，在某种情况下，自动触发（自动执行）的方法。魔术方法特殊就特殊在定义的时候，多数的魔术方法前后都有两个连续的下划线。但是切记，这个方法并不是我们自己定义的，而是系统定义好的，我们来使用而已。</p><h4 id="init__-初始化方法"><code>__init__</code> 初始化方法</h4><p>这个初始化方法是在通过类实例化对象之后，自动触发的一个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个初始化方法。&#x27;</span>)<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大家好，我是茶桁。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person()<br><br>---<br>我是一个初始化方法。<br></code></pre></td></tr></table></figure><p>注意到了么？我们仅仅是实例化的对象而已，并没有进行任何调用，初始化方法就执行了一遍。那么，我们可以得到下面这些内容：</p><ul><li><code>__init__</code> 触发机制：在通过类实例化对象后，自动触发的一个方法</li><li>作用：可以在对象实例化之后完成对象的初始化（属性的复制，方法的调用）。</li><li>应用场景：文件的打开，数据的获取。 干活之前，做好一些准备工作。</li></ul><p>以下，我们改造一下这个类，然后再实例化的时候多做一些动作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age, sex</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个初始化方法。&#x27;</span>)<br>        <span class="hljs-comment"># 完成对象属性的初始化赋值</span><br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大家好，我是茶桁。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">41</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;我叫<span class="hljs-subst">&#123;zs.name&#125;</span>, 我今年<span class="hljs-subst">&#123;zs.age&#125;</span>岁，性别:<span class="hljs-subst">&#123;zs.sex&#125;</span>&#x27;</span>)<br><br>---<br>我是一个初始化方法。<br>我叫张三, 我今年<span class="hljs-number">41</span>岁，性别:male<br></code></pre></td></tr></table></figure><p>当然，我们还可以再初始化方法中调用<code>say</code>方法，完成自我介绍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>  ...<br>  self.say()<br>  <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;打击好，我是<span class="hljs-subst">&#123;self.name&#125;</span>。&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="del__-析构方法"><code>__del__</code>： 析构方法</h4><p>和初始化方法一样，我们直接来解析一下这个方法的触发机制，作用以及注意点。</p><ul><li>触发机制： 析构方法方法会在对象被销毁时自动触发。</li><li>作用：关闭一些开发的资源</li><li>注意：对象被销毁时触发了析构方法，而不是析构方法销毁了对象。</li></ul><p>我们还是从代码里来观察这个方法。</p><p>我们来定义一个类，完成一个日志的记录，调用这个对象的时候，传递一个日志信息。这个对象会创建一个文件，开始写入，并在最后关闭这个文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">writeLog</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    <span class="hljs-comment"># 文件的路径</span><br>    fileurl = <span class="hljs-string">&#x27;./data&#x27;</span><br>    <span class="hljs-comment"># 日志文件的名称</span><br>    filename = <span class="hljs-built_in">str</span>(time.strftime(<span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>))+<span class="hljs-string">&#x27;.log&#x27;</span><br>    <span class="hljs-comment"># 初始化 打开文件</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 完成文件的打开</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;初始化方法触发类，完成文件的打开&#x27;</span>)<br>        self.fileobj = <span class="hljs-built_in">open</span>(self.fileurl+self.filename, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-comment"># 写日志的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self,s</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;把日志<span class="hljs-subst">&#123;s&#125;</span>写入到文件中&#x27;</span>)<br><br>    <span class="hljs-comment"># 析构方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;析构方法触发了，关闭打开的文件&#x27;</span>)<br>        <span class="hljs-comment"># 在对象被销毁时，关闭在初始化方法中打开的文件对象</span><br>        self.fileobj.close()<br><br>l = writeLog()<br>l.log(<span class="hljs-string">&#x27;today is good day.&#x27;</span>)<br><span class="hljs-keyword">del</span> l<br><br>---<br>初始化方法触发类，完成文件的打开<br>把日志today <span class="hljs-keyword">is</span> good day.写入到文件中<br>析构方法触发了，关闭打开的文件<br></code></pre></td></tr></table></figure><p>这段代码中，我们实例化了<code>writeLog()</code>类，调用了初始化方法。在方法中我们打开了文件，因为我用的是变量创建，所以不一定是什么文件。当前我操作的文件为<code>2023-08-16.log</code>。</p><p>然后我们调用<code>l.log()</code>，也就是实例化对象中的<code>log</code>方法来对该文件写入一段日志内容：<code>today is good day.</code>，在执行之后，我们又使用了<code>del l</code>来销毁这个实例。在销毁实例的时候，就会调用<code>__del__</code>方法来执行其中的方法。</p><p>那么对象会在什么情况下被销毁呢？</p><ol type="1"><li>当程序执行完毕，内存中所有的资源都会被销毁释放</li><li>使用 del 删除时</li><li>对象没有被引用时，会自动销毁</li></ol><h2 id="面向对象的三大特性">面向对象的三大特性</h2><p>面向对象有三大特性，分别是「封装、继承、多态」，那么它们具体都是什么呢？下面让我们分别来解释。</p><h3 id="封装">封装</h3><p>封装，就是使用特殊的语法，对成员属性和成员方法进行包装，达到保护和隐藏的目的。就像我们送礼的时候，会找东西把礼物包起来一样。</p><p>但是一定注意，不能把成员全部封装死，就失去意义了。就好比我们买的笔记本电脑，无论如何都会给你留下一些接口的，比如说电源接口，USB接口等等。只有有了这些接口，我们才能插上鼠标啊，移动硬盘等等来进行使用。</p><p>被封装的成员主要是供类的内部使用。被特殊语法封装的成员，会有不同的访问的权限。比如笔记本内的硬盘，内存等等，这些并不是不让你使用，而是提供给笔记本本身使用，我们可以操作笔记本电脑来达到间接使用它们的目的。</p><p>封装分为了几个不同的级别，一般情况下有三种：</p><p>公有的 public</p><p>受保护的 protected</p><p>私有的 private</p><p>被特殊语法封装的成员，会有不同的访问权限。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    sex = <span class="hljs-literal">None</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self.age = age<br>        self.sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;talk about life.&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kiss</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;come on...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><br><span class="hljs-comment"># 查看对象的所有成员</span><br><br><span class="hljs-built_in">print</span>(Person.__dict__) <span class="hljs-comment"># 获取当前类的所有成员信息</span><br><span class="hljs-built_in">print</span>(zs.__dict__) <span class="hljs-comment"># 获取当前对象的所有成员信息</span><br><br><span class="hljs-comment"># 我们也可以直接访问对象所有的方法</span><br><span class="hljs-built_in">print</span>(zs.name)<br>zs.kiss()<br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Person.__init__ at <span class="hljs-number">0x111a355a0</span>&gt;, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Person.say at <span class="hljs-number">0x111a35750</span>&gt;, <span class="hljs-string">&#x27;sing&#x27;</span>: &lt;function Person.sing at <span class="hljs-number">0x111a357e0</span>&gt;, <span class="hljs-string">&#x27;kiss&#x27;</span>: &lt;function Person.kiss at <span class="hljs-number">0x111a35870</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br>张三<br>come on...<br></code></pre></td></tr></table></figure><p>在整段代码中，我们实例化对象的时候，基本可以访问<code>Person</code>类中所有的成员。我们说定义的属性和方法，都可以无障碍访问。那么，我们现在说定义的这些成员，就都是<code>Public</code>级别。</p><p>现在想象一个场景，我们走在美国街头上，遇到一个美女，然后我们上前询问人家的年龄，大多数时候我们得不到想要的答案。而如果我们上去询问性别（现在知道为什么我要设定为美国街头了吧？），我估计这个就是保密的了吧，有可能一种情况就是当事人在当时的情况下，自己都不知道自己是什么性别。</p><p>那这个时候，我们就需要改写一下这段代码了,改写之前，我们需要理解一下<code>Python</code>中不同级别成员的定义方式，分别为：</p><ul><li><code>str</code> =&gt; 公共的</li><li><code>_str</code> =&gt;受保护的（约定俗成，在Python中没有具体实现）</li><li><code>__str</code> =&gt; 私有的。</li></ul><p>在了解了定义方法之后，我们可以着手来做实验了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-comment"># 成员属性</span><br>    name = <span class="hljs-literal">None</span><br>    _age = <span class="hljs-literal">None</span> <span class="hljs-comment"># 这是一个protected 成员属性</span><br>    __sex = <span class="hljs-literal">None</span> <span class="hljs-comment"># 这是一个 private 成员属性</span><br><br>    <span class="hljs-comment"># 初始化方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, sex</span>):<br>        self.name = name<br>        self._age = age<br>        self.__sex = sex<br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;talk about life.&#x27;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_sing</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 这是一个protected 成员方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sing a song.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__kiss</span>(<span class="hljs-params">self</span>): <span class="hljs-comment"># 这是一个private 成员方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;come on...&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>zs = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;male&#x27;</span>)<br><br><span class="hljs-comment"># 查看对象的所有成员</span><br><br><span class="hljs-built_in">print</span>(Person.__dict__) <span class="hljs-comment"># 获取当前类的所有成员信息</span><br><span class="hljs-built_in">print</span>(zs.__dict__) <span class="hljs-comment"># 获取当前对象的所有成员信息</span><br><br>---<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_age&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;_Person__sex&#x27;</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Person.__init__ at <span class="hljs-number">0x111f99630</span>&gt;, <span class="hljs-string">&#x27;say&#x27;</span>: &lt;function Person.say at <span class="hljs-number">0x111f996c0</span>&gt;, <span class="hljs-string">&#x27;sing&#x27;</span>: &lt;function Person.sing at <span class="hljs-number">0x111f99870</span>&gt;, <span class="hljs-string">&#x27;kiss&#x27;</span>: &lt;function Person.kiss at <span class="hljs-number">0x111f99c60</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Person&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;_age&#x27;</span>: <span class="hljs-number">49</span>, <span class="hljs-string">&#x27;_Person__sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们调用实例化方法得到的结果已经和之前有所不同了。最终拿到的<code>__sex</code>成员属性是属于类的。</p><p>现在让我们逐一来调用一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(zs._age)<br><span class="hljs-built_in">print</span>(zs.__sex)<br><br>---<br><span class="hljs-number">49</span><br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__sex&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>_age</code>作为受保护的成员属性可以调用，但是<code>__sex</code>作为私有成员属性则不允许。</p><blockquote><p>实际上，受保护的成员属性也是不能调用的，但是Python中因为没有具体实现，所以唯独在Python中可以调用。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">zs._sing()<br>zs.__kiss()<br><br>---<br>sing a song.<br>AttributeError: <span class="hljs-string">&#x27;Person&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;__kiss&#x27;</span><br></code></pre></td></tr></table></figure><p>那么，作为受保护的成员方法<code>_sing</code>被正常调用了，但是室友的成员方法<code>__kiss</code>调用的时候报错。看来和成员属性是一致的。</p><p>那么我们现在就可以总结如下：</p><table><colgroup><col style="width: 15%" /><col style="width: 21%" /><col style="width: 40%" /><col style="width: 23%" /></colgroup><thead><tr class="header"><th></th><th>公有的(Public)</th><th>受保护的(Protected)</th><th>私有的(Private)</th></tr></thead><tbody><tr class="odd"><td>在类的内部</td><td>可以访问</td><td>可以访问</td><td>可以访问</td></tr><tr class="even"><td>在类的外部</td><td>可以访问</td><td>不可以访问（Python中可以）</td><td>不可以访问</td></tr></tbody></table><p>在实现上我们总结如下：</p><table style="width:100%;"><colgroup><col style="width: 2%" /><col style="width: 23%" /><col style="width: 37%" /><col style="width: 37%" /></colgroup><thead><tr class="header"><th></th><th>公有的(Public)</th><th>受保护的(Protected)</th><th>私有的(Private)</th></tr></thead><tbody><tr class="odd"><td>定义</td><td>默认定义的成员都属于公有成员</td><td>在成员名称前面加一个下划线 <code>_成员名称</code></td><td>在成员名称前面加两个下划线 <code>__成员名称</code></td></tr><tr class="even"><td>特征</td><td>公有的成员可以在任何位置进行访问和操作</td><td>受保护的成员和公有成员一样可以在任何位置进行访问，但是一般不要随便访问和操作受保护成员</td><td>私有的成员只能在当前类的内部去访问和操作，不能在类的外部进行操作</td></tr></tbody></table><p><strong>⚠️ 这里我们需要注意Python特殊的亮点：</strong></p><ol type="1"><li>在python中并没有实现受保护的封装，属于开发者的约定俗成。</li><li>python中的私有化封装是通过改名策略实现的，并不是真正的私有化</li></ol><h3 id="继承">继承</h3><p>继承是什么？我们是不是经常听到「文化的继承，技艺的继承，衣钵的继承...」等等这些。</p><p>那计算机的继承又是什么？</p><p>在面向对象中，一个类去继承父类，那么这个类就拥有了父类中除了私有成员之外的所有成员，包括属性和方法。这个，就叫做继承。</p><p>在整个继承过程中，被其他类继承的类就称为「父类」，也可以称为「基类」或者「超类」。那么继承其他类的类，就被称为「子类」，也可以称为「派生类」。</p><p>那么我们继承又什么意义吗？继承的主要意义，就是为了提高代码的重用性，建立新的类与类的关系，方便其他逻辑的操作。</p><p>继承实现起来其实非常方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承的语法格式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父类</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>我们直接看代码来理解，比如，我有如下定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    coatColor = <span class="hljs-string">&#x27; white&#x27;</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们看，猫是不是也是属于猫科动物的一种动物？那么在猫科动物中定义的所有成员，其实在猫这边我也会有。不过这样重复定义是不是感觉特别繁琐？其实，我们在<code>Cat</code>中完全不需要再次输入这么多，完全可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    <span class="hljs-keyword">pass</span><br><br>mimi = Cat()<br>mimi.run()<br></code></pre></td></tr></table></figure><p>这样，我在定义<code>Cat</code>的时候就完成了对<code>Felidae</code>的继承，然后我们实例化一个<code>Cat</code>,再调用这个实例化对象中的方法<code>run()</code>，也就输出了原本是属于类<code>Felidae</code>中的<code>run()</code>方法。</p><p>我们再继承父类的时候，之类还可以写入自己独有的成员属性或方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    size = <span class="hljs-string">&#x27;small&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃猫粮。&#x27;</span>)<br>    <span class="hljs-keyword">pass</span><br>  <br>mimi = Cat()<br>mimi.run()<br><span class="hljs-built_in">print</span>(mimi.size)<br>mimi.eat()<br>Felidae.eat()<br><br>---<br>轻盈的跳跃<br>small<br>吃猫粮。<br><br>AttributeError: <span class="hljs-built_in">type</span> <span class="hljs-built_in">object</span> <span class="hljs-string">&#x27;Felidae&#x27;</span> has no attribute <span class="hljs-string">&#x27;eat&#x27;</span><br></code></pre></td></tr></table></figure><p>我们定义<code>Cat</code>的时候，除了继承<code>Felidae</code>里的成员之外，还定义了一个<code>size</code>成员属性和一个<code>eat</code>成员方法。然后我们在实例化对象中进行调用，都正常运行。</p><p>这个时候我们反过来，使用父类<code>Felidae</code>来调用在之类<code>Cat</code>中定义的成员，则会报错。说明这个成员是独属于之类的。</p><p>我们不仅可以继承的时候进行扩展，还可以复写父类中的方法，使的它与父类方法产生差异化。其方法是在子类中将父类的方法重新定义一遍就可以了。</p><p>那有什么办法在我重写父类方法的时候，仍然可以调用父类方法吗？也是可以的，就是使用<code>super().父类方法名()</code>来进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义猫科动物</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Felidae</span>():<br>    <span class="hljs-comment"># 属性</span><br>    coatColor = <span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-comment"># 毛色</span><br>    sex = <span class="hljs-string">&#x27;M&#x27;</span> <span class="hljs-comment"># 定义性别</span><br><br>    <span class="hljs-comment"># 成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;轻盈的跳跃&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">walk</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;走的猫步&#x27;</span>)<br><br><span class="hljs-comment"># 定义猫</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Felidae</span>):<br>    size = <span class="hljs-string">&#x27;small&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().run()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;更加轻盈的跳跃。&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;吃猫粮。&#x27;</span>)<br><br>    <span class="hljs-keyword">pass</span><br><br>mimi = Cat()<br>mimi.run()<br><br>---<br>轻盈的跳跃<br>更加轻盈的跳跃。<br></code></pre></td></tr></table></figure><p>我们可以看到，在子类中我们重写了父类中的<code>run</code>方法，但是由于我们在重写的时候在内部使用了<code>super().run()</code>。所以父类中的方法被完全调用了一遍。</p><p>所以，我们目前可以总结<strong>继承的特征</strong>如下：</p><ul><li>在不指定继承的父类时，所有类都继承自object类（系统提供） 了解</li><li>子类继承了父类后，就拥有了父类中的所有成员包括魔术方法（除了私有成员）</li><li>子类继承父类后，并不会把父类的成员复制给子类，而去引用</li><li>子类继承父类后可以重写父类中的方法，叫做 重写</li><li>子类重写父类的方法，依然可以使用<code>super().父类方法名()</code>的方式调用父类的方法</li><li>子类中如果定义了父类中不存在的方法，称为对父类的扩展</li><li>一个父类可以被多个子类继承，还可以存在 链式继承 。<ul><li>链式继承：A类继承了B类，B类继承了C类，C类继承了D类。。。</li></ul></li></ul><h3 id="单继承和多继承">单继承和多继承</h3><p>一个类只能继承一个父类的方式，就叫做单继承。如果一个类继承了多个父类的方式，就称为多继承。直接看例子，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;人的样子。&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chusheng</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;畜生的特性。&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Japanese</span>(Person, Chusheng):<br>    <span class="hljs-keyword">pass</span><br><br>c = Japanese()<br>c<br><br>---<br>人的样子。<br>畜生的特性。<br></code></pre></td></tr></table></figure><p>像代码中定义的<code>Japanese</code>类，同时继承了<code>Person</code>和<code>Chusheng</code>，那这个，就属于多继承。我们来区分一下语法特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父类</span>():<br>  <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子类</span>(<span class="hljs-title class_ inherited__">父类</span>):<br>  <span class="hljs-keyword">pass</span><br>  <br><span class="hljs-comment"># 多继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">父</span>():<br>  <span class="hljs-keyword">pass</span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">母</span>():<br>  <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">子</span>(父，母):<br>  <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>在多继承的关系里，有一个有意思的部分，我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大口撕咬食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小口吞咽食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(Tiger, Cat):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;到底该怎么吃？&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = C()<br>c.eat()<br></code></pre></td></tr></table></figure><p>我们现在看到这段代码是一个多继承关系，我在<code>C</code>这个类中继承了<code>Tiger</code>和<code>Cat</code>两个类，并且复写了<code>eat()</code>这个方法。按道理来说，我们实例化<code>C</code>类之后，打印的结果一定是复写的结果。但是我们在<code>C</code>类的<code>eat</code>方法里还调用了<code>super().eat()</code>，我们知道<code>super()</code>是调用一遍父类的方法。那么这里到底是调用<code>Tiger</code>里的<code>eat</code>方法，还是<code>Cat</code>里的<code>eat</code>方法呢？</p><p>让我们看打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">---<br>大口撕咬食物...<br>到底该怎么吃？<br></code></pre></td></tr></table></figure><p>打印结果有没有出乎你的意料？那么这个原因是什么呢？其实也不复杂，就是因为<code>Tiger</code>的调用在前面，<code>Cat</code>在后面。让我们重新改一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;大口撕咬食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;小口吞咽食物...&#x27;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(Cat,Tiger):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;到底该怎么吃？&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = C()<br>c.eat()<br><br>---<br>小口吞咽食物...<br>到底该怎么吃？<br></code></pre></td></tr></table></figure><p>这就证实了，谁在前面就调用谁的方法。</p><h3 id="菱形继承钻石继承">菱形继承（钻石继承）</h3><p>先来看一个图形：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">  <span class="hljs-selector-tag">A</span><br><span class="hljs-selector-tag">B</span>   C<br>  D<br></code></pre></td></tr></table></figure><p>那我们先有一个<code>A</code>类，下面有<code>B</code>和<code>C</code>类，再下面还有一个<code>D</code>类。</p><p>看图可能还是不太明白，它们之间的关系是这样的：<code>B</code>和<code>C</code>继承了<code>A</code>类，然后<code>D</code>又多继承了<code>B</code>和<code>C</code>。</p><p>那么这种继承关系就叫做菱形继承。</p><p>那么我们现在面临的一个问题就是：在这种菱形继承关系中，类与类是什么关系？<code>super()</code>调用时的顺序是怎样的？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菱形继承</span><br><br><span class="hljs-comment"># 祖先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    num = <span class="hljs-number">111</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学着凭借本能寻找食物...&#x27;</span>)<br><br><span class="hljs-comment"># 父亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">222</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化了，学会大口吃肉。。。&#x27;</span>)<br><br><span class="hljs-comment"># 母亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">333</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化的另外一个分支，小口吞咽...&#x27;</span>)<br><br><span class="hljs-comment"># 子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<br>    num = <span class="hljs-number">444</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;居然退化了，又忘了怎么吃...&#x27;</span>)<br><br>d = D()<br>d.eat()<br><br>---<br>学着凭借本能寻找食物...<br><span class="hljs-number">111</span><br>进化的另外一个分支，小口吞咽...<br><span class="hljs-number">333</span><br>进化了，学会大口吃肉。。。<br><span class="hljs-number">222</span><br>居然退化了，又忘了怎么吃...<br></code></pre></td></tr></table></figure><p>那么我们来看一下，究竟是怎样的一个顺序：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">D.super<span class="hljs-function"><span class="hljs-params">()</span> =&gt; <span class="hljs-title">B</span>.<span class="hljs-title">super</span><span class="hljs-params">()</span> =&gt;<span class="hljs-title">C</span>.<span class="hljs-title">super</span><span class="hljs-params">()</span> =&gt; <span class="hljs-title">A</span>.<span class="hljs-title">print</span><span class="hljs-params">()</span> -&gt;</span> C.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> B.<span class="hljs-built_in">print</span><span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> D.<span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure><p>上边这一段中，<code>=&gt;</code>是继承关系，<code>-&gt;</code>是执行顺序。</p><p>好，那我们这个时候要清楚一个点是，我们使用的<code>d</code>这个实例化去执行的，那么在这所有的继承类中，<code>self</code>全部都是<code>c</code>这个实例化对象。让我们来看看到底是不是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 菱形继承</span><br><br><span class="hljs-comment"># 祖先</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>():<br>    num = <span class="hljs-number">111</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;学着凭借本能寻找食物...&#x27;</span>)<br><br><span class="hljs-comment"># 父亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">222</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化了，学会大口吃肉。。。&#x27;</span>)<br><br><span class="hljs-comment"># 母亲</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(<span class="hljs-title class_ inherited__">A</span>):<br>    num = <span class="hljs-number">333</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(self.num)<br>        <span class="hljs-built_in">print</span>(self)<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;进化的另外一个分支，小口吞咽...&#x27;</span>)<br><br><span class="hljs-comment"># 子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B, C):<br>    num = <span class="hljs-number">444</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().eat()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">super</span>().num)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;居然退化了，又忘了怎么吃...&#x27;</span>)<br><br>d = D()<br>d.eat()<br><br>---<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br><span class="hljs-number">444</span><br>&lt;__main__.D <span class="hljs-built_in">object</span> at <span class="hljs-number">0x111b71540</span>&gt;<br>学着凭借本能寻找食物...<br><span class="hljs-number">111</span><br>进化的另外一个分支，小口吞咽...<br><span class="hljs-number">333</span><br>进化了，学会大口吃肉。。。<br><span class="hljs-number">222</span><br>居然退化了，又忘了怎么吃...<br></code></pre></td></tr></table></figure><p>打印的结果证实了我们刚才的说法。</p><p>这个地方可能比较让人意外的是之前那个继承关系上，明明我<code>B</code>继承的是<code>A</code>，怎么变成<code>C</code>了？我们来看看原因：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">在定义类之后，程序会自动生成一个继承的列表MRO(Method Realtion Order)方法关系列表</span><br><span class="hljs-string">MRO列表生成原则：</span><br><span class="hljs-string">1. 子类永远在父类的前面</span><br><span class="hljs-string">2. 同一等级的类，按照之类中的继承顺序摆放</span><br><span class="hljs-string">3. 先之类，后父类的顺序原则，最终的类是系统提供的obejct类</span><br><span class="hljs-string"></span><br><span class="hljs-string">MRO的调用方法</span><br><span class="hljs-string">类名.mro()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>D.mro()<br><br>---<br>[__main__.D, __main__.B, __main__.C, __main__.A, <span class="hljs-built_in">object</span>]<br></code></pre></td></tr></table></figure><p><code>super</code>在调用时，并不是查找父类，而是去MRO列表上找上一个类。</p><p><code>super</code>方法在调用时，会自动把当前<code>self</code>传入到上一级的类的方法中。</p><p>所以我们之前会呈现出<code>D=&gt;B=&gt;C=&gt;A</code>的顺序。</p><p>看着有点晕是吧？别着急，我们接下来介绍一个方法，能很方便的看到类关系。</p><h3 id="issubclass类关系检测"><code>issubclass()</code>类关系检测</h3><p>这个方法是检测一个类是否是另一个类的之类的方法。用起来也非常简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">issubclass</span>(D, B)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(D, C)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(D, A)<br><span class="hljs-built_in">print</span>(res)<br>res = <span class="hljs-built_in">issubclass</span>(A, D)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="多态">多态</h3><p>对于同一个方法，由于调用的对象不同，产生了不同形态的结果。这个就叫做多态。</p><p>比如说，我们现在的电脑上有一个USB接口，那么这个接口在接入不同的设备的时候，产生的结果也是不一样的。插入鼠标，我们可以点击。插入键盘我们可以输入，插入U盘呢，我们可以读取。对吧？对于这个USB接口来说。就属于多态。</p><p>好的，让我们来实现一下，直接看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span>():<br>    <span class="hljs-comment"># 在电脑类中定义一个 sub 的规范的接口 方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">usb</span>(<span class="hljs-params">self,obj</span>):<br>        obj.start()<br><br><span class="hljs-comment"># 定义鼠标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标启动成功，可以双击单击嗨起来。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义键盘类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBord</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘启动成功了，赶紧输入666。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义 U盘 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Udisk</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;U盘启动了，赶紧检查一下我的种子还在不在。。。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>c = Computer()  <span class="hljs-comment"># 电脑对象</span><br>m = Mouse()     <span class="hljs-comment"># 鼠标对象</span><br>k = KeyBord()   <span class="hljs-comment"># 键盘对象</span><br>u = Udisk()     <span class="hljs-comment"># u盘对象</span><br><br><br><span class="hljs-comment"># 把不同的设备插入到电脑的usb的接口中</span><br>c.usb(m)<br>c.usb(k)<br>c.usb(u)<br><br>---<br>鼠标启动成功，可以双击单击嗨起来。。。<br>键盘启动成功了，赶紧输入<span class="hljs-number">666</span>。。。<br>U盘启动了，赶紧检查一下我的种子还在不在。。。<br></code></pre></td></tr></table></figure><p>这样，我们就实现了一个多态的程序。</p><p>我们在实例化<code>Computer()</code>之后，利用实例化对象<code>c</code>调用类中的方法<code>usb</code>，将实例化对象传入，并且还传入了不同的<code>obj</code>，这里的<code>obj</code>是我们之前实例化过的<code>m, k, u</code>。那这样，我们<code>obj</code>代表了不同的实例化对象，那也就会启动不同的类方法。</p><p>那这样呢，属于一个普通的方式来实现，其实对于这段程序，我们还可以使用继承关系来完成。</p><p>我们先定义一个接口规范类，其他类都继承这个类，并实现（重写）父类中的方法。由于每个对象实现父类的方式或者过程都不相同，最后的结果是不一样的形态。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承关系写多态</span><br><br><span class="hljs-comment"># 定义USB</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">USB</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    info:</span><br><span class="hljs-string">        这个类是一个接口规范类，需要子类继承并实现start方法</span><br><span class="hljs-string">        start方法不做任何具体功能的实现</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 在usb类中定义一个规范的接口方法，但是不实现任何功能</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义鼠标类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouse</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;鼠标启动成功，可以双击单击嗨起来。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义键盘类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyBord</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;键盘启动成功了，赶紧输入666。。。&#x27;</span>)<br><br><span class="hljs-comment"># 定义 U盘 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Udisk</span>(<span class="hljs-title class_ inherited__">USB</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;U盘启动了，赶紧检查一下我的种子还在不在。。。&#x27;</span>)<br><br><span class="hljs-comment"># 实例化对象</span><br>m = Mouse()<br>k = KeyBord()<br>u = Udisk()<br><br>m.start()<br>k.start()<br>u.start()<br><br>---<br>鼠标启动成功，可以双击单击嗨起来。。。<br>键盘启动成功了，赶紧输入<span class="hljs-number">666</span>。。。<br>U盘启动了，赶紧检查一下我的种子还在不在。。。<br></code></pre></td></tr></table></figure><p>我们回来看这段代码，实际上，如果抛开<code>USB</code>类，我们单独去写后面的类，并且把继承关系去掉。最后是不是也可以进行打印？可以...</p><p>可是这样的话，那这三个方法中的<code>satrt</code>方法之间就毫无关系，继承了<code>USB</code>中的<code>start</code>方法，也就是继承了规范。</p><p>而且这个继承的形式，和我们之前实现的普通版本其实并无什么差别，虽然代码实现上有不同，可是逻辑上是完全相同的。</p><p>好了，关于面向对象，我们就先介绍到这里。不过别着急，并不是讲完了，我们下节课还要接着讲「面向对象」。讲解一些高级语法和思想。小伙伴们记得关注。</p><p>另外，面向对象这个东西，确实蛮难的，并不是看我这一两节课就能学懂的。虽然我尽力，但是我还是有自知之明。</p><p>在这里给大家推荐一本好书，有它在，你想不懂都难。 <code>^_^</code></p><p><a href="https://u.jd.com/2zo4Ee3">领取优惠券</a>再<ahref="https://u.jd.com/2QmKR3j">购买</a>：</p><p><imgsrc="https://img1.doubanio.com/view/subject/l/public/s24550919.jpg"alt="img" /></p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Object-Oriented-Programming/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>20. 异常处理</title>
    <link href="https://hivan.me/Get-the-exception/"/>
    <id>https://hivan.me/Get-the-exception/</id>
    <published>2023-08-15T05:35:35.000Z</published>
    <updated>2023-08-15T12:58:41.436Z</updated>
    
    <content type="html"><![CDATA[<img src="/Get-the-exception/cover.png" class="" title="cover"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>在我们日常使用Python或者其他编程语言的时候，不可避免的都会出现报错和异常。那么，我们今天就来谈谈异常。</p><h2 id="什么是异常">什么是异常？</h2><p>异常异常，根据名字简单理解，那就是非正常，也就是没有达到预期目标。</p><p>异常呢，其实就是一个事件，并且这个异常事件在程序的运行过程中出现，会影响程序的正常执行。而一般来说，异常被分为两种：</p><ol type="1"><li>语法错误导致的异常</li><li>逻辑错误导致的异常</li></ol><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">varlist = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(varlist[<span class="hljs-number">3</span>])<br><br>---<br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>这个时候，系统抛出了异常，提示我们列表索引超出范畴。</p><p>这里我们需要知道，「异常」在Python中实际上也是一个对象，表示一个错误。当我们的程序无法继续正常进行时，就会被抛出。</p><p>我们来完整的看看这个报错信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">---------------------------------------------------------------------------<br>IndexError                                Traceback (most recent call last)<br>Cell In[<span class="hljs-number">2</span>], line <span class="hljs-number">2</span><br>      <span class="hljs-number">1</span> varlist = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>----&gt; <span class="hljs-number">2</span> <span class="hljs-built_in">print</span>(varlist[<span class="hljs-number">3</span>])<br><br>IndexError: <span class="hljs-built_in">list</span> index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>Python在遇到异常之后，首先会给出一个「错误回溯」，然后给出具体哪一句代码出现了问题。</p><p>然后在最后给出异常分类和解释。那么<code>IndexError</code>告知我们，这是一个「索引错误」，并且给出了具体的描述「列出索引超出范围」。其中<code>IndexError</code>是我们的异常类，<code>list index out of range</code>是我们的异常信息。</p><p>在程序运行过程中，会出现各种各样的异常类，常见标准异常类，我放在最下面作为一个附录。</p><h2 id="如何处理异常">如何处理异常</h2><h3 id="可预知">可预知</h3><p>如果错误发生的情况是我们可以预知的，那么就可以使用流程控制进行预防处理。比如，两个数字的运算，其中一个不是数字，运算就会出错，这个时候就可以判断来预防：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">n2 = <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(n2, <span class="hljs-built_in">int</span>):<br>    res = <span class="hljs-number">10</span>+n2<br>    <span class="hljs-built_in">print</span>(res)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;非整型。&#x27;</span>)<br><br>---<br>非整形<br></code></pre></td></tr></table></figure><p>在这一段代码中，我们使用<code>isinstance</code>方法来检测第一个参数是否是第二个参数的所属类型。这是一个用来检测的方法，返回<code>True</code>或者<code>False</code>。那我们在<code>if</code>中，只有真才会打印结果，假则会打印另外一则消息。</p><p>有些小伙伴会想，那既然知道不是整型就会出错，那前面限制传如整型不就好了，干嘛还要费劲去做非整判断。</p><p>你要知道，很多时候一个程序的编写和维护并不是单一一个人来做的，即便是一个人在做，也不能完全保证自己某个地方埋下了隐患。那么在每一段代码中，我们对可能预知的情况做妥善的预防是必须的。</p><h3 id="不可预知">不可预知</h3><p>那可预知的情况我们避免了，可是在我们编写代码的时候，更多的情况是我们自己都不知道我们到底埋了什么雷，哪一段没有遵循规则或者逻辑。那这种情况就是不可预知的。</p><p>对于这种不可预知的情况我们该怎么办呢？我们又没办法预先判断。那这种情况下，我们可以使用<code>try...except...</code>语句，在错误发生时进行处理。相关语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    可能发生异常错误的代码<br><span class="hljs-keyword">except</span>:<br>    如果发生异常这进入<span class="hljs-keyword">except</span>代码块进行处理<br><br>异常被捕获之后程序继续向下执行<br></code></pre></td></tr></table></figure><p>我们来看个示例，比如我们之前做过的一个注册、登录练习。其中我们有一段代码是要去读取列表中的所有用户。之前我们的练习中，有提到过文件不存在的情况，所以我们使用了<code>a+</code>的方法，当文件不存在的时候，就新建。</p><p>那么现在，我们假设我们就用了<code>r</code>的方法，当文件不存在的时候，一定会报错对吧？这个时候，我们可以使用两种方式来进行处理。</p><p>第一种方式，就可以在读取前先判断当前文件是否存在。</p><p>第二种方式，就可以使用<code>try...except...</code>在错误发生的时候进行处理。</p><p>那么这里，我们用第二种方式来做一下处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设我们读取的文件不存在，会发生错误</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user5.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件不存在。&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序继续运行...&#x27;</span>)<br><br>---<br>文件不存在。<br>程序继续运行...<br></code></pre></td></tr></table></figure><p>可以看到，我们准确的捕获了错误，并且之后程序仍然继续往后执行了。</p><blockquote><p>⚠️ <code>try...except...</code>是在错误发生后进行处理，并不是提前判断。也就是说，错误其实还是发生了。这和<code>if</code>实际上有根本性的区别。</p></blockquote><h2 id="try...except...-详解">try...except... 详解</h2><p>首先，我们认识<code>try...except</code>的一个特性，就是它可以处理指定的异常，如果引发了非指定的异常，则无法处理。比如，我们下面人为制造一个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-built_in">int</span>(s1)<br><br>---<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，我们这一段代码引发了一个<code>ValueError</code>异常。</p><p>现在我们来捕获一下,但是这次，我们为这个异常指定一个异常类再来看看，先看看正常状态下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序错误。&#x27;</span>)<br>    <br>---<br>程序错误。<br></code></pre></td></tr></table></figure><p>接着我们来看指定异常之后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;程序错误。&#x27;</span>)<br>    <br>---<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br></code></pre></td></tr></table></figure><p>这里我们指定了一个<code>IndexError</code>的异常类，显然我们之前看到了，程序报错是<code>ValueError</code>异常类，两者并不匹配。所以最后依然还是报错。</p><p>那么之前我们谈到过标准的异常类，并且也知道异常实际上也就是一个对象。而我们平时在使用的时候，<code>except</code>实际上就是去这个「标准的异常类」的列表里去查找，如果没有对应的异常类，它依然是无法捕获的。不过大部分时候，我们基本不会遇到标准异常类之外的异常。而这种处理指定的异常类的特性，平时也可以被我们使用。</p><p>其中一个使用方式，就是进行多分支处理异常类，不同的异常可以走不通的<code>except</code>进行处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    s1[<span class="hljs-number">5</span>] <span class="hljs-comment"># IndexError</span><br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是IndexError&#x27;</span>, e)<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是KeyError&#x27;</span>, e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这里是ValueError&#x27;</span>, e)<br>    <br>---<br>这里是IndexError string index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>是不是和<code>if...elif</code>的分支形式很像？</p><p>让我们继续，在我们说指定的异常类中，实际上会有一个万能的通用异常类。那就是<code>Exception</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception ===&#x27;</span>,e)<br>    <br>---<br>Exception === invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>基本上所有的异常，都可以走到这个异常类。在这段代码中，我们之前记得<code>int(s1)</code>是属于一个<code>ValueError</code>，但是我们使用<code>Exception</code>依然可以获取到这个错误。可是如果这两种异常类同时被指定的情况下会如何？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(s1)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception ===&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError ===&#x27;</span>, e)<br>    <br>---<br>Exception === invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>我们看到，就是按照程序的从上至下的顺序在执行。</p><p>所以，其实我们可以这样理解，当我们进行多分支异常类+通用异常类的时候，<code>Exception</code>是最后的一个保底。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># int(s1) # ValueError</span><br>    s1[<span class="hljs-number">5</span>]    <span class="hljs-comment"># IndexError</span><br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IndexError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;KeyError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>,e)<br>    <br>---<br>IndexError string index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>除此之外，<code>try...except</code>是支持<code>else</code>的，当<code>try</code>里的代码顺利执行没有捕获到任何错误之后，还可以走到<code>else</code>之中额外执行分支内的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">str</span>(s1)<br>    <span class="hljs-built_in">print</span>(s1)<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IndexError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>,e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try代码块中没有引发异常时，执行&#x27;</span>)<br>    <br>---<br>hello<br><span class="hljs-keyword">try</span>代码块中没有引发异常时，执行<br></code></pre></td></tr></table></figure><p>我们再来了解一下<code>finally</code>,这个方法是无论是否引发异常都会执行。通常情况下用于执行一些清理工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = <span class="hljs-string">&#x27;hello&#x27;</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(s1)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;如果前面的代码引发了异常，这个代码块将不在继续执行。。&#x27;</span>)<br><span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IndexError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ValueError&#x27;</span>,e)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>,e)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try代码块中没有引发异常时，执行&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;无论是否引发了异常，都会执行这个代码块&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;如果上面的代码有异常并且进行了处理，那么后面的代码将继续执行&#x27;</span>)<br><br>---<br>ValueError invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;hello&#x27;</span><br>无论是否引发了异常，都会执行这个代码块<br>如果上面的代码有异常并且进行了处理，那么后面的代码将继续执行<br></code></pre></td></tr></table></figure><p>这段代码中，我们引发了一个异常，也被捕获了。但是依然执行了<code>finally</code>内的代码，并且也未影响程序继续往后执行。</p><p>在我们平常写代码的过程中还有一种情况，就是我们需要自己制作一个异常信息，然后抛出。这个时候，我们需要用<code>raise</code>，来主动抛出异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;发生错误&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Exception&#x27;</span>, e)<br>    <br>---<br>Exception 发生错误<br></code></pre></td></tr></table></figure><p>除了上述的异常处理之外，其实还有另外一种方式，是直接判断逻辑是否成立，不成立抛出<code>AssertionError</code>错误。就是使用<code>assert</code>进行断言。它在表达式错误的时候，会直接抛出<code>AssertionError</code>错误，如果表达式正确，这什么都不做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">assert</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span><br><br>---<br>AssertionError: <br></code></pre></td></tr></table></figure><h2 id="自定义异常处理类">自定义异常处理类</h2><p>虽然系统已经给到了很多异常处理的方式，而我们在平时开发中也会经常的使用。但是实际上，很多时候我们都需要一些自己的处理要求。比如说，当异常出现的时候，我们要将异常信息写入日志，在日后我们从日志里查看日常信息或者做数据分析，就是我们最常使用的。</p><p>那我们接下来看看，如果做一个异常处理的自定义开发:</p><p>再最开始，我们需要归纳一下，我们到底要保存怎样一个格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 日志的基本格式：</span><br><span class="hljs-bullet">-</span> 日期时间， 异常的级别<br><span class="hljs-bullet">-</span> 异常信息：引发的异常类别，异常的信息，文件及行号。<br></code></pre></td></tr></table></figure><p>在确定了日志格式后，我们可以进入开发了，首先我们需要导入两个所需的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先导入所需模块</span><br><span class="hljs-keyword">import</span> traceback<br><span class="hljs-keyword">import</span> logging<br></code></pre></td></tr></table></figure><p>让我们先来人为创建一个日常，并用<code>try</code>语句来捕获它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>  <br>---<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><p>这句代码报了一个<code>ValueError</code>异常类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在此进行异常的处理&#x27;</span>)<br>    <br>---<br>在此进行异常的处理<br></code></pre></td></tr></table></figure><p>没问题，我们捕获了异常并且正确的进入了<code>except</code>。那么，我们可以通过<code>traceback</code>模块来获取异常信息,替换一下打印信息我们来查看一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-comment"># 通过traceback获取异常信息</span><br>    errormsg = traceback.format_exc()<br>    <span class="hljs-built_in">print</span>(errormsg)<br>    <br>---<br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;/var/folders/h4/7cr1cmpn7v5b3x20_9wz8m740000gn/T/ipykernel_39689/2534911191.py&quot;</span>, line <span class="hljs-number">2</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>ValueError: invalid literal <span class="hljs-keyword">for</span> <span class="hljs-built_in">int</span>() <span class="hljs-keyword">with</span> base <span class="hljs-number">10</span>: <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><p>接下来，就轮到<code>logging</code>模块了。该模块定义了实现用于应用程序和库的灵活事件日志记录系统的函数和类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    filename = <span class="hljs-string">&#x27;./data/error.log&#x27;</span>, <span class="hljs-comment"># 日志存储的文件及目录</span><br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s \n %(message)s&#x27;</span>, <span class="hljs-comment"># 格式化存储的日志格式</span><br>    datefmt = <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>在定义了<code>logging</code>的基本信息之后，我们就可以定义一下将刚才的<code>errormsg</code>写入日志了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入日志</span><br>logging.error(traceback.format_exc())<br></code></pre></td></tr></table></figure><p>那么我们完善一下整个代码就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    filename = <span class="hljs-string">&#x27;./data/error.log&#x27;</span>, <span class="hljs-comment"># 日志存储的文件及目录</span><br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s \n %(message)s&#x27;</span>, <span class="hljs-comment"># 格式化存储的日志格式</span><br>    datefmt = <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>)<br><br><span class="hljs-comment"># 写入日志</span><br>logging.error(traceback.format_exc())<br></code></pre></td></tr></table></figure><p>我们需要在异常出发的时候，将错误写入到日志内。那么需要将这段代码放到<code>except</code>中。可是我们总不能每次都写这么长一段代码，那怎么办呢？嗯，没错，我们需要封装一个函数用于多次调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Myexception</span>():<br>    <span class="hljs-comment"># logging的基本配置</span><br>    logging.basicConfig(<br>        filename = <span class="hljs-string">&#x27;./data/error.log&#x27;</span>, <span class="hljs-comment"># 日志存储的文件及目录</span><br>        <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s \n %(message)s&#x27;</span>, <span class="hljs-comment"># 格式化存储的日志格式</span><br>        datefmt = <span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>    )<br><br>    <span class="hljs-comment"># 写入日志</span><br>    logging.error(traceback.format_exc())<br><br><span class="hljs-comment"># 使用自定义异常处理类</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;bb&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在此处进行异常的处理&#x27;</span>)<br>    Myexception() <span class="hljs-comment"># 在异常处理的代码块中去调用自定义异常类</span><br></code></pre></td></tr></table></figure><p>然后我们将导入库的方法也写进去，这样在我们需要的时候才会进行导入，顺便，我们将这个函数封装成一个类。就便于更多的文件调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义异常日志处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myexception</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">import</span> traceback<br>        <span class="hljs-keyword">import</span> logging<br><br>        <span class="hljs-comment"># logging的基本配置</span><br>        logging.basicConfig(<br>            filename=<span class="hljs-string">&#x27;./error.log&#x27;</span>,<span class="hljs-comment"># 日志存储的文件及目录</span><br>            <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s  %(levelname)s \n %(message)s&#x27;</span>,<span class="hljs-comment"># 格式化存储的日志格式</span><br>            datefmt=<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span><br>        )<br>        <span class="hljs-comment"># 写入日志</span><br>        logging.error(traceback.format_exc())<br><br><span class="hljs-comment"># 使用自定义异常处理类</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;bb&#x27;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;在此处进行异常的处理&#x27;</span>)<br>    Myexception() <span class="hljs-comment"># 在异常处理的代码块中去调用自定义异常类</span><br></code></pre></td></tr></table></figure><p>这样，一个自定义的获取异常之后写入日常的类就定义好了，我们可以在任意地方导入并调用这个类方法，以便获取以及日后查看整个程序中的异常。</p><h2 id="附录">附录</h2><h3 id="标准的异常类">标准的异常类</h3><table><colgroup><col style="width: 33%" /><col style="width: 66%" /></colgroup><thead><tr class="header"><th style="text-align: center;">异常名称</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">BaseException</td><td style="text-align: center;">所有异常的基类</td></tr><tr class="even"><td style="text-align: center;">SystemExit</td><td style="text-align: center;">解释器请求退出</td></tr><tr class="odd"><td style="text-align: center;">KeyboardInterrupt</td><td style="text-align: center;">用户中断执行(通常是输入^C)</td></tr><tr class="even"><td style="text-align: center;">Exception</td><td style="text-align: center;">常规错误的基类</td></tr><tr class="odd"><td style="text-align: center;">StopIteration</td><td style="text-align: center;">迭代器没有更多的值</td></tr><tr class="even"><td style="text-align: center;">GeneratorExit</td><td style="text-align: center;">生成器(generator)发生异常来通知退出</td></tr><tr class="odd"><td style="text-align: center;">StandardError</td><td style="text-align: center;">所有的内建标准异常的基类</td></tr><tr class="even"><td style="text-align: center;">ArithmeticError</td><td style="text-align: center;">所有数值计算错误的基类</td></tr><tr class="odd"><td style="text-align: center;">FloatingPointError</td><td style="text-align: center;">浮点计算错误</td></tr><tr class="even"><td style="text-align: center;">OverflowError</td><td style="text-align: center;">数值运算超出最大限制</td></tr><tr class="odd"><td style="text-align: center;">ZeroDivisionError</td><td style="text-align: center;">除(或取模)零 (所有数据类型)</td></tr><tr class="even"><td style="text-align: center;">AssertionError</td><td style="text-align: center;">断言语句失败</td></tr><tr class="odd"><td style="text-align: center;">AttributeError</td><td style="text-align: center;">对象没有这个属性</td></tr><tr class="even"><td style="text-align: center;">EOFError</td><td style="text-align: center;">没有内建输入,到达EOF 标记</td></tr><tr class="odd"><td style="text-align: center;">EnvironmentError</td><td style="text-align: center;">操作系统错误的基类</td></tr><tr class="even"><td style="text-align: center;">IOError</td><td style="text-align: center;">输入/输出操作失败</td></tr><tr class="odd"><td style="text-align: center;">OSError</td><td style="text-align: center;">操作系统错误</td></tr><tr class="even"><td style="text-align: center;">WindowsError</td><td style="text-align: center;">系统调用失败</td></tr><tr class="odd"><td style="text-align: center;">ImportError</td><td style="text-align: center;">导入模块/对象失败</td></tr><tr class="even"><td style="text-align: center;">LookupError</td><td style="text-align: center;">无效数据查询的基类</td></tr><tr class="odd"><td style="text-align: center;">IndexError</td><td style="text-align: center;">序列中没有此索引(index)</td></tr><tr class="even"><td style="text-align: center;">KeyError</td><td style="text-align: center;">映射中没有这个键</td></tr><tr class="odd"><td style="text-align: center;">MemoryError</td><td style="text-align: center;">内存溢出错误(对于Python解释器不是致命的)</td></tr><tr class="even"><td style="text-align: center;">NameError</td><td style="text-align: center;">未声明/初始化对象 (没有属性)</td></tr><tr class="odd"><td style="text-align: center;">UnboundLocalError</td><td style="text-align: center;">访问未初始化的本地变量</td></tr><tr class="even"><td style="text-align: center;">ReferenceError</td><td style="text-align: center;">弱引用(Weakreference)试图访问已经垃圾回收了的对象</td></tr><tr class="odd"><td style="text-align: center;">RuntimeError</td><td style="text-align: center;">一般的运行时错误</td></tr><tr class="even"><td style="text-align: center;">NotImplementedError</td><td style="text-align: center;">尚未实现的方法</td></tr><tr class="odd"><td style="text-align: center;">SyntaxError</td><td style="text-align: center;">Python 语法错误</td></tr><tr class="even"><td style="text-align: center;">IndentationError</td><td style="text-align: center;">缩进错误</td></tr><tr class="odd"><td style="text-align: center;">TabError</td><td style="text-align: center;">Tab 和空格混用</td></tr><tr class="even"><td style="text-align: center;">SystemError</td><td style="text-align: center;">一般的解释器系统错误</td></tr><tr class="odd"><td style="text-align: center;">TypeError</td><td style="text-align: center;">对类型无效的操作</td></tr><tr class="even"><td style="text-align: center;">ValueError</td><td style="text-align: center;">传入无效的参数</td></tr><tr class="odd"><td style="text-align: center;">UnicodeError</td><td style="text-align: center;">Unicode 相关的错误</td></tr><tr class="even"><td style="text-align: center;">UnicodeDecodeError</td><td style="text-align: center;">Unicode 解码时的错误</td></tr><tr class="odd"><td style="text-align: center;">UnicodeEncodeError</td><td style="text-align: center;">Unicode 编码时错误</td></tr><tr class="even"><td style="text-align: center;">UnicodeTranslateError</td><td style="text-align: center;">Unicode 转换时错误</td></tr><tr class="odd"><td style="text-align: center;">Warning</td><td style="text-align: center;">警告的基类</td></tr><tr class="even"><td style="text-align: center;">DeprecationWarning</td><td style="text-align: center;">关于被弃用的特征的警告</td></tr><tr class="odd"><td style="text-align: center;">FutureWarning</td><td style="text-align: center;">关于构造将来语义会有改变的警告</td></tr><tr class="even"><td style="text-align: center;">OverflowWarning</td><tdstyle="text-align: center;">旧的关于自动提升为长整型(long)的警告</td></tr><tr class="odd"><td style="text-align: center;">PendingDeprecationWarning</td><td style="text-align: center;">关于特性将会被废弃的警告</td></tr><tr class="even"><td style="text-align: center;">RuntimeWarning</td><td style="text-align: center;">可疑的运行时行为(runtimebehavior)的警告</td></tr><tr class="odd"><td style="text-align: center;">SyntaxWarning</td><td style="text-align: center;">可疑的语法的警告</td></tr><tr class="even"><td style="text-align: center;">UserWarning</td><td style="text-align: center;">用户代码生成的警告</td></tr></tbody></table><p>那么，这节课到这里也就结束了。各位小伙伴，下去以后记得勤加练习。下课。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Get-the-exception/cover.png&quot; class=&quot;&quot; title=&quot;cover&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>19. 第三方库的管理和虚拟环境</title>
    <link href="https://hivan.me/Third-party-libraries-and-virtual-environments/"/>
    <id>https://hivan.me/Third-party-libraries-and-virtual-environments/</id>
    <published>2023-08-15T03:48:45.000Z</published>
    <updated>2023-08-15T04:56:42.184Z</updated>
    
    <content type="html"><![CDATA[<img src="/Third-party-libraries-and-virtual-environments/cover.png" class="" title="img"><p>Hi， 大家好。我是茶桁。</p><span id="more"></span><p>在我们之前的课程中，讲解了数据，函数，类，模块以及包。这些基本上已经构成了Python的全部了。</p><p>那么，我们在学习Python的包之后，有没有思考过，既然Python有内置模块，我们也可以自己写一些模块来使用，那一定有很多第三方写过相应的模块来供我们使用。那么，这些包该如何去找，找到以后如何使用和管理呢？今天，就让我们来看看这个问题。</p><h2 id="第三方库的管理">第三方库的管理</h2><p>现在很多编程语言都有第三方库的提供，比如<code>Ruby</code>,<code>Node</code>等。而Python的生态也是发展的最好的之一。Python中比较牛逼的地方就是由大量的第三方库提供给你使用。生态的蓬勃发展也是Python广为流行的最大的原因之一。</p><p>Python的第三方库的管理网站：<code>https://pypi.org/</code>。</p><h3 id="如何安装第三方库">如何安装第三方库？</h3><p><code>pip</code>就是Python得包管理工具，解决了包直接的依赖关系，可以方便的管理第三方库（包）。类似于<code>PHP</code>中的<code>Composer</code>,或者<code>Nodejs</code>中的<code>npm</code>,又或者<code>Mac</code>中的<code>Homebrew</code>。</p><p>我们可以使用<code>pip install 包名（库名）</code>来进行安装。而如果是有多个Python环境的情况下，可能需要使用<code>pip3</code>。比如说，我们要安装<code>pymysql</code>这个库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pymysql<br></code></pre></td></tr></table></figure><p>在安装命令过程中，有的时候我们可能对版本会有一定的要求，并不是越新的版本越好。这个时候，我们也可以安装指定版本的包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install 包名==版本<br></code></pre></td></tr></table></figure><p>现在包都已经安装到本地了，可是因为安装的内容太多，我们可能有的时候会忘记自己以前是否安装过这个包。为了避免重复再装一次，我们可以搜索一下看看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip show 包名<br></code></pre></td></tr></table></figure><p>这样，这个包的所有信息就会打印出来供我们查看：</p><img src="/Third-party-libraries-and-virtual-environments/image-20230815121349204.png" class="" title="img"><p>当然，我们也有类似于想要查看本地安装的所有包的需求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip list<br></code></pre></td></tr></table></figure><p>这样，我们就可以把本地说安装的包名以及版本都列出来进行查看：</p><img src="/Third-party-libraries-and-virtual-environments/image-20230815121607429.png" class="" title="img"><p>这些呢，就是我们在包管理经常用到的一些命令。</p><p>等等，大家在执行安装的时候，一定会遇到安装特别缓慢的情况。多数时候可能是因为我们所在的环境因为各种原因连接不上官方的源服务器。</p><p>不过别着急，我们可以切换到镜像源上，找一个速度快的来下载安装。</p><p>目前国内的安装源有以下几个可供选择：</p><ul><li>阿里云 http://mirrors.aliyun.com/pypi/simple/</li><li>中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</li><li>豆瓣(douban) http://pypi.douban.com/simple/</li><li>清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</li><li>中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</li></ul><p>修改源的方式也很简单，包括了「临时修改」和「永久修改」两种。</p><p>临时修改，顾名思义，就是我们有的时候临时需要切换到其他源上进行下载了。</p><p>我们可以使用<code>pip</code>的时候在后面加上<code>-i</code>参数，指定pip源：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple/ <br></code></pre></td></tr></table></figure><p>多数情况下，我还是习惯于将源永久修改为一个速度较快的镜像上，也懒得每次都输入长传的命令。那么永久修改的方式稍微复杂点，我们分系统来看：</p><p>在Linux中，我们找到<code>pip.conf</code>这个文件，一般来说，它的位置应该是<code>~/.pip/pip.conf</code>，如果没有的话，那就创建一个，然后写入如下内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>timeout = <span class="hljs-number">6000</span><br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br><span class="hljs-keyword">trusted</span>-host = pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><p>在Windows内原理也是一样的，不同的是路径和文件有所不同。</p><p>我们在<code>user</code>目录中创建一个<code>pip</code>目录，如：<code>C:\Users\du\pip</code>,然后在PIP目录下新建一个<code>pip.ini</code>文件，然后写入内容：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>]<br>timeout = <span class="hljs-number">6000</span><br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br><span class="hljs-keyword">trusted</span>-host = pypi.tuna.tsinghua.edu.cn<br></code></pre></td></tr></table></figure><p>这样，我们在之后安装第三方库的时候就会发现，速度快多了。</p><h2 id="虚拟环境">虚拟环境</h2><p>虚拟环境呢，就是在当前的系统环境中，去配置另外一个Python得运行环境。我们理论上是可以创建多个不同的虚拟环境的，Python得虚拟环境相互独立，互相之间不会影响。</p><p>那么虚拟环境下呢，具有以下一些特点：</p><ul><li>虚拟环境中可以在没有权限的情况下安装新的库（Linux系统中可能会出现的问题）</li><li>不同的应用可以使用不同的库或不同的版本。</li><li>虚拟环境中的库升级也不影响其它环境</li><li>虚拟环境可以作为一个项目的专有环境。在需要部署时，一键导出项目的所需要的包</li></ul><h3 id="默认方式">默认方式</h3><p>Python本身就支持创建和管理虚拟环境。可以使用以下方式进行创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m venv 虚拟环境名<br></code></pre></td></tr></table></figure><p>创建完成后，我们可以使用下面的方式进入虚拟环境，激活虚拟环境</p><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用source命令去执行v1/bin/目录下的activate</span><br>localhost:code yc$ <span class="hljs-built_in">source</span> v1/bin/activate<br></code></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Windows系统需要进入v1/Scripts/这个目录</span><br><span class="hljs-built_in">cd</span> v1/Scripts/<br><span class="hljs-comment"># 运行activate.bat文件</span><br>activate.bat<br>(v1) F:\code<br></code></pre></td></tr></table></figure><p>在这之后，我们现在就处于某一个虚拟环境中了，可以执行安装等操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pymysql<br><br>pip show pymysql<br></code></pre></td></tr></table></figure><p>那么如果我的某一个环境被我给搞乱了，我也找不到原因，还不如重新安装来的快。这会儿我们可能就想要退出并删除这个虚拟环境：</p><p>如果想要退出虚拟环境，在Linux中，我们可以输入下面这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 退出虚拟环境</span><br><br><span class="hljs-comment"># Linux</span><br>deactivate<br></code></pre></td></tr></table></figure><p>那如果是Windows中呢就比较简单了，直接<code>Ctrl+C</code>就好了。</p><p>在退出之后，我们直接删除虚拟环境的文件夹，就搞定了。</p><p>以上是我们不想要当前虚拟环境的情况下，那也有一种可能是我们需要更换电脑等原因，但是我想带着我的环境一起迁移，这该怎么办？</p><p>这也好办，我们可以到处当前环境所有安装过的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看所有安装的包</span><br>pip list<br>```<br>packageversion<br>------------------------<br>Numpy1.3.1<br>........<br><br><br><span class="hljs-comment"># 导出所有包到文件</span><br>pip freeze &gt; ./requirements.txt<br></code></pre></td></tr></table></figure><p>然后在下一个环境中，我们直接执行安装文件内所有包就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r requirements.txt<br></code></pre></td></tr></table></figure><h3 id="conda">Conda</h3><p>虽然Python中已经有了包管理的方法，但是还是不得不说，有时候第三方提供的方案确实香。</p><p>目前，我现在都是使用<code>conda</code>(Andaconda)来管理我本地的虚拟环境。其使用也是非常的简单了，我们可以去其官网上（<ahref="https://www.anaconda.com/">https://www.anaconda.com/</a>）下载并安装对应自己系统的版本。</p><p>安装完成后，Conda就会创建一个默认的<code>base</code>环境，我们之前一直使用的<code>Jupyter Notebook</code>也一并是安装在环境中的。</p><p>那么在Conda中，我们经常会用的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装包</span><br>conda install 包名称<br><br><span class="hljs-comment"># 安全方式安装包</span><br>conda install -c conda-forge 包名称<br><br><span class="hljs-comment"># 创建环境</span><br>conda create --name 环境名 python=3.10 <span class="hljs-comment">#最后是输入当前环境要用的Python版本</span><br><br><span class="hljs-comment"># 切换（激活）环境</span><br>conda activate 环境名<br><br><span class="hljs-comment"># 查看环境列表</span><br>conda info --<span class="hljs-built_in">env</span><br><br><span class="hljs-comment"># 删除某个环境</span><br>conda remove --name 环境名 --all<br></code></pre></td></tr></table></figure><p>对比下来，<code>conda</code>真的是非常的方便。推荐大家使用。</p><p>那么，今天的课程就到这里结束了。我知道，今天的课程似乎显的特别的少。em....不是似乎，是确实。</p><p>原因在于这一部分必须拿出一个章节来介绍一下，否则大家平时在使用的过程中万一将自己的默认环境搞乱了，但是又不知道该怎么办，确实挺烦人的。所以我专门拿一节出来，将环境的问题好好的跟大家介绍下，顺便也是告诉大家，不管你做什么实验和操作，尽量新建一个环境来操作。这样，即便你把当前环境搞的乱七八糟无法恢复，删了就好了。</p><p>好，那我们这节课到这里也就结束了，咱们下节课讲讲如何处理异常。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Third-party-libraries-and-virtual-environments/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi， 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>18. Python中的模块与包</title>
    <link href="https://hivan.me/Modules-and-packages/"/>
    <id>https://hivan.me/Modules-and-packages/</id>
    <published>2023-08-14T09:00:32.000Z</published>
    <updated>2023-08-14T18:30:20.891Z</updated>
    
    <content type="html"><![CDATA[<img src="/Modules-and-packages/cover.png" class="" title="img"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>这一段Python之旅怎么样？还算顺利吧？</p><p>之前我们都学习了些什么？有基本常识，流程，函数，不同类型的数据以及一些模块对吧？并且还做了一些练习来巩固所学过的内容。</p><p>那么今天，我们接着来学习模块。不过今天要学的模块和以往不太一样了，以前我们学习的都是Python内置的一些模块，而今天呢，我们自己来打包模块。</p><h2 id="模块">模块</h2><p>简单点说，当我们定义一个Python文件，其后缀名为<code>.py</code>的时候，那么这个文件就被称为模块。</p><p>模块中通常呢会定义一些相似的类、函数等代码内容，提供给别的程序引入使用。那对于应用，之前我们已经用过很多次了对吧？我们曾多次应用系统模块来使用，那这次，我们还是从系统模块开始吧。</p><h3 id="系统模块">系统模块</h3><p>系统模块实际上就是一个Python的程序脚本，专门提供给我们自己的程序使用。它们是在安装好Python环境时，就已经存在的，需要的时候可以使用<code>import</code> 导入到程序中使用。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os, re, time, json, calendar<br></code></pre></td></tr></table></figure><h3 id="自定义模块">自定义模块</h3><p>那知道了系统模块是什么东西，在理解自定义模块就轻松多了对吧？其实就是我们自己创建一个Python脚本，定义一些类或方法，供别的脚本导入后使用。</p><blockquote><p>由于本节课比较特殊，所以课程源码除了<code>18.ipynb</code>这个笔记本文件之外，还有有一个文件夹，路径为<code>./Python/packages/file</code>，然后内部会有多个<code>.py</code>文件。</p></blockquote><p>比如我们定义一个<code>self.py</code>文件如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># self.py</span><br><br><span class="hljs-comment"># 定义类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span>():<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 定义函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;我是一个模块中的func函数&#x27;</span>)<br><br><span class="hljs-comment"># 定义变量</span><br>myStr = <span class="hljs-string">&#x27;iloveyou&#x27;</span><br></code></pre></td></tr></table></figure><p>然后让我们在笔记本中引用这个文件（模块）以及其他模块，让我们来看看，还记得我们是怎么引入模块的嘛？来，回忆一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先引入一个系统模块：time</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;time:<span class="hljs-subst">&#123;time.time()&#125;</span>&#x27;</span>)<br><br>---<br>time:<span class="hljs-number">1692005247.144672</span><br></code></pre></td></tr></table></figure><p>我们引入了一个系统模块<code>time</code>，然后执行了一下模块里的<code>time()</code>方法，并把最终结果打印了出来。</p><p>既然都已经有例子了，那我们有样学样来试试引入我们自己创建的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> self<br><br>---<br>ModuleNotFoundError: No module named <span class="hljs-string">&#x27;self&#x27;</span><br></code></pre></td></tr></table></figure><p>报错了，告诉我们并没有<code>self</code>这个模块。这个...</p><p>还记得我们刚才说过的文件路径嘛？<code>./Python/packages/file</code>，而我们当前文件<code>18.ipynb</code>是放在<code>Python</code>目录下的，层级关系如下：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>.<br><span class="hljs-bullet">- </span>Python/<br><span class="hljs-bullet">- </span>...<br><span class="hljs-bullet">- </span>18.ipynb<br><span class="hljs-bullet">- </span>packages/<br><span class="hljs-code">| - self.py</span><br></code></pre></td></tr></table></figure><p>也就是说，我们要应用<code>self.py</code>，需要找对路径才行。那我们将路径加上去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 引入自定义模块</span><br><span class="hljs-keyword">import</span> packages.self <br></code></pre></td></tr></table></figure><p>这回执行之后是没报错了，应该没问题了。</p><p>那下面呢，让我们来操作一下文件内的类、函数之类的试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用模块中定义的类</span><br>obj = packages.self.MyException()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;packages.self.MyException <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10468cb80</span>&gt;<br></code></pre></td></tr></table></figure><p>没毛病，确实获取到了相关类病打印了出来。</p><p>可是我们这也太麻烦了，每次使用这个模块不是抖要输入这么长一段吧？<code>packages.self.xxx</code>，不知道之前的学习中大家有没有注意到一个关键字<code>as</code>，这个我之前课程中都没有特意讲解过，但是在我们引入模块的时候会经常的用到。所以这里顺带讲一下吧，比如，我们在操作文件的时候有如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./file&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>  fp.read()<br></code></pre></td></tr></table></figure><p>那这个<code>as</code>我们能猜到是什么作用吗？其实，就是讲<code>as</code>前的内容放入<code>as</code>后面的这个变量里，然后将<code>as</code>身后的这个变量改为一个对象而已，在这段代码里，我们打开了文件，并且将其放入了<code>fp</code>这个变量里，变成了一个<code>fp</code>对象。也可以理解为，我们将<code>as</code>之前的内容起了一个别名。</p><p>那么我们导入文件的时候可以这么操作吗？我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.self <span class="hljs-keyword">as</span> self<br>obj = self.MyException()<br><span class="hljs-built_in">print</span>(obj)<br><br>---<br>&lt;packages.self.MyException <span class="hljs-built_in">object</span> at <span class="hljs-number">0x1046ce2c0</span>&gt;<br></code></pre></td></tr></table></figure><p>嗯，看来我们没搞错，确实可以这么用。</p><p>那让我们再来试试文件中的那个函数吧，函数内应该是执行了一段打印方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">self.func()<br><br>---<br>我是一个模块中的func函数<br></code></pre></td></tr></table></figure><p>确实正确执行了。这也太顺利了，趁热打铁，让我们再来获取其中的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(self.myStr)<br><br>---<br>iloveyou<br></code></pre></td></tr></table></figure><p>导入模块其实不是仅可导入模块，还能从一个模块中导入类，方法甚至是变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.self <span class="hljs-keyword">import</span> func<br><span class="hljs-keyword">from</span> packages.self <span class="hljs-keyword">import</span> myStr <span class="hljs-keyword">as</span> <span class="hljs-built_in">str</span><br><br>func()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br></code></pre></td></tr></table></figure><p>应该能看出这一段代码的含义吧？就是<code>from</code>（从）一个模块中<code>import</code>导入一个对象。</p><h3 id="模块中的测试代码">模块中的测试代码</h3><p>在自定义模块中，通常我们只是去定义类或函数，变量等，并不调用。如果在指定模块中，想要写一些测试代码，在当前模块作为主程序使用时执行，而作为模块被别的程序导入时不执行，那么可以把测试代码写到下面的代码块中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这个位置的代码只有当前脚本被直接运行时才会运行。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>那么这个模块再被别的程序调用之后，这段代码中的程序是不会被执行的。因为只有这个模块作为主程序运行时才会运行这段代码。我们来看下面这些操作就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.self <span class="hljs-keyword">as</span> self<br>self<br><br>---<br>&lt;module <span class="hljs-string">&#x27;packages.self&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/packages/self.py&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>按道理，我们引入模块之后应该会拿到该模块内的所有方法，可是刚才我们写的打印并没有被执行。现在我们在命令行内直接大概这个<code>.py</code>文件来试试：</p><img src="/Modules-and-packages/image-20230814221847463.png" class="" title="img"><p>能看到，<code>if</code>里面的<code>print</code>被直接执行了，打印出了里面的字符串。</p><p>在这整段代码中，<code>__name__</code>是一个特殊的变量，这个变量在当前脚本作为模块被别的程序导入时<code>__name__</code>的值是当前这个模块的名称，也就是说，我在笔记本中导入的时候<code>__name__</code>就是<code>self</code>，而我们在<code>if</code>条件中的设定，是只有当前脚本被作为主程序直接由Python解析时才会进入判断，也就是<code>__name__</code>这个变量的值为<code>__main__</code>时。</p><p>我们来看看是不是如此，我们在<code>self.py</code>中加上一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = __name__<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;__name__: <span class="hljs-subst">&#123;name&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们直接让<code>self.py</code>在Python解释器中运行：</p><img src="/Modules-and-packages/image-20230814222553966.png" class="" title="img"><p>现在让我们在笔记本中重新引入一下模块中的变量<code>name</code>，再打印出来看看：</p><img src="/Modules-and-packages/image-20230814222932491.png" class="" title="img"><p>打印的第一段内容为引入模块的时候，模块内的<code>print(f'__name__: &#123;name&#125;')</code>执行了一次，第二段内容则是在笔记本中输入的方法<code>print(name)</code>。这样，我们就很直观的看到了<code>__name__</code>在不同位置时存储了不同的值。</p><p>我们在写程序的时候要记得，不要想着把所有的方法定义在一个脚本文件内。</p><h2 id="包">包</h2><p>那什么是包呢？包并不是模块。你可以将包理解为一个文件夹，这个文件夹里面包含了多个Python文件。</p><h3 id="包的结构">包的结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">package/   # 包(文件夹)</span><br><span class="hljs-string">├── __init__.py  # 包中的初始化文件</span><br><span class="hljs-string">├── a.py         # 包中的模块</span><br><span class="hljs-string">├── b.py</span><br><span class="hljs-string">└── ps/   # 子包</span><br><span class="hljs-string">  ├── __init__.py</span><br><span class="hljs-string">  ├── c.py</span><br><span class="hljs-string">  └── d.py</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="包的使用方法">包的使用方法</h3><p>其实，我们在刚才所讲的内容中，已经给大家演示过了包的使用方法，不知道小伙伴们能不能反应过来到底是哪里？不知道也没有关系，让我们从头来好好的盘一下这件事。</p><p>我们之前在当前目录下创建了一个文件夹<code>packages</code>，里面有我们<code>self.py</code>文件。实际上，这就是一个包了。</p><p>让我们将这个包搞的复杂一点，按照上面我们写的结构来增加一些文件，然后我们看看现在的目录结构：</p><img src="/Modules-and-packages/image-20230814225350552.png" class="" title="img"><p>我们可以看到，除了我们之前设定的文件之外，还有多出来一个文件夹<code>__pycache__</code>以及文件<code>self.cpython-310.pyc</code>，这个文件夹和文件是当这个包内的文件存在引入关系的时候，自动生成的缓存文件。大家可以不用管。</p><p>下面我们来看具体的包使用方法，我们预先在<code>a, b, c, d</code>这四个文件内都写入了一模一样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">funca</span>():<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a.py&#x27;</span>)<br></code></pre></td></tr></table></figure><p>当然，方法名和打印的内容都和文件同名的。</p><p>然后我们回到<code>18.ipynb</code>这个笔记本文件内，开始操作使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages <span class="hljs-keyword">as</span> pa<br>pa.a.funca<br><br>---<br>AttributeError: module <span class="hljs-string">&#x27;packages&#x27;</span> has no attribute <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>似乎并不行，我们好像并不能引用包来直接使用。那我们怎么办呢？前面我们介绍过一个引用的方法<code>from ... import</code>，我们在使用包内的模块时，需要这样去引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages <span class="hljs-keyword">import</span> a, b<br>a.funca()<br>b. funcb()<br><br>---<br>a.py<br>b.py<br></code></pre></td></tr></table></figure><p>可以看到，这回我们引用成功了。那我们之前也学到了，在引入模块的时候，也可以直接就引用模块内的方法和变量，模块在包内也可以如此使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.a <span class="hljs-keyword">import</span> funca<br>funca()<br><br>---<br>a.py<br></code></pre></td></tr></table></figure><p>那既然我们得到了这种方式来导入模块内的内容，同样的，包内层如果还存在一个包，而我们要使用子包里的模块，也是这样的导入方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.ps <span class="hljs-keyword">import</span> c<br>c.funcc()<br><br>---<br>c.py<br></code></pre></td></tr></table></figure><p>看到了，同样能够正常使用。</p><p>那如果再过分点，我们要想导入<code>c.py</code>里的函数可以吗？试试就知道了,再使用<code>.</code>多链接一层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages.ps.d <span class="hljs-keyword">import</span> funcd<br>funcd()<br><br>---<br>d.pys<br></code></pre></td></tr></table></figure><p>呐，完全没问题。</p><p>然后我们再反过来看最开始，其实呢，我们的第一种方法直接引用包不是不可以，这需要用到我们这个包内的<code>__init__.py</code>文件。</p><p><code>__init__.py</code>是一个包内的初始化文件，可以说，没有这个文件，这只是一个文件夹，只有有了这个文件，这才是一个包。在初始化的时候，就把包内的模块导入一次，在<code>__init__.py</code>中写下以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> a<br></code></pre></td></tr></table></figure><p>然后我们再回到笔记本文件中直接导入包来使用试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages<br>a.funca()<br><br>---<br>a.py<br></code></pre></td></tr></table></figure><p>这样就可以了。</p><p>好了，那如果这个时候我<code>packages</code>这个包里一大堆的模块，我不想一个个的来导入，有什么办法吗？也是有的，我们需要用到<code>__all__</code>这个参数，在<code>__init__.py</code>中将包内所有的模块名做成一个列表，然后赋值给<code>__all__</code>这个变量，那么我们在引入包内的模块的时候，就可以使用`<code>*</code>来代表所有文件：</p><p><code>__init__.py</code>文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__all__ = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br></code></pre></td></tr></table></figure><p>然后进行引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> packages <span class="hljs-keyword">import</span> *<br>b.funcb()<br><br>---<br>b.py<br></code></pre></td></tr></table></figure><p>这样，我们就一次性导入了<code>packages</code>这个包里的所有文件。</p><h2 id="导入方式的分类">导入方式的分类</h2><p>之前我们讲的内容中，把导入的方式都过了一遍。到现在这个位置，我们应该总结一下了。</p><p>具体的导入方式，我们可以将其分为两个类别，分别是<code>绝对导入</code>和<code>相对导入</code>。那两者有什么区别呢？</p><h3 id="绝对导入">绝对导入</h3><p>绝对导入的方式会使用「搜索路径」去查找和导入指定的包或模块，包括以下几种方式：</p><ul><li><p><code>import module</code> 导入模块</p></li><li><p><code>import package</code> 导入包</p></li><li><p><code>import package.module</code>导入包.模块</p></li><li><p><code>from module import func</code> 从模块中导入函数</p></li><li><p><code>from package import module</code>从包中导入模块</p></li><li><p><code>from package.module import func</code>从包.模块中导入函数</p></li></ul><p>关于「搜索路径」，我们先简单的理解一下就是，从当前文件夹中去找，如果找不到，就会去Python的安装环境中去寻找。</p><h3 id="相对导入">相对导入</h3><p>⚠️相对导入智能在非主程序的模块中使用，不需要直接运行的模块文件。比如：</p><ul><li><code>from .包名/模块名 import 模块/内容</code></li><li><code>from ..包名/模块名 import 模块/内容</code></li></ul><p><code>.</code>和<code>..</code>我们之前已经了解过了，<code>.</code>代表的就是当前这一级，<code>..</code>代表的就是上一级。</p><p>举个栗子好理解：假设我们现在去修改一下<code>ps/c.py</code>这个文件，在这个模块中如果需要当前包中的<code>d</code>模块:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> .d <span class="hljs-keyword">import</span> funcd<br></code></pre></td></tr></table></figure><p>注意啊，我们这个时候不要在<code>c.py</code>中直接运行<code>funcd()</code>方法，这样会导致报错：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">ImportError: attempted relative <span class="hljs-keyword">import</span> <span class="hljs-keyword">with</span> <span class="hljs-literal">no</span> known parent package<br></code></pre></td></tr></table></figure><p>那我们需要怎么运行呢？我们需要讲<code>c.py</code>导入到其他文件中再执行。比如我们进入到笔记本<code>18.ipynb</code>中导入执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.ps.c <span class="hljs-keyword">as</span> c<br>c.funcd()<br><br>---<br>d.py<br></code></pre></td></tr></table></figure><p>然后让我们再在<code>c.py</code>中加上一段内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ..a <span class="hljs-keyword">import</span> funca<br></code></pre></td></tr></table></figure><p>小伙伴们应该都看出来了，我是在引用<code>c.py</code>的上一级的<code>a.py</code>。</p><p>让我们再在笔记本中执行一下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> packages.ps.c <span class="hljs-keyword">as</span> c<br>c.funcd()<br>c.funca()<br><br>---<br>d.py<br>a.py<br></code></pre></td></tr></table></figure><p>这样，在我们引入了模块<code>c</code>之后，我们同时也拥有了<code>c.py</code>引入的同级和上一级中的<code>d.py</code>、<code>a.py</code>。</p><h3 id="搜索路径">搜索路径</h3><p>刚才我们简单提到了一下「搜索路径」， 这里我们详细的来展开说一下。</p><p>「搜索路径」就是在导入模块或者包的时候，程序查找的路径。主要的搜索路径包含以下三部分：</p><ul><li>当前导入模块的程序所在的文件</li></ul><ol start="2" type="1"><li>python的扩展目录中</li><li>python解释器指定的其它 第三方模块位置<code>/lib/sitepackages</code></li></ol><p>当然，如果你像我一样，系统中安装了多个Python版本，并且使用虚拟环境。那么你的「搜索路径」就不一定是在哪里了。那么我们到底该如何查找呢？我们来看一下以下查找方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在当前脚本中查看包或者模块的搜索路径</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">print</span>(sys.path)<br><br>---<br>[<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python310.zip&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python3.10&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python3.10/lib-dynload&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/Users/du/miniforge3/envs/glm/lib/python3.10/site-packages&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们看到找到的搜索路径被以列表的形式呈现出来。当然，我们找到搜索路径后，其实是可以向其中添加一个的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sys.path.append(<span class="hljs-string">&#x27;/Users/du/AI/GPT&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="单入口程序">单入口程序</h2><p>那什么是单入口程序呢？顾名思义，这种程序就只有一个入口。那单入口程序就是指整个程序都是经过一个主程序文件在运行，其它程序都封装成了包或模块。</p><p>单入口文件是作为程序直接被运行的唯一文件，其他都是作为模块或者包，被导入单入口中去执行。打个比方说，我们要去做一个ATM机的程序，我们来实现一个单入口程序。那么可能的情况如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json">ATM/<br>|-- main.py  # 当前程序的主入口文件，单入口文件<span class="hljs-punctuation">,</span>唯一直接运行的文件<br>|-- package/ # 主要程序模块包<br>|-- |--- __init__.py  # 包的初始化文件<br>|-- |--- View.py      # 视图函数模块<br>|-- |--- Controller.py# 控制器模块<br>|-- |--- Card.py      # 银行卡模块<br>|-- |--- User.py      # 用户模块<br>|-- databases/ # 数据存储文件夹<br>|-- |-- user.txt<br>|-- |-- user_id_card.txt<br></code></pre></td></tr></table></figure><p>那么这个程序中，<code>main</code>就是程序的主入口文件，会被直接作为主程序运行。所以<code>main.py</code>文件必须使用「绝对导入」的方式。</p><p>好，那讲到这里，我们今天的内容也就结束了。不知道小伙伴们理解了多少？</p><p>本节课也不太好放练习，那我们这节课就免了。下去之后，大家去拉取我的源码好好的研究一下引入关系，然后讲包、模块的概念好好的理解透。</p><p>那小伙伴们，咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Modules-and-packages/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>17. 正则表达式</title>
    <link href="https://hivan.me/regular-expression/"/>
    <id>https://hivan.me/regular-expression/</id>
    <published>2023-08-13T05:21:10.000Z</published>
    <updated>2023-08-13T16:51:01.994Z</updated>
    
    <content type="html"><![CDATA[<img src="/regular-expression/cover.png" class="" title="img"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>不知不觉中，咱们针对人工智能的Python课程已经过去了一半。相信大家这段时间也都有所进步了。</p><p>今天这节课呢，我给大家划一个重点。不仅仅是Python，很多语言里都是通用的，而且非常的强大。这就是我们的正则表达式。</p><p>说起正则表达式，很多程序员其实对其都不是很重视，但是学好它，必定在处理数据的时候事倍功半。虽然内容看似不多，但是市面上有一本经典的「精通电子表达式」整本书还是非常厚的。当然，它比咱们今天要讲的内容详尽的多了。听完我这节课之后想继续研究正则的小伙伴，推荐这本书（唯一推荐）。</p><img src="/regular-expression/s11292040.jpg" class="" title="img"><p>正则表达式是什么呢？其实就是使用字符、转义字符和特殊字符组成一个规则，使用这个规则对文本的内容完成一个搜索或匹配或替换的功能。</p><h2 id="正则表达式的组成">正则表达式的组成</h2><p>正则表达式内，包含了普通字符，转义字符，特殊字符以及匹配模式：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">普通字符： 大小写字母，数字，符号...<br>转义字符： <span class="hljs-string">\w,</span> <span class="hljs-string">\W,</span> <span class="hljs-string">\d,</span> <span class="hljs-string">\D,</span> <span class="hljs-string">\s,</span> <span class="hljs-string">\S</span> ...<br>特殊字符： . * ? + ^ $ [] &#123;&#125; () <br>匹配模式： I U ...<br></code></pre></td></tr></table></figure><p>接下来我们看几个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义字符串</span><br>myStr = <span class="hljs-string">&#x27;iloveyou521tosimida&#x27;</span><br><span class="hljs-comment"># 定义正则</span><br>myReg = <span class="hljs-string">&#x27;love&#x27;</span><br><br><span class="hljs-comment"># 调用正则函数方法</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;love&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们就匹配了一个字符串。如果我们想匹配数字，那<code>myReg=521</code>就能够匹配了。不过，现在我有一个新需求，我们重新定义一下<code>myStr = 'iloveyou521to123simida'</code>，我们可以看到，这个字符串十分的混乱，数字和字母都是混在一起的。现在，我就想把数字都单独的拎出来，又该怎么做呢？来，让我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123simida&quot;</span><br>myReg = <span class="hljs-string">&#x27;\d&#x27;</span><br><span class="hljs-comment"># 调用正则表达式相关函数</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们使用<code>\d</code>这个转义字符匹配到了字符串内相关的所有数字，返回了一个列表。</p><p>可是这还是不符合我们的要求，我们想要的是将其中的数字组合匹配出来，而不是单独的数字。接着继续改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123si7894mida&quot;</span><br>myReg = <span class="hljs-string">&#x27;\d\d\d&#x27;</span><br><span class="hljs-comment"># 调用正则表达式相关函数</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;521&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-string">&#x27;789&#x27;</span>]<br></code></pre></td></tr></table></figure><p>将原本一个<code>\d</code>改为了三个叠在一起的<code>\d\d\d</code>，这样，我们匹配到了三位数字的组合。注意，我在原本的字符串内又加入了一个四位的数字组合<code>7894</code>，但是也只匹配出了<code>789</code>，那也就是说，这种数字匹配方式，有几个转义字符组合在一起，那就匹配出多少位;<code>\d</code>这个转义字符就是代表单个的数字。</p><p>整个代码中，<code>findall</code>就是正则中的相关函数，除了<code>findall</code>之外，还有一些其他函数，我们一起来认识下：</p><h3 id="re模块的函数"><code>re</code>模块的函数</h3><h3 id="match与search"><code>match</code>与<code>search</code></h3><p><code>match</code>和<code>search</code>经常是被放在一起来进行讨论的，因为这两个函数很像。具体它们有什么作用和区别呢？我们直接上代码，一点点讲：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>).span()) <span class="hljs-comment"># 起始位置匹配</span><br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&#x27;me&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>)) <span class="hljs-comment"># 不在起始位置匹配</span><br><br>---<br>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>可以看到，虽然第二段打印中，我输入的<code>me</code>也可以从字符串中找到，但是因为不是从起始位置匹配的，所以返回了<code>None</code>。</p><p>再来看看<code>search</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(re.search(<span class="hljs-string">&#x27;www&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>).span()) <span class="hljs-comment"># 起始位置匹配</span><br><span class="hljs-built_in">print</span>(re.search(<span class="hljs-string">&#x27;me&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>).span()) <span class="hljs-comment"># 不在起始位置匹配</span><br><br>---<br>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)<br>(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure><p><code>search</code>方法中，无论我们要匹配的字符是在起始位置还是结束位置，只要是能找到，都会返回其位置。</p><p>有小伙伴们可能会奇怪，我在成功返回的末尾都加了一个<code>span()</code>,是不是这个影响的原因？我们来看看这两个方法匹配成功后的返回值就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(re.search(<span class="hljs-string">&#x27;me&#x27;</span>, <span class="hljs-string">&#x27;www.hivan.me&#x27;</span>)) <span class="hljs-comment"># 不在起始位置匹配</span><br><br>---<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;me&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>其完整的返回值应该是这样的，我后面加的<code>span()</code>只是为了获取返回值中的<code>span</code>信息。</p><p>所以对于这两个函数，我们可以稍微归纳一下：</p><p><strong><code>re.match()</code>函数</strong>：</p><ul><li>会从头开始进行匹配，如果第一个就符合要求，那么匹配成功</li><li>如果第一个不符合规则，则返回<code>None</code></li><li>匹配成功后返回<code>Match</code>对象</li><li>成功后可以使用<code>group()</code>和<code>span()</code>方法获取数据和下标区间</li></ul><p><strong><code>re.search()</code>函数</strong>：</p><ul><li>从字符串的开头开始进行搜索式的匹配</li><li>匹配成功则返回<code>Match</code>对象，匹配失败者返回<code>None</code></li><li>成功后可以使用<code>group()</code>和<code>span()</code>方法获取数据和下标区间</li></ul><p><strong>两者的区别：</strong></p><ul><li><code>match</code>方法是从字符串的开头进行匹配，如果开始就不符合正则的要求，则匹配失败，返回None。</li><li><code>search</code>方法是从字符串的开始位置一直搜索到字符串的最后，如果在整个字符串中都没有匹配到，则失败，返回None</li></ul><p>在看完<code>match</code>和<code>search</code>之后，我们再来看看<code>re</code>模块的其他函数：</p><h3 id="re.findall"><code>re.findall()</code></h3><p>这个函数在文章开头我们就用到了，但是并未给大家进行详解。现在我们就来认识一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123si7894lovemida&quot;</span><br>myReg = <span class="hljs-string">&#x27;love&#x27;</span><br><span class="hljs-built_in">print</span>(re.findall(myReg, myStr))<br><br>---<br>[<span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;love&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，和一开头我们所写的不同，这次返回的参数列表内出现了两个<code>love</code>，原因就是我对<code>myStr</code>这个变量又重新定义了一下，在接近尾部的地方多加了一个<code>love</code>。</p><p>从这我们也能看出来了，<code>findall</code>这个函数是按照正则表达式的规则在字符中匹配所有符合规则的元素，结果返回一个列表，如果没有找到的情况下，会返回一个空列表。</p><h4 id="re.finditer"><code>re.finditer()</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = re.finditer(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;callable_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x107ab3790</span>&gt;<br></code></pre></td></tr></table></figure><p>从返回的结果中看到，这个函数返回的是一个迭代器。那让我们利用迭代器规则来试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><br>---<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;love&#x27;</span>&gt;<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">22</span>, <span class="hljs-number">26</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;love&#x27;</span>&gt;<br>StopIteration:<br></code></pre></td></tr></table></figure><p>在第三个<code>next</code>方法的时候报错了，那和我们使用<code>findall</code>结果是一致的，返回了两个<code>love</code>。并且，<code>finditer</code>方法会返回每一个匹配值的下标范围。使用<code>span()</code>来获取到这个范围。</p><h3 id="re.sub"><code>re.sub()</code></h3><p>这个函数方法和之前介绍的方法有些不太一样了，以上我们所使用的可以说都是搜索、查找。那这个函数就是修改了。其功能是按照正则表达式的规则，在字符串中找到需要被替换的字符串，完成一个替换。主要参数有三个：</p><ul><li><code>pattern</code>: 正则表示的规则，匹配需要被替换的字符串</li><li><code>repl</code>: 替换后的字符串</li><li><code>string</code>: 被替换的原始字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&quot;iloveyou521to123si7894lovemida&quot;</span><br>myReg = <span class="hljs-string">&#x27;love&#x27;</span><br>res = re.sub(myReg, <span class="hljs-string">&#x27;live&#x27;</span>, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>iliveyou521to123si7894livemida<br></code></pre></td></tr></table></figure><p>这样，我们对整个<code>myStr</code>就完成了特定字符串的替换，将其中的<code>love</code>全部替换成了<code>live</code>。</p><h3 id="re.split"><code>re.split()</code></h3><p>这个方法会按照指定的正则规则，进行数据切割。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;hello my name is chaheng&#x27;</span><br>res = re.split(<span class="hljs-string">&#x27; &#x27;</span>, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;my&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;is&#x27;</span>, <span class="hljs-string">&#x27;chaheng&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在这段代码中，我们将原字符串以空格<code></code>来进行风格，将整个字符串分割成了一个列表。其原理和我们将字符串时讲到的基本一致，这里就不详细讲解这个函数了。</p><h3 id="compile"><code>compile()</code></h3><p>这个函数可以直接将正则表达式定义为「正则对象」，使用正则对象直接操作。</p><p>我们现在来看一个示例：</p><p>假如说，我有下面这样一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<br>    <span class="hljs-string">&#x27;i love 123 you&#x27;</span>,<br>    <span class="hljs-string">&#x27;i love 234 you&#x27;</span>,<br>    <span class="hljs-string">&#x27;i love 456 you&#x27;</span>,<br>    <span class="hljs-string">&#x27;i love 678 you&#x27;</span><br>]<br></code></pre></td></tr></table></figure><p>我现在想要从中找到所有的数字，那么使用之前所学的内容，当然我们想到的一定是<code>for</code>循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>    newReg = <span class="hljs-string">&#x27;\d\d\d&#x27;</span><br>    res = re.search(newReg, i)<br>    <span class="hljs-built_in">print</span>(res.group())<br>    <br>---<br><span class="hljs-number">123</span><br><span class="hljs-number">234</span><br><span class="hljs-number">456</span><br><span class="hljs-number">678</span><br></code></pre></td></tr></table></figure><p>可以看到，我们确实正确的拿到了<code>arr</code>中的相关数字。</p><p>这里，我们稍微讲解一下正则表达式中的<code>\d&#123;n&#125;</code>，在正则中，<code>\d</code>是转义字符我们之前学过了，但是其实，我们并不需要写三个<code>\d</code>来去匹配三个数字，那如果真是这样的话，我们要匹配几十个数字的时候怎么办呢？这个时候我们可以用到<code>\d&#123;n&#125;</code>这样的写法，大括号中的<code>n</code>表示的就是前面这个<code>\d</code>的匹配连续匹配n次。那么，我们原本的<code>newReg='\d\d\d'</code>就可以改为<code>newRge='\d&#123;3&#125;'</code>。</p><p>让我们回过头来继续，刚才我们使用了<code>for</code>循环来完成了依次取值对吧。这个时候，让我们深入<code>search()</code>这个方法的源码去看看，其中是长这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">pattern, string, flags=<span class="hljs-number">0</span></span>):<br>  <span class="hljs-keyword">return</span> _<span class="hljs-built_in">compile</span>(pattern, flags).search(string)<br></code></pre></td></tr></table></figure><p>那么根据这个<code>return</code>的结构来看，我们是不是可以这样来写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\d&#123;3&#125;&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>    res = myReg.search(i).group()<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br><span class="hljs-number">123</span><br><span class="hljs-number">234</span><br><span class="hljs-number">456</span><br><span class="hljs-number">678</span><br></code></pre></td></tr></table></figure><p>确实，我们获得了我们想要的结果。</p><p>那上下两种写法的区别在于哪里呢？</p><p>其实，我们第一种写法里，我们定义了一个正则规则，然后传给<code>search(myReg, i)</code>之后，<code>search</code>方法在其内部先是调用了一下<code>_compile</code>,生成了一个正则对象，在这之后，才又传给了<code>search</code>方法，最后得到结果。</p><p>而我们在第二种写法中，直接用<code>compile</code>函数将规则定义成了一个对象，使用<code>search</code>直接得到了结果。</p><p>你们注意看结构，是不是我第二个写法里，<code>for</code>循环里的<code>myReg</code>实际上就是<code>search</code>方法内的<code>_compile(pattern, flags)</code>。</p><p>那我们这样写有什么意义呢？呃，实际上，从性能上来说虽然是快了一些，但是也不见得快多少。更多的是想让大家养成一个去方法源码中探究逻辑的好习惯。</p><p>那么接下来，才是这节课的重点。大家集中注意力，我们开始。</p><h2 id="正则表达式的规则">正则表达式的规则</h2><p>在本文的最开头，我们就先给到了正则表达式的基本规则，我们拿下来再复习一下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">普通字符： 大小写字母，数字，符号...<br>转义字符： <span class="hljs-string">\w,</span> <span class="hljs-string">\W,</span> <span class="hljs-string">\d,</span> <span class="hljs-string">\D,</span> <span class="hljs-string">\s,</span> <span class="hljs-string">\S</span> ...<br>特殊字符： . * ? + ^ $ [] &#123;&#125; () <br>匹配模式： I U ...<br></code></pre></td></tr></table></figure><p>那其实，我们之前介绍相关函数方法的时候，所使用到的基本都是普通字符，其中也用到了<code>\d</code>这个转义字符，明白<code>\d</code>就是去匹配数字。</p><h3 id="普通字符">普通字符</h3><p>普通字符实际上就是最简单的匹配方式，你写什么就是什么。可以理解为，我在全文中去搜索一个单词或者数字。而且我们之前也使用过多次了，所以这部分我们就不再继续向西介绍了。</p><h3 id="转义字符">转义字符</h3><p>转义字符包括：<code>\w, \W, \d, \D, \s, \S ...</code></p><p>什么都是从代码里去理解最直接，让我们先来定义一个字符串待用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">myStr</span> = <span class="hljs-string">&#x27;a2$_ilove521you&#x27;</span><br></code></pre></td></tr></table></figure><p>然后我们一个一个来看：</p><p><code>\w</code>, 这个转义字符匹配的内容是单个字母、数字、下划线</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们看，在最后的结果中，我们匹配到了这个字符串中所有的字母，数字和下划线。其中的特殊字符和制表符都被过滤掉了。</p><p><code>\W</code>，注意，现在这个<code>W</code>是大写的。那这个转义字符规则会去匹配单个「非」字母、数字，下划线。啥意思？简单，看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 转义字符</span><br>myReg = <span class="hljs-string">&#x27;\W&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>]<br></code></pre></td></tr></table></figure><p>看到区别了吧？和<code>\w</code>(小写)完全相反，之前匹配到的字母、数字、下划线一个没匹配到，而之前没被匹配到的特殊字符和制表符，则被匹配后组成了一个列表。</p><p><code>\d</code>，这个转义字符规则会匹配单个的数字。这个我们之前用过了，这里就不演示了。</p><p><code>\D</code>，这个转义字符实际也非常简单，就是匹配非数字。注意到了吧？所有的转义字符里，小写字母大写之后，其匹配的内容都是相反的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\D&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>结果也是，除了数字其他的内容都被匹配到了。</p><p><code>\s</code>， 这个转义字符规则是匹配单个的空格符或制表符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\s&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;\t&#x27;</span>]<br></code></pre></td></tr></table></figure><p>结果却是如此，唯一的制表符被匹配了出来。（初学时，我一度长期混乱的认为<code>\s</code>是匹配所有字符串，大家别犯我一样的错误。）</p><p><code>\S</code>，那这个大写字母的匹配规则不用说，一定是匹配空格或制表符之外的所有内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\S&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;$&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>打印结果验证了我们的猜想。</p><p><code>\w&#123;4&#125;\d</code>，基本转义字符我们都介绍完了，这里我们来看看组合在一起会是什么样。其中的<code>\w&#123;4&#125;</code>大家也应该明白其含义，就是<code>\w\w\w\w</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;4&#125;\d&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;love5&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，这样组合之后匹配出来的就是4个字母、数字、下划线+一个数字。那是不是这次匹配我们也可以写成<code>\w&#123;5&#125;</code>呢？反正最后匹配出来的<code>love5</code>不也就是5个<code>w</code>的组合么？</p><p>那我们试试看就知道了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;5&#125;&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_ilov&#x27;</span>, <span class="hljs-string">&#x27;21you&#x27;</span>]<br></code></pre></td></tr></table></figure><p>没想道结果是这样的对吧？这是因为，<code>\w&#123;5&#125;</code>中，最后一位可以是字母，数字或者下划线都可以，而我们用<code>\w&#123;4&#125;\d</code>则是最后一位必须是数字，不能是其他的。</p><h3 id="特殊字符">特殊字符</h3><p>特殊字符包括：<code>. * ? + ^ $ [] &#123;&#125; ()</code></p><p>这回，让我们再重新定义一段合适的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;@_2i4l22oveyou&#x27;</span><br></code></pre></td></tr></table></figure><p>然后，我们还是一个一个的来看：</p><p><code>.</code>，表示匹配单个的任意字符，当然也有例外，就是除了换行符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;.&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;@&#x27;</span>, <span class="hljs-string">&#x27;\t&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>字符串内的所有内容，我们都匹配了出来，然后组成了一个列表。</p><p><code>*</code>,这个特殊字符需要和其他的匹配进行组合使用，它表示的是任意次数。具体什么意思呢？我们还是从代码里去看看是如何表现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @_2i4l22oveyou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>l<br></code></pre></td></tr></table></figure><p>这段代码我们应该是比较熟悉了，<code>\w</code>和<code>search</code>方法我们都已经学过了。那这个其实就是在字符串中从开头去匹配<code>\w</code>对吧？</p><p>我们再来继续往下看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @_2i4l22oveyou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w*&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>like<br></code></pre></td></tr></table></figure><p>我们看结果，这次<code>search</code>在匹配到第一个<code>\w</code>之后，又继续向后匹配了，直到遇到空格才停了下来。就是因为<code>\w</code>后面加了一个<code>*</code>,所以就会一直匹配任意次数，直到<code>\w</code>不再匹配了才结束。</p><p>这里有一个概念，就是<code>*</code>代表的匹配任意次数，为什么我要强调这个呢？就是任意次数其实是包含<code>0</code>次的。也就是说，我们只要使用了<code>*</code>这个特殊字符，那么就算没有符合匹配项，一样是酸是匹配成功了，只是返回的是空而已。我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27; like chaheng @_2i4l22oveyou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w*&#x27;</span><br>res = re.<span class="hljs-keyword">match</span>(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&lt;re.Match <span class="hljs-built_in">object</span>; span=(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-keyword">match</span>=<span class="hljs-string">&#x27;&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>我们在之前的字符串前面加了一个空格，按道理说是不符合<code>\w</code>匹配的。那么<code>match</code>从字符串的开头开始进行搜索式的匹配,没有就返回<code>None</code>对吧？可是这次，并没有返回<code>None</code>，我们看到<code>match=''</code>，也就是说，它匹配成功了，只是成功了0次。所以按照<code>*</code>匹配任意次的规则，它不会返回<code>None</code>。这里比较绕，大家好好理解一下。我们继续。</p><p><code>+</code>，这又是一个和其他规则配合使用的特殊字符，和<code>*</code>一样，它也表示匹配次数，但是这个表示的是至少要求匹配一次。正好，我们之前改造的字符串最前面多加了一个空格，让我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w+&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>like<br></code></pre></td></tr></table></figure><p>按<code>search</code>从字符串的开头开始进行搜索式的匹配，是不是这里我们应该返回<code>l</code>了？然而并没有，却返回了<code>like</code>，这是为什么呢？</p><p>原因就在于<code>+</code>这个特殊字符，它也并不是只拿到第一个就罢休了，和<code>\w*</code>一样，一直往后匹配，直到第二个空格的时候，才宣告罢休。所以<code>\+</code>是「至少」匹配一次，<code>0</code>次不干，而<code>1</code>之后如果可以连续，那就继续匹配。</p><p><code>?</code>,这个特殊字符的作用是「拒绝贪婪」，看着很特殊是吧？其实就是，在<code>?</code>之前的规则，只要达成即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w+?&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>l<br></code></pre></td></tr></table></figure><p>看，我们之前使用<code>\w+</code>的时候，<code>+</code>这孩子遇到第一个还不满足，非要向后继续拿。可是这个时候我多加了一个家长<code>?</code>，勒令<code>+</code>既然目的已经达到了，就不要再继续了。这就是<code>?</code>字符「拒绝贪婪」的作用。</p><p><code>&#123;&#125;</code>，这个特殊字符咱们用过了，应该大家也都知道它的含义。就是重复多少次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;5&#125;&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>chahe<br></code></pre></td></tr></table></figure><p>从结果我们可以看到，因为前面的<code>like</code>只有四位，并不符合连续匹配五次的标准，所以最后被匹配出来的是<code>chahe</code>。</p><p><code>&#123;&#125;</code>这个特殊字符其实还有一种用法，就是可以给定范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;\w&#123;1,4&#125;&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br>like<br></code></pre></td></tr></table></figure><p>我们知道，下标1到下标4这个范围内，正好是<code>like</code>。</p><p><code>‘[]’</code>，这个特殊字符代表字符的范围。用于匹配范围内说包含的字符。使用<code>[]</code>我们可以更精准的筛选出我们需要匹配的内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2i4l22LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br>myReg = <span class="hljs-string">&#x27;[a-z]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br>myReg = <span class="hljs-string">&#x27;[0-9]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br>myReg = <span class="hljs-string">&#x27;[_]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>]<br>[<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br>[<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>]<br>[<span class="hljs-string">&#x27;_&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，不同的组合匹配出了不同的范围内的单个字符。</p><p><code>[A-Za-z0-9_]</code> 这个组合等价于<code>\w</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2i4l22LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;[A-Za-z0-9_]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;_&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>()</code>,这个特殊字符代表的子组，括号中的表达式首先作为整个正则的一部分，另外会把符合小阔中的内容单独提取一份。我们先看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2ial2345LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;\w+\d&#123;4&#125;\w+&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;_2ial2345LoveYou&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这个组合我们匹配到了<code>_2ial2345LoveYou</code>，有且只有这一个组合了。不过这不是我想要的，我想要的是什么呢？是这段匹配出的字符串，并且，我还想要这段字符串中那段数字作为单独的匹配出来。那这个时候我们怎么做呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2ial2345LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;(\w+)(\d&#123;4&#125;)(\w+)&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[(<span class="hljs-string">&#x27;_2ial&#x27;</span>, <span class="hljs-string">&#x27;2345&#x27;</span>, <span class="hljs-string">&#x27;LoveYou&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>我们将用<code>()</code>将前中后包裹了起来，希望得到一个子组，而中间的部分，就是我们想要得到的4个数字的组合。</p><p><code>^</code>和<code>$</code>这两个特殊字符实际上属于「定位符」，<code>^</code>是匹配输入字符串开始的位置。<code>$</code>是匹配输入字符串结尾的位置。</p><p>那我们从一个案例中来了解一下这两个定位符的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;186301916675&#x27;</span><br><span class="hljs-comment"># 定义一个匹配手机号的正则表达式</span><br>myReg = <span class="hljs-string">&#x27;^1\d&#123;10&#125;$&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>返回了<code>None</code>，这又是为什么呢？原因就在于，我们用<code>^</code>限制了必须是1开始，而用了<code>$</code>来限制了到结尾必须是后面有十位数字，而我们数一下，我们给定了12位数字，超出了一位，才会匹配不上。</p><p>如果我们去掉限制结尾<code>$</code>再来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;186301916675&#x27;</span><br><span class="hljs-comment"># 定义一个匹配手机号的正则表达式</span><br>myReg = <span class="hljs-string">&#x27;^1\d&#123;10&#125;&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res.group())<br><br>---<br><span class="hljs-number">18630191667</span><br></code></pre></td></tr></table></figure><p>可以看到，我们遵循了开头位1和后面跟十位数字的规则，但是原字符串中多出来的一位数字被直接过滤掉了。那我们并不知道，用户输入的数字中到底是哪个位置多输入了一个数对吧？</p><p>再来看，我们把结尾限制加上，但是开头限制改一个数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myStr = <span class="hljs-string">&#x27;186301916675&#x27;</span><br><span class="hljs-comment"># 定义一个匹配手机号的正则表达式</span><br>myReg = <span class="hljs-string">&#x27;^2\d&#123;10&#125;$&#x27;</span><br>res = re.search(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>因为开头匹配不对，所以返回了<code>None</code>。</p><p>所以，争取的匹配方式至少有三个条件：</p><ol type="1"><li>1开头，当然，如果能把运营商的所有开头数字都拿到，那我们能够匹配的条件就变多了。</li><li>必须全部是数字</li><li>必须是11位</li></ol><p>这样，我们可以加上开头限制和结尾限制，正好能满足一个简易的手机号匹配规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;^1\d&#123;10&#125;$&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="正则的模式">正则的模式</h3><p>在正则的模式中，包含了一下几个模式：</p><p><code>re.I</code>: 不区分大小写</p><p><code>re.L</code>: 作本地化识别匹配</p><p><code>re.M</code>:多行匹配，会影响到<code>^</code>个<code>$</code></p><p><code>re.S</code>：使用<code>.</code>匹配包括换行在哪的所有字符</p><p><code>re.U</code>：根据<code>Unicode</code>字符集解析字符。这个标志影响<code>\w, \W, \b, \B</code></p><p><code>re.X</code>:改标志通过给予更灵活的格式以便将正则表达式写的更易于理解。</p><p>实际上，我们虽然列出了这么多模式，真正常用的，也就是<code>re.I</code>这个模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 正常匹配，给定规则大写字母</span><br>myStr = <span class="hljs-string">&#x27;like chaheng @ ShO _2i4l22LoveYou&#x27;</span><br>myReg = <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br>res = re.findall(myReg, myStr)<br><span class="hljs-built_in">print</span>(res)<br><br><span class="hljs-comment"># 使用模式&#x27;re.I&#x27;， 其他不变</span><br>myReg = <span class="hljs-string">&#x27;[A-Z]&#x27;</span><br>res = re.findall(myReg, myStr,re.I)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>]<br>[<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;n&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;S&#x27;</span>, <span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;Y&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;u&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，当我设定了不区分大小写的情况下。字符串中的所有英文字母都被匹配了出来。</p><h2 id="练习">练习：</h2><p>这次，我们和以往不同，将练习和课程放在了一起。至于为什么嘛，只是因为我课程写完之后发现还有时间。<code>^_^</code></p><p>这次我们作这样一个练习：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 定义一个正则表达式来验证邮箱是否正确。<br><span class="hljs-bullet">2.</span> 完善手机号码的正则表达式<br><span class="hljs-bullet">3.</span> 定义一个匹配IP的正则表达式 [255.255.255.254]<br></code></pre></td></tr></table></figure><h3 id="验证邮箱">验证邮箱</h3><p>首先让我们来看，邮箱的格式基本包含以下内容：</p><ul><li><code>123456@qq.com</code> 纯数字</li><li><code>chaheng@qq.com</code> 纯字母</li><li><code>chaheng75@126.com</code> 数字加字母</li><li><code>cha_heng@163.com</code> 混合型</li><li><code>chaheng@vip.163.com</code> 多级域名</li><li><code>chaheng@hivan.me</code> 企业邮箱（企业域名）</li><li><code>cha.heng@gmail.com</code> 包含特殊字符<code>.</code></li></ul><p>好，让我们来看，我们以<code>@</code>来前后区分，那么我们先看左边，会包含的内容就是<code>数字，字母，下划线，特殊字符</code>，让我们先来写一下规则试一下：</p><p><code>[a-zA-Z0-9]+([_\.][a-zA-Z0-9])*</code></p><p>那么右边的部分呢？</p><p><code>@(\w)+\.[a-z]&#123;2,6&#125;</code></p><p>让我们结合其实试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mailReg</span>(<span class="hljs-params">mail</span>):<br>    myReg = <span class="hljs-string">&#x27;[a-zA-Z0-9]+([_\.][a-zA-Z0-9]+)*@(\w)+\.[a-z]&#123;2,6&#125;&#x27;</span><br>    res = re.search(myReg, mail)<br>    <span class="hljs-keyword">if</span> res:<br>        <span class="hljs-keyword">return</span> res.group()<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res)<br>    <br>mailReg(<span class="hljs-string">&#x27;123456@qq.com&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;123456@qq.com&#x27;</span><br></code></pre></td></tr></table></figure><p>感觉是OK。那让我们多测试下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">mailReg(<span class="hljs-string">&#x27;cha.heng@gmail.com&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;cha.heng@gmail.com&#x27;</span><br><br>=========================<br>mailReg(<span class="hljs-string">&#x27;chaheng@vip.163.com&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>多级域名的测试没有通过，在函数内打印出了<code>None</code>。我们回过头来看看：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">myReg</span> = &#x27;[a-zA-Z0-<span class="hljs-number">9</span>]+([_\.][a-zA-Z0-<span class="hljs-number">9</span>]+)*@(\w)+\.[a-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;&#x27;<br></code></pre></td></tr></table></figure><p>既然是多级域名出现了问题，那问题肯定出现在多出的那一个点上，我们这样改：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">myReg</span> = &#x27;^[a-zA-Z0-<span class="hljs-number">9</span>]+([_\.][a-zA-Z0-<span class="hljs-number">9</span>]+)*@(\w+\.)+[a-z]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;$&#x27;<br></code></pre></td></tr></table></figure><p>注意，我们加上了<code>^</code>和<code>$</code>符号。</p><p>然后我们再重新试试看，这次呢，我不想一个个实验了，让我们来定义一个数组来批量测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mailReg</span>(<span class="hljs-params">mail</span>):<br>    myReg = <span class="hljs-string">&#x27;^[a-zA-Z0-9]+([_\.][a-zA-Z0-9]+)*@(\w+\.)+[a-z]&#123;2,6&#125;$&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mail:<br>        res = re.search(myReg, i)<br>        <span class="hljs-keyword">if</span> res:<br>            <span class="hljs-built_in">print</span>(res.group())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(res)<br><br>emailarr = [<br>   <span class="hljs-string">&#x27;123456@qq.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng@qq.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng75@126.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;cha_heng@163.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng@vip.163.com&#x27;</span>,<br>   <span class="hljs-string">&#x27;chaheng@hivan.me&#x27;</span>,<br>   <span class="hljs-string">&#x27;cha.heng@gmail.com&#x27;</span>,<br>   <span class="hljs-string">&#x27; list@gmail.com &#x27;</span><br>]<br><br>mailReg(emailarr)<br><br>---<br><span class="hljs-number">123456</span>@qq.com<br>chaheng@qq.com<br>chaheng75@<span class="hljs-number">126.</span>com<br>cha_heng@<span class="hljs-number">163.</span>com<br>chaheng@vip<span class="hljs-number">.163</span>.com<br>chaheng@hivan.me<br>cha.heng@gmail.com<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>这一下子我们就将刚才想到的格式都测试完了，最后我们还特意加了一个不符合的格式来测试下康康是否被过滤了出来。结果说明我们写的正则没有问题。</p><h3 id="手机号码">手机号码</h3><p>就像我们上面写验证手机号正则提到过的，我们可以定义一个所有运营商可能的开头来做头部验证：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">13</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>],<span class="hljs-number">14</span>[<span class="hljs-number">5</span>-<span class="hljs-number">9</span>],<span class="hljs-number">15</span>[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>-<span class="hljs-number">9</span>],<span class="hljs-number">16</span>[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],<span class="hljs-number">17</span>[<span class="hljs-number">0</span>-<span class="hljs-number">8</span>],<span class="hljs-number">18</span>[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>],<span class="hljs-number">19</span>[<span class="hljs-number">0</span>-<span class="hljs-number">3</span>,<span class="hljs-number">5</span>-<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>实际上，我们还可以分的更细一点，区分运营商。不过在这个练习中，没必要分的这么细了。</p><p>来，我们实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;^(13[0-9]|14[5-9]|15[0-3,5-9]|16[2,5,6,7,8]|17[0-8]|18[0-9]|19[0-3,5-9])\d&#123;8&#125;$&#x27;</span><br><br>phonearr = [<br>    <span class="hljs-string">&#x27;13728739429&#x27;</span>,<br>    <span class="hljs-string">&#x27;13128319520&#x27;</span>,<br>    <span class="hljs-string">&#x27;17729231234&#x27;</span>,<br>    <span class="hljs-string">&#x27;23210023421&#x27;</span>,<br>    <span class="hljs-string">&#x27;189232198341&#x27;</span>,<br>    <span class="hljs-string">&#x27;19123214421&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> phonearr:<br>    res = re.search(myReg, i)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;手机号码不正确:&#x27;</span>, i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res.group())<br>        <br>---<br><span class="hljs-number">13728739429</span><br><span class="hljs-number">13128319520</span><br><span class="hljs-number">17729231234</span><br>手机号码不正确: <span class="hljs-number">23210023421</span><br>手机号码不正确: <span class="hljs-number">189232198341</span><br><span class="hljs-number">19123214421</span><br></code></pre></td></tr></table></figure><p>正确的辨认并打印了出来，不正确的也辨认了出来。</p><h3 id="匹配ip地址">匹配IP地址</h3><p>我们来看看，一个正确的IP地址（IPv4），是由四个三位数来组成的，包含：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.0.0.0</span> ~ <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span><br></code></pre></td></tr></table></figure><p>既然是这样一个格式，我们来思考一下，</p><p>首先，我们需要匹配<code>0 ~ 199</code>的范围，也就是0或者1开头,这个比较简单：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[0-1]</span>?\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>这一段匹配中：</p><ul><li><p><code>[0-1]?</code>表示匹配0或1一次或者零次</p></li><li><p><code>\d</code>就是要匹配任意单个数字。0～9都可以</p></li><li><p><code>&#123;1,2&#125;</code>， 给定范围1 ～ 2，表示前面的<code>\d</code>出现1次或者2次。</p></li></ul><p>然后我们需要来匹配<code>200 ~ 255</code>范围,这个范围内比较复杂，包含了两种情况，一种是<code>201 ~250</code>的情况，一种是<code>251 ~ 255</code>的情况</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span>((<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])|([<span class="hljs-number">0</span>-<span class="hljs-number">4</span>][<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]))<br></code></pre></td></tr></table></figure><p>这一段匹配，一开表示数字<code>2</code>开头</p><p>然后2之后用异或限定了开头可以是<code>5</code>或者可以是<code>0-4</code>之间的任意数字。</p><p>是<code>5</code>的话，后面需要匹配0-5<code>，是</code>4<code>的话，后面需要匹配</code>0-9`。</p><p>既然一次的匹配已经有了，那剩下的和第一次也都一样，就好些了，我们再多加一个<code>.</code>的匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">((<span class="hljs-number">2</span>((<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])|([<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d)))|([<span class="hljs-number">0</span>-<span class="hljs-number">1</span>]?\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;))(\.((<span class="hljs-number">2</span>((<span class="hljs-number">5</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])|([<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]\d)))|([<span class="hljs-number">0</span>-<span class="hljs-number">1</span>]?\d&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)))&#123;<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>让我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;&#x27;</span><br><br><br>ipArr = [<br>    <span class="hljs-string">&#x27;25.232.123.241&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.242.211.221&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.123.421&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.421.4.5&#x27;</span>,<br>    <span class="hljs-string">&#x27;212.444.523&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>    <span class="hljs-string">&#x27;214.113.231.256&#x27;</span>,<br>    <span class="hljs-string">&#x27;54.214.213.265&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ipArr:<br>    res = re.search(myReg, i)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IP 地址不正确:&#x27;</span>, i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res.group())<br><br>---<br><span class="hljs-number">25.232</span><span class="hljs-number">.123</span><span class="hljs-number">.241</span><br><span class="hljs-number">123.242</span><span class="hljs-number">.211</span><span class="hljs-number">.221</span><br><span class="hljs-number">0.0</span><span class="hljs-number">.123</span><span class="hljs-number">.42</span><br>IP 地址不正确: <span class="hljs-number">123.421</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><br>IP 地址不正确: <span class="hljs-number">212.444</span><span class="hljs-number">.523</span><br><span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br><span class="hljs-number">214.113</span><span class="hljs-number">.231</span><span class="hljs-number">.25</span><br><span class="hljs-number">54.214</span><span class="hljs-number">.213</span><span class="hljs-number">.26</span><br></code></pre></td></tr></table></figure><p>从结果中可以看到，到底还是有漏网之鱼。第三个和最后两个判断都失误了。这是为什么呢？</p><p>似乎最后一位被截断判断了，也就是说，它并没有判断三位数。</p><p>哦，我大概猜到了。让我们把头部匹配和结尾匹配加上再试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python">myReg = <span class="hljs-string">&#x27;^((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;$&#x27;</span><br><br><br>ipArr = [<br>    <span class="hljs-string">&#x27;25.232.123.241&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.242.211.221&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.123.421&#x27;</span>,<br>    <span class="hljs-string">&#x27;123.421.4.5&#x27;</span>,<br>    <span class="hljs-string">&#x27;212.444.523&#x27;</span>,<br>    <span class="hljs-string">&#x27;0.0.0.0&#x27;</span>,<br>    <span class="hljs-string">&#x27;214.113.231.256&#x27;</span>,<br>    <span class="hljs-string">&#x27;54.214.213.265&#x27;</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ipArr:<br>    res = re.search(myReg, i)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;IP 地址不正确:&#x27;</span>, i)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(res.group())<br><br>---<br><span class="hljs-number">25.232</span><span class="hljs-number">.123</span><span class="hljs-number">.241</span><br><span class="hljs-number">123.242</span><span class="hljs-number">.211</span><span class="hljs-number">.221</span><br>IP 地址不正确: <span class="hljs-number">0.0</span><span class="hljs-number">.123</span><span class="hljs-number">.421</span><br>IP 地址不正确: <span class="hljs-number">123.421</span><span class="hljs-number">.4</span><span class="hljs-number">.5</span><br>IP 地址不正确: <span class="hljs-number">212.444</span><span class="hljs-number">.523</span><br><span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><br>IP 地址不正确: <span class="hljs-number">214.113</span><span class="hljs-number">.231</span><span class="hljs-number">.256</span><br>IP 地址不正确: <span class="hljs-number">54.214</span><span class="hljs-number">.213</span><span class="hljs-number">.265</span><br></code></pre></td></tr></table></figure><p>这回没问题了。我们的正则匹配算是完成了。</p><p>那这节课下来之后，大家要多去理解，多去练习。这节课对于打算玩数据的人正的很重要。</p><p>好了，那我们下节课再见吧。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/regular-expression/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>16. 练习：万年历</title>
    <link href="https://hivan.me/Exercise-perpetual-calendar/"/>
    <id>https://hivan.me/Exercise-perpetual-calendar/</id>
    <published>2023-08-12T16:59:35.000Z</published>
    <updated>2023-08-19T12:39:00.959Z</updated>
    
    <content type="html"><![CDATA[<img src="/Exercise-perpetual-calendar/cover.png" class="" title="img"><p>Hi, 大家好。我是茶桁。</p><span id="more"></span><p>上一节课最后，我让我家去预习一下日历和时间的相关模块，不知道大家有没有去预习。不管如何，这节课，让我们开始做一个练习：万年历。</p><p>没有预习的小伙伴也跟着一起，在本次练习完成的时候，相信你会对这些模块有了初步的了解。</p><p>好，让我们开始吧。</p><p>首先，我们需要来看看<code>calendar.monthrange()</code>这个函数，它属于<code>calendar</code>模块内，返回指定年份和月份的数据，月份的第一天是周几，和月份中的天数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendar<br><br>res = calendar.monthrange(<span class="hljs-number">2023</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-number">3</span>, <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><p>我们接收了返回值，但是这个3和30分别是什么意思呢？我们打开日历看一下就明白了：</p><img src="/Exercise-perpetual-calendar/image-20230813010916395.png" class="" title="img"><p>如图所见，2023年的6月份一共是30天，第一天是周四。这也正是<code>(3, 30)</code>的含义。之所以是3而不是4，是因为是从0开始计算的，也就是说，周一是0。比如，2023年5月的第一天就是周一，我们来看看是不是这么回事：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = calendar.monthrange(<span class="hljs-number">2023</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-number">0</span>, <span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>那有了这个，我们要做一个当月的日历就简单了，还记得我们之前做过一个星星的矩阵吗？是一样的概念，这是这次直接换成了数字而已，来，让我们从最基本框架开始（<strong>还是以6月份数据来做</strong>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot; &quot;</span>)<br>        d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>01 02 03 04 05 06 07 <br>08 09 <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <br><span class="hljs-number">15</span> <span class="hljs-number">16</span> <span class="hljs-number">17</span> <span class="hljs-number">18</span> <span class="hljs-number">19</span> <span class="hljs-number">20</span> <span class="hljs-number">21</span> <br><span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span> <span class="hljs-number">25</span> <span class="hljs-number">26</span> <span class="hljs-number">27</span> <span class="hljs-number">28</span> <br><span class="hljs-number">29</span> <span class="hljs-number">30</span> <span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span> <span class="hljs-number">35</span> <br></code></pre></td></tr></table></figure><p>这样，我们就将天数打印出来了。可是，明眼人一眼就看出了问题，这一月只有30天，怎么得到的35天的？让我们来修复一下这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-comment"># 判断是否输出</span><br>        <span class="hljs-keyword">if</span> d &gt; days:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>        d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>一   二    三   四   五    六   日<br>01   02   03   04   05   06   07   <br>08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <br><span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <br><span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <br><span class="hljs-number">29</span>   <span class="hljs-number">30</span>  <br></code></pre></td></tr></table></figure><p>我们在代码中加了一层判断，如果循环中的<code>d</code>大于<code>days</code>了，那我们就直接输出空格，否则才正确输出格式化的数字，那么这样就可以不输出<code>31-35</code>了。</p><p>完成了，顺便还打印了一行星期几。可是问题是，没有和实际情况对齐对吧？没事，我们继续来改动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-comment"># 判断是否输出</span><br>        <span class="hljs-keyword">if</span> d &gt; days <span class="hljs-keyword">or</span> (d==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i&lt;week):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;     &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>            d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>一   二    三   四   五    六   日<br>               01   02   03   04   <br>05   06   07   08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <br><span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <br><span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <br><span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>    <br></code></pre></td></tr></table></figure><p>我们在之前判断<code>d</code>大于<code>days</code>的判断上再加上一层，不仅如此，当<code>d==1</code>并且<code>i</code>小于<code>week</code>的时候，也都是出制表符，那自然最开始和最末尾不该出现数字的地方都被制表符补齐了。</p><p>我们再来多做一次实验，将月份改成7月来看看和实际情况是否相符,并且，这次我们多加一些内容，将其中的年份和月份也都打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">year = <span class="hljs-number">2023</span><br>month = <span class="hljs-number">7</span><br>res = calendar.monthrange(year, month)<br><br>days = res[<span class="hljs-number">1</span>]<br>week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;========= <span class="hljs-subst">&#123;year&#125;</span> 年  <span class="hljs-subst">&#123;month&#125;</span> 月 =========&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">32</span>)<br>d = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> d &lt;= days:<br>    <span class="hljs-comment"># 循环周</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>        <span class="hljs-comment"># 判断是否输出</span><br>        <span class="hljs-keyword">if</span> d &gt; days <span class="hljs-keyword">or</span> (d==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i&lt;week):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;     &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>            d+=<span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>()<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">7</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>                         01   02   <br>03   04   05   06   07   08   09   <br><span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <br><span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <br><span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <br><span class="hljs-number">31</span>  <br></code></pre></td></tr></table></figure><p>我们来看看实际情况是不是如此：</p><img src="/Exercise-perpetual-calendar/image-20230813014347015.png" class="" title="img"><p>没错，确实如此。7月份的第一天从周六开始，一个月有31天，周一为最后一天。那说明，我们上面写的内容真实有效。</p><p>那现在要干嘛呢？当然是封装成一个函数，以<code>year</code>和<code>month</code>为参数，这样，不管我想要查询任意月份，只要我输入对应参数就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">showdate</span>(<span class="hljs-params">year, month</span>):<br>    res = calendar.monthrange(year, month)<br><br>    days = res[<span class="hljs-number">1</span>] <span class="hljs-comment"># 当前月份的天数</span><br>    week = res[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> <span class="hljs-comment"># 当前月份第一天是周几</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;========= <span class="hljs-subst">&#123;year&#125;</span> 年  <span class="hljs-subst">&#123;month&#125;</span> 月 =========&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一   二    三   四   五    六   日&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">32</span>)<br>    <span class="hljs-comment"># 实现日历信息的输出</span><br>    d = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> d &lt;= days:<br>        <span class="hljs-comment"># 循环周</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>):<br>            <span class="hljs-comment"># 判断是否输出</span><br>            <span class="hljs-keyword">if</span> d &gt; days <span class="hljs-keyword">or</span> (d==<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> i&lt;week):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;     &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:0&gt;2d&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(d), end=<span class="hljs-string">&quot;   &quot;</span>)<br>                d+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>()<br><br>showdate(<span class="hljs-number">2023</span>, <span class="hljs-number">12</span>)<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">12</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>                    01   02   03   <br>04   05   06   07   08   09   <span class="hljs-number">10</span>   <br><span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <br><span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <br><span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <span class="hljs-number">31</span>   <br></code></pre></td></tr></table></figure><p>我们尝试调用了一下封装好的函数，输出2023年12月份日历，大家可以看看自己手机里的日历，绝对真实可靠。</p><p>好了，现在我们要完成万年历的制作了。</p><p>万年历，自然是有一个初始值，那这个初始值必须是当前时间最妥当。不然你们试试打开你们的日历，看是不是打开默认都是指向的「今天」。</p><p>那么首先，让我们获取一下当前系统的年月，这个就需要用到我们的<code>time</code>模块里的<code>localtime()</code>方法，其返回参数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">time.struct_time(tm_year=<span class="hljs-number">2023</span>, tm_mon=<span class="hljs-number">8</span>, tm_mday=<span class="hljs-number">13</span>, tm_hour=<span class="hljs-number">1</span>, tm_min=<span class="hljs-number">50</span>, tm_sec=<span class="hljs-number">38</span>, tm_wday=<span class="hljs-number">6</span>, tm_yday=<span class="hljs-number">225</span>, tm_isdst=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>那我们如何从中拿到我需要的内容？我们接着看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>dd = time.localtime()<br>year = dd.tm_year<br>month = dd.tm_mon<br><br>showdate(year, month)<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">8</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>     01   02   03   04   05   06   <br>07   08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <br><span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <br><span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <br><span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <span class="hljs-number">31</span>  <br></code></pre></td></tr></table></figure><p>很明显，我们用<code>year</code>和<code>month</code>两个变量从得到的<code>localtime</code>里获取了其中的年份和月份信息。然后重新调用<code>showdate()</code>封装函数，将其传入。也就打印出了我们当前月份的日历。</p><p>可是这都是静态的，我们总不能就只看我们当月的月份。所以，我们接着扩展这个程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>...<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 默认输出当前年月的日历信息</span><br>    showdate(year, month)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &lt; 上一月     下一月 &gt; &#x27;</span>)<br>    c = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的选择 &quot;&lt;&quot; or &quot;&gt;&quot;：&#x27;</span>)<br>    <span class="hljs-comment"># 判断用户的输入内容</span><br>    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>        month -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>        month += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您输入内容错误，请重新输入&quot;&lt;&quot;或者&quot;&gt;&quot;来选择。&#x27;</span>)<br><br>---<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">8</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>     01   02   03   04   05   06   <br>07   08   09   <span class="hljs-number">10</span>   <span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <br><span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <br><span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <br><span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>   <span class="hljs-number">31</span>                  <br> &lt; 上一月     下一月 &gt; <br>&gt;<br>========= <span class="hljs-number">2023</span> 年  <span class="hljs-number">9</span> 月 =========<br>一   二    三   四   五    六   日<br>================================<br>                    01   02   03   <br>04   05   06   07   08   09   <span class="hljs-number">10</span>   <br><span class="hljs-number">11</span>   <span class="hljs-number">12</span>   <span class="hljs-number">13</span>   <span class="hljs-number">14</span>   <span class="hljs-number">15</span>   <span class="hljs-number">16</span>   <span class="hljs-number">17</span>   <br><span class="hljs-number">18</span>   <span class="hljs-number">19</span>   <span class="hljs-number">20</span>   <span class="hljs-number">21</span>   <span class="hljs-number">22</span>   <span class="hljs-number">23</span>   <span class="hljs-number">24</span>   <br><span class="hljs-number">25</span>   <span class="hljs-number">26</span>   <span class="hljs-number">27</span>   <span class="hljs-number">28</span>   <span class="hljs-number">29</span>   <span class="hljs-number">30</span>        <br> &lt; 上一月     下一月 &gt; <br></code></pre></td></tr></table></figure><p>我们在程序运行中没有图形界面，无法接收鼠标信息，那就用输入<code>&lt;</code>和<code>&gt;</code>来代替一下，其逻辑是相同的。</p><p>可以看到，我们做了一个判断，当输入<code>&lt;</code>的时候，我月份数字减少，当我们输入<code>&gt;</code>的时候，月份数字增加。所以当我们输入<code>&gt;</code>的时候，表示下一月，数字增加，也就打印出了9月份的月份信息。</p><p>可是问题又来了，我们总不能无限加或者无限减下去吧，12月份之后不可能是13月份吧。这又该怎么办呢？</p><p>别着急，我们继续研究下该怎么改善：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br>...<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    ...<br>    <span class="hljs-comment"># 判断用户的输入内容</span><br>    <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>        month -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> month &lt; <span class="hljs-number">1</span>:<br>            month = <span class="hljs-number">12</span><br>            year -= <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>        month += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> month &gt; <span class="hljs-number">12</span>:<br>            month = <span class="hljs-number">1</span><br>            year += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;exit&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您输入内容错误，请重新输入&quot;&lt;&quot;或者&quot;&gt;&quot;来选择。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>既然月份是固定的数字，那就是最好办的，我们让变量控制在范围内不就好了。如果超过数字了，那就改变年份，将月份回滚为最小值或者最大值不就好了。两个简单的<code>if</code>解决了问题。</p><p>这就完了吗？并没有。在打印的过程当中，我发现一个问题，就是我们的月份信息不断的叠加，那导致打印区变的过长，最终都没打印完全。这并不是我们想要的，如图：</p><img src="/Exercise-perpetual-calendar/image-20230813021632548.png" class="" title="img"><p>所以，其实我都还没验证到底12月份之后是否正常变为2024年1月了。忍不了，这个问题也必须要解决。</p><p>那如何解决呢？我想起来，在<code>Linux</code>命令中有一个<code>clear</code>命令，其功能就是将当前窗口内容清理掉。那Python中又有很多和系统操作相同的功能，这次有没有呢？就算没有，我记得<code>os.system()</code>似乎可以调用系统命令的。</p><p>那，我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    os.system(<span class="hljs-string">&#x27;clear&#x27;</span>)<br>    <span class="hljs-comment"># 默认输出当前年月的日历信息</span><br>   ...<br></code></pre></td></tr></table></figure><p>实际操作了一下，无法在JupyterNotebook中实现，但是当你将代码存储成<code>.py</code>文件之后，在<code>shell</code>中执行是完全可以实现的。如下图：</p><img src="/Exercise-perpetual-calendar/ScreenFlow-1.gif" class="" title="img"><p>至此，我们本次的练习「万年历」就完成了。</p><p>大家可以下载我的源码来研究，第16课，包含一个<code>.ipynb</code>笔记本文件和一个<code>.py</code>完整文件。</p><p>有什么问题，评论区留言。</p><p>好了，下课，咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Exercise-perpetual-calendar/cover.png&quot; class=&quot;&quot; title=&quot;img&quot;&gt;
&lt;p&gt;Hi, 大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>15. 系统内置模块</title>
    <link href="https://hivan.me/System-built-in-modules/"/>
    <id>https://hivan.me/System-built-in-modules/</id>
    <published>2023-08-10T15:20:33.000Z</published>
    <updated>2023-08-12T16:58:34.847Z</updated>
    
    <content type="html"><![CDATA[<img src="/System-built-in-modules/cover.png" class="" title="封面"><span id="more"></span><p>Hi，大家好。我是茶桁。</p><p>上一节中，在我们的学习到达一个阶段的时候，我们用之前所学过的知识创建了一个简单的注册登录系统。不知道小伙伴们有没有在课后自己实现一遍呢？编程这种事情，还是要多上手多练才行。</p><p>那么今天这节课，我们来学习一下Python系统内置模块。</p><p>系统内置模块就是安装完Python解释器之后，系统本身所提供的模块。我知道，咱们之前的课程里有学习系统的内置函数，这个模块和函数不是一个东西。模块这种东西，是需要导入后才可以使用的，比如：<code>json, re, os</code>等等。</p><p>行，废话不多说，让我们进入正题。</p><h2 id="序列化模块">序列化模块</h2><p>序列化，就是指可以把Python中的数据，以文本或者二进制的方式进行转换，并且还能反序列化为原来的数据。数据在程序和网络中进行传输和存储的时候，需要以更加方便的形式进行操作，因此需要对数据进行序列化。</p><p>对数据进行序列化主要有两种方法，一种呢是Python专用的二进制序列化模块：<code>pickle</code>，还有一种呢，是互联网通用的文本序列化模块<code>json</code>。</p><h3 id="pickle"><code>pickle</code></h3><p>按照官方的定义来讲</p><blockquote><p>pickle实现了对一个Python对象结构的二进制序列化和反序列化</p></blockquote><p>它提供了一些可供使用的函数，下面让我们来一一介绍一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br>myStr = <span class="hljs-string">&#x27;I love you&#x27;</span><br>res = pickle.dumps(myStr)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br><span class="hljs-string">b&#x27;\x80\x04\x95\x0e\x00\x00\x00\x00\x00\x00\x00\x8c\nI love you\x94.&#x27;</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bytes&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>当前是将一段字符串使用<code>dumps()</code>进行了转化，那其他数据类型是否可以呢？我们来一段列表试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>res = pickle.dumps(myList)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br><span class="hljs-string">b&#x27;\x80\x04\x95\x0f\x00\x00\x00\x00\x00\x00\x00]\x94(K\x01K\x02K\x03K\x04K\x05e.&#x27;</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bytes&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，依然进行了转化，并且类型还是<code>bytes</code>。其他的诸如字典、元组等都可以进行这样的转化，我们就不一一的在这里展示了。结论为，我们使用<code>pickle.dumps</code>方法可以进行序列化成为一个二进制的数据。</p><p>再让我们来看看反序列化的效果，我在源码中还做过一个元组的序列化，并且给<code>res</code>进行了赋值，我们就拿最后一次的结果来做演示（<code>res = b'\x80\x04\x95\x10\x00\x00\x00\x00\x00\x00\x00(K\x01K\x02K\x03K\x04K\x05K\x06t\x94.'</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = pickle.loads(res)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到, 之前序列化成二进制数据的元组被<code>loads()</code>反序列化转化回来恢复成了元组，我们打印其类型，为<code>tuple</code>。</p><p>除了以上两个方法之外，还有另外两个方法<code>dump()</code>和<code>load()</code>，这四者的区别如下：</p><ul><li><code>dumps(obj, protocol=None, *, fix_imports=True, buffer_callback=None)</code>:序列化，可以把一个Python的任意对象序列化成为一个二进制，返回一个序列化后的二进制数据。</li><li><code>dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None)</code>:序列化，把一个数据对象进行序列化并写入到文件中。注意，<code>demps</code>是返回并不写到文件中，而<code>dump</code>者是写入到文件中。所以多一个必填参数<code>file</code>，就是写入的文件对象。</li><li><code>loads(data, /, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=None)</code>:反序列化，可以把一个序列化后的二进制数据反序列化为Python的对象。返回一个反序列化后的Python对象。</li><li><code>load(file, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=None)</code>:反序列化，<strong>在一个文件中</strong>读取序列化的数据，并且完成一个反序列化。和<code>loads</code>最大的不同是加载的是读取的文件对象<code>file</code>，而不是<code>data</code>。</li></ul><p>可以看到，基本上来说，<code>dump</code>和<code>load</code>是对文件进行操作的方法，那能不能使用<code>dumps</code>和<code>loads</code>来完成呢？让我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义数据</span><br>myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-comment"># 进行序列化</span><br>res = pickle.dumps(myDict)<br><span class="hljs-comment"># 写入文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.write(res)<br></code></pre></td></tr></table></figure><p>然后我们看，文件夹中确实多了一个data.txt文件，当我想要打开的时候，提示我为二进制文件。</p><img src="/System-built-in-modules/image-20230811221839214.png" class="" title="储存文件"><p>那基本上可以确定，咱们所作的操作确实成功了。</p><p>借用其他的支持二进制文件的编辑器打开看看：</p><img src="/System-built-in-modules/image-20230811223427385.png" class="" title="二进制文件"><p>再来，我们把一个反序列的二进制文件读取处理，并完成反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br><br><span class="hljs-comment"># 进行反序列化</span><br>myDict = pickle.loads(res)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>以上两个方式，我们其实完全可以使用<code>pickle</code>模块提供的方法来完成，<code>dump</code>和<code>load</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data2.txt&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    pickle.dump(myDict, fp)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/data2.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    newdict = pickle.load(fp)<br>    <span class="hljs-built_in">print</span>(newdict)<br>    <br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们又重新创建了一个序列化，保存数据到<code>data2.txt</code>中，然后反序列化再从文件中读取转化。和之前我们用到的方法得到的结果一样，但是方法我们用的却完全不同。</p><h3 id="json序列化">JSON序列化</h3><p>JSON的全称为: JavaScript Object Notation,是一个受JS的对象字面量语法启发的轻量级数据交换格式。其在JS语言中是一个对象的表示方法，和Python中的字典的定义规则和语法都很像。</p><p>JSON在互联网中又是一种通用的数据交换，传输，定义的一种数据格式。</p><p>和之前的<code>pickle</code>序列化方法一样，JSON序列化也有四种函数，其功能基本是一模一样。只是最后转化的数据格式不同：</p><ul><li><code>json.dumps()</code>: 完成JSON格式数据的序列化</li><li><code>json.loads()</code>: 完成JSON格式数据的反序列化</li><li><code>json.dump()</code>:和<code>pickle</code>模块的<code>dump</code>方法一致</li><li><code>json.load()</code>:和<code>pickle</code>模块的<code>load</code>方法一致</li></ul><p>这里，我们先不着急写代码，我觉得需要对JSON简单了解一下，其实很简单，一说就明白了：</p><p>我们之前定义了一个字典：<code>myDict = &#123;'name':'茶桁', 'age':32, 'sex':'male'&#125;</code>，这个格式的数据在Python中是字典，但是在JS中，这个玩意是一个对象(<code>Object</code>)，如果它放在一个<code>.json</code>文件中，这会是正常的<code>json</code>格式的数据。</p><p>我们来做一下操作，上几张图就明白了，为了说明，我们创建一个<code>15_json.html</code>文件和<code>15_json.json</code>，大家来看：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">let</span> person = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person, <span class="hljs-title function_">typeof</span>(person))</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们在脚本中定义了一个<code>person</code>，格式和Python中的字典一模一样，但是在JS中，它被称为对象。我们在浏览器的控制台中打印出来看看：</p><img src="/System-built-in-modules/image-20230811230908151.png" class="" title="JS中的对象"><p>那如果在一个JSON文件中呢，它就是一个最普通的JSON数据格式。只是稍微需要注意一下，虽然我们这样写并不会报错，但是总会提示格式问题，JSON最正规的写法，是需要用<code>“"</code>，尽量不要使用<code>‘’</code>。</p><p>提前说这么多JSON的知识点，是因为接下来，如果我们没有说清楚，可能正的会分辨不清。好了，让我们转回Python中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br>myDict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(myDict, <span class="hljs-built_in">type</span>(myDict))<br><br><span class="hljs-comment"># 使用JSON模块的dumps方法进行JSON格式的转换</span><br>res = json.dumps(myDict)<br><span class="hljs-built_in">print</span>(res, <span class="hljs-built_in">type</span>(res))<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br>&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;\u8336\u6841&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;male&quot;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>我们在代码中执行了两次打印，第一次是定义完字典之后，第二次是转换为JSON之后。我们可以看到两次打印结果，几乎是一模一样。当然，中文部分转化的比较明显，但是如果我讲<code>name</code>的值设定为英文，比如<code>Hivan</code>，那么可以说几乎看不出区别。比较明显的，是我们将类型打印了出来，一个是<code>dict</code>,一个就是<code>str</code>。</p><p>当然，和<code>pickle</code>一样，<code>loads</code>方法将会进行反序列化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">newDict = json.loads(res)<br><span class="hljs-built_in">print</span>(newDict, <span class="hljs-built_in">type</span>(newDict))<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;dict&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>JSON的转化，基本Python中所有的数据类型都可以进行序列化而不会出现报错的情况，但是有些数据是真的转为了JSON格式的数据，但是有的则只是转为了字符串而已。</p><p>让我们尝试将一个复杂的结构数据写到一个JSON文件中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">myList = [&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;female&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;du&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-number">34</span>,<span class="hljs-string">&#x27;sex&#x27;</span>:<span class="hljs-string">&#x27;male&#x27;</span>&#125;]<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    json.dump(myList, fp)<br></code></pre></td></tr></table></figure><p>我们去查看一下文件的内容：</p><img src="/System-built-in-modules/image-20230812015421930.png" class="" title="15_data.json"><p>读取的话，当然也和<code>pickle</code>中的用法也是一致的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    newList = json.load(fp)<br>    <span class="hljs-built_in">print</span>(newList)<br><br>---<br>[&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;female&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;du&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">34</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="数学与数值">数学与数值</h2><h3 id="数学模块-math">数学模块 Math</h3><p>Python中的内置数学模块Math提供了很多的数学相关运算。整个模块中的方法都非常简单，直接调用就可以了，当然，前提是需要导入数学模块。下面我们就简单的介绍一下相关方法(当然，其实我们之前已经介绍过一部分了。)：</p><ul><li>向上取整 <code>math.ceil()</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-comment"># math.ceil() 向上取整</span><br>res = math.ceil(<span class="hljs-number">3.14</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这个函数让你想到了什么？不知道小伙伴们还记得前面学习的内容不，是不是特别像我们曾经学过的<code>round()</code>方法？不过这两个方法还有不一样的地方，让我们来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.14</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">round</span>(<span class="hljs-number">3.5</span>))<br><br>---<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>看到区别了吗？<code>round</code>实际上是一个四舍五入的函数，而<code>ceil</code>只是向上取整，则不管你小数点后面的数字大小。当然，有向上取整:<code>math.floor()</code>，这肯定有对应的向下取整，为了很清晰的看出来，我选择了一个向上接近整数的小数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.floor(<span class="hljs-number">3.94</span>))<br><br>---<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>接下来是求幂次方:<code>math:pow(x,y)</code>，这个方法会传入两个数值，前一个数值为底数，后一个则为指数，结果是浮点数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">1.44</span><br></code></pre></td></tr></table></figure><p>下面一个是求开平方，结果也是浮点数： <code>math.sqrt()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.sqrt(<span class="hljs-number">4</span>))<br><br>---<br><span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p><code>math.fabs()</code>能够计算绝对值,结果是浮点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.fabs(-<span class="hljs-number">3.14</span>))<br><br>---<br><span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p><code>math.modf()</code>: 把一个数值拆分成小数和整数组成的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.modf(<span class="hljs-number">3.1415</span>))<br><br>---<br>(<span class="hljs-number">0.14150000000000018</span>, <span class="hljs-number">3.0</span>)<br></code></pre></td></tr></table></figure><p>至于最后的打印结果，不用太纠结。这并不是Python中的BUG，而是与计算机如何处理浮点数有关，因为计算机存储数据实际上都是二进制的，而二进制无法正确处理。</p><p>举个栗子：<code>1/3</code>，在十进制下，这个数是无限循环小数对吧？<code>3.33333333</code>，二进制实际上也有这种问题，比如说<code>1/10</code>,十进制下是<code>0.1</code>，可是二进制下呢，就成了无限循环小数：<code>0.000111001100110011...</code>。</p><p>其实大部分情况之下，这并不影响我们的使用，只是得到的数值需要处理一下四舍五入就可以了，但是也有不适用的情况。实际上，Python中有专门处理精度计算的模块：<code>decimal</code>，这个等我们以后再详细讲。</p><p><code>math.copysign(x,y)</code>:把第二个参数的正负符号拷贝给第一个参数，结果为浮点数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.copysign(-<span class="hljs-number">3</span>, <span class="hljs-number">99</span>))<br><span class="hljs-built_in">print</span>(math.copysign(<span class="hljs-number">3</span>, -<span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">3.0</span><br>-<span class="hljs-number">3.0</span><br></code></pre></td></tr></table></figure><p><code>math.fsum()</code> :将一个容器类型数据中的元素进行一个求和运算，结果为浮点数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.fsum((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)))<br><span class="hljs-built_in">print</span>(math.fsum(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))<br><br>---<br><span class="hljs-number">6.0</span><br><span class="hljs-number">6.0</span><br></code></pre></td></tr></table></figure><p>这个方法的参数值需要注意一下，容器中的元素必须是可以运算的<code>number</code>类型。</p><p><code>math.factorial(x)</code>: 以一个整数返回x的阶乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.factorial(<span class="hljs-number">4</span>))<br><br>---<br><span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>除了运算函数外，还有一些常量函数。最典型的就是<code>数学常数 π = 3.141592...</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(math.pi)<br><br>---<br><span class="hljs-number">3.141592653589793</span><br></code></pre></td></tr></table></figure><p>基本可以看出来，Python的数学模块基本都属于很简单的工具类函数，列举几个之后，大家基本上就都能上手了。其官方的文档地址可以看这里：相关文档地址为：<ahref="https://docs.python.org/zh-cn/3.10/library/math.html#module-math">https://docs.python.org/zh-cn/3.10/library/math.html#module-math</a>。</p><h3 id="随机模块-random">随机模块 <code>random</code></h3><p>随机模块也是一个比较简单的模块，大部分时候，我们是使用它来产生随机值使用的。</p><p><code>random</code>模块中的<code>random</code>函数直接使用会返回一个0-1之间的随机小数（左闭右开）</p><p>什么是左闭右开呢？通俗点说，就是<code>random</code>这个函数，有可能取到<code>0</code>这个值，而无论如何不会取到<code>1</code>这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.random())<br><br>---<br><span class="hljs-number">0.7363473107012012</span><br></code></pre></td></tr></table></figure><p><code>random.randrange([开始值]，结束值，[步进值])</code>:随机获取指定<strong>范围内的整数</strong>。对于这种需要开始值，结束值和步进值的参数形式的函数我们应该都已经非常熟悉了对吧？</p><p>这里有三个值，除了结束值是必选之外，另外两个值都是可选值。当<strong>只有一个参数</strong>时，默认就是从0到整数之间的值，<strong>存在两个参数</strong>时，就从开始值到结束值之间的随机数，而<strong>当有三个参数时</strong>，就会按照步进值从开始值到结束值之间产生一个随机数。需要记住一点，这三种参数取值方式，都是左闭右开的形式。也就是说，结束值是不会被取到的。</p><p>随机数大量应用在数字验证码，抽奖以及高并发下生成订单号等应用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">3</span>,<span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(random.randrange(<span class="hljs-number">4</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span>))<br><br>---<br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><code>random.randint()</code> 会随机产生指定范围内的随机整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.randint(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>))<br><br>---<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>可能有的小伙伴会发出疑问了：茶桁老师，你这个解释是不是写错位置了？将<code>randrange</code>的解释直接复制了下来。其实没有，这两个的功能几乎一模一样，说几乎的意思当然是还是有不同点，唯一一点不相同的是，<code>randint</code>产生的随机整数，是左闭右闭的模式，也就是说，它是可以取到结束值的。</p><p>当然我们不能只随机整数对吧？实际应用场景中我们也需要大量的浮点数：</p><p><code>random.uniform()</code> 获取指定返回内的随机小数,实际应用中我们需要注意，这个函数是没有开始值和结束值的，只有<strong>范围值</strong>，也就是说，你最小值和最大值填入的先后顺序无所谓。</p><p>那有的小伙伴会想，如果两个值我填入的数值一样会如何？嗯，那就产生一个唯一的浮点值呗。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(random.uniform(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>))<br><br>---<br><span class="hljs-number">9.540258898738779</span><br><span class="hljs-number">7.343136835899989</span><br><span class="hljs-number">5.0</span><br></code></pre></td></tr></table></figure><p><code>random.choice()</code>，随机获取容器类型中的值。这个函数的应用范围就非常广了，我们在做数据分析的时候经常会用得到。因为大部分时候，我们说面对的应该都是容器类数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(random.choice(<span class="hljs-string">&#x27;123&#x27;</span>))<br><span class="hljs-built_in">print</span>(random.choice([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br><br>---<br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><code>random.shuffle()</code>随机打乱当前列表中的值，没有返回值，仅仅是打乱原数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>res = random.shuffle(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;arr:<span class="hljs-subst">&#123;arr&#125;</span> \nres:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>arr:[<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <br>res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>当然，我说介绍的函数都只是一部分，目的是打个样，让大家知道这些函数是个怎么回事。大部分时候会用到的函数抽出来讲解一下，更多的内容，还需要参考官方文档：<ahref="https://docs.python.org/zh-cn/3.10/library/random.html#module-random">https://docs.python.org/zh-cn/3.10/library/random.html#module-random</a></p><h2 id="系统操作相关模块">系统操作相关模块</h2><h3 id="os模块">OS模块</h3><p>OS模块，就是操作系统接口模块。这个模块提供了一些方便使用操作系统相关功能的函数。我们之前重点学习的<code>open()</code>，就是这个模块中的相关函数。现在让我们来看看除了<code>open</code>之外，还有哪些函数可供我们日常使用：</p><p><code>os.getcwd()</code>获取当前的工作目录,注意获取的不是当前脚本的目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>res = os.getcwd()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>/Users/du/git/AI_Cheats/Python<br></code></pre></td></tr></table></figure><p>不过需要注意一点是，这个函数并不是获取现在这个文件的所在目录，而是当前此文件的执行目录。这个怎么理解呢？我给大家举例说明一下：</p><p>我们首先需要知道一个，就是我们在Linux中执行<code>cd</code>和<code>pwd</code>的时候，一个是进入某个目录，一个是打印当前目录路径：</p><img src="/System-built-in-modules/image-20230812144245562.png" class="" title="命令符"><p>那么这里的<code>pwd</code>所执行的结果，是随着进入目录不同而变化的，比如我们进入我们当前的文件目录：</p><img src="/System-built-in-modules/image-20230812144439461.png" class="" title="切换目录"><p>也就是说，我在哪个目录下执行<code>pwd</code>，那么返回结果就是当前执行的这个目录，而不是<code>pwd</code>这个执行文件本身所在的目录。</p><p><code>gwtcwd()</code>文件，和<code>pwd</code>实际上就是相同的特点，如果在当前目录执行这个脚本文件，那么getcwd获取的就是当前的文件目录。如果这个时候我切换到了其他目录，但是写了<code>getcwd()</code>方法的文件没有挪动位置，那么此时我获取的返回值就是我切换的其他目录，而非文件所在的位置。下面我们可以测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;/Users/du/git/&#x27;</span>)<br>res = os.getcwd()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>/Users/du/git<br></code></pre></td></tr></table></figure><p>可以看到，我们执行了和上main相同的代码，但是这个时候<code>res</code>接收返回值发生了变化，其原因就是我使用了<code>os.chdir</code>来改变了一下当前的工作目录。不知道大家现在是否能理解<code>gwtcwd()</code>的工作原理？还是无法理解的，可以多自己写一下代码，做做尝试。连我这种笨人之前学习的时候都能很快理解，小伙伴们肯定更没有问题。</p><p>刚才我们的实验中，引出了另外一个方法：</p><p><code>os.chdir()</code>,如上所见，其功能就是修改<strong>当前工作目录</strong>。</p><p>下面我们直接介绍其他的函数：</p><p><code>os.listdir()</code>获取当前或指定目录中的所有项（文件，文件夹，隐藏文件），组成的列表</p><p>这个方法和Linux中的<code>list</code>命令就十分像了，让我们先将<strong>当前工作目录</strong>切回我们当前文件本来所在的目录，然后在来执行一下这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">os.chdir(<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/&#x27;</span>)<br>res = os.listdir()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;12.ipynb&#x27;</span>, <span class="hljs-string">&#x27;10.ipynb&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;15_json.html&#x27;</span>, <span class="hljs-string">&#x27;14.ipynb&#x27;</span>, <span class="hljs-string">&#x27;8.ipynb&#x27;</span>, <span class="hljs-string">&#x27;14.py&#x27;</span>, <span class="hljs-string">&#x27;11.ipynb&#x27;</span>, <span class="hljs-string">&#x27;globals.ipynb&#x27;</span>, <span class="hljs-string">&#x27;13.ipynb&#x27;</span>, <span class="hljs-string">&#x27;Kalman.ipynb&#x27;</span>, <span class="hljs-string">&#x27;9.ipynb&#x27;</span>, <span class="hljs-string">&#x27;15.ipynb&#x27;</span>, <span class="hljs-string">&#x27;7.ipynb&#x27;</span>, <span class="hljs-string">&#x27;5.ipynb&#x27;</span>, <span class="hljs-string">&#x27;1.ipynb&#x27;</span>, <span class="hljs-string">&#x27;3.ipynb&#x27;</span>, <span class="hljs-string">&#x27;4.ipynb&#x27;</span>, <span class="hljs-string">&#x27;6.ipynb&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;2.ipynb&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，目录内所有的文件，包括隐藏文件<code>.DS_Store</code>和文件夹<code>data</code>都被放进了一个列表当中。</p><p>这是在不指定目录的情况下，默认为当前工作目录，当然，我们还可以指定目录来获取那个目录下的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.listdir(<span class="hljs-string">&#x27;/Users/du/AI/&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;AIGC&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;GPT&#x27;</span>, <span class="hljs-string">&#x27;AI_core_competence&#x27;</span>, <span class="hljs-string">&#x27;stable-diffusion-webui&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们就获取到了我们希望查找的目录下的所有内容。我们继续：</p><p><code>os.mkdir(文件夹路径, 权限)</code>这个函数用来创建文件夹，其命令 和Linux中是一模一样，功能也是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.listdir(<span class="hljs-string">&#x27;./data/&#x27;</span>))<br>os.mkdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>, <span class="hljs-number">0o777</span>)<br><span class="hljs-built_in">print</span>(os.listdir(<span class="hljs-string">&#x27;./data/&#x27;</span>))<br><br>---<br>[<span class="hljs-string">&#x27;black.txt&#x27;</span>, <span class="hljs-string">&#x27;user.txt&#x27;</span>, <span class="hljs-string">&#x27;13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;data2.txt&#x27;</span>, <span class="hljs-string">&#x27;data3.json&#x27;</span>, <span class="hljs-string">&#x27;13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;15_data.json&#x27;</span>, <span class="hljs-string">&#x27;data.txt&#x27;</span>]<br>[<span class="hljs-string">&#x27;black.txt&#x27;</span>, <span class="hljs-string">&#x27;user.txt&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;data2.txt&#x27;</span>, <span class="hljs-string">&#x27;data3.json&#x27;</span>, <span class="hljs-string">&#x27;13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;15_data.json&#x27;</span>, <span class="hljs-string">&#x27;data.txt&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到我们两次打印结果的对比，确实多了一个<code>test</code>的目录。前一个参数很好理解，重点是后一个参数，什么是权限？</p><p>关于系统中的文件权限，我下面所讲的仅限<code>Linux</code>系统，确切的说是<code>unix</code>，因为包括Mac一样通用：</p><p>来，我们先进入目录打印出来看看：</p><img src="/System-built-in-modules/image-20230812150938583.png" class="" title="命令符查看目录"><p>我们主要来看一下<code>data</code>目录的<code>drwxr-xr-x</code>，分别来介绍一下：</p><ul><li>第一个字母<code>d</code>代表的是一个目录，如果是<code>-</code>呢，这表示这是一个文件</li><li>前三位的<code>rwx</code>代表当前目录（文件）对所有人(u)的权限</li><li>中间位置的<code>r-x</code>代表的所属组(g)的权限</li><li>末尾的三位<code>r-x</code>代表的是其他人(o)的权限</li><li>三个位置介绍完了我们来看字母所代表的意义：</li></ul><p><code>r,w,x</code>代表不同的操作权限，其中:</p><ul><li><code>r</code>就是可读，权限针对文件，表示可以查看文件内容，针对目录，表示可以<code>ls</code>查看目录中存在的文件名称。</li><li><code>w</code>就是可写，针对文件，表示可以更改文件的内容，针对目录，表示是否可以删除目录中的子文件或者子目录。</li><li><code>x</code>是访问权限，针对文件，表示是否可以开启文件当中记录的程序，针对目录，这表示是否可以进入该目录。</li></ul><p>那为什么是<code>777</code>呢？那是因为<code>r</code>代表是<code>4</code>,<code>w</code>代表是<code>2</code>,<code>x</code>代表的是<code>1</code>,那么<code>7</code>就可以理解了，就是所有数值相加的结果。那么为什么是三个<code>7</code>呢？因为这是在设置三个不同目标的权限，三个位数分别是<strong>所有人，所有组，其他</strong>。</p><p>不过，大家还要注意的一点是，无法使用Python去创建一个比自己这个进程权限还要高的文件。</p><p><code>mkdir()</code>方法是只能创建一个文件夹，无法递归创建文件夹，而当我们需要进行递归创建该怎么办呢？也就是说，我们不仅仅是想要创建<code>test</code>文件夹，而是想创建<code>/test/a/b/c/d/e</code>该怎么办？</p><p><code>os.makedirs()</code>可是进行递归创建文件夹。我们先看一下当前目录结构，直接Finder来看吧：</p><img src="/System-built-in-modules/image-20230812153001971.png" class="" title="原目录结构"><p>好，让我们执行一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.makedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再来看看目录结构：</p><img src="/System-built-in-modules/image-20230812173639238.png" class="" title="执行后目录结构"><p>这样就能最直观的看到执行这个函数之后的结果了。</p><p>在创建完一些无用目录之后，我当然想着是怎么删除它们。</p><p><code>os.rmdir*()</code>删除<strong>空文件夹</strong>，比如我们尝试着删除一下刚才我们创建的目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><br>---<br>OSError: [Errno <span class="hljs-number">66</span>] Directory <span class="hljs-keyword">not</span> empty: <span class="hljs-string">&#x27;./data/test&#x27;</span><br></code></pre></td></tr></table></figure><p>报错了，告知我们无法删除一个空目录，原因就是我们在<code>test</code>里创建了好几层文件夹，那现在<code>test</code>肯定不是空目录，那让我们从内层开始试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rmdir(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>没有报错，应该是成功了，我们来看看：</p><img src="/System-built-in-modules/image-20230812173724292.png" class="" title="删除后的目录"><p>确实，<code>f</code>文件夹被删除了。不过太烦了，一个个删除到什么时候去了，还不如我到<code>Finder</code>中直接手动删除呢。</p><p><code>os.removedirs()</code>就是一个递归删除空文件夹的函数，我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">os.removedirs(<span class="hljs-string">&#x27;./data/test/&#x27;</span>)<br><br>---<br>OSError: [Errno <span class="hljs-number">66</span>] Directory <span class="hljs-keyword">not</span> empty: <span class="hljs-string">&#x27;./data/test/&#x27;</span><br></code></pre></td></tr></table></figure><p>居然又报错，告诉我们非空目录，这...</p><p>原来，<code>removedirs</code>方法使用必须是从后往前递归的，也就是说，我们需要将需要删除的所有目录的层级关系给到这个方法，在执行过程中，向上递归，路径中的所有空目录都会被删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.removedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>再执行一次，这回没问题了。从<code>test</code>开始，下层的所有空目录都被删除了。</p><p>然后就是删除文件了</p><p><code>os.remove()</code>就是删除文件，为了测试这个方法，我在<code>data</code>目录下创建了一个空文件<code>test.txt</code></p><img src="/System-built-in-modules/image-20230812155752043.png" class="" title="创建test.txt"><p>不过在删除之前，我们还是要先用一下这个文件，来看看如何改名：</p><p><code>os.rename()</code>: 用于修改文件或者文件夹的名字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.rename(<span class="hljs-string">&#x27;./data/test.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/System-built-in-modules/image-20230812173931755.png" class="" title="文件改名"><p>好了，文件用完了，现在让我们删除吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.remove(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>顺利删掉了刚才创建的文件。</p><p><code>os.system()</code> 执行操作系统中的命令</p><p>比如，我们刚才在命令行里执行过<code>ls -al</code>的命令用于查看当前目录下的所有文件及目录，包括其相关权限，那么我们在Python里可以执行吗？来试试看就知道了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;ls -al&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行效果如图：</p><img src="/System-built-in-modules/image-20230812174342944.png" class="" title="system()"><p>这个方法实际上不止是让你在Python中执行系统命令用的，可以用于执行其他<code>.py</code>，也就是Python文件。比如我们创建了一个<code>hello.py</code>文件，里面写了如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello Python。&#x27;</span>)<br></code></pre></td></tr></table></figure><p>那么，我在其他Python文件中使用<code>os.system</code>方法就可以执行这段代码，当然，前提是你得写对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;/file_path/hello.py&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样，你在其他文件内写的一个方法就被当前文件执行了。</p><h3 id="os.path-路径模块"><code>os.path</code> 路径模块</h3><p>在Python创建的整个工程或者某一个函数里，路径操作也是经常要做的事情。比如：</p><p><code>os.path.abspath()</code>就是将相对路径转化为绝对路径吗，多数时候，我们是需要获取文件的绝对路径的，更多的是为了获取当前工作目录的绝对路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&#x27;./15.ipynb&#x27;</span>))<br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&#x27;./&#x27;</span>))<br><br>---<br>/Users/du/git/AI_Cheats/Python/<span class="hljs-number">15.</span>ipynb<br>/Users/du/git/AI_Cheats/Python<br></code></pre></td></tr></table></figure><p><code>os.path.basename()</code>，这个方法可以获取到路径后截取返回主体部分，来看代码，一看就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.abspath(<span class="hljs-string">&#x27;./15.ipynb&#x27;</span>)<br><span class="hljs-built_in">print</span>(os.path.basename(res))<br><br>---<br><span class="hljs-number">15.</span>ipynb<br></code></pre></td></tr></table></figure><p>截取了路径中最末尾的文件名和扩展名，如果路径上最末尾的是一个文件夹不包含文件，那获取的就是那最后一个文件夹名称。</p><p><code>os.path.dirname()</code>， 返回路径中主体部分之前的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.dirname(<span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/data/data.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>不过使用这个方法的时候需要注意，如果你填入的是一个相对路径，它并不能打印出绝对路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.dirname(<span class="hljs-string">&#x27;./1.ipynb&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>.<br></code></pre></td></tr></table></figure><p><code>join()</code> 链接多个路径，组成一个新的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.join(<span class="hljs-string">&#x27;./data/test/&#x27;</span>, <span class="hljs-string">&#x27;2.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>./data/test/<span class="hljs-number">2.</span>txt<br></code></pre></td></tr></table></figure><p>实际上，它更像是一个字符串拼接，因为这个方法并不会去验证路径的有效性。</p><p><code>split()</code>这个方法和<code>join()</code>正好相反，用于拆分路径，把路径拆分为路径和主体部分。然后返回一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.split(<span class="hljs-string">&#x27;./data/test/2.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;./data/test&#x27;</span>, <span class="hljs-string">&#x27;2.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>splitext()</code>拆分路径，可以拆分文件后缀名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.splitext(<span class="hljs-string">&#x27;./data/test/2.jpg&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;./data/test/2&#x27;</span>, <span class="hljs-string">&#x27;.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>os.path.getsize()</code>获取文件的大小 , 单位是字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.getsize(<span class="hljs-string">&#x27;./data/15_data.json&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">91</span><br></code></pre></td></tr></table></figure><p><code>os.path.isdir()</code>会检测是否是一个文件夹，检测其是否存在，返回<code>True</code>或者<code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.isdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><code>os.path.isfile()</code>会检测文件是否存在，一样是返回<code>True</code>或者<code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.isfile(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><code>exists()</code>是一个通用函数，检测路径是否存在。和以上两个不同的是，也可以检测文件，也可以检测路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = os.path.exists(<span class="hljs-string">&#x27;./data/test_update.txt&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br>res = os.path.exists(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>当我们有一个相对路径和一个绝对路径，而我们想看看两个路径是否指向一个目标位置的时候，是不是要先获取相对路径的绝对路径之后，再去对比呢？</p><p>其实没有那么麻烦,只需要<code>os.path.samefile(a, b)</code>就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;./data/data.txt&#x27;</span><br>b = <span class="hljs-string">&#x27;/Users/du/git/AI_Cheats/Python/data/data.txt&#x27;</span><br>res = os.path.samefile(a, b)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>使用这个方法，我们需要填入的两个值是真实存在的路径。</p><p>当然，官方的文档内还有更多的函数，我这里仅仅是列出了一些常用的。大家可以去官方文档内去看看。</p><h3 id="shutil高级操作模块"><code>shutil</code>高级操作模块</h3><p><code>shutil</code>模块对文件和文件集合提供了许多的高级操作。其中就有支持文件复制和删除的一些功能。</p><p>要说，其实<code>shutil</code>这个模块的很多方法和<code>Unix</code>里的<code>shell util</code>都一样，所以会用命令行的小伙伴，对这个模块应该是极其容易上手：</p><p><code>shutil.copy()</code>，一看就明白是干什么的是吧？就是将文件拷贝到指定目录的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br><br>---<br>FileNotFoundError: [Errno <span class="hljs-number">2</span>] No such file <span class="hljs-keyword">or</span> directory: <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>报错了，咋回事？看提示，应该目录或文件不存在。嗯，这个方法要操作之前，目标路径中的目录是必须存在的，它无法自动创建目录。</p><p>让我们手动创建目录之后再试试，还记得我们之前创建目录的命令怎么做吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">os.mkdir(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br>shutil.copy(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br><br>---<br><span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>有返回值了，那我们操作应该完成了。走，去目录里看看：</p><img src="/System-built-in-modules/image-20230812193844046.png" class="" title="copy"><p>确实，目录和文件都存在了，这里注意我标注的两个文件，<code>copy</code>这个命令指示拷贝了一个副本到目标目录中，原文件还是存在于原来的位置。但是注意到时间了吗？修改时间被更改了，改为了我们执行当前操作的时间。</p><p><code>copy2</code>是另外一个拷贝方法，它所有功能和<code>copy</code>都一样，但是如果真是一模一样的方法，也就没必要多创建一个了对吧？这个方法最大的不同，就是保留了原文件的信息，包括操作时间和权限等。</p><p>再让我们操作一下试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copy2(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/System-built-in-modules/image-20230812194413804.png" class="" title="copy2"><p>除了这两个拷贝方法外，还有一个拷贝方法<code>copyfile()</code>，专门用于拷贝文件中的内容，写入到新的文件中去。让我们在<code>./data/test/</code>中新建一个<code>data2.txt</code>文件来接收写入内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.copyfile(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/test/data2.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们来打开<code>data2.txt</code>之后查看一下内容，确实写入了：</p><img src="/System-built-in-modules/image-20230812195204028.png" class="" title="copyfile"><p><code>shutil.copytree('./a', './b')</code>方法看名字应该就猜到是干什么的，是将整个目录结构全部拷贝到指定目录中。使用的时候要多注意，指定的目标目录必须不存在同名目录。</p><p><code>shutil.rmtree()</code>，我们之前有用到带<code>rm</code>的方法，那么看名字也就知道了，这个方法是删除整个文件夹，包括文件夹下的所有目录和文件，和之前我们使用的<code>removedirs</code>不同，这个方法并不是从下往上递归，而是直接全部删除。让我再创建一次多级目录才测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.makedirs(<span class="hljs-string">&#x27;./data/test/a/b/c/d/e/f/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>目录创建完成后，来让我们将整个<code>test</code>文件夹全部删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.rmtree(<span class="hljs-string">&#x27;./data/test&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行成功，<code>test</code>整个目录及其内部文件全部删除了。</p><p>我们最后再来看一个用的非常多的方法<code>shutil.move()</code>，我们都知道，<code>windows</code>中有剪切和复制两种菜单命令，然后到新的目标目录后进行粘贴，如果是剪切命令，这原目录中文件会在粘贴完成后删除，而如果是复制，不会执行删除。<code>Linux</code>的逻辑稍微有些不同，是先进行拷贝，然后在目标目录之后决定是粘贴还是移动，如果是粘贴的话就保留原目录的文件，如果是移动，则会在粘贴完成之后在原位置删除文件。</p><p>虽然逻辑上有些许不同，但是不管是<code>Windows</code>还是<code>Linux</code>(包括Mac)，如果是移动某个文件的时候都遵循的是先复制一份到目标目录之后，再把原文件删除的先后顺序。</p><p>其实<code>move()</code>命令也是一样的逻辑，基于这个逻辑，<code>move</code>实际上也可以用于修改文件夹或文件的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.move(<span class="hljs-string">&#x27;./data/data.txt&#x27;</span>, <span class="hljs-string">&#x27;./data/data_copy.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后我们去看一下：</p><img src="/System-built-in-modules/image-20230812201611443.png" class="" title="move"><p>可以看到，执行成功了。我们多注意一下就会发现，<code>move</code>命令也有和<code>copy2</code>相同的特性，将原文件的信息保留了下来。</p><h2 id="zipfile压缩模块"><code>zipfile</code>压缩模块</h2><p>ZIP文件格式基本是互联网上最通用的一种压缩格式，常见的存档和压缩标准。该模块提供了用于创建，读取，写入，附加和列出ZIP文件的工具。</p><p>在日常使用中，我们也会经常用到这个模块的相关功能。和之前介绍方法不同，我们这一部分按需求来介绍：</p><h3 id="压缩文件">压缩文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile, os<br><br><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> myzip:<br>    myzip.write(<span class="hljs-string">&#x27;./data/data_copy.txt&#x27;</span>)<br>    myzip.write(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>)<br>    myzip.write(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有没有发现，其方法和我们在对文件进行读写操作的时候很像，逻辑就是先创建一个压缩包文件，然后往里面扔入对应的文件。</p><img src="/System-built-in-modules/image-20230812202451930.png" class="" title="压缩文件"><h3 id="解压缩文件">解压缩文件</h3><p>压缩之后，我们这次解压缩来看看压缩包内的文件是不是我们刚才扔进去的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> myzip:<br>    myzip.extractall(<span class="hljs-string">&#x27;./data2&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行之后结果：</p><img src="/System-built-in-modules/image-20230812202902088.png" class="" title="解压缩"><p>文件的确都是原来的文件。</p><h3 id="批量压缩">批量压缩</h3><p>不过之前压缩文件的时候也太麻烦了，文件一个一个的列出来扔进压缩包，那有没有办法将指定文件夹中的文件全部打包呢？</p><p>当然没问题，既然我们嫌弃手动一个个添加文件名太麻烦，那我们直接用机器添加不就好了，怎么做呢？</p><p>首先第一步当然是获取文件夹下所有的文件，应该还记得<code>listdir()</code>这个方法吧？才学的。</p><p>获取列表之后，我们直接用代码一个个的扔到压缩包内就可以了，用<code>for</code>循环吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;temp.zip&#x27;</span>,<span class="hljs-string">&#x27;w&#x27;</span>, zipfile.ZIP_DEFLATED) <span class="hljs-keyword">as</span> myzip:<br>    <span class="hljs-comment"># 获取当前目录中的所有的项</span><br>    arr = os.listdir(<span class="hljs-string">&#x27;./&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(arr)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr:<br>        myzip.write(i)<br>        <br>---<br>[<span class="hljs-string">&#x27;12.ipynb&#x27;</span>, <span class="hljs-string">&#x27;10.ipynb&#x27;</span>, <span class="hljs-string">&#x27;.DS_Store&#x27;</span>, <span class="hljs-string">&#x27;15_json.html&#x27;</span>, <span class="hljs-string">&#x27;14.ipynb&#x27;</span>, <span class="hljs-string">&#x27;8.ipynb&#x27;</span>, <span class="hljs-string">&#x27;temp.zip&#x27;</span>, <span class="hljs-string">&#x27;14.py&#x27;</span>, <span class="hljs-string">&#x27;11.ipynb&#x27;</span>, <span class="hljs-string">&#x27;globals.ipynb&#x27;</span>, <span class="hljs-string">&#x27;13.ipynb&#x27;</span>, <span class="hljs-string">&#x27;Kalman.ipynb&#x27;</span>, <span class="hljs-string">&#x27;9.ipynb&#x27;</span>, <span class="hljs-string">&#x27;15.ipynb&#x27;</span>, <span class="hljs-string">&#x27;7.ipynb&#x27;</span>, <span class="hljs-string">&#x27;5.ipynb&#x27;</span>, <span class="hljs-string">&#x27;1.ipynb&#x27;</span>, <span class="hljs-string">&#x27;3.ipynb&#x27;</span>, <span class="hljs-string">&#x27;4.ipynb&#x27;</span>, <span class="hljs-string">&#x27;6.ipynb&#x27;</span>, <span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-string">&#x27;2.ipynb&#x27;</span>]<br></code></pre></td></tr></table></figure><p>通过将打印出来的<code>arr</code>我们可以看到所有被成功扔进压缩包的内容。</p><h3 id="其他压缩方法">其他压缩方法</h3><p><code>zipfile</code>是Python中内置的专门用于压缩<code>zip</code>格式压缩包的方法，但是其实，我们并不限于压缩成<code>zip</code>格式。那是不是还有<code>rarfile</code>,<code>7zfile</code>等模块呢？那真是想多了，我们刚才学过的<code>shutil</code>方法，就可以进行压缩操作。不过不一样的是，虽然效果是一样的，但是我们这个方法是<strong>创建归档</strong>:</p><p><code>shutil.make_archive()</code>，用于创建一个压缩文档。这个方法中有三个比较重要的参数，一个是创建的归档文件名称，第二个是指定的归档格式，第三个则是要归档的文件或文件夹路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shutil.make_archive(<span class="hljs-string">&#x27;temp&#x27;</span>, <span class="hljs-string">&#x27;tar&#x27;</span>, <span class="hljs-string">&#x27;./data&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="/System-built-in-modules/image-20230812204243773.png" class="" title="archive_file"><p>成功完成<code>tar</code>格式的归档。</p><p>除了以上的这些介绍的内置模块之外，我们平时应用中还会用到许多其他的模块，比如日历模块<code>calendar</code>，时间模块<code>time</code>等等。我上方讲解模块使用的同时，更多的是想向大家传递一个思想就是内置模块基本都很易上手，并且就算一时之间不太明白，可以多看看官方文档。从官方文档上学习是一个很好的习惯。我们可以从官方<ahref="https://docs.python.org/zh-cn/3/py-modindex.html">Python模块索引</a>中去找到自己需要的模块。</p><p>好了，那这节课就先到这里了，下一节课中，我们利用日历和时间模块来做一个练习：万年历。大家要提前做预习，去官方文档好好学习一下其相关模块，包括<code>calendar</code>、<code>datetime</code>、<code>time</code>等.</p><p>那小伙伴们，让我们下节课练习再见吧。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/System-built-in-modules/cover.png&quot; class=&quot;&quot; title=&quot;封面&quot;&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>14. 练习：登录注册系统</title>
    <link href="https://hivan.me/Exercise-register-system/"/>
    <id>https://hivan.me/Exercise-register-system/</id>
    <published>2023-08-10T03:54:59.000Z</published>
    <updated>2023-08-10T11:06:03.178Z</updated>
    
    <content type="html"><![CDATA[<img src="/Exercise-register-system/cover.png" class="" title="封面"><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>上一节课，我们详细的介绍了文件读写的流程和原理，并用Python进行实际操作了一下。</p><p>那么这节课呢，我们利用之前所学的内容，尝试做一个小练习：建立一个登录注册系统。上节课我们在结尾的时候讲练习内容贴了出来，还记得要求吗？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">实现功能：<br><span class="hljs-bullet">1.</span> 用户输入用户名和密码以及确认密码<br><span class="hljs-bullet">2.</span> 用户名不能重复<br><span class="hljs-bullet">3.</span> 两次密码要一致<br><span class="hljs-bullet">4.</span> 用户用已经注册的账户登录<br><span class="hljs-bullet">5.</span> 密码如果错误3次，锁定，无法再登录。<br></code></pre></td></tr></table></figure><p>那么这节课呢，因为都是一些讲过的知识点，所以在整个实现过程中我就不详细讲解了，我们重点在于介绍思想和流程。那让我们开始吧。</p><h2 id="注册功能">注册功能</h2><p>我们先把大的结构写出来，一个注册功能，那首先需要接收两个参数：用户名、密码。</p><p>并且，为了防止用户注册时候输错密码导致无法登录，还需要让用户确认一遍密码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br><br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 用户输入密码</span><br>    password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br><br>    <span class="hljs-comment"># 请确认您的密码</span><br>    re_password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请再输入一次您的密码: &#x27;</span>)<br><br>    <span class="hljs-built_in">print</span>(username, password, re_password)<br><br><br>register()<br><br>---<br>du <span class="hljs-number">111111</span> <span class="hljs-number">111111</span><br></code></pre></td></tr></table></figure><p>下一步我们来细化这个框架，我们把用户名先放在一边，来挑一挑密码的刺：</p><p>首先，我们需要让密码保持安全性，那么我们对位数，组合就要有要求。这里我们简单点，必须输入6位以上吧。</p><p>然后，在确认密码的时候，肯定两次密码要一致才行。</p><p>OK，让我们补全这几个逻辑关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br><br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>    <br>    <span class="hljs-comment"># 用户输入密码</span><br>    password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br>    <br>    <span class="hljs-comment"># 检测密码长度不能低于6位</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>        <span class="hljs-comment"># 请确认您的密码</span><br>        re_password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请再输入一次您的密码: &#x27;</span>)<br>        <span class="hljs-comment"># 检测密码和确认密码是否一致</span><br>        <span class="hljs-keyword">if</span> re_password == password:<br>            <span class="hljs-comment"># 用户名和密码都正确，可以写入文件</span><br>            <span class="hljs-keyword">pass</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;两次输入的密码不同，请重新输入。&#x27;</span>, username, password, re_password)<br><br>    <span class="hljs-comment"># 密码长度不够</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;密码格式不正确：&#x27;</span>, username, password)<br><br>register()<br><br>---<br>两次输入的密码不同，请重新输入。 du <span class="hljs-number">123456</span> <span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p>可以看得出来，我确认密码的时候输入了其他密码，判断逻辑没有问题。</p><p>继续来细化，现在的问题是，当我们输入第一次密码的时候判断有问题，或者两次密码输入不一致的时候，我们没有办法跳到一开始让用户重新输入，那么下面我们就来解决这个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br><br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>    <br>    <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 用户输入密码</span><br>        password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检测密码长度不能低于6位</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>            <span class="hljs-comment"># 请确认您的密码</span><br>            re_password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请再输入一次您的密码: &#x27;</span>)<br>            <span class="hljs-comment"># 检测密码和确认密码是否一致</span><br>            <span class="hljs-keyword">if</span> re_password == password:<br>                <span class="hljs-comment"># 用户名和密码都正确，可以写入文件</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;恭喜你，注册成功&#x27;</span>, username, password, re_password)<br>                <span class="hljs-comment"># 结束循环</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;两次输入的密码不同，请重新输入。&#x27;</span>, username, password, re_password)<br><br>        <span class="hljs-comment"># 密码长度不够</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;密码格式不正确：&#x27;</span>, username, password)<br><br>register()<br><br>---<br>密码格式不正确： du <span class="hljs-number">12345</span><br>两次输入的密码不同，请重新输入。 du <span class="hljs-number">123456</span> <span class="hljs-number">1234567</span><br>恭喜你，注册成功 du <span class="hljs-number">123456</span> <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>外面套一层<code>while</code>循环，这样就解决了。</p><p>只有当密码正确输入的时候，循环才会结束，否则就会跳到循环的最开始，重新进行输入。</p><p>接着，我们就来看看当输入正确之后，我们如何写入文件呢？这个是我们上一节课刚讲解的课程，现在让我们来实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>...<br>            <span class="hljs-keyword">if</span> re_password == password:<br>                <span class="hljs-comment"># 用户名和密码都正确，可以写入文件</span><br>                <span class="hljs-comment"># 打开文件，写入数据</span><br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>                    fp.write(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;username&#125;</span>:<span class="hljs-subst">&#123;password&#125;</span>\n&#x27;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;注册成功，用户名:<span class="hljs-subst">&#123;username&#125;</span>&#x27;</span>)<br>                <span class="hljs-comment"># 结束循环</span><br>                <span class="hljs-keyword">break</span><br>...<br>register()<br><br>---<br>注册成功，用户名:du<br></code></pre></td></tr></table></figure><p>这样，我们就将用户名和密码以<code>username:password</code>的格式以一行的形式存储到了一个<code>user.txt</code>文件内。并且，因为我们使用的<code>a+</code>的模式，所以每次打开指针都会是放在文件的末尾进行添加。</p><p>来，让我们看看是否成功了：</p><img src="/Exercise-register-system/image-20230810145145278.png" class="" title="user.txt"><p>可以看到，没问题。这样，我们在之后读取的时候就可以直接读取单行，并且以<code>key:value</code>的形式拿到我们说要的用户名和密码。用于验证<code>key</code>是否存在，<code>value</code>是否正确。</p><p>说到验证<code>key</code>是否存在，似乎我们还没写这一段验证代码，既然文件里已经有数据了，让我们把这段代码补全吧,我们在<code>register()</code>这个自定义函数外面写一段读取文件的代码，写在外面是因为，我们读取文件这个动作，和整个注册动作不能说毫无关系，只能说是没有关联。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.readlines()<br>    <span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;admin:123456\n&#x27;</span>, <span class="hljs-string">&#x27;du:654321\n&#x27;</span>]<br></code></pre></td></tr></table></figure><p>还记得吗？<code>readlines()</code>这个函数的应用，不记得的，看我教程的上一节内容复习下。</p><p>看似我们确实成功的读取到了全部内容，可是我们细想一下，这样想有没有问题？还记得我们上一节课上对<code>r</code>这个模式的说明吗？<code>r</code>是读取已有文件，但是如果文件不存在，那就会报错。</p><p>可是我们在整个程序运行过程中，不能因为这个原因就不让用户继续往下走了对吧？那么我们怎么去修改呢？来，我们一起尝试下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    res = fp.readlines()<br>    <span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-string">&#x27;admin:123456\n&#x27;</span>, <span class="hljs-string">&#x27;du:654321\n&#x27;</span>]    <br></code></pre></td></tr></table></figure><p>我们利用<code>a+</code>的特性，如果文件不存在则会创建，如果有，这将指针放在文件末尾。这样的话，这一段内容就没有问题了？为什么不用<code>w+</code>?还不是因为<code>w+</code>太霸道，虽然新人胜旧人，但也不能就直接把旧人干掉吧。</p><p>但是<code>a+</code>是将指针放在文件末尾的，我们直接使用的话，什么内容也读不到，所以我们使用可<code>seek(0,0)</code>来将指针放在了文件头的位置。</p><p>好了，继续。我们只将文件读取出来没用，需要将其中的数据放在一个变量里供我们检测，所以下一步，我们就需要创建一个变量，并且接收文件中的所有数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先实现注册功能</span><br><br><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>userlist = []<br>pwdlist = []<br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>    res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>        r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>        mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>) <span class="hljs-comment"># 分隔用户名和密码</span><br>        userlist.append(mydict[<span class="hljs-number">0</span>])<br>        pwdlist.append(mydict[<span class="hljs-number">1</span>])<br>    <span class="hljs-built_in">print</span>(userlist, pwdlist)<br>    <br>---<br>[<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>] [<span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;654321&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这样，我们拿到用户名和密码，并且分别放入了两个<code>list</code>变量中。</p><p>接下来，我们对于注册那一步就需要进行判断了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    ...<br>    <span class="hljs-comment"># 用户输入用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br><br>    <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>    <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 用户输入密码</span><br>            password = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码: &#x27;</span>)<br>        ...<br><br><span class="hljs-comment"># register()</span><br></code></pre></td></tr></table></figure><p>在代码中，我们判断用户名是否存在于列表中，如果存在，打印已经存在，如果不存在，则继续往下执行。将之前输入密码的<code>while</code>循环放入了<code>else</code>判断逻辑中。</p><p>看似问题解决了，不过新的问题又来了。虽然我们现在判断了用户是否存在，并且用户不存在的话可以继续往下执行，可是如果存在呢？我们需要的是让用户重新输入用户名，但是现在是打印完之后就结束了。所以，我们还得继续修改代码，这回简单了，和<code>password</code>的处理用一样的方法就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 执行循环， 用户名操作</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 用户输入用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br><br>        <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>               ...<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>                    ...<br>                    <span class="hljs-keyword">if</span> re_password == password:<br>                        ...<br>                        <span class="hljs-comment"># 结束循环</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                      ...<br><span class="hljs-comment"># register()</span><br></code></pre></td></tr></table></figure><p>我们将<code>register()</code>内的所有判断代码放入了一个循环中，那么在<code>if</code>之后，没有向下执行<code>else</code>内的逻辑的时候，就会跳转到最开始的<code>while</code>循环重新执行。</p><p>不过这样似乎还是不行，那就是几遍<code>else</code>逻辑全部执行完毕，内部的<code>break</code>也是跳出里面那层<code>while</code>循环，外层循环只能无限的执行下去了。</p><p>我们目前所要做的，就是在所有的代码顺利执行到<strong>密码正确确认</strong>的时候，整个函数执行就全部终止了。那有什么办法吗？</p><p>我们看到了<code>while True</code>，然后开启了无限循环。那是不是说，如果<code>True</code>那里不为真，就无法进入循环了？</p><p>嗯，既然这样，我们设定一个变量，在需要终止函数的时候，设定变量为<code>Flase</code>就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 定义一个变量，用于控制外循环</span><br>    site = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 执行循环， 用户名操作</span><br>    <span class="hljs-keyword">while</span> site:<br>        ...<br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 利用循环，都正确的时候结束循环。</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(password) &gt;= <span class="hljs-number">6</span>:<br>                    ...<br>                    <span class="hljs-keyword">if</span> re_password == password:<br>                        ...<br>                        <span class="hljs-comment"># 结束循环</span><br>                        <span class="hljs-comment"># 结束外循环</span><br>                        site = <span class="hljs-literal">False</span><br>                        <span class="hljs-comment"># 结束内循环</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                        ...<br><br><span class="hljs-comment"># register()</span><br><br></code></pre></td></tr></table></figure><p>这样，在密码确认成功之后，<code>site</code>设定为<code>false</code>，<code>while</code>循环判断条件为假，无法再次进入循环。执行代码，输出<code>注册成功：用户名:du2</code>，并且跳出了循环不再继续向下执行。说明我们这一步已经没问题了。</p><p>那到这里，我们一个简易的可运行的注册方法就完成了，当然，这段代码中其实还有很多可以完善的空间，比如说，判断用户名是否存在之后，还要判断用户名是否合法，密码是否合法等等。还有就是我们一般接收账户密码的变量应该使用<code>key:value</code>形式的字典，不过大多数时候，我们还要考虑效率问题。分别保存成两份是不错的选择，那么这个时候，我们就需要用到获取当前字典中所有<code>key</code>值的方法了。以上代码在关键部位可以这样改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>userdict = &#123;&#125;<br>userlist = []<br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>    res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>        r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>        mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>        userdict.update(&#123;mydict[<span class="hljs-number">0</span>]:mydict[<span class="hljs-number">1</span>]&#125;)<br>        userlist = userdict.keys()<br>        <br><span class="hljs-comment"># 封装一个函数 完成注册功能</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">register</span>():<br>    <span class="hljs-comment"># 定义一个变量，用于控制外循环</span><br>    site = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 执行循环， 用户名操作</span><br>    <span class="hljs-keyword">while</span> site:<br>        <span class="hljs-comment"># 用户输入用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎注册，请输入用户名：&#x27;</span>)<br><br>        <span class="hljs-comment"># 用户名需要检测是否已经存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前用户已经存在，请更换用户名。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            ...<br>register()<br></code></pre></td></tr></table></figure><p>总之，代码的实现是需要一步一步细细琢磨的，而且实现的方式也不是只有一种。要考虑逻辑，效率等等因素。文章最后会给到我的源码文件，现在大家先一步步的跟着我往下走吧。</p><h2 id="登录功能">登录功能</h2><p>在实现登录功能之前，我们来分析一下这个功能要做的事情：</p><ol type="1"><li>需要使用已经注册的用户信息登录</li><li>密码输入错误3次之后，锁定账户信息（不能再使用这个账户进行登录操作）</li></ol><p>这是两个最基本的功能，既然要核对用户信息和密码，那和注册一样，我们还是需要读取<code>user.txt</code>文件，拿到里面的信息后传给相应的变量，用于检测。那好，我们先把注册那边实现的部分功能拿过来，就无需自己再写一遍了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搞定登录功能</span><br><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>userdict = &#123;&#125;<br>userlist = []<br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>    res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>        r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>        mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>        userdict.update(&#123;mydict[<span class="hljs-number">0</span>]:mydict[<span class="hljs-number">1</span>]&#125;)<br>        userlist = userdict.keys()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;userdict:<span class="hljs-subst">&#123;userdict&#125;</span>,\nuserlist:<span class="hljs-subst">&#123;userlist&#125;</span>&#x27;</span>)<br><br>---<br>userdict:&#123;<span class="hljs-string">&#x27;admin&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>: <span class="hljs-string">&#x27;654321&#x27;</span>, <span class="hljs-string">&#x27;du2&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;zhang&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-string">&#x27;wang&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>&#125;,<br>userlist:dict_keys([<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;du&#x27;</span>, <span class="hljs-string">&#x27;du2&#x27;</span>, <span class="hljs-string">&#x27;zhang&#x27;</span>, <span class="hljs-string">&#x27;wang&#x27;</span>]),<br></code></pre></td></tr></table></figure><p>执行过后可以看到，三个变量已经分别存储了一个字典和两个列表，也就是字典存储了健值对的用户密码，以及将用户和密码再分别存储到两个列表内。</p><p>数据准备好了，接下来，我们开始定义函数吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br><br>    <span class="hljs-comment"># 获取用户登录时输入的用户名</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎登录，请输入您的用户名：&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 检测当前用户名是否存在</span><br>    <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>        <span class="hljs-comment"># 让用户输入密码</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 用户名不存在</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户名错误，亲重新输入&#x27;</span>)<br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br></code></pre></td></tr></table></figure><p>那么大的框架就定义好了。现在让我们逐步开始细化这些代码。</p><p>先不看让用户继续输入密码的逻辑，我们先来看看用户名不存在的逻辑该怎么做。</p><p>当用户名不存在的时候，我们肯定是先要告知提示用户，接下来应该是让用户重新输入一次用户名。那怎么做呢？之前实现注册那边实际上已经有经验了，用<code>while</code>循环呗，接下来，让我们完善一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <span class="hljs-comment"># 自定义变量, 控制登录外循环</span><br>    isLogin = <span class="hljs-literal">True</span> <br>    <br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br><br>        <span class="hljs-comment"># 获取用户登录时输入的用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎登录，请输入您的用户名：&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检测当前用户名是否存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 让用户输入密码</span><br>                pwd = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入您的密码：&#x27;</span>)<br>                <span class="hljs-comment"># 检测用户输入的密码是否正确</span><br>                <span class="hljs-keyword">if</span> pwd == userdict[username]:<br>                    <span class="hljs-built_in">print</span>(pwd)<br>                    isLogin = <span class="hljs-literal">False</span> <span class="hljs-comment"># 结束外循环</span><br>                    <span class="hljs-keyword">break</span> <span class="hljs-comment"># 结束内循环</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您的密码输入有误。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 用户名不存在</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;用户名错误，亲重新输入&#x27;</span>)<br><br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br><br>login()<br></code></pre></td></tr></table></figure><p>在细化的代码中，我们用了和注册函数一样的方法，创建了一个外循环和一个内循环。原因就是我们分别需要判断用户名和密码，都需要返回来重新输入。</p><p>之前注册的循环已经讲的比较详细了，所以这里我们就不细致的讲解了，小伙伴们自己好好琢磨一下逻辑关系。</p><p>那到这里，我们还缺什么呢？看看需求，我们似乎还需要判断用户输入密码错误的次数对吧？</p><p>好的，让我们继续，从定义变量开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    <br>    ...<br>    <span class="hljs-comment"># 定义变量，用来记录用户输入密码错误次数</span><br>    errorNum = <span class="hljs-number">3</span><br><br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br>        ...<br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>                <span class="hljs-keyword">if</span> pwd == userdict[username]:<br>                    ...<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 密码错误，修改变量次数</span><br>                    errorNum -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 判断当前密码错误次数</span><br>                    <span class="hljs-keyword">if</span> errorNum == <span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;给你机会你不中用啊细狗。账户已锁定，请联系管理人员并上供品。&#x27;</span>)<br>                        isLogin = <span class="hljs-literal">False</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;您的密码输入有误, 您还能再尝试<span class="hljs-subst">&#123;errorNum&#125;</span>次。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            ...<br><br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br><br>login()<br></code></pre></td></tr></table></figure><p>我们定义了一个<code>errorNum</code>的变量，因为我们只能尝试最多三次，所以我们给这个变量设定了一个3的值。</p><p>在之后的循环中，没尝试错误一次，我们就让这个变量<code>-1</code>操作，直到变为0为止。</p><p>然后，就是我们需要定义一个黑名单把用户名写入了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    ...<br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>                <span class="hljs-keyword">if</span> pwd == userdict[username]:<br>                    ...<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 密码错误，修改变量次数</span><br>                    errorNum -= <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 判断当前密码错误次数</span><br>                    <span class="hljs-keyword">if</span> errorNum == <span class="hljs-number">0</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;给你机会你不中用啊细狗。账户已锁定，请联系管理人员并上供品。&#x27;</span>)<br>                        <span class="hljs-comment"># 锁定当前账户，把锁定的用户拉入黑名单</span><br>                        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>                            fp.write(username+<span class="hljs-string">&#x27;\n&#x27;</span>)<br>                        isLogin = <span class="hljs-literal">False</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;您的密码输入有误, 您还能再尝试<span class="hljs-subst">&#123;errorNum&#125;</span>次。&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            ...<br><br>login()<br><br>---<br>您的密码输入有误, 您还能再尝试<span class="hljs-number">2</span>次<br>您的密码输入有误, 您还能再尝试<span class="hljs-number">1</span>次<br>给你机会你不中用啊细狗。账户已锁定，请联系管理人员并上供品。<br></code></pre></td></tr></table></figure><p>这样，当我们的账户被输入错误三次之后，就会得到神的审判：关入小黑屋了。需要上供才行。（谁家这么设计产品，估计死的会很快吧？）</p><p>好了，继续往后，我们只写入了黑名单还不行，这样在执行的时候，还是无法判断用户是否输入的是锁定的账户。接下来需要做的事情，就是读取这个黑名单的文件，然后把里面的用户名全部以列表形式传到这个变量中。</p><p>再然后，我们只要在用户输入用户名的时候判断此用户是否被关小黑屋了就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搞定登录功能</span><br><span class="hljs-comment"># 专门定义数据变量，存放已经注册的用户信息</span><br>...<br>blackUserList = [] <span class="hljs-comment"># 定义一个小黑屋专用变量</span><br><br><span class="hljs-comment"># 读取所有的注册信息</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>  ...<br><br><span class="hljs-comment"># 读取所有黑名单用户</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>    res = fp.readlines()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>        r = i.strip() <span class="hljs-comment">#</span><br>        blackUserList.append(r)<br><br><span class="hljs-comment"># 封装登录函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login</span>():<br>    ...<br>    <span class="hljs-comment"># 创建循环</span><br>    <span class="hljs-keyword">while</span> isLogin:<br><br>        <span class="hljs-comment"># 获取用户登录时输入的用户名</span><br>        username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;欢迎登录，请输入您的用户名：&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检测当前用户名是否存在</span><br>        <span class="hljs-keyword">if</span> username <span class="hljs-keyword">in</span> blackUserList:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;您的账户已经被锁定，并且还未给管理员上供品。&#x27;</span>)<br>            isLogin = <span class="hljs-literal">False</span> <span class="hljs-comment"># 结束外循环</span><br>        <span class="hljs-keyword">elif</span> username <span class="hljs-keyword">in</span> userlist:<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                ...<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 用户名不存在</span><br>            ...<br><br>    <span class="hljs-comment"># 检测用户是否属于锁定状态</span><br><br>login()<br></code></pre></td></tr></table></figure><h2 id="功能合并">功能合并</h2><p>现在，我们把注册和登录功能都分别完成了，那么我们现在就剩下最后一步，将两个功能合并在一起。</p><p>注册和登录的函数是现成的，那么现在我们要做的事情就是：</p><ol type="1"><li>将读取数据的两个<code>with</code>方法封装到一个函数内</li><li>定义一个主函数，进入进程后就执行</li><li>告知用户选择登录还是注册</li><li>在执行登录注册函数之前，初始化数据（加载读取数据的函数）</li></ol><p>OK，让我们来实现吧：</p><p>首先是封装读取数据的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个读取所有用户数据的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">readAllUsers</span>():<br>    <span class="hljs-comment"># 读取所有的注册信息</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/user.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>        <span class="hljs-keyword">global</span> userdict<br>        <span class="hljs-keyword">global</span> userlist<br>        fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment"># 调整指针到文件头</span><br>        res = fp.readlines() <span class="hljs-comment"># 按照每一行读取所有用户数据</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res: <span class="hljs-comment"># 循环读取每一行数据</span><br>            r = i.strip() <span class="hljs-comment"># 处理每一行尾部的换行符</span><br>            mydict = r.split(<span class="hljs-string">&#x27;:&#x27;</span>)<br>            userdict.update(&#123;mydict[<span class="hljs-number">0</span>]:mydict[<span class="hljs-number">1</span>]&#125;)<br>            userlist = userdict.keys()<br><br>    <span class="hljs-comment"># 读取所有黑名单用户</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/black.txt&#x27;</span>, <span class="hljs-string">&#x27;a+&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>        <span class="hljs-keyword">global</span> blackUserList<br>        fp.seek(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        res = fp.readlines()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>            r = i.strip() <span class="hljs-comment">#</span><br>            blackUserList.append(r)<br></code></pre></td></tr></table></figure><p>注意我们这里用了<code>global</code>,因为我们需要使用外部定义的变量，所以必须要讲变量改成全局变量，改动才会有效。</p><p>注册登录函数不用改动，直接原封不动的粘贴过来就可以了。再来我们就需要直接进入主进程进行选择：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 判断当前脚本是否作为一个主进程脚本在执行</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    这里的代码，只有在使用Python解释器直接运行时才会执行</span><br><span class="hljs-string">    如果当前脚本作为了模块被其他文件导入后使用，那么这个地方的代码不会执行</span><br><span class="hljs-string">    因此这个地方的代码，适合写当前脚本中的一些测试，这样不会影响其他脚本</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 调用初始化方法，加载数据</span><br>    readAllUsers()<br>    <br>    isBegin = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">while</span> isBegin:<br>        myStr = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        ======================</span><br><span class="hljs-string">        ** 登录（0） 注册（1）**</span><br><span class="hljs-string">        ======================</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(myStr)<br><br>        <span class="hljs-comment"># 让用户选择对应的操作</span><br>        num = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入对应的序号，体验功能：&#x27;</span>)<br>        <span class="hljs-keyword">if</span> num == <span class="hljs-string">&#x27;0&#x27;</span>:<br>            login()<br>            isBegin = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">elif</span> num == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            register()<br>            isBegin = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;后续功能还在开发中。&#x27;</span>)<br>            isBegin = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>这样当我们输入<code>python3 file.py</code>的时候，就会直接进入这个主程序内。然后执行加载数据的函数，打印用户选择内容，然后等待用户选择并执行后续操作，如图：</p><img src="/Exercise-register-system/image-20230810185215413.png" class="" title="执行截图"><p>而这其中我们设定一个变量<code>isBegin</code>来控制循环，每次执行完一次函数就会结束循环，然后需要重新执行。主要原因就是因为加载数据的方法我们写在了<code>while</code>循环外面，所以当我们注册之后再去登录，新创建的用户并不在用户列表内，无法完成登录。所以干脆结束掉之后重新加载数据，就可以执行登录了。</p><p>能不能改善呢？可以。只是今天的课程目的已经完毕了，所以当作留给大家的练习题吧。如何优化整个程序让其更合理高效，大家试试看。然后记得在评论区给我留言。</p><p>好了，这节课到这里就结束了，相关代码可以在我的仓库里去找到。</p><p>下一节课中，我们会讲解模块，系统的内置模块。我们下次见。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;/Exercise-register-system/cover.png&quot; class=&quot;&quot; title=&quot;封面&quot;&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>13. Python的文件操作</title>
    <link href="https://hivan.me/file-operations/"/>
    <id>https://hivan.me/file-operations/</id>
    <published>2023-08-08T13:26:16.000Z</published>
    <updated>2023-08-10T10:58:02.282Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230809125900.png?imgNote"alt="茶桁的AI秘籍" /></p><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>在之前的几节课程中，我们学习了Python的数据类型。和市面上大多数的Python教程不同的是，我先为大家介绍完函数之后才开始介绍数据类型，其中原因就是很多数据类型的方法及理解都需要先搞懂函数的基本语法。</p><p>在结束了Python数据类型学习之后，我们今天开始进入一个新的篇章。今天，让我们来详细了解一下在Python中如何去进行文件操作。</p><p>我们大家都使用过智能手机，电脑，iPad等电子产品。那我们肯定有打开文件的经验，比如说打开一个Word、Excel文档。最基础的操作实际上就两步，分别是1.打开文件， 2. 关闭文件。</p><p>我们要理解的一点是，文件都是放在存储设备中的，这才是我们能打开它的基础。那我们在存储设备中对文件进行打开之后进行的读写操作，实际上就是文件<code>I/O</code>。</p><p>什么是<code>I/O</code>?<code>I</code>代表<code>Input</code>(输入)，<code>O</code>代表<code>Output</code>（输出）。当你打开一个文件的时候，就算你没有对文件进行更改，也依然已经有了<code>I/O</code>操作，毕竟文件只有读取之后，才能显示到你的屏幕上。</p><p>那么文件读写到底分了几步呢？让我们引用一下宋丹丹的经典小品中的一段：</p><blockquote><p>问，把大象装进冰箱分几步？</p></blockquote><p>我们就不在这里进行分步讨论了，因为流程步骤实际上是一模一样的：</p><ol type="1"><li>打开文件<code>open()</code> ： 打开冰箱。</li><li>读取文件<code>read()</code>/ 写入内容<code>write()</code>：把大象装进冰箱。</li><li>关闭文件<code>close()</code>： 关闭冰箱。</li></ol><p>可以说，你在你的设备上做的任何操作都逃不开这几步，区别无非就是你有没有写入内容，从哪里打开的，读取的文件是什么类型的。</p><p>那么复杂一点的，就是当你打开一个App的时候，这个App执行某项操作的时候去互联网上的服务器找相应的文件然后到本地之后打开，读取。我们不讨论在打开文件之前的一系列例如下载（这个下载动作有时是主动的，有时是被动的）操作，就只说到本地之后读取文件并展示，就一定包含这三步。</p><p>理解到这，可以了。我们接着正式来学习Python如何对文件进行操作。</p><h2 id="文件操作">文件操作</h2><h3 id="open"><code>open()</code></h3><p><code>open</code>函数就是用于最初的打开文件的动作，其基本格式为：<code>open(文件路径, 打开方式, [字符集])</code>，完整的格式为：<code>open(file, mode='r', buffering=None, encoding=None, errors=None, newline=None, closefd=True)</code></p><p>在大部分时候，我们使用基本格式就足够了。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">&#x27;&#x27;&#x27;<br>打开文件 open()<br><span class="hljs-code">    参数1: 文件路径</span><br><span class="hljs-code">    参数2: 打开的方式</span><br><span class="hljs-code">    参数3: 字符集</span><br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><p>路径，也就是<code>url</code>是一种统一资源定位符。其中包括<strong>相对路径</strong>和<strong>绝对路径</strong>。</p><p><strong>相对路径</strong>，比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走100米左右就到了。</p><p><strong>绝对路径</strong>，这个就非常好理解了，北京市西城区鼓楼东大街28号，特别准确了对吧？</p><p>这两个路径的描述呢，其实指向的是一个地方。只是一个是针对人所在的位置来告知你怎么走，另外一个是从最上层给到你一个绝对的地址。而电脑里的相对路径和绝对路径也基本就是这么个意思。</p><p><strong>我们来看相对路径</strong>，主要是使用<code>./</code>和<code>../</code>来进行描述，这两个都有一个共同点，就是以当前文件为准。也就是当前文件向我们问路，我们站在当前文件的地方告诉它该怎么走去到达自己的目的地。</p><p>举例,假设我们现在正在编辑<code>index.py</code>这个文件，也就是说，向我们问路的文件是<code>index.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">- project<br>| - index.py<br>|- test.txt<br>  | img<br>    |- person.jpg <br>    | - dog.jpg<br>    | - cat.jpg<br>- data<br>| - person.csv<br></code></pre></td></tr></table></figure><p>这样一个路径关系中：</p><ol type="1"><li>当我们需要去访问<code>person.jpg</code>并打开的话，那就是<code>index.py</code>同目录下的<code>img</code>目录里面去寻找<code>person.jpg</code>，那我们相对路径的写法为<code>./img/person.jpg</code>。</li><li>当我们要去找<code>person.csv</code>的时候，由于这个csv是存在于上一层目录的同级目录<code>data</code>内，那我们需要向上去寻找，就是<code>../data/person.csv</code>。</li></ol><p>这就是<code>./</code>和<code>../</code>的区别，一个是当前目录同级内去寻找，一个是向上一级的目录内去寻找。那如果文件存储于上两层目录中呢？那就向上翻两层呗：<code>../../</code>这样，多层的时候，依次类推。</p><p>相对路径介绍完了，<strong>我们来看看绝对路径</strong>。</p><p>绝对路径的前提是必须找到根目录。在<code>windows</code>中我们其实都熟悉一个东西就是盘符。比如说<code>C:\</code>，不严谨的说，盘符就算是绝对路径的根目录了。那为什么说不严谨的说呢？因为我们输入文件路径的时候可以输入：<code>C:\data\person.csv</code>这样去寻找。但是，盘符之上其实是整个硬盘，我们只是将硬盘虚拟成了不同的盘符用于划分空间而已。</p><p>在<code>Mac</code>或者<code>Linux</code>中，就是以整个硬盘为准去寻找文件的。比如说<code>/Users/xx/Downloads</code>，就是我们的下载目录。</p><p>那我们如果想要打开文件，这两种方式其实都可以，一般来说，为了代码能够适应环境变化，我们都会选择使用相对路径。</p><p>说完文件路径，让我们来说说打开方式，我先介绍一个模式，后面咱们再慢慢讲：</p><p><strong><code>w</code>模式： write， 写入</strong></p><p>如果文件不存在，创建这个文件；如果文件存在，则打开这个文件，并且清空文件内容。文件打开后，文件的指针在文件的最前面。什么是指针呢？可以这么理解，当我们打开一个word文档的时候，我们的光标是不是都在这个文档的最上面？这个光标的位置，就是指针的位置。</p><h3 id="write"><code>write()</code></h3><p><code>write()</code>是用于对文件写入内容来使用的，格式为:<code>文件对象.write(内容)</code></p><h3 id="close"><code>close()</code></h3><p>格式为: <code>文件对象.close()</code> , 可以关闭打开的文件。</p><p>我们需要注意一点，我们在对文件进行操作的时候，一定记得操作完要关闭它。否则，这个文件就会一直存在于内存地址中。</p><p>下面，让我们看看在Python中如何打开操作一个文件的。</p><blockquote><p>以下所有的操作演示都会在../Python/13.ipynb中进行编写，所以我们的操作路径都会以这个文件为准。</p></blockquote><p>让我们现在当前文件的中创建一个文件夹<code>data</code>，然后在其中放入一个文件<code>13-1.txt</code>，我们说要做的事情，就是打开这个文件，然后将我们之前写的内容复制一部分写入到这个<code>txt</code>文件中去，路径关系如下图：</p><img src="/file-operations/image-20230809191156847.png" class="" title="13-1.txt url"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开13-1 并且写入内容</span><br>fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-built_in">print</span>(fp, <span class="hljs-built_in">type</span>(fp))<br>fp.write(<span class="hljs-string">&#x27;相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走100米左右就到了。\n 绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街28号，特别准确了对吧？&#x27;</span>)<br>fp.close()<br><br>---<br>&lt;_io.TextIOWrapper name=<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span> mode=<span class="hljs-string">&#x27;w&#x27;</span> encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_io.TextIOWrapper&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>打印区打印的内容，实际上是我们<code>print</code>函数执行的结果，可以看到，我们打印<code>fp</code>这个变量的时候，显示的是<code>&lt;_io.TextIOWrapper name='./data/13-1.txt' mode='w' encoding='UTF-8'&gt;</code>,其类型是<code>&lt;class '_io.TextIOWrapper'&gt;</code>。</p><p>这些先放在一边，让我们看看文件到底写入没有：</p><img src="/file-operations/image-20230809193049499.png" class="" title="13-1.txt内容"><p>写入是写入了，可是这是什么鬼？</p><p>啊，差点忘了，整个<code>open()</code>方法内后面还有一个参数<code>encoding=</code>，这个参数是告诉我们这个文件以什么字符集去打开。默认的就是<code>UTF-8</code>，显然，我们保存的这个文件并不是，所以最终导致了乱码。</p><p>让我们修改一下代码，在<code>open()</code>内添加一下<code>encoding</code>，其他不变:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>)<br>...<br><br>---<br>&lt;_io.TextIOWrapper name=<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span> mode=<span class="hljs-string">&#x27;w&#x27;</span> encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>&gt; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;_io.TextIOWrapper&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，打印出来的<code>fp</code>最后的<code>encoding</code>值已经发生了变化。让我们再去看看文件如何了：</p><img src="/file-operations/image-20230809193522741.png" class="" title="13-1.txt"><p>果然没问题，内容能够正确显示而不会乱码了，我们注意到下方文件字符集确实为<code>GBK</code>。</p><blockquote><p>关于<code>字符集编码</code>的问题这里有疑问的，自己回过头再去把我之前讲的课程好好翻腾一下，复习一下。</p></blockquote><p>整段代码中，我们引用了刚才介绍的三个文件操作的函数：<code>open()</code>, <code>write()</code>, <code>close()</code>。</p><p>在简单了解了文件的操作步骤之后，我们接下来再继续看文件操作中另外一个比较重要的函数:<code>read()</code>。</p><h3 id="read"><code>read()</code></h3><p>在对文件进行操作的时候，一定要记得流程一定是打开<code>open</code>在最前面，<code>close</code>关闭在最后面。至于中间你是要读取，写入还是别的什么操作，那都不违反文件操作的整个流程。</p><p>所以在下面一段代码里，我们可以尝试把之前的<code>write()</code>替换为<code>read()</code>，顺便可以学一下如何在代码中看看我们刚修改过的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>)<br>res = fp.read()<br>fp.close()<br><br><span class="hljs-built_in">print</span>(res)<br><br>---<br>相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走<span class="hljs-number">100</span>米左右就到了。<br>绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街<span class="hljs-number">28</span>号，特别准确了对吧？<br></code></pre></td></tr></table></figure><p>可以看到，我们讲刚才写入的内容在打印区完整的打印了出来。</p><p>不知道小伙伴们有没有注意到，在使用<code>open()</code>函数的时候，其中的第二个参数「打开方式」这次发生了变化，改成了<code>‘r’</code>，这中打开模式就是专门用于读取文件的，它在打开文件的时候，不会想<code>‘w’</code>的打开方式一样清空文件。</p><p>比如，我们讲之前的代码中换一下打开方式来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">fp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>)<br>res = fp.read()<br>fp.close()<br><br><span class="hljs-built_in">print</span>(res)<br><br>---<br>UnsupportedOperation: <span class="hljs-keyword">not</span> readable<br></code></pre></td></tr></table></figure><p>报错了，提示不可读。</p><p>我们再去直接打开<code>13-1.txt</code>的时候可以看到。文件内空空如也，之前写入的内容全都被清空了。</p><p>到这里为止，大家了解了文件操作的四个基本操作函数，在这里我可以教大家一个文件操作中的一些高级技巧，比如，我们可以使用<code>with...as...</code>来进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">with open(文件路径, 打开模式) as 变量:</span><br><span class="hljs-string">变量.操作()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>让我们直接来看示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br>相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走<span class="hljs-number">100</span>米左右就到了。<br>绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街<span class="hljs-number">28</span>号，特别准确了对吧？<br></code></pre></td></tr></table></figure><p>这样，我们也就直接完成了之前读取的操作。</p><p><code>read</code>函数内是有参数的：<code>read(count)</code>，接收的值为整型，这里是描述当前我要读取几个字节长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read(<span class="hljs-number">5</span>)<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br>相对路径:<br></code></pre></td></tr></table></figure><p>有的小伙伴看到我写到这可能就有疑问了，我为什么没有写<code>close()</code>函数，那是不是说，现在这个文件都还一直存在内容地址中。</p><p>其实并不是如此。在使用<code>with...as...</code>这个方式去打开一个文件的之后，在整个代码结束的时候会自动对当前打开的文件一遍执行<code>close()</code>函数。</p><p>好，让我接着继续：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    fp.write(res)<br><br>---<br>相对路径: 比如说我们被路人问路，我们就说：这条街往前，前面十字路口就是交道口，然后左转，再走<span class="hljs-number">100</span>米左右就到了。<br>绝对路径: 这个就非常好理解了，北京市西城区鼓楼东大街<span class="hljs-number">28</span>号，特别准确了对吧？<br></code></pre></td></tr></table></figure><p>打印区并未发生变化，原因就是我们的写入操作是在<code>print</code>之后进行的，我们直接打开文件来看看：</p><img src="/file-operations/image-20230809212650123.png" class="" title="写入操作"><p>可以看到，内容确实被写入文件中了。注意我打标记的地方，并没有换行对吧，也就是说，我们在做写入的时候，指针是标记在这个位置的，然后继续往后写入。</p><p>另外整个代码中需要注意的就是打开模式了，我们之前已经用过的打开模式有<code>‘w’和``'r'</code>，现在我们用了<code>‘r+’</code>的模式，那么<code>r+</code>呢就是既可以读，也可以写入。并且，不会一开始就清空文件的内容。</p><p>对应<code>‘w’</code>的清空模式，就是<code>‘w+’</code>,虽然<code>‘w+’</code>也是可读可写的模式，但是它和<code>‘w’</code>的模式一致，打开文件的时候直接清空整个文件的内容。</p><p>除了这四个模式之外，还有<code>'a'</code>和‘<code>'a+’</code>模式，是追加写的模式，这种模式的特点是打开文件的时候，指针是放在文件最末尾的。所以这种模式使用<code>read()</code>的时候，是读不到任何内容的。</p><p>以为到这里就结束了吗？太单纯了，整个文件操作的打开模式中，还有一个<code>‘x+’</code>的模式，这种模式我们可以称它为异或，什么意思呢？就是这种模式只会新建文件来执行后续操作，否则就会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span>, <span class="hljs-string">&#x27;x+&#x27;</span>, encoding=<span class="hljs-string">&#x27;GBK&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.read())<br>    <br>---<br>FileExistsError: [Errno <span class="hljs-number">17</span>] File exists: <span class="hljs-string">&#x27;./data/13-1.txt&#x27;</span><br></code></pre></td></tr></table></figure><p>提示文件错误：文件存在。</p><p>如果我们操作的是一个本来不存在的文件，才可以正常的往下进行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;x+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    fp.write(<span class="hljs-string">&#x27;这里是&quot;x+&quot;模式下新加入的内容。&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-x+.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    res = fp.read()<br>    <span class="hljs-built_in">print</span>(res)<br>    <br>---<br>这里是<span class="hljs-string">&quot;x+&quot;</span>模式下新加入的内容。<br></code></pre></td></tr></table></figure><p>我们在用<code>‘x+’</code>模式打开一个文件的时候，它已经新建了这个文件，我们可以看到读取之后并未读取到任何内容，因为这个文件内还是空的。在进行写入操作之后，我们在下面再一次读取这个文件，可以看到内容已经被写入了。</p><h3 id="详谈打开模式">详谈「打开模式」</h3><p>其实<code>mode</code>这个参数并不只是我们演示的这么点内容，<code>mode</code>这个参数是接收两种值的，一个是刚才我们一直在讲的<code>读写模式</code>,而另外一个则是<code>文件格式</code>：</p><p><strong>读写模式</strong>：</p><p>读写模式的参数主要有四种， 分别是<code>r</code>,<code>w</code>,<code>a</code>以及一个特殊<code>+</code>，其中<code>r</code>, <code>w</code>,<code>a</code>决定了当前文件默认是只读还是只写，还有就是指针位置。<code>+</code>是和前面三个结合使用的，无法单独使用，其主要作用是使的文件读写兼备。</p><p><strong>文件格式</strong>：</p><p>文件格式主要是以两种格式为准，一种是普通的文本文件，一种是二进制格式文件。不要以为二进制格式没什么大不了，我们一般谈到非文本文件都属于二进制格式文件，比如：图片。</p><p>这两个格式控制字符一个是<code>t</code>:以文本格式打开文件（默认值）， 一个是<code>b</code>:以二进制格式打开文件。</p><p>一般来说，我们大部分时候都不会单独使用某一个参数吗，而是结合着一起使用。比如：</p><p><code>r+</code>，打开一个文件用于读写，文件存在就打开，文件不存在则报错。指针在文件头。这种模式要注意，因为指针在文件头，所以新写入的内容会在原内容之前。</p><p><code>w+</code>,打开一个文件用于读写，文件存在就打开，并且会清空所有内容后进入编辑模式，如果文件不存在则会创建一个新文件。虽然指针也在文件头，但是因为它霸道的清空属性，所以也不存在新写入的内容会在原内容之前了。</p><p><code>a+</code>，以追加的模式打开一个文件用于读写，如果文件存在就打开，如果文件不存在，则会创建一个新文件用于读写。这种模式下和<code>w+</code>不同的地方在于它会将指针放在文件末尾，写入的时候是从文件尾部开始写。并且，它没那么霸道，要清空原内容才可以。</p><p>其他的模式就是在打开文件格式和读写模式的组合，一般我们不写是因为大部分时候我们操作的都是文本文件进行操作，而如果我们需要用二进制格式打开文件的时候，就不能使用默认的<code>t</code>而是<code>b</code>了，一般我们会是这样进行组合：<code>rb</code>,<code>rb+</code>, <code>wb</code>, <code>wb+</code>, <code>ab</code>,<code>ab+</code>。</p><p>当然，最后就是我们刚才用到的<code>x+</code>，其实它也是一种组合形式，原本应该是<code>x</code>,这种模式是在Python3中新添加的，它在文件不存在的时候它会创建一个新文件用于写入。如果这个文件存在，就会报错。</p><p>那么有了<code>x</code>这个参数之后，我们以前为了避免误操作覆盖原文件，那么我们会先去判断一个文件是否存在，然后再去执行后续的写入操作。可是使用<code>x</code>就没那么麻烦了，可以直接操作写入，反正文件如果存在会返回错误。</p><h3 id="关于指针位置">关于指针位置</h3><p>那么我们在使用了<code>r+</code>之后，有没有什么办法可以让我们不在原内容之前写入内容而是从后开始写呢？</p><p>答案是有办法，也就是调整指针位置，调整完毕之后再进行写入操作就可以了。</p><p>调整指针的方法为<code>seek(offset[, whence])</code>。我们来看一个对比：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个新文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.write(<span class="hljs-string">&#x27;1. Hello Python.\n2. Hello C++. \n3. Hello Ruby.&#x27;</span>)<br><br><span class="hljs-comment"># 正常状态下</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.readline())<br>    <span class="hljs-built_in">print</span>(fp.readline())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------------&#x27;</span>)<br><br><span class="hljs-comment"># 设置指针重新偏移到头部</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.readline())<br>    fp.seek(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(fp.readline())<br><br>---<br><span class="hljs-number">1.</span> Hello Python.<br><br><span class="hljs-number">2.</span> Hello C++. <br><br>------------<br><span class="hljs-number">1.</span> Hello Python.<br><br><span class="hljs-number">1.</span> Hello Python.<br></code></pre></td></tr></table></figure><p>在最开始，我们重新创建了一个文件，然后写了三行文字。分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> Hello Python.<br><span class="hljs-number">2.</span> Hello C++. <br><span class="hljs-number">3.</span> Hello Ruby.<br></code></pre></td></tr></table></figure><p>然后我们开始用不同的方法进行读取，每次仅读取一行。</p><p>正常状态下，<code>readline()</code>这个方法是顺序往下执行的，第一次执行的时候读取的是第一行，第二次执行的时候就是读取的第二行。这种方式是不是感觉有些熟悉，像不像迭代器？</p><p>回过头来，我们再来看两次执行的结果，不同的是，第二次我在两个<code>readline()</code>方法中间加入了一段<code>fp.seek(0,0)</code>来将指针再次调整到头部，别着急，我们一会讲为什么这样写，先来看看结果。</p><p>因为有了<code>fp.seek(0,0)</code>的存在，第二次执行和第一次完全不同。第一段内容被读取了两次。这就是<code>seek()</code>的作用，讲指针又调整到了文件头部。</p><p>现在，让我们来说说<code>seek()</code>内参数的含义，完整的写法是：<code>seek(offset[, whence])</code>，其中<code>offset</code>是偏移量，而<code>whence</code>是从哪开始。<code>whence</code>就只有三个值，<code>0, 1, 2</code>，0就表示是从头部开始偏移，1就表示从当前位置开始偏移，2就代表从文件末尾开始偏移。而我们写的<code>(0,0)</code>意思就是从文件头部开始偏移，偏移量为0。</p><p>再来看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置指针重新偏移到头部</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r+&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    fp.seek(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>    fp.write(<span class="hljs-string">&#x27;这里是使用r+添加到末尾的内容&#x27;</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./data/13-2.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>    <span class="hljs-built_in">print</span>(fp.read())<br>    <br>---<br><span class="hljs-number">1.</span> Hello Python.<br><span class="hljs-number">2.</span> Hello C++. <br><span class="hljs-number">3.</span> Hello Ruby.这里是使用r+添加到末尾的内容<br></code></pre></td></tr></table></figure><p>通过前面的学习我们知道，<code>r+</code>在打开文件之后，指针是放在头部的，但是我们这里用<code>seek(0,2)</code>将指针调整到了最末尾，并且写入了一段文字。</p><p>学到这里，文件的基本操作也就差不多学完了，让我们来分别总结一下：</p><h2 id="相关函数">相关函数</h2><ul><li><p><code>open()</code>, 打开文件,格式：<code>open(file_name [, access_mode][, buffering])</code></p></li><li><p><code>read()</code>, 读取内容，格式：<code>fileObject.read([count])</code></p></li></ul><p>不设置<code>count</code>是从当前位置读取到文件末尾，设置<code>count</code>这是读取指定长度的字符。</p><ul><li><code>readline()</code>, 读取一行</li></ul><p>不设置<code>count</code>是从当前位置读取到这一行末尾，设置<code>count</code>这是读取这一行中指定长度的字符。</p><ul><li><code>readlines()</code>, 读取所有行</li></ul><p>不设置参数是表示读取所有汗，每一行作为一个参数，返回了一个列表。设置<code>count</code>是按照行进行读取，可以设置读取的字节数，设置的字节数不足一行按一行来读取。</p><ul><li><code>write()</code>，写入内容,格式：<code>fileObject.write(string)</code></li><li><code>writelines()</code>, 写入容器类型数据：</li></ul><p>写入容器类数据的时候要注意，这个容器类数据必须是可更新的类型。</p><ul><li><code>seek()</code>, 设置文件指针的偏移, 格式:<code>seek(offset[, whence])</code></li><li><code>close()</code>， 关闭文件</li></ul><p>当然，除了这几个之外，文件还有很多其他的函数，但是目前我们用这些进行读写操作就足够了。</p><h2 id="打开模式图">打开模式（图）</h2><p>关于打开模式，我之前写的那些内容看懂理解了，其实也就不需要现在这两张图了，可是我担心的是有些小伙伴理解不了，那有了下面的图，至少操作的时候可以参考：</p><table><colgroup><col style="width: 6%" /><col style="width: 93%" /></colgroup><thead><tr class="header"><th style="text-align: left;">模式</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">t</td><td style="text-align: left;">文本模式 (默认)。</td></tr><tr class="even"><td style="text-align: left;">x</td><tdstyle="text-align: left;">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr class="odd"><td style="text-align: left;">b</td><td style="text-align: left;">二进制模式。</td></tr><tr class="even"><td style="text-align: left;">+</td><td style="text-align: left;">打开一个文件进行更新(可读可写)。</td></tr><tr class="odd"><td style="text-align: left;">U</td><td style="text-align: left;">通用换行模式（不推荐）。</td></tr><tr class="even"><td style="text-align: left;">r</td><tdstyle="text-align: left;">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr class="odd"><td style="text-align: left;">rb</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">r+</td><tdstyle="text-align: left;">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr class="odd"><td style="text-align: left;">rb+</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">w</td><tdstyle="text-align: left;">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr class="odd"><td style="text-align: left;">wb</td><tdstyle="text-align: left;">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">w+</td><tdstyle="text-align: left;">打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</td></tr><tr class="odd"><td style="text-align: left;">wb+</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr class="even"><td style="text-align: left;">a</td><tdstyle="text-align: left;">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr class="odd"><td style="text-align: left;">ab</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr class="even"><td style="text-align: left;">a+</td><tdstyle="text-align: left;">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr class="odd"><td style="text-align: left;">ab+</td><tdstyle="text-align: left;">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>总结一下最常用的六种模式：</p><table><thead><tr class="header"><th style="text-align: center;">模式</th><th style="text-align: center;">r</th><th style="text-align: center;">r+</th><th style="text-align: center;">w</th><th style="text-align: center;">w+</th><th style="text-align: center;">a</th><th style="text-align: center;">a+</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">读</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;">✓</td></tr><tr class="even"><td style="text-align: center;">写</td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td></tr><tr class="odd"><td style="text-align: center;">创建</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td></tr><tr class="even"><td style="text-align: center;">覆盖</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">指针在开始</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">指针在结尾</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">✓</td><td style="text-align: center;">✓</td></tr></tbody></table><p>下面这张经典的流程图可以告诉你在什么时候需要用什么：</p><img src="/file-operations/drawio.png" class="" title="流程图"><h2 id="结尾与预告">结尾与预告</h2><p>文件的基本操作就介绍到这里了，大家下课之后记得要去多多的熟悉和练习。</p><p>那么下一节课呢，我们会根据我们这之前所讲的所有内容，尝试做一个小<code>demo</code>，实现一个简单的注册和登录功能。</p><p>这里先介绍一下这个<code>demo</code>:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">实现功能：<br><span class="hljs-bullet">1.</span> 用户输入用户名和密码以及确认密码<br><span class="hljs-bullet">2.</span> 用户名不能重复<br><span class="hljs-bullet">3.</span> 两次密码要一致<br><span class="hljs-bullet">4.</span> 用户用已经注册的账户登录<br><span class="hljs-bullet">5.</span> 密码如果错误3次，锁定，无法再登录。<br></code></pre></td></tr></table></figure><p>好了，小伙伴们，咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230809125900.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>12. 数据类型 - 集合详解</title>
    <link href="https://hivan.me/Detailed-of-set/"/>
    <id>https://hivan.me/Detailed-of-set/</id>
    <published>2023-08-08T04:59:49.000Z</published>
    <updated>2023-08-10T10:58:12.939Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230808130113.png?imgNote"alt="茶桁的AI秘籍 Python-set" /></p><p>Hi， 大家好。我是茶桁</p><span id="more"></span><p>通过最近几节课的内容，我们已经了解到了大部分的容器类数据的特性和应用，今天这一节课是容器类数据的最后一部分。让我们今天来详细了解一下「集合」。</p><p>集合是<strong>确定的</strong>一组<strong>无序的</strong>数据的组合。注意这一句话中的几个概念：</p><ul><li>首先是「确定的」，当前集合中的元素的值是不能重复的。</li><li>集合是由多个数据组合的容器类型数据</li><li>集合中的数据没有先后顺序</li><li>集合的作用大多数时候是为了从成员检测、从无序列中去除重复项。还有就是数学中的集合类计算，例如交集、并集、差集一集对称差集等等。</li></ul><h2 id="集合的定义">集合的定义</h2><p>集合的定义和字典类数据的定义非常像，包含了三种定义方式：</p><ul><li>可以直接使用<code>&#123;&#125;</code>来定义集合</li><li>可以使用<code>set()</code>进行集合的定义和转换</li><li>使用集合推导式来完成集合的定义</li></ul><blockquote><p>⚠️ 需要注意：集合中的元素不能重复，集合中存放的数据为：Number,String, Tuple，冰冻集合</p></blockquote><h2 id="冰冻集合">冰冻集合</h2><p>在集合的定义部分，其他数据类型我们都能理解，唯独多出来一个<code>冰冻集合</code>似乎没有见过，也难以理解。</p><p>冰冻集合的定义，需要且仅能使用<code>frozenset()</code>函数来进行定义。故名思义，冰冻集合一旦定义之后，是不能进行修改的，只能做一些集合相关的运算，比如交集，差集等等。</p><p>回过头来看冰冻集合的定义函数<code>frozenset()</code>，这个函数本身是一个强制转换类的函数，可以把其他任何容器类型的数据转为冰冻集合，然后参与集合运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个冰冻集合</span><br>mySets = <span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-number">666</span>, <span class="hljs-number">333</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;MAMT&#x27;</span>,<span class="hljs-string">&#x27;55IW&#x27;</span>&#125;)<br><br><span class="hljs-comment"># 遍历集合</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mySets:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot;, &quot;</span>)<br><br>---<br><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, 55IW, love, <span class="hljs-number">333</span>, MAMT, <span class="hljs-number">666</span>, a, <br></code></pre></td></tr></table></figure><p>也是可以看到，打印的结果完全没有任何顺序。</p><p>冰冻集合当然也可以使用集合推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">frozenset</span>(&#123;i&lt;&lt;<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>)&#125;)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;)<br></code></pre></td></tr></table></figure><p>可以进行拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = res.copy()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-built_in">frozenset</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;)<br></code></pre></td></tr></table></figure><p>当然冰冻集合也可以进行集合的运算，不过这部分我们将在后面讲解集合的时候来学习。暂时我们只是对「冰冻集合」的概念有个了解就可以了。</p><h2 id="集合的基本操作和常规函数">集合的基本操作和常规函数</h2><p>以往的几节，我们都是将集合的操作和函数分开来讲，而这次我们放在一起讲。其实也没其他原因，就是因为这部分的内容并没有多少，并且很容易理解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义集合</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>mySets<br><br>---<br>&#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>, <span class="hljs-number">3.1415</span>, <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-string">&#x27;love&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>打印的结果再一次验证了集合无序，除此之外，我们可以看到打印出来的集合比我们进行定义的时候似乎少了,这又是为什么呢？</p><p>原来，在集合内布尔类型的数据其实就是0和1， True表示为1，False表示为0，而集合内的值是不能重复的，所以，布尔值和<code>0,1</code>就只能存在一个。</p><p>我们来尝试检测一下集合中的值，和其他容器类数据一样，我们可以直接使用<code>for...in</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检测集合中的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-keyword">in</span> mySets)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> mySets)<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>然后一样，可以使用<code>len()</code>检测长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(mySets))<br><br>---<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>遍历的方法依然是用<code>for</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mySets:<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-built_in">type</span>(i))<br>    <br>---<br><span class="hljs-literal">False</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bool&#x27;</span>&gt;<br><span class="hljs-literal">True</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bool&#x27;</span>&gt;<br><span class="hljs-number">3.1415</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br>love &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br>abc &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br><span class="hljs-number">123</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-number">123</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>为什么我这次会将数据类型也打印出来呢？是因为我想让大家好好记住这些类型，目前集合就只支持这些数据类型，其他的并不支持放入。比如说列表，是无法进入集合内的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看看列表是否能放入</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>,[<span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]&#125;<br><br>---<br>TypeError: unhashable <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到报错信息提示，不支持类型：列表。</p><p>那我们如何像集合中追加元素呢？可以使用<code>add()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义集合</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>res = mySets.add(<span class="hljs-string">&#x27;茶桁&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">&#x27;\nres:&#x27;</span>, res)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125; <br>res: <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>可以看到我们在其中追加了一个字符串<code>茶桁</code>,但是我们再一次验证了集合的无序，新加入的字符串并没有和其他数据类型一样新加入的元素放在最末端。</p><p>并且我们注意到了，我用<code>res</code>来接收了<code>add()</code>的返回值，返回了一个<code>None</code>。</p><p>除了追加之外，当然我们也可以对集合进行删除元素的处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySets.pop()<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">&#x27;\nres:&#x27;</span>, res)<br><br>---<br>&#123;<span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125; <br>res: <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>用<code>pop()</code>删除集合内的元素是随机的，并且，会将删除的元素返回。</p><p>如果想指定删除集合中的元素有没有办法呢？其实也有，<code>remove()</code>和<code>discard()</code>都可以做到，但是两者又有些区别，我们接着看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用remove()</span><br>res = mySets.remove(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets)<br>res = mySets.remove(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;茶桁&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125; <br>res: <span class="hljs-literal">None</span><br>KeyError: <span class="hljs-string">&#x27;aaa&#x27;</span><br></code></pre></td></tr></table></figure><p>能看到，<code>remove()</code>确实可以删除集合内的指定元素，并给一个返回值<code>None</code>。不过当集合内没有此元素的时候，就会报错，提示关键词错误。</p><p>那让我们再来看看<code>discard()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用discard</span><br>mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>res = mySets.discard(<span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br>res = mySets.discard(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>&#125; res:<span class="hljs-literal">None</span><br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>&#125; res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>和<code>remove()</code>一样，也删除了一个指定元素，并且返回了<code>None</code>。不同的是，当我们使用<code>discard</code>删除一个不存在的元素时，<code>discard</code>虽然没有删除任何内容，但是也没有报错。</p><p>一个个删除太麻烦了，这个集合我就想让它变成一个空集合，好办，用<code>clear()</code>做清空处理呗，和字典一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br><span class="hljs-built_in">print</span>(mySets)<br>mySets.clear()<br><span class="hljs-built_in">print</span>(mySets)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125;<br><span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>空集合拿到了，可以放入我们喜欢的元素了。依然和字典一致，我们可以使用<code>update</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySets.update(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br>res = mySets.update(&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;)<br><span class="hljs-built_in">print</span>(mySets, <span class="hljs-string">f&#x27;res:<span class="hljs-subst">&#123;res&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125; res:<span class="hljs-literal">None</span><br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; res:<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>结果中显示，我们更新成功了，新添加了一些元素进入集合。那第二次添加，为什么就只有<code>6</code>添加进去了呢？还记得么？集合不能有重复值，就跟字典不能有重复的<code>key</code>一样。在字典中使用<code>update</code>，遇到相同<code>key</code>后面的<code>value</code>会被更新，那其实集合也是一样的，只是因为只有一个值，所以更新完不还是这个值么。</p><p>在冰冻集合的时候我们用到过一次<code>copy</code>，这里我们要单独拿出来说说，因为集合中的元素都是不可变的，包括元组和冰冻集合，所以当前集合的浅拷贝并不存在深拷贝的问题。换句话说，就是不存在在拷贝后，对集合中不可变的二级容器进行操作的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">mySets = &#123;<span class="hljs-number">123</span>,<span class="hljs-string">&#x27;abc&#x27;</span>,<span class="hljs-literal">False</span>,<span class="hljs-string">&#x27;love&#x27;</span>,<span class="hljs-literal">True</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>,<span class="hljs-number">3.1415</span>,<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-number">1</span>&#125;<br>res = mySets.copy()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-literal">False</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.1415</span>, (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-string">&#x27;love&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;123&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>集合是没有<code>deepcopy</code>方法的。</strong></p><h2 id="集合的运算和检测">集合的运算和检测</h2><p>集合的主要运算有四种，以下将列出这四种以及他们的方法:</p><ul><li>交集<code>&amp;, set.intersection(), set.intersection_update()</code></li><li>并集 <code>|, union(), update()</code></li><li>差集 <code>-, difference(), difference_update()</code></li><li>对称差集<code>^, symmetric_difference(), symmetric_difference_update()</code></li></ul><p>我们先来看看符号运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先定义两个集合</span><br>mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>然后让我们先求交集<code>&amp;</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求两个集合交集</span><br>res = mySet1 &amp; mySet2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>求两个集合并集（求并集的时候会去除重复项）<code>|</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1 | mySet2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>求两个集合差集<code>-</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1 - mySet2<br>res2 = mySet2 - mySet1<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(res2)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>这段代码结果中<code>res</code>和<code>res2</code>的区别在于，<code>res</code>是<code>mySet1</code>中有，而<code>mySet2</code>中没有，<code>res2</code>是<code>mySet2</code>中有，而<code>mySet1</code>中没有。</p><p>求两个集合对称差集<code>^</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1 ^ mySet2<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>看完符号运算，我们可以再来看看函数运算</p><p>交集的运算函数为<code>set.intersection(), set.intersection_update()</code>,那这两个函数又有什么区别呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1.intersection(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>让我们先记住<code>intersection()</code>的结果,<code>mySet1</code>和<code>mySet2</code>并没有发生变化，而返回值为两个集合相同的内容。然后我们再来看看另外一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">res = mySet1.intersection_update(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Python&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>首先我们就能看到，返回值为<code>None</code>,并且<code>mySet1</code>发生了变化。也就是说，<code>set.intersection_update()</code>是将两者的交集重复赋值给到了头部的变量，这里就是<code>mySet1</code>，然后返回一个<code>None</code>值。</p><p>接着我们来看一下并集运算函数: <code>union(), update()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet1.union(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>我们首先看到了返回值，正事两个集合的并集，两个原始集合也没有发生变化。</p><p>再来看看<code>update()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet1.update(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>可以很明显看到区别：返回值为<code>None</code>，并集的计算结果被复制给了第一个变量，这里是<code>mySet1</code>。</p><p>再看完并集之后，就轮到差集了,分别是这两个函数<code>difference(),difference_update()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet1.difference(mySet2)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>返回值为差集的计算结果,这里是<code>mySet1</code>有的而<code>mySet2</code>没有的。那不用问，按照一贯的惯例，<code>difference_update()</code>一定是将计算结果返回给第一个变量，这回我们换一下，将<code>mySet2</code>换成第一个变量试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet2.difference_update(mySet1)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>果然就跟料想的一样，最终的计算结果赋值给了<code>mySet2</code>。</p><p>最后当然就是对称差集函数<code>symmetric_difference()  symmetric_difference_update()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet2.symmetric_difference(mySet1)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br>&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><code>res</code>接收了计算结果，成为了一个新集合。</p><p>接下来，大家应该能猜到了吧？不过还是要做做实验才知道，万一和自己想的不一样呢。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Go&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>&#125;<br>mySet2 = &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>&#125;<br><br>res = mySet2.symmetric_difference_update(mySet1)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;mySet1:<span class="hljs-subst">&#123;mySet1&#125;</span>, \nmySet2:<span class="hljs-subst">&#123;mySet2&#125;</span>&#x27;</span>)<br><br>---<br><span class="hljs-literal">None</span><br>mySet1:&#123;<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>&#125;, <br>mySet2:&#123;<span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>嗯，这个结果，一点都没有惊喜和意外。</p><p>好吧，运算我们学完之后，接着我们要看看集合的检测方法,一共有三个，记住用法就可以了：</p><ul><li><code>issuperset()</code>检测是否为超集</li><li><code>issubset()</code>检测是否为子集</li><li><code>isdisjoint()</code>检测是否不相交</li></ul><p>为了更好的说明，我们不能在用之前的集合，这回，我们定义三个集合来看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">mySet1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;<br>mySet2 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>mySet3 = &#123;<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br></code></pre></td></tr></table></figure><p>接下来从第一个检测开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(mySet1.issuperset(mySet2))<br><span class="hljs-built_in">print</span>(mySet2.issuperset(mySet1))<br><span class="hljs-built_in">print</span>(mySet1.issuperset(mySet3))<br><br>---<br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>不知道大家在数学里有没有学过「超集」的概念，我们从最后的打印结果可以看出来，<code>mySet1</code>是<code>mySet2</code>的超集，反过来则不是，并且，<code>mySet1</code>也不是<code>mySet3</code>的超集。观察三个集合内的元素我们可以得出结论，如果集合<code>a</code>是另外一个集合<code>b</code>的超集，那么集合<code>b</code>内的元素一定在集合<code>a</code>中都找得到。</p><p>再来检测子集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(mySet1.issubset(mySet2))<br><span class="hljs-built_in">print</span>(mySet2.issubset(mySet1))<br><span class="hljs-built_in">print</span>(mySet3.issubset(mySet1))<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>从这个结果中我们能看到，子集的概念就和超集完全相反了。</p><p>最后就是检测两个集合是否相交了，也就是集合中的元素有没有重复的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(mySet1.isdisjoint(mySet2))<br><span class="hljs-built_in">print</span>(mySet2.isdisjoint(mySet1))<br><span class="hljs-built_in">print</span>(mySet3.isdisjoint(mySet1))<br><span class="hljs-built_in">print</span>(mySet2.isdisjoint(mySet3))<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>虽然前三个都打印的<code>False</code>，最后一个打印的<code>True</code>，但是我们从集合中应该知道，只有<code>mySet2</code>和<code>mySet3</code>没有相交关系。所以我们可以知道，<code>isdisjoint()</code>这个函数其实是检测不相交的。也就是说，返回结果为<code>False</code>则证明相交，返回结果为<code>True</code>反而是不相交。</p><h2 id="结语">结语</h2><p>至此，随着我们的集合内容讲完，咱们的容器类数据类型就全部讲完了。</p><p>咱们下一节开始，咱们要开始行的篇章。下一节内容预告：Python中File文件的操作。</p><p>本节课一样就不布置作业了，大家好好的将最近将的容器类数据好好的回顾一下，将基础打扎实。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230808130113.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍 Python-set&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi， 大家好。我是茶桁&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>11. 数据类型 - 字典</title>
    <link href="https://hivan.me/Detailed-of-dictonary/"/>
    <id>https://hivan.me/Detailed-of-dictonary/</id>
    <published>2023-08-07T11:40:50.000Z</published>
    <updated>2023-08-10T10:58:17.297Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807194318.png?imgNote"alt="茶桁的AI秘籍-dictionary" /></p><p>Hi，大家好。我是茶桁。</p><span id="more"></span><p>关于Python的数据类型，我们已经详细讲解了三种，字符串，列表和元组。那么今天，我们再来讲一种：字典。</p><p>字典也是一种数据的集合，由健值对组成的数据集合，字典中的键是不能重复的。</p><p>字典中的键必须是不可变的数据类型，常用的键主要是：字符串，整型...</p><p><strong>实际上，在之前字符串和列表的铺垫之后，任何数据类型其实都会感觉差不多，当然，每个数据类型也都有自己的特点以及需要注意的地方，不过在方法，操作上也会有很多类同点。</strong></p><p>那么，让我们开始学习字典吧。</p><h2 id="字典的定义">字典的定义</h2><ul><li>字典可以通过把以逗号分隔的<code>key:value</code>对列表包含于花括号之内来创建字典。</li><li>也可以通过<code>dict</code>构造器来创建</li></ul><p><code>&#123;'jack': 666, 'stored': 777&#125;</code>或者<code>&#123;666:'jack', 777:'stored'&#125;</code></p><p>让我们开始写代码来做实验：</p><p>使用<code>&#123;&#125;</code>定义:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>dict(key=value, key=value)</code>函数进行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>(name=<span class="hljs-string">&#x27;张三&#x27;</span>, sex=<span class="hljs-string">&#x27;male&#x27;</span>, age=<span class="hljs-number">22</span>)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;sex&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>&#125;<br></code></pre></td></tr></table></figure><p>数据类型的转换：<code>dict(二级容器类型)</code>列表或元组，并且只有二级容器才可以转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>([[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>]])<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>让我们来试试如果不是二级容器类型会如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>([<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>], [<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>], [<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>TypeError: <span class="hljs-built_in">dict</span> expected at most <span class="hljs-number">1</span> argument, got <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>报错了，提示我们字典最多一个参数，但是现在里面有3个。</p><p>再继续试试其他情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = <span class="hljs-built_in">dict</span>([[[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>],[<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>],[<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>]]])<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>ValueError: dictionary update sequence element <span class="hljs-comment">#0 has length 3; 2 is required</span><br></code></pre></td></tr></table></figure><p>再次抛出异常，提示字典更新序列元素长度为3，第2位是必填项。</p><p>以上可以看出，只有二级容器才能通过<code>dict()</code>函数来做数据类型的转换。</p><p><code>zip</code>压缩函数，<code>dict</code>转类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>ex2 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><br><span class="hljs-comment"># 压缩过后做的事情其实就是数据类型的转换</span><br>myDict = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(ex1, ex2))<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="字典的操作">字典的操作</h2><p>还记得吗，无论是列表还是元组，都支持数学的基本运算符<code>+</code>和<code>*</code>。那字典是不是也同样支持？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>ex2 = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">4</span>:<span class="hljs-string">&#x27;d&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(ex1 + ex2)<br><br>---<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> +: <span class="hljs-string">&#x27;dict&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;dict&#x27;</span><br></code></pre></td></tr></table></figure><p>提示类型错误，<code>*</code>实际上也是一样，这里我们就不占用篇幅再多打印一次错误了。说明，字典并不支持这两个基本的数学运算符。想想我们之前提到的<code>dict</code>中<code>key</code>不能重复其实也就好理解了。如果支持<code>+</code>，那相加的两个字典内<code>key</code>值如果相同，那到底舍去那一个呢？<code>*</code>法就更容易理解，原本<code>*</code>就是将相同的数据重复乘n份，不支持也就理所应当了。</p><p>那么，字典到底支持哪些操作呢？我们接着往下看实验：</p><p>首先，让我们尝试获取一下元素，既然字典是<code>key:value</code>形式的，那要想拿到<code>value</code>值，必然是使用<code>key</code>来获取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = ex1[<span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>拿到元素了，那如果我们是要修改元素呢？直接赋值试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">111</span><br><span class="hljs-built_in">print</span>(ex1)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">111</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>看来是有效的，增删改查，我们现在来试试删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> ex1[<span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-built_in">print</span>(ex1)<br><br>---<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>也没毛病。</p><p>接下来，当然就是添加元素了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ex1[<span class="hljs-string">&#x27;aa&#x27;</span>]  = <span class="hljs-string">&#x27;aaaaa&#x27;</span><br><span class="hljs-built_in">print</span>(ex1)<br><br>---<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;aa&#x27;</span>: <span class="hljs-string">&#x27;aaaaa&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>之前我们反复说过字典的一个特点，就是字典不能有重复的<code>key</code>，这也是我们无法使用<code>+</code>和<code>*</code>操作字典的原因。那么问题来了，如果我在添加元素的时候<code>key</code>重复了怎么办？</p><p>什么怎么办，添加<code>key</code>重复了，那不就变成修改元素了吗？<code>^_^</code></p><h2 id="检测和获取">检测和获取</h2><p>增删改查我们前三个基本都已经讲完了，那剩下的，就是查了。让我们看看如何检测和获取元素。</p><p>成员检测，只能检测<code>key</code>，无法检测<code>value</code>。是否注意到我们之前一直使用的一句代码<code>for i in range(10)</code>,大家应该都能明白这一句代码是做什么吧？其实，我们坚持是否包含的时候，就可以用<code>in</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AA&#x27;</span> <span class="hljs-keyword">in</span> ex1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;AA&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ex1)<br><br>---<br><span class="hljs-literal">False</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>获取当前字典的长度，只能检测当前有多少个健值对：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(ex1))<br><br>---<br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>我们还可以获取当前字典中的所有<code>key</code>键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ex1.keys())<br><br>---<br>dict_keys([<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;aa&#x27;</span>])<br></code></pre></td></tr></table></figure><p>当然，不只是<code>key</code>。实际上，字典中所有的<code>value</code>值，我们一样可以获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ex1.values())<br><br>---<br>dict_values([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>])<br></code></pre></td></tr></table></figure><p>最后，让我们尝试把<code>key</code>和<code>value</code>一起获取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(ex1.items())<br><br>---<br>dict_items([(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;aaaaa&#x27;</span>)])<br></code></pre></td></tr></table></figure><h2 id="字典的遍历">字典的遍历</h2><p>当我们谈到对字典的遍历时，实际上和检测、获取时一样的。只是写进了遍历循环里而已，让我们来看看吧：</p><p>在我们遍历当前字典时，只能获取当前的<code>key</code>,但是我们可以通过获取到的<code>key</code>来完成获取当前<code>key</code>的<code>value</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ex1:<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-string">&#x27;:&#x27;</span>, ex1[i], end=<span class="hljs-string">&quot;; &quot;</span>)<br>    <br>---<br>b : <span class="hljs-number">2</span>; c : <span class="hljs-number">3</span>; aa : aaaaa; <br></code></pre></td></tr></table></figure><p>这种获取方式就显得略微繁琐一点，既然我们之前有提到一个将<code>key</code>和<code>value</code>一起获取到的函数方法，那我们在<code>for</code>里一样可以使用它来将<code>key</code>和<code>value</code>一起获取到，只是，我们需要用到两个参数来接收：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> ex1.items():<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&#x27;:&#x27;</span>, v, end=<span class="hljs-string">&quot;; &quot;</span>)<br>    <br>---<br>b : <span class="hljs-number">2</span>; c : <span class="hljs-number">3</span>; aa : aaaaa; <br></code></pre></td></tr></table></figure><p>既然之前介绍的获取上我们可以单独获取<code>key</code>和<code>value</code>，当然这里也通通能用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历所有的key</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> ex1.keys():<br>    <span class="hljs-built_in">print</span>(k, end=<span class="hljs-string">&quot;; &quot;</span>)<br><br><span class="hljs-built_in">print</span>()<br><br><span class="hljs-comment"># 遍历所有的value</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> ex1.values():<br>    <span class="hljs-built_in">print</span>(v, end=<span class="hljs-string">&quot;; &quot;</span>)<br><br>---<br>b; c; aa; <br><span class="hljs-number">2</span>; <span class="hljs-number">3</span>; aaaaa; <br></code></pre></td></tr></table></figure><h2 id="字典的相关函数">字典的相关函数</h2><p>和列表、元组一样，字典也有一些相关函数。有些嘛，一看到就很熟悉，在其他地方也能用，可是也有一些事字典专用的。</p><p><code>len(dict)</code>: 获取字典的健值对个数</p><p><code>dict.keys()</code>获取当前字典的所有<code>key</code>键，组成的列表</p><p><code>dict.values()</code>获取当前字典的所有<code>value</code>值，组成的列表</p><p><code>dict.items()</code>返回由字典项（（键，值）对）组成一个新视图</p><p><code>iter(dict)</code>返回以字典的键为元素的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-built_in">iter</span>(ex1)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))<br><br>---<br>b<br>[<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;aa&#x27;</span>]<br></code></pre></td></tr></table></figure><p>接下来，让我们重新定义一个新的字典来继续下面的函数学习：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p><code>dict.pop(key)</code>通过<code>key</code>从当前字典中弹出健值对，删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>myDict.pop(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>这里我们需要注意一个点，就是<code>pop()</code>这个函数其实是有返回值的，会返回当前删除的健值对的<code>value</code>,我们拿一个变量来接收一下返回值看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>res = myDict.pop(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>res</code>接收到了<code>pop()</code>方法的返回值<code>1</code></p><p><code>dict.popitem()</code>:后进先出（LIFO）的方式删除健值对，我们这里需要理解一下什么叫后进先出，就是最后一个加入字典的元素，先出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>myDict.popitem()<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>和<code>pop</code>方法一样，<code>popitem</code>方法也会有一个返回值，不过是返回一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = myDict.popitem()<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>(<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>上面我们在讲获取的时候提到，可以直接使用<code>key</code>来获取元素的<code>value</code>，不过如果字典内如果没有这个<code>key</code>的话，程序会报错。除了使用<code>key</code>来直接获取，字典里还有一个<code>get()</code>方法可以用来获取一个元素，用<code>get</code>获取元素存在就返回，不存在也不回报错，而是回返回<code>None</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(myDict.keys(<span class="hljs-string">&#x27;f&#x27;</span>))<br><br>---<br>TypeError: <span class="hljs-built_in">dict</span>.keys() takes no arguments (<span class="hljs-number">1</span> given)<br><br>============<br><span class="hljs-comment"># get方法获取</span><br>myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(myDict.get(<span class="hljs-string">&#x27;f&#x27;</span>))<br><br>---<br><span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>字典的<code>update</code>方法可以更新对字典进行更新，如果这个<code>key</code>存在的话，就是更新。如果<code>key</code>不存在，则会进行添加。<code>update</code>可是使用<code>key = value</code>的形式更新，也可以直接获取一个新字典进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>myDict.update(a=<span class="hljs-number">11</span>, b=<span class="hljs-number">22</span>)<br>myDict.update(&#123;<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">33</span>, <span class="hljs-string">&#x27;f&#x27;</span>:<span class="hljs-number">66</span>&#125;)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">33</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;f&#x27;</span>: <span class="hljs-number">66</span>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际上可以这么理解，update方法在获取其他字典更新原字典就有点像使用数学运算符的+,区别只是，update是强制把最终确定值定为 + 号后方的值。</p></blockquote><p>字典中还有一个方法<code>setdefault()</code>,完整的写法为:<code>dict.setdefault(key[, default])</code>这个方法会去字典中找寻存在的<code>key</code>，并且会返回它的值。如果这个<code>key</code>不存在，这会插入一个值为<code>default</code>的<code>key</code>，并且返回<code>default</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>res = myDict.setdefault(<span class="hljs-string">&#x27;aa&#x27;</span>, <span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br>res = myDict.setdefault(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(myDict)<br><br>---<br><span class="hljs-number">123</span><br><span class="hljs-number">1</span><br>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;aa&#x27;</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，如果这个<code>key</code>在字典中本来就存在，则并不会修改原本<code>key</code>的值，即便你在后面设定了一个<code>default</code>。并且返回的也会是字典内原本的<code>value</code>。也就是说，这个方法只能用来查询和新增。</p><h2 id="字典推导式">字典推导式</h2><p>和之前介绍的数据类型一样，字典也可以使用推导式来实现一些功能。比如：</p><p>字典中的健值对位置进行交换，先用普通的方法实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br><br>newDict = &#123;&#125;<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> myDict.items():<br>    newDict[v] = k<br><br><span class="hljs-built_in">print</span>(newDict)<br><br>---<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>然后再让我们看看字典推导式如何完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>newDict = &#123;v:k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> myDict.items()&#125;<br><span class="hljs-built_in">print</span>(newDict)<br><br>---<br>&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>有的小伙伴可能会在推导式前方只写了一个变量来进行接收，那会变成什么样呢？我们来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>newDict = &#123;v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> myDict.items()&#125;<br><span class="hljs-built_in">print</span>(newDict, <span class="hljs-built_in">type</span>(newDict))<br><br>---<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;set&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以看到，最终打印的字典似乎看起来怪怪的，不是<code>key:value</code>的对形式，而是只有一个值。我们<code>type</code>一下能看到，类型并非是字典，而是<code>set</code>，也就是说这是一个集合。</p><p>来让我们再看一个案例，让我们把一个字典中的<code>value</code>值有偶数的对保留下来，并且交换健值对的位置，一样的，让我们先用普通方式做一遍：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">myDict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;f&#x27;</span>:<span class="hljs-number">6</span>&#125;<br><br><span class="hljs-comment"># 使用普通方式完成</span><br>newDict = &#123;&#125;<br><span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> myDict.items():<br>    <span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        newDict[v] = k<br><span class="hljs-built_in">print</span>(newDict)<br></code></pre></td></tr></table></figure><p>再让我们使用字典推导式来完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">newDict = &#123;v:k <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> myDict.items() <span class="hljs-keyword">if</span> v%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125;<br><span class="hljs-built_in">print</span>(newDict)<br><br>---<br>&#123;<span class="hljs-number">2</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">6</span>: <span class="hljs-string">&#x27;f&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>OK，关于字典的东西基本上也就这么多。在前面学习过字符串和列表之后，是不是其他的<strong>容器类数据</strong>就没那么难了？很多东西都是普遍适用的，所以我们要活学活用，多思考。</p><p>那今天就不留练习题了，咱们下节课是数据类型最后一节了，之后我们开始讲解具体实际应用。字符串和容器类数据是Python中的基础也是重点，大家一定要好好的巩固。</p><p>下一节：集合。咱们下节课再见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807194318.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍-dictionary&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>10. 数据类型 - 元组详解</title>
    <link href="https://hivan.me/Detailed-of-tuple/"/>
    <id>https://hivan.me/Detailed-of-tuple/</id>
    <published>2023-08-07T03:44:38.000Z</published>
    <updated>2023-08-07T10:37:50.276Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807182811.png?imgNote"alt="茶桁的AI秘籍 Python - tuple" /></p><p>Hi，大家好。我是茶桁。</p><p>之前两节分别介绍了字符串和列表，今天，我们来讲讲另外一个常用到的数据类型：元组。</p><span id="more"></span><p>元组和列表很像，两者都是一组有序的数据的组合。但是也有很多不同点，比如元组内的元素一旦定义了就不可以再修改，因此元组称为<strong>不可变数据类型</strong>。</p><h2 id="元组定义">元组定义</h2><p>元组的定义方式包括以下要点：</p><ul><li>定义元组<code>变量 = ()</code>, 或者<code>变量 = tuple()</code></li><li>可以使用<code>变量 = (*iterable)</code>定义含有数据的元组</li><li>⚠️需要注意：如果元组中只有一个元素时，这唯一的元素后面也必须加逗号，这是为了区分其他元素标识这是一个元组:<code>(1,)</code></li><li>特例： <code>变量 = 1,2,3</code>，这种方式也可以定义为一个元组。</li></ul><h2 id="元组的相关操作">元组的相关操作</h2><p>由于元组是一个不可变的数据类型，因此其在创建之后只能使用索引进行访问，无法进行其他操作。访问方式其实和列表一样，同样可以使用切片方式获取元素。</p><p>元组可以进行切片操作，在访问数据这件事情上和列表几乎一样，没有什么区别，所以完全可以借鉴上一节我讲的内容来看，这里就不详细介绍了，仅仅给大家写出一些案例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常见的元组切片索引查询操作</span><br>tup = <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[:]:\t&#x27;</span>,tup[:]) <span class="hljs-comment"># 获取全部</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[::]:\t&#x27;</span>, tup[::]) <span class="hljs-comment"># 获取全部</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[1:]:\t&#x27;</span>, tup[<span class="hljs-number">1</span>:]) <span class="hljs-comment"># 从索引1开始获取到最后</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[1:3]:\t&#x27;</span>, tup[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 从索引1开始索引到3之前</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[:3]:\t&#x27;</span>, tup[:<span class="hljs-number">3</span>]) <span class="hljs-comment"># 从0开始索引到3之前</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[1:5:2]:\t&#x27;</span>, tup[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]) <span class="hljs-comment"># 从1开始索引到5之前，步进值为2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[::2]:\t&#x27;</span>, tup[::<span class="hljs-number">2</span>]) <span class="hljs-comment">#从0开始索引到最后，步进值为2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[5:1:-1]:\t&#x27;</span>, tup[<span class="hljs-number">5</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 从5开始往前索引到1， 步进值为-1。</span><br><br>---<br>[:]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>[::]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>[<span class="hljs-number">1</span>:]: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]: (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>[:<span class="hljs-number">3</span>]: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>]: (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>[::<span class="hljs-number">2</span>]: (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>)<br>[<span class="hljs-number">5</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>]: (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>除了常用的切片操作之外，和列表一样，元组也能使用一些基本函数来完成查询操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取元组的长度</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(tup))<br><br><span class="hljs-comment"># 统计一个元素在元组中出现的次数</span><br><span class="hljs-built_in">print</span>(tup.count(<span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 获取一个元素在元组内的下标（索引值）</span><br><span class="hljs-built_in">print</span>(tup.index(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>))<br><br>---<br><span class="hljs-number">10</span><br><span class="hljs-number">2</span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>除此之外，元组还可以引用基础的数学运算符<code>+</code>和<code>*</code>来进行加和乘的运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加和乘操作</span><br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) + (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) * <span class="hljs-number">5</span>)<br><br>---<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>有一个同学曾经问过我：既然元组是不可修改的，那为什么还能用加和乘的运算呢？</p><p>不知道在座的小伙伴有没有这种想法？</p><p>这样吧，我重新写一段代码，小伙伴们应该就明白了:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 元组是这样的</span><br>tup = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(tup))<br>tup2 = (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>tup = tup + tup2<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(tup))<br><br>---<br><span class="hljs-number">4446580864</span><br><span class="hljs-number">4450629120</span><br><span class="hljs-number">4450647984</span><br><span class="hljs-number">4459297216</span><br></code></pre></td></tr></table></figure><p>不知道大家看明白没有。解释一下，其实就是说，在进行加法和乘法运算的时候，即便我们的变量名是一样的，实际上也是生成了一个新的元组，而不是之前那一个了。所以这个并非是修改和更新，而是创建。</p><p>为了对比，我再写一段更新的代码给大家看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试更新元组</span><br>tup = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><span class="hljs-built_in">print</span>(tup[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">del</span> tup[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(tup)<br><br>---<br>TypeError: <span class="hljs-string">&#x27;tuple&#x27;</span> <span class="hljs-built_in">object</span> doesn<span class="hljs-string">&#x27;t support item deletion</span><br></code></pre></td></tr></table></figure><p>可以看到，报错提示了，<code>tuple</code>对象不支持删除项目</p><p>作为对比，我们看看列表的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 看看列表更新（只看id）</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-keyword">del</span> items[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items), <span class="hljs-string">&#x27;\t&#x27;</span>,items)<br><br>---<br><span class="hljs-number">4450415936</span><br><span class="hljs-number">4450415936</span>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p>可以看到，不仅是内部元素被删除了，并且<code>id</code>完全没有变化。也就是说，我们是在这个列表本身做了删除动作，并未生成新的列表。关于这部分，我们上一节中的深拷贝和浅拷贝讲的很清楚，大家可以回去好好看看理解一下。</p><h2 id="元组推导式-生成器">元组推导式 生成器</h2><p>在起初，我们先来看看元组是否和列表一样支持使用推导式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(tup)<br><br>---<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x109cfa570</span>&gt;<br></code></pre></td></tr></table></figure><p>这段并非是报错，而是打印出了<code>tup</code>的类型：生成器对象。</p><p>我们之前学过，使用列表推导式生成的结果是一个列表，但是元组似乎和列表并不一样，生成的结果是一个生成器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">列表推导式 ==&gt; [变量运算 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 容器]  ==&gt; 结果 是一个 列表<br>元组推导式 ==&gt; (变量运算 <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 容器)  ==&gt; 结果 是一个 生成器<br></code></pre></td></tr></table></figure><p>那这里就有个疑问了，什么是生成器？</p><p>生成器是一个特殊的迭代器，生成器可以自定义，也可以使用元组推导式去定义。</p><p>生成器是按照某种算法去推算下一个数据或结果，只需要往内存中存储一个生成器，节约内存消耗，提升性能。</p><p><strong>语法</strong></p><ol type="1"><li>里面是推导式，外面是一个()的结果就是一个生成器</li><li>自定义生成器，含有yield关键字的函数就是生成器</li></ol><p>那么，我们到底应该怎样操作生成器呢？</p><p>既然生成器是迭代器的一种，那我们是否可以使用迭代器的操作方法来操作生成器呢？</p><p>说干就干，让我们直接操作做实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(tup))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(tup))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(tup))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(tup))<br><br>---<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>没毛病，确实支持<code>next()</code>函数，并且内部元素在使用后也被移除了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 让我们将其转为元组</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tuple</span>(tup))<br><br>---<br>()<br></code></pre></td></tr></table></figure><p>哎，为什么里面是空的？那是因为，我们上一段代码中的最后一句，已经讲所有迭代器内的元素转为了列表，素衣目前迭代器<code>tup</code>内是没有任何元素了，所以我们转过来必须是空的。</p><p>再来生成一个，我们来试试用<code>for</code>对它进行循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">tup = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tup:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>    <br>---<br><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><p>可以看到结果没有问题。可以推断出，生成器和迭代器没有任何区别，我们在平时使用的时候，就直接将它作为迭代器使用就可以了。</p><h2 id="yield关键字">yield关键字</h2><p>在之前，我们提到了，含有<code>yield</code>关键字的函数就是生成器。</p><p>它返回的结果是一个迭代器。我们可以理解为，生成器函数就是一个返回迭代器的函数。</p><p>那么<code>yield</code>有哪些需要注意的点呢？我们先在下面列一下，之后再带着大家一起过：</p><p><code>yield</code>和函数中的<code>return</code>有点像</p><ul><li>共同点： 执行到这个关键字后会把结果返回来</li><li>不同点：<ul><li><code>return</code>会把结果返回，并结束当前函数的调用</li><li><code>yield</code>会返回结果，并记住当前代码执行的位置，下一次调用时会从上一次离开的位置继续向下执行。</li></ul></li></ul><p>上实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义一个普通函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br><br>func()<br>func()<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello <span class="hljs-keyword">yield</span><br></code></pre></td></tr></table></figure><p>在这个自定义函数内，<code>return</code>执行的时候，就会结束当前函数的调用，而在之前，第一个<code>print()</code>函数正确执行了，但是第二个<code>print()</code>函数因为在<code>return</code>之后，所以并未运行。即便我们一共执行了两次函数，可是也仅仅是讲第一个<code>print()</code>函数执行了两次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><span class="hljs-built_in">next</span>(res)<br><span class="hljs-built_in">next</span>(res)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello again<br></code></pre></td></tr></table></figure><p>可以看到，当我们使用<code>next()</code>函数的时候，迭代器起作用了，每执行一次，分别调用第一个<code>yield</code>之前和之后的<code>print()</code>，也就是说<strong>继续</strong>执行了。</p><p>那如何验证<code>yield</code>的返回呢？我们将这段代码改造一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><span class="hljs-built_in">str</span> = <span class="hljs-built_in">next</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><span class="hljs-built_in">str</span> = <span class="hljs-built_in">next</span>(res)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">yield</span><br>Hello again<br><span class="hljs-keyword">return</span> again<br></code></pre></td></tr></table></figure><p>没问题，依次打印出了返回值<code>return yield</code>和<code>return again</code>。</p><p>还记得我们之前教过，使用<code>list</code>函数去调用，可以讲迭代器的返回结果，作为容器的元素，让我们再来改造一下这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><br>items = <span class="hljs-built_in">list</span>(res)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello again<br>[<span class="hljs-string">&#x27;return yield&#x27;</span>, <span class="hljs-string">&#x27;return again&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们看见，确实，返回结果被依次放入了一个<code>list</code>容器中。</p><p>当然，除了<code>list</code>函数之外，还可以使用<code>for</code>来获取迭代器内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 尝试使用yield定义一个生成器函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello yield&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return yield&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello again&#x27;</span>)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;return again&#x27;</span><br><br><span class="hljs-comment"># 调用生成器函数， 返回一个迭代器</span><br>res = func()<br><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> res:<br>    items.append(i)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>Hello <span class="hljs-keyword">yield</span><br>Hello again<br>[<span class="hljs-string">&#x27;return yield&#x27;</span>, <span class="hljs-string">&#x27;return again&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们来分析一下在以上这几段代码中，生成器函数调用时到底是什么过程。</p><p>首先，调用生成器函数，返回一个迭代器：</p><ol type="1"><li>第一次去调用迭代器，走到当前的生成器函数中，遇到第一个<code>yield</code>,把<code>return yield</code>返回，并且记住当前的执行状态（位置），暂停了执行，等待下一次的调用</li><li>第二次去调用迭代器，从上一次遇到的<code>yield</code>位置开始执行，遇到了第二个<code>yield</code>，把<code>return again</code>返回，并重新记录状态，暂停执行，等待下一次调用。</li><li>如果最后又调用了迭代器，那么会从上一次的<code>yield</code>位置开始，可是后面没有了，就会超出范围，抛出异常：<code>StopIteration:</code>。</li></ol><p>那么这种一次一次调用执行的方式什么时候适用呢？比如说，我们在处理一个非常大的数据，电脑可能吃不住，这个时候我们就可以拆开来一次一次的执行获取结果。</p><h2 id="小练习">小练习</h2><blockquote><ol type="1"><li>为了能达到练习的目的，从这一节开始，所有练习可以不在课程中展示了。大家先做一下，然后可以在我下一节课中的源码中去找答案，然后来看看和自己做的是否一样。</li><li>以下所有练习必须使用列表推导式来实现</li><li>有些练习不止一个方法，大家尝试用多种方法来实现一下。</li><li>做完的小伙伴可以在课程后面留言讨论。</li><li>上一节的练习已经放到本次教程的源码内，可以在此获取：https://github.com/hivandu/AI_Cheats/tree/main/Python</li></ol></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">今天就一个练习：使用生成器改写斐波那契数列函数<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807182811.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍 Python - tuple&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;之前两节分别介绍了字符串和列表，今天，我们来讲讲另外一个常用到的数据类型：元组。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>9. 数据类型 - 列表详解</title>
    <link href="https://hivan.me/Detailed-of-list/"/>
    <id>https://hivan.me/Detailed-of-list/</id>
    <published>2023-08-06T06:45:03.000Z</published>
    <updated>2023-08-07T13:17:11.602Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://qiniu.hivan.me/picGo/20230807211708.png?imgNote"alt="茶桁的AI秘籍" /></p><p>Hi，大家好。我是茶桁。</p><p>最近几节课，我们都是在详细讲解Python内的数据类型，上一节课我们详细了解了字符串，这节课，让我们来详解一下列表。</p><span id="more"></span><p>首先，我们先有一个大的概念，列表，其实就是<strong>一组有序的数据组合</strong>；另外，列表中的数据是可以被修改的。也就是说，列表是<strong>一个可变序列类型</strong>。</p><h2 id="列表定义">列表定义</h2><p>如何在Python的定义列表，记住以下几点就可以了：</p><ul><li>可以使用中括号进行定义<code>[]</code></li><li>可以使用<code>list()</code>函数定义</li><li>还可以使用列表推导式定义: <code>[x for x in iterable]</code></li><li>在定义列表中的元素时，需要在每个元素之间使用逗号（英文逗号），进行分隔。<code>[1, 2, 3]</code></li><li>列表中的元素可以是任意类型，通常用于存放同类项目的集合。</li></ul><h2 id="列表的基本操作">列表的基本操作</h2><p>让我们先来定义一个列表:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items2 = <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;1234&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(items,<span class="hljs-string">&#x27;\n&#x27;</span>, items2)<br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <br> [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我们使用了最基本的两个方式来定义列表。至于<strong>列表推导式</strong>，先不用着急，我们后面会单独讲它。</p><p>我们可以看到，刚才我刻意将<code>item</code>和<code>items</code>两个列表定义了不同种类的元素，那他们到底能否拼接在一起？我们尝试一下列表的相加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items + items2)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br></code></pre></td></tr></table></figure><p>没问题，两种不同类型的元素拼接到了一起，组成了一个新的列表。</p><p>让我们将这段代码搞的复杂一点，新的列表对于我要的模拟数据来说太少了，我想再增加5倍的长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>((items + items2) * <span class="hljs-number">5</span>)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br></code></pre></td></tr></table></figure><p>没毛病，也就是说，我将小学学到的基本数学运算用到这里完全适用。</p><p>那如果用到减法呢，虽然难以想象最后的结果，试试中可以：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items - items2)<br><br>---<br>TypeError: unsupported operand <span class="hljs-built_in">type</span>(s) <span class="hljs-keyword">for</span> -: <span class="hljs-string">&#x27;list&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;list&#x27;</span><br></code></pre></td></tr></table></figure><p>果然是我想多了，完全不支持操作数类型。</p><p>那是不是关于列表的操作也就到此为止了？并不是，列表除了利用加和乘进行拼接和循环的操作之外，还有很多其他的基本操作，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items[<span class="hljs-number">2</span>] = <span class="hljs-number">9</span><br><span class="hljs-built_in">print</span>(items, <span class="hljs-string">&quot;\t&quot;</span>,items[<span class="hljs-number">3</span>])<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>]  <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>这里，我们利用了列表的下标操作修改了列表内的下标<code>[2]</code>的元素（第三个），并且将修改后的列表和列表内下标<code>[3]</code>的元素打印了出来。</p><p>有这样一种情况大家想过没有，这个列表呢，我并不知道有多长，但是我知道最后一个数字，现在我就想把最后一个数字取出来该怎么办？用<code>len()</code>获取长度之后再-1?是不是太麻烦了？</p><p>还记得之前咱们讲过，下标是可以从后往前数的吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">items[-<span class="hljs-number">1</span>]<br><br>---<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>嗯，我想再这个列表添加几个数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">items[<span class="hljs-number">4</span>] = <span class="hljs-number">10</span><br><br>---<br>IndexError: <span class="hljs-built_in">list</span> assignment index out of <span class="hljs-built_in">range</span><br></code></pre></td></tr></table></figure><p>哎，我似乎想的并不对。本以为原列表下标<code>[3]</code>是最后一个元素，那我多加一个下标就会再多加一个元素，可是似乎并不行。那么我们该怎么在列表内最佳元素呢？</p><p>可以尝试一下专门添加元素的<code>append()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items.append(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>加是加了，可是我们之前是想加<code>10</code>的，现在不小心加成<code>2</code>了，不行，我要删了它。该怎么办？随便吧，我就记得windows的CMD命令中的删除文件似乎是<code>del</code>，试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> items[-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>居然成了...这就神奇了。看起来，Python并不是很难。不过我们这里不得不说，在Python中还有一个针对列表删除元素的方法：<code>pop()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items.pop()<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><code>pop([index=-1])</code>函数专门用于移除列表中的一个元素，其中参数<code>index</code>为索引值，默认为<code>-1</code>，也就是说默认是从列表移除最后一个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将索引值改为从前数第一个</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>items.pop(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><h2 id="列表中的切片">列表中的切片</h2><p>在学习了列表的基本操作之后，我们来看看列表中的切片。提前说一声，在数据分析的应用中，对数据整理的过程绝大多数时候都需要用到列表的切片操作，所以大家这部分要好好理解。</p><p>列表的切片操作基本语法其实很简单</p><p><code>list[开始值:结束值:步进值]</code></p><p>看起来很熟悉对吧？在我们之前介绍<ahref="../Detailed-of-string/">字符串相关的操作</a>的时候，就是这种方式。其用法和字符串中也是如出一辙：</p><ul><li><code>list[开始值:]</code> 从开始值索引到列表的最后</li><li><code>list[:结束值]</code>从列表最前面索引到结束值之前</li><li><code>list[开始值:结束值]</code>按照给到的开始值开始索引，到结束值之前为止。</li></ul><p>当然，除了这三个基本的操作之外还有<code>list[::], list[::步进值], list[开始值::步进值], list[:结束值:步进值],list[开始值:结束值:步进值]</code>，我们下面一一的来看看，在字符串相关操作中没有特别理解的没关系，这里再来加深下印象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先来定义一个列表方便后续操作</span><br>items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>从开始值索引到最后：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items[<span class="hljs-number">2</span>:])<br><br>---<br>[<span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从下标<code>[2]</code>开始，也就是从第三个<code>Ruby</code>开始向后索引。</p><p><strong>从最前面索引到结束值之前：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items[:<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>]<br></code></pre></td></tr></table></figure><p>现在我们让这两个语言单独露脸，算是对它们进行补偿了。</p><p><strong>从开始值索引到结束值之前：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(items[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>])<br><br>---<br>[<span class="hljs-string">&#x27;Ruby&#x27;</span>]<br></code></pre></td></tr></table></figure><p>哎，为什么只索引出来一个值？因为结束值为<code>3</code>，它之前不就是<code>2</code>吗。开始值也是<code>2</code>，那可不就只有一个值而已。</p><p>这回，<strong>我们把步进值加上：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加上步进值</span><br><span class="hljs-built_in">print</span>(items[<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从最前面索引到最后，步进值为<code>2</code>，所以是隔一个索引一个。那为什么<code>PHP</code>没索引到？估计你又忘了，是索引到结束值之前，不包含结束值，自然<code>PHP</code>就没被索引到。</p><p><strong>只有步进值</strong>会是什么情况？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只有步进值</span><br><span class="hljs-built_in">print</span>(items[::-<span class="hljs-number">2</span>])<br><br>---<br>[<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br></code></pre></td></tr></table></figure><p>步进值为负数，那显然是从后向前索引了。隔一个索引一个，等等，为啥第一个<code>Python</code>被索引到了？那是因为，当我们开始值和结束值都没取值的情况下，默认是从头到尾索引，现在嘛，应该是从尾到头索引。也就是包含了头尾，不存在最后一个值之前，所以列表内的所有值都索引了一个遍，只是因为有步进值的关系，所以变成隔一个索引一个。</p><p>再让我们<strong>将所有值都去掉</strong>，只留下<code>[::]</code>试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删掉所有值试试</span><br><span class="hljs-built_in">print</span>(items[::])<br><span class="hljs-built_in">print</span>(items[:])<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>]<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>]<br></code></pre></td></tr></table></figure><p>从结果上看，中括号内一个冒号和两个冒号出来的结果是一样的。</p><p>在索引查找之后，我们来看看，利用切片的方式是否可以对列表内的元素进行更新和删除？</p><p>从指定下标开始，到指定下标前结束，并替换为对应的数据(容器类型数据，会拆分成每个元素进行赋值)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>指定的切片内的元素被替换掉了。</p><p>刚才我们使用切片替换元素的时候元素是一一对应的，那如果我们没有对应的话会发生什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片范围大于添加元素的个数</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>] = [<span class="hljs-number">7</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>结果并没有报错，而是将切片范围内的元素都移除之后添加了一个元素<code>7</code>。我们再试试其他的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># # 切片范围小于添加元素的个数</span><br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>] = [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>可以看到，比起原本的列表，我们的值增加了。原本下标<code>[2]</code>的元素被移除之后，在这个位置插入了<code>[7,8,9,0]</code>四个元素。</p><p>以此，我们可以总结切片更新列表，实际上就是删除掉切片范围内的元素，再在原来的位置上插入新加的元素，并且将之后的元素向后移动。</p><p>那既然这样的话，我们是不是可以利用这种特性对列表内的元素进行删除？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>] = []<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>没毛病，确实可以这么用。</p><p>当然，除了这种插入空列表的方式之外，还有其他方式可以删除列表内的指定元素,还记得前面我们介绍的<code>del</code>方法吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">del</span> items[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><p>那既然我们可以用添加空列表的方式来删除列表内的元素，<code>del</code>是不是就没用武之地了？实际上，并非如此。<code>del</code>有一个特殊的用法，就是在利用步进值来跳着删除元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">del</span> items[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>:<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>那聪明的小伙伴肯定想，添加空列表的方式也加上步进值就不行吗？我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>] = []<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>ValueError: attempt to assign sequence of size <span class="hljs-number">0</span> to extended <span class="hljs-built_in">slice</span> of size <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>报错提示我们，序列分配不正确。说明我们不能这样使用。如果要这样使用的话，替换的元素个数必须对应才行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>items[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>] = [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure><h2 id="列表相关函数-重点">列表相关函数(✨ 重点)</h2><p>除了以上介绍的关于列表的一些方法之外，Python还为我们提供了一些列表常用的相关函数：</p><p><strong><code>len()</code></strong></p><p>这个函数可以检测当前列表的长度，列表中元素的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br><span class="hljs-built_in">len</span>(items)<br><br>---<br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong><code>count()</code></strong></p><p>这个函数可以检测当前列表中指定元素出现的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">items.count(<span class="hljs-string">&#x27;Python&#x27;</span>)<br><br>---<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong><code>append()</code></strong></p><p>这个函数前面我们已经介绍过了，就是向列表尾部追加新的元素，返回值为None。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items.append(<span class="hljs-string">&#x27;SQL&#x27;</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;SQL&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong><code>insert()</code></strong></p><p>这个函数可以向列表中指定的索引位置添加新的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items.insert(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;Go&#x27;</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;SQL&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong><code>pop()</code></strong></p><p>还记得我们之前删除列表中元素的时候介绍<code>pop()</code>函数吗？其实，<code>pop()</code>函数是对指定索引位置上的元素做出栈操作，然后返回出栈的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br><span class="hljs-built_in">print</span>(items.pop())<br><span class="hljs-built_in">print</span>(items.pop(<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>PHP<br>Ruby<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>]<br></code></pre></td></tr></table></figure><p>默认的情况下，<code>pop()</code>是把列表的最后一个元素出栈，当给值之后，是将指定索引的元素进行出栈。</p><p><strong><code>remove()</code></strong></p><p>这个函数是专门删除特定元素用的，可以指定列表中的元素进行删除，只删除第一个，如果没有找到，则会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.remove(<span class="hljs-string">&#x27;PHP&#x27;</span>)<br><span class="hljs-built_in">print</span>(items)<br>items.remove(<span class="hljs-string">&#x27;Go&#x27;</span>)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>]<br>ValueError: <span class="hljs-built_in">list</span>.remove(x): x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p>可以看到，第一个<code>remove</code>成功删除了<code>PHP</code>，但是第二个<code>remove</code>并未在列表中找到<code>Go</code>，所以报错。</p><p><strong><code>index()</code></strong></p><p>这个函数可以查找指定元素在列表中第一次出现的索引位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.index(<span class="hljs-string">&#x27;PHP&#x27;</span>)<br><br>---<br><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>除此之外，<code>index()</code>还能接收索引值，当输入索引值的时候，<code>index()</code>会在指定范围内查找元素的索引位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br><span class="hljs-built_in">print</span>(items.index(<span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>))<br>items.index(<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br><br>---<br><span class="hljs-number">2</span><br>ValueError: <span class="hljs-string">&#x27;PHP&#x27;</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p>可以看到，指定范围内没有说要查找的元素的时候就会报错，告知元素不在列表内。</p><p><strong><code>extend()</code></strong></p><p>这个函数接收一个容器类型的数据，把容器的元素追加到原列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = [<span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;MATLAB&#x27;</span>]<br>items.extend(a)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;Go&#x27;</span>, <span class="hljs-string">&#x27;MATLAB&#x27;</span>]<br></code></pre></td></tr></table></figure><p>看到这，是不是感觉很像两个列表相加？那既然我们可以将两个列表相加了，这个方法似乎有些多余了。</p><p>这么想的小伙伴们，我们再来看两段示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>items.extend(a)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>另外一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>items = items + a<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>TypeError: can only concatenate <span class="hljs-built_in">list</span> (<span class="hljs-keyword">not</span> <span class="hljs-string">&quot;tuple&quot;</span>) to <span class="hljs-built_in">list</span><br></code></pre></td></tr></table></figure><p>可以看到，第二段代码直接报错了。那说明，相加这个操作必须两个都是列表才可以，不支持列表和元组相加。可是<code>extend()</code>方法是支持将任意一个容器类型的数据中的元素追加到原列表中的。</p><p>我们再来多看一段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>a = <span class="hljs-string">&#x27;1234&#x27;</span><br>items.extend(a)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br></code></pre></td></tr></table></figure><p>将<code>a</code>定义为一段字符串，一样可以使用<code>extend()</code>来接收并追加到原列表内。</p><p><strong><code>clear()</code></strong></p><p>这个函数比较简单，就是清空列表内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br></code></pre></td></tr></table></figure><p><strong><code>reverse()</code></strong></p><p>这个函数可以对列表进行翻转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.reverse()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong><code>sort()</code></strong></p><p>该函数将对列表进行排序,在默认的情况下，会对元素进行从小到大的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Rust&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Swift&#x27;</span>,<span class="hljs-string">&#x27;JavaScript&#x27;</span>,<span class="hljs-string">&#x27;Node&#x27;</span>,<span class="hljs-string">&#x27;PHP&#x27;</span>]<br>items.sort()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;C++&#x27;</span>, <span class="hljs-string">&#x27;Java&#x27;</span>, <span class="hljs-string">&#x27;JavaScript&#x27;</span>, <span class="hljs-string">&#x27;Node&#x27;</span>, <span class="hljs-string">&#x27;PHP&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>, <span class="hljs-string">&#x27;Ruby&#x27;</span>, <span class="hljs-string">&#x27;Rust&#x27;</span>, <span class="hljs-string">&#x27;Swift&#x27;</span>]<br></code></pre></td></tr></table></figure><p>额，这样似乎并不明显，我们重新换个案例。不过大家也可以想想现在这段代码中，为什么会有这样的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>]<br>items.sort()<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>嗯，这回明显了。</p><p>除了从小到大排序外，我们还可以将其从大到小排序，利用关键参数<code>reverse</code>来开启：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>]<br>items.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>OK，现在让我们来回过头来解释一下第一段代码中的结果：<code>['C++', 'Java', 'JavaScript', 'Node', 'PHP', 'Python', 'Ruby', 'Rust', 'Swift']</code>，之所以会产生这样的结果，不是因为它按英文字母来排序，当然这么想也对但是不全对，而是因为它的排序依据是ASCII码，之前我们学习过，ASCII码只包含了128个字符，仅仅是美国的标准，128个字符里面都是西文码，那么如果中间包含了中文会怎样呢？</p><p>不如我们直接来看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;茶&#x27;</span>, <span class="hljs-string">&#x27;桁&#x27;</span>]<br>items.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>TypeError: <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">not</span> supported between instances of <span class="hljs-string">&#x27;int&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></td></tr></table></figure><p>完了，直接报错。不过这个似乎和编码无关，而是数据类型的问题，告诉我们字符和整型之间不能排序。别问我怎么看懂的，我也是查字典。</p><p>知道是数据类型的问题就好办了，我们将数据类型变成一致的再试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;茶&#x27;</span>, <span class="hljs-string">&#x27;桁&#x27;</span>]<br>items.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-string">&#x27;茶&#x27;</span>, <span class="hljs-string">&#x27;桁&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>]<br></code></pre></td></tr></table></figure><p>居然成功了，那既然是ASCII码，那为什么还会支持中文排序呢？还记得我们除了介绍ASCII码之外，还介绍过一个Unicode编码。那即是说，Python中的<code>sort()</code>排序的依据是<code>Unicode</code>编码。</p><p>当然，除了默认规则之外，我们还可以自己对排序进行干预，加上你想要的规则。<code>sort(key)</code>内的<code>key</code>参数可以接收一个函数，按照函数的处理结果进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [-<span class="hljs-number">5</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">6</span>]<br>items.sort(key=<span class="hljs-built_in">abs</span>)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">6</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br></code></pre></td></tr></table></figure><p>这一段是不是让小伙伴们想到之前我们在<ahref="../python-Built-in-functions">Python的内置函数</a>中介绍高阶函数的内容？没错，就是一样的。所以，我们这次就不对函数内部排序过程进行分析了，有兴趣的小伙伴可以回去看看第七节的内容。</p><h2 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h2><p>接着，让我们来看看关于拷贝的问题，先说浅拷贝。</p><p>说到浅拷贝，实际上是仅拷贝了列表中的一维元素，如果列表中存在二维元素或容器，则为引用而不是拷贝。使用<code>copy</code>函数或者<code>copy</code>模块中的<code>copy</code>函数拷贝的都是浅拷贝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>res = items.copy()<br><span class="hljs-built_in">print</span>(items, <span class="hljs-string">&#x27;\t&#x27;</span>, res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><code>copy()</code>之后的新列表和原列表内容上是一样的。</p><p>接着让我们来操作一下<code>copy</code>之后的<code>res</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>res = items.copy()<br><span class="hljs-keyword">del</span> res[<span class="hljs-number">2</span>]<br><span class="hljs-built_in">print</span>(items)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>可以看到，对<code>res</code>进行操作完全不影响原列表的内容。这就说明，<code>copy</code>产生的新列表和原列表并不是一个列表，我们可以验证一下看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><br>---<br><span class="hljs-number">4636359872</span><br><span class="hljs-number">4636086464</span><br></code></pre></td></tr></table></figure><p>当我们用<code>id()</code>函数的时候，可以看到他们是两个完全不同的<code>id</code></p><p>刚才我们定义的<code>items</code>是一个一维列表，接着让我们再来定义一个多维列表来尝试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>res = items.copy()<br><span class="hljs-keyword">del</span> res[<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(items)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>我们可以看到，做删除操作之后，<code>res</code>内容变了，但是原列表<code>items</code>没变化。似乎和之前的并没有什么不同，让我们再继续试试:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> res[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>发生了什么？我们明明是操作的<code>res</code>而不是原列表<code>items</code>，为什么<code>items</code>也发生了变化？难道是<code>id</code>是相同的吗？来，试试就知道了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><br>---<br><span class="hljs-number">4636427264</span><br><span class="hljs-number">4636085824</span><br></code></pre></td></tr></table></figure><p>似乎并不相同。那既然不是同一个元素，为什么我们操作<code>res</code>的时候，<code>items</code>也会跟着一起变化？</p><p>别着急，让我们接着看下面的操作:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items[<span class="hljs-number">4</span>])) <span class="hljs-comment"># items这个位置是列表[&#x27;a&#x27;, &#x27;c&#x27;]</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res[<span class="hljs-number">3</span>])) <span class="hljs-comment"># res这个位置是列表[&#x27;a&#x27;, &#x27;c&#x27;]</span><br><br>---<br><span class="hljs-number">4635245952</span><br><span class="hljs-number">4635245952</span><br></code></pre></td></tr></table></figure><p>如何，一模一样对吧？这就说明，在<code>items</code>以及它的copy列表<code>res</code>中，这个嵌套的列表是同一份。这也就能解释为什么我们对<code>res</code>内的嵌套列表进行操作的时候,<code>items</code>也发生了变化。</p><p>这个就是我们在一开始说到的，<code>copy</code>仅仅是拷贝了列表中的一维元素，对二维元素和容器仅仅是引用，这个应用对象当然还是原来那个对象。所以，两者的<code>id</code>才是是同一个。</p><p>浅拷贝我们理解完之后，才看看什么是深拷贝。</p><p>深拷贝和浅拷贝比起来就有深度的多，嗯，这么讲是因为深拷贝不仅仅是拷贝了当前的列表，同时还把列表中的多维元素或容易也拷贝了一份，而不是像浅拷贝一样仅仅是引用。完成深拷贝的函数是<code>copy</code>模块中的<code>deepcopy</code>函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>res = items.deepcopy()<br><br>---<br>AttributeError: <span class="hljs-string">&#x27;list&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;deepcopy&#x27;</span><br></code></pre></td></tr></table></figure><p>额，尴尬。居然报错了...似乎<code>deepcopy</code>并不是和<code>copy</code>函数一样的用法。</p><p>细心的小伙伴应该之前就注意到了，在介绍<code>copy</code>函数和<code>deepcopy</code>函数的时候，我都在强调是<code>copy</code>模块中的这句话，确实，我们在使用<code>deepcopy</code>的时候，是需要先引用模块再使用的，并且，使用方式也有一些不同:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>items = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br>res = copy.deepcopy(items)<br><span class="hljs-built_in">print</span>(res)<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]]<br></code></pre></td></tr></table></figure><p>没错，我们这就对<code>items</code>完成了深拷贝，生成了新的列表<code>res</code>。</p><p>那到底是否是真的深拷贝呢？让我们试一试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(items[<span class="hljs-number">3</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res[<span class="hljs-number">3</span>]))<br><br>---<br><span class="hljs-number">4636282048</span><br><span class="hljs-number">4634799872</span><br><span class="hljs-number">4636285120</span><br><span class="hljs-number">4637491072</span><br></code></pre></td></tr></table></figure><p>没问题，我们打印出来的<code>id</code>各不一样，包括<code>items</code>内的二维列表以及<code>res</code>内的二维列表，<code>id</code>也都不同，说明确实是深拷贝。</p><p>不放心的小伙伴，我们再来更改列表元素测试一下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">del</span> res[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]<br><br><span class="hljs-built_in">print</span>(res[<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(items[<span class="hljs-number">3</span>])<br><br>---<br>[<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>可以看到，当我们更改<code>res</code>内的二维列表时，<code>items</code>并未发生改变。说明二维列表我们也一样完成了拷贝，而不是像浅拷贝一样仅是引用了。</p><h2 id="列表推导式">列表推导式</h2><p>在本文最开始，我们介绍列表的时候提过三种列表生成方式，包括直接定义列表,用<code>list</code>函数，最后一个就是列表推导式。那我们接下来，就要详细讲讲列表推导式。</p><p>列表推导式提供了一个更简单的创建列表的方法，常见的用法是把某种操作应用于序列或可迭代的每个元素上，然后使用其结果来创建列表，或者通过满足某些特定条件元素来创建子序列。</p><p>采用一种表达式的当时，对数据进行过滤或处理，并且把结果组成一个新的列表。</p><p>哎，最怕就是定义和文字过多，让我们直接上示例吧。</p><h3 id="基本的列表推导式使用方式">基本的列表推导式使用方式</h3><p><code>结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据]</code></p><p>现在，假设我们想要创建一个平方列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用普通方法完成</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    items.append(i**<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p>这是用我们所学过的内容来进行创建，当然，我们还学过另外一种方式:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用 map函数和list完成</span><br>items = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p>这里似乎有一点复杂，咱们还是来分析一下吧。</p><p>首先，我们创建了一个匿名函数<code>lambda x:x**2</code>,再创建了一个可迭代对象<code>range(10)</code>。</p><p>接着，我们给<code>map</code>函数传入了这两个参数，分别传给了<code>func</code>和<code>*iterables</code>,关于<code>map</code>函数，我们在第七节：内置函数中有讲解过，完了的小伙伴可以翻看前面复习一下。</p><p><code>map</code>函数在对传入的可迭代数据中的每一个元素进行处理，然后返回一个新的迭代器,最后用<code>list</code>函数将这个新的迭代器转换成了一个列表。</p><p>然后，我们将传入的<code>func</code>函数用一个匿名函数</p><p>没错，我们使用<code>map</code>函数和<code>list</code>也可以进行实现。</p><p>那么最后，让我们来看看列表推导式如何完成这个需求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表推导式</span><br>items = [i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><p>简简单单一句话，比用<code>map</code>函数更简单的逻辑，就完成了我们的需求。这一句话的代码其实逻辑桁清晰，也很好理解：</p><p>首先，我们用<code>for</code>来进行循环传值给<code>i</code>，接着，我们用<code>i**2</code>来得到我们期望的值，最后生成列表。本质上，其实和我们用的第一种普通方法是一样的。</p><p>接着我们再来看一个， 我们现在有一个字符串<code>'1234'</code>，想要得到这样一个列表<code>[2, 4, 6, 8]</code>。照例，从普通方法开始：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 普通方法</span><br><span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;1234&#x27;</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>:<br>    items.append(<span class="hljs-built_in">int</span>(i)*<span class="hljs-number">2</span>)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>OK，没问题。我们继续：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>items = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-built_in">int</span>(x)*<span class="hljs-number">2</span>, <span class="hljs-built_in">str</span>))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>可以看到，我们先将<code>items</code>清空之后再继续操作的，这次我们用了<code>list</code>+<code>map</code>的方式，一样得到了我们想要的结果。</p><p>最后，当然是用列表推导式的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>items = [<span class="hljs-built_in">int</span>(i)*<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>同样，我们得到了想要的结果。</p><p>讲到这里了，我给大家秀一个小技巧，俗称骚操作，就是我们其实可以运用位运算操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">items.clear()<br><span class="hljs-built_in">print</span>(items)<br><br>items = [<span class="hljs-built_in">int</span>(i) &lt;&lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[]<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>具体代码执行的时候发生了什么，就算是给大家留个小思考题。<strong>提示：可以回头翻看下我们之前讲到的位运算符。</strong></p><h3 id="带有判断条件的列表推导式">带有判断条件的列表推导式</h3><p>除了基本的列表推导式，我们还有一种带有判断条件的列表推导式。</p><p><code>结果变量 = [变量或变量的处理结果 for 变量 in 容器类型数据 条件表达式]</code></p><p>相比起基本的列表推导式，我们现在多了一个<code>条件表达式</code>，那么我们该怎么利用呢？来个需求：从0~9，求所有的偶数并且形成一个新的列表。这回，我们就只完成常规方法和列表推导式，对比着来观察一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常规方式</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        items.append(i)<br><br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>很好，我们完成了需求。接下来，大家试试不看我下面写的代码，自己从常规方式思考下该怎么写，然后自己运行一下试试写对了没，最后，再和我写的对比一下看看咱们写的有没有区别。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>没错，就是这么简单，你做对了吗？</p><h3 id="带有条件判断的多循环推导式">带有条件判断的多循环推导式</h3><p>现在有这样一个需求，我们拿到两个列表<code>[1,2,3], [3,1,4]</code>,要将这两个列表中的元素两两组合，要求组合的元素不能重复：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常规方法</span><br>items = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:<br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>]:<br>        <span class="hljs-keyword">if</span> x != y:<br>            items.append((x,y))<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]<br></code></pre></td></tr></table></figure><p>这样，我们就完成了刚才的需求。那用推导式该如何实现呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">if</span> x != y]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)]<br></code></pre></td></tr></table></figure><p>没毛病，我们完全实现了刚才的需求。这个很好理解对吧？</p><p>让我们接着来看最后一个推导式的形式。</p><h3 id="对于嵌套循环的列表推导式">对于嵌套循环的列表推导式</h3><p>这次我们直接写需求，然后上示例。</p><p>需求为，现在我们有一个3x4的矩阵，由3个长度为4的列表组成，我们现在要交换其行和列。</p><p><strong>注意哦，这个行转列需求在处理数据的时候经常会用到。</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"># 需求样例<br>&#x27;&#x27;&#x27;<br>[<br><span class="hljs-code">    [1, 2, 3, 4],</span><br><span class="hljs-code">    [5, 6, 7, 8],</span><br><span class="hljs-code">    [9, 10, 11, 12]</span><br>]<br><br>==&gt;<br><br>[<br><span class="hljs-code">    [1, 5, 9],</span><br><span class="hljs-code">    [2, 6, 10],</span><br><span class="hljs-code">    [3, 7, 11],</span><br><span class="hljs-code">    [4, 8, 12]</span><br>]<br>&#x27;&#x27;&#x27;<br></code></pre></td></tr></table></figure><p>来，让我们尝试着实现一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先，定义初始数据，大家可以直接copy我给到的矩阵数据</span><br><br><span class="hljs-comment"># 先定义数据</span><br>arr = [<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],<br>    [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>],<br>    [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]<br>]<br><br><span class="hljs-comment"># 使用常规方法</span><br>items = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    res = []<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr:<br>        res.append(row[i])<br>    items.append(res)<br><span class="hljs-built_in">print</span>(items)<br><br><span class="hljs-comment"># 使用列表推导式, 我们从内向外来写</span><br>items = [[row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><span class="hljs-built_in">print</span>(items)<br><br>---<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]]<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]]<br><br></code></pre></td></tr></table></figure><p>这样，我们就完成了刚才的需求。我们拆解呢，还是从外层开始讲起：</p><p>首先，因为我们发现数据是4列，所以我们设定了一个<code>range(4)</code>来进行4次迭代，将<code>0,1,2,3</code>这四个下标分别传到内层循环。</p><p>然后我们开始在<code>arr</code>内循环找到当前的<code>row</code>,循环会依次去寻找<code>[1,2,3,4]，[5,6,7,8],[9,10,11,12]</code>。然后将每一个<code>row</code>中的寻找当前的<code>row[i]</code>，并且填入一个新列表内。那么这三组列表中的<code>row[i]</code>就会是这样的：</p><p><code>row[1]</code>分别为<code>1, 5, 9</code>,<code>row[2]</code>分别为<code>2, 6, 10</code>....依次类推。当外层循环完成之后，就正好是组成了新的四个新的列表，最后再将新列表依次传到<code>items</code>这个空列表内，就完成了。</p><p>那同样都是两次<code>for</code>循环嵌套，为什么上面那个案例就是顺序写的，内层<code>for</code>循环写在了后面，而下面这个案例的内层<code>for</code>循环就写到了前面呢？</p><p>好的，让我们来看看，如果将下面这个案例的内存<code>for</code>循环写在后面会是怎样的:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [row[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr]<br>items<br><br>---<br>[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><p>看到了吗？顺序还是对的，只是依次传入了数据，并未形成矩阵。那有小伙伴就说了，那是不是因为没在<code>row[i]</code>上加<code>[]</code>从而形成列表呢？</p><p>好的，让我们再来做一个实验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [[row[i]] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr]<br>items<br><br>---<br>[[<span class="hljs-number">1</span>], [<span class="hljs-number">5</span>], [<span class="hljs-number">9</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">6</span>], [<span class="hljs-number">10</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">7</span>], [<span class="hljs-number">11</span>], [<span class="hljs-number">4</span>], [<span class="hljs-number">8</span>], [<span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure><p>可以看到，列表是形成了，但是却是一个元素占一个列表，并没形成我们想要的矩阵。</p><p>估计小伙伴们看出来了，在推导式中，因为<code>变量或变量的处理结果</code>必须放在前面，所以我们为了要形成矩阵内层新的<code>row</code>，所以才必须将<code>处理结果</code>和内层循环方法放在一起，并加上<code>[]</code>来确保这组结果能形成一个列表,也就是我们现在这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">items = [[row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> arr] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>items<br><br>---<br>[[<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">12</span>]]<br></code></pre></td></tr></table></figure><p>看一次没看懂的小伙伴，可以多看看，尝试着自己去分解，将其理解透彻。因为这个方法在我们后续的数据清洗中使用非常频繁。</p><h2 id="小练习">小练习</h2><blockquote><ol type="1"><li>为了能达到练习的目的，从这一节开始，所有练习可以不在课程中展示了。大家先做一下，然后可以在我下一节课中的源码中去找答案，然后来看看和自己做的是否一样。</li><li>以下所有练习必须使用列表推导式来实现</li><li>有些练习不止一个方法，大家尝试用多种方法来实现一下。</li><li>做完的小伙伴可以在课程后面留言讨论。</li></ol></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 1. 让我们尝试将字典中的健值对转成`key = value`的数据格式</span><br>&#123;<span class="hljs-string">&#x27;user&#x27;</span>:<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>:<span class="hljs-string">&#x27;20&#x27;</span>, <span class="hljs-string">&#x27;phone&#x27;</span>:<span class="hljs-string">&#x27;133&#x27;</span>&#125; 转为 [<span class="hljs-string">&#x27;user=admin&#x27;</span>,<span class="hljs-string">&#x27;age=20&#x27;</span>,<span class="hljs-string">&#x27;phone=133&#x27;</span>]<br><br><span class="hljs-comment"># 2. 把列表中的所有字符全部转为小写</span><br>[<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;CCCC&#x27;</span>, <span class="hljs-string">&#x27;SHIss&#x27;</span>, <span class="hljs-string">&#x27;Sipoa&#x27;</span>,<span class="hljs-string">&#x27;Chaheng&#x27;</span>, <span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;dsAhio&#x27;</span>]<br><br><span class="hljs-comment"># 3. x是0～5之间的偶数，y是0~5之间的奇数，把x，y组成一个元组，放到列表中</span><br><br><span class="hljs-comment"># 4. 使用列表推导式完成九九乘法表</span><br><br><span class="hljs-comment"># 5. 求M, N中矩阵和元素的乘积</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">M = [</span><br><span class="hljs-string">    [1, 2, 3],</span><br><span class="hljs-string">    [4, 5, 6],</span><br><span class="hljs-string">    [7, 8, 9]</span><br><span class="hljs-string">]</span><br><span class="hljs-string"></span><br><span class="hljs-string">N = [</span><br><span class="hljs-string">    [2, 2, 2],</span><br><span class="hljs-string">    [3, 3, 3],</span><br><span class="hljs-string">    [4, 4, 4]</span><br><span class="hljs-string">]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br></code></pre></td></tr></table></figure><p>最后，大家记得做练习并且留言，下课。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://qiniu.hivan.me/picGo/20230807211708.png?imgNote&quot;
alt=&quot;茶桁的AI秘籍&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;最近几节课，我们都是在详细讲解Python内的数据类型，上一节课我们详细了解了字符串，这节课，让我们来详解一下列表。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
</feed>
