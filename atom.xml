<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>茶桁.MAMT</title>
  
  <subtitle>ChaHeng Notes，codding and writting ~</subtitle>
  <link href="https://hivan.me/atom.xml" rel="self"/>
  
  <link href="https://hivan.me/"/>
  <updated>2023-08-02T17:20:14.450Z</updated>
  <id>https://hivan.me/</id>
  
  <author>
    <name>Hivan Du</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>卡尔曼滤波器的非数学介绍</title>
    <link href="https://hivan.me/2023_8_3_Kalman/"/>
    <id>https://hivan.me/2023_8_3_Kalman/</id>
    <published>2023-08-02T11:23:14.000Z</published>
    <updated>2023-08-02T17:20:14.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如果你想查看的话，本文的代码可以在我的<ahref="https://github.com/hivandu/AI_Cheats/blob/main/Python/Kalman.ipynb">Github</a>上查看。</p></blockquote><p>卡尔曼滤波器非常巧妙。如果你从未听说过卡尔曼滤波器，那么一种非常直观（也可以说是还原）的思考方式就是将其视为一个漏斗，在这里你可以从多个嘈杂的信息源中获取信息，并将其浓缩为一个更精确的统计数据。</p><span id="more"></span><p>如果这一切听起来含糊不清，请不要担心。稍后，我们将把这句话剥离成一个更容易理解的例子，希望能进一步加深我们的直觉。要研究和推理卡尔曼滤波器，没有比数学更好的工具了。但同样，卡尔曼滤波器的基础数学具有挑战性，包含线性代数、概率论和微积分等内容。因此，并非所有人都能轻松掌握。这篇文章的目的就是希望为你提供一个易于理解的直观印象，或许能促使你自己深入研究这个问题。现在，让我们开始吧，同时牢记这一点："以下内容仅提供直觉，可能并不完整"。</p><p>让我们先问一句："为什么卡尔曼滤波器是必要的？对于这个问题，一个简单而又故意模糊的答案是：现实生活并不完美。请看这个激励性的例子：想象一艘船在一个维度上行驶，从港口出发（x=0）并行驶一段距离。这艘船的发动机被设定为为船提供一个恒定的速度，例如10 米/秒。</p><figure><img src="https://qiniu.hivan.me/picGo/20230803010908.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们首先要问的问题是，在离开港口 2秒钟后，船到底在哪里？很自然，你会说船离港口的距离是2<em>10=20m，因为毕竟距离 = 速度 </em>时间。在理想世界里，这的确是正确的，根本不需要卡尔曼滤波器。但在现实世界中，情况绝非如此简单。首先，可能没有足够的发动机能够产生足够的力，使每个时间点的速度始终保持在10 米/秒。当然，你可能会在某些时候获得 10.00001 的速度，或在其他时候获得9.99999 m/s 或介于两者之间的某个数字，但正如所说，99.99%的完美终究还是不完美。其次，即使你说你确实拥有这样一个完美的发动机，但当你施加一个精确测量的力时，你也不可能获得预期的完美速度。波浪运动可能会让你的船稍微慢一点，或者风可能会让它加速，或者谁也不知道什么东西会以什么方式对它产生影响。</p><blockquote><p>因此，仅仅通过测量你想要的位置，你永远无法确定你的船在哪里。</p></blockquote><p>那么，我们是否注定永远无法真正知道自己的位置呢？不尽然！这就是传感器的用武之地。想象一下，你，水手，随身携带一个全球定位系统。这样，GPS就能精确地告诉您在任何给定时刻的位置！事实上，你现在甚至不需要船的速度，因为无论船如何行驶，你的全球定位系统都能准确地告诉你所在的位置。问题解决了吗？就像我说的，不完全是。在现实中，传感器经常会出现错误，而且不可靠。也就是说，它们确实能告诉你你在哪里，但测量结果可能并不精确。因此，您的GPS 可能会告诉您，3 秒钟后您距离港口 29.998 米或 30.002米，甚至是距离港口 100米，但这种可能性极低。此外，您也无法确保传感器永远不会出现故障。以 GPS传感器为例。一旦你发现自己身处没有卫星覆盖的地区，它就会失灵。事实上，如果有一个传感器能保证永远不会离线，并能以任意的精确度测量出你想知道的信息，那就根本不需要卡尔曼滤波器了。</p><p>有了这些，我们现在就可以回答为什么需要卡尔曼滤波器了。而答案与我们之前已经确定的并没有什么不同。卡尔曼滤波器是一个漏斗，它能接收两个或更多不完美、不可靠的信息源，并对你想知道的信息做出更准确的估计。在这个例子中，卡尔曼滤波器会把你在任何时间的速度估计值和GPS估计值（如果有的话）作为输入，然后给出比这两个信息加起来更准确的估计值！事实上，如果你有更多的信息来源，比如雷达或声纳，甚至是你目前在水中看到的鱼的种类，理论上你可以将这些测量结果结合起来，从而对你的位置做出更准确的估计。</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011007.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>因此，现在的问题是，如果不使用这样的数学知识（摘自维基百科），我们如何理解卡尔曼滤波器的作用和原理？</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011011.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>首先，我们假设船上没有一名乘客，而是有一千名乘客，每个人都有自己的GPS设备。现在，每位乘客都可以通过以下方式进行基于速度的估算，从而估算出自己的位置（进而估算出船的位置）：</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011016.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from random import gauss</span><br><span class="line">def new_position(last):</span><br><span class="line"> velocity = 10</span><br><span class="line"> wind = gauss(0, 2)</span><br><span class="line"> wave = gauss(0, 0.1)</span><br><span class="line"> return last + velocity + wind + wave</span><br></pre></td></tr></table></figure><blockquote><p>注：有关高斯函数的可选但更完整的解释，请参阅下面的附录。目前，只需说明它会产生一个随机数（正数/负数），其顺序由第二个参数指示即可。</p></blockquote><p>从本质上讲，这 1000名乘客中的每一个人都是这样做的：取上一次已知的位置（在现在之前的时间），加上速度，并且知道风和水波会轻微地改变航向，再加上一些随机的估计波动。现在，如果这些乘客真的有估算风速和水速的好方法，他们就会使用它。但因为他们没有，所以只能用随机数来估计影响。实际上，现实生活中也是如此。我们不可能测量所有的东西，所以我们只能用一些简单的方法来估计它们，就像我们上面用平均值（0）和偏差参数（0.1和 2）所做的那样。</p><p>现在我们进入卡尔曼滤波法的第二阶段，即测量。在这一阶段，所有乘客都知道，由于风噪和水噪的影响，他们对自己的状态（所处位置）只有不完全的了解，因此，他们会利用自己的传感器来改善自己的状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sensor(t):</span><br><span class="line"> if t == 3:</span><br><span class="line"> # oops, passing through a thunderstorm. GPS fluctuating!</span><br><span class="line"> sensor_noise = gauss(5, 10)</span><br><span class="line"> elif t == 6:</span><br><span class="line"> # uh-oh, satellite unavailable!</span><br><span class="line"> sensor_noise = gauss(-5, 10)</span><br><span class="line"> else:</span><br><span class="line"> sensor_noise = gauss(0, 1)</span><br><span class="line"> return true_position[t] + sensor_noise</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请记住，传感器是一种不精确的设备，也就是说，它们返回的统计数据大多是正确的，在本例中就是变量true_position，但它们本身也有噪声，我们再次使用高斯函数随机生成的数字来模拟这种噪声。此外，我们在这里还模拟了传感器的不稳定性，即在某些情况下（t=3和t=6），由于某些因素传感器基本上是不可用的，而这些因素并非完全不可想象。因此，每位乘客在使用传感器时，实际上都会得到不同的测量结果。</p><p>想象一下，这艘船现在离开港口，每秒行驶这些距离：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true_position = [0, 9, 19.2, 28, 38.1, 48.5, 57.2, 66.2,</span><br><span class="line">                 77.5, 85, 95.2]</span><br></pre></td></tr></table></figure><p>也就是说，船从港口出发（x=0），第一秒行驶 9 米，第二秒行驶 10.2米，最后到达 19.2米，以此类推。现在，乘客们的任务是利用他们所掌握的嘈杂且不可靠的测量数据，尽可能准确地预测出每一秒的不同位置。</p><p>因此，在时间 t = 1 时，乘客可以通过上述函数得到这些读数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 如果 t=0 时的新位置为 0，则 t=1 时的新位置为 0new_position(0) =&gt; 9.37 (error -0.37)# t = 1s 时的传感器读数sensor(1) =&gt; 8.98                (error +0.02)</span><br></pre></td></tr></table></figure><p>所有乘客都是如此。现在的问题是，真相到底是什么？是我们的牛顿物理知识更可靠，还是GPS 传感器更可靠？在这种特殊情况下，由于我们已经知道船的真实位置距离true_position 变量 9米，答案可能是显而易见的，但情况并非总是如此。在这种情况下，为了将这两个独立的统计数据结合起来，我们实际上采用了一种非常简单的方法：取两者的平均值！在上面的例子中，我们可以得出以下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combined =&gt; (9.37+8.98)/2 =&gt; 9.17         (error -0.17)</span><br></pre></td></tr></table></figure><p>请注意，在这个例子中，综合统计量的误差比单独的速度估计值要小，但比传感器估计值要差。但问题是，我们实际上可以做得比取平均值更好。考虑一下这样的情况：你知道你的传感器实际上是最先进的，而且非常可靠。这实际上意味着你应该更倾向于传感器的数据，而不是速度更新的数据。实际上，您可以通过使用加权平均值来做到这一点。请看这段代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def combine(A, B, trustA, trustB):</span><br><span class="line"> total_trust = trustA + trustB</span><br><span class="line"> return (A * trustA + B * trustB) / total_trust</span><br></pre></td></tr></table></figure><p>这就综合了 A 和 B来源的两个数字，但也考虑到了您对这些来源的信任程度。因此，如果您将其称为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">combine(9.37, 8.98, 10, 1) =&gt; 9.33         (error -0.33)</span><br><span class="line">combine(9.37, 8.98, 1, 10) =&gt; 9.01         (error -0.01)</span><br></pre></td></tr></table></figure><p>在第一次调用中，您对源 A（速度）的信任度远高于源 B（传感器），即 10比 1，因此得到的答案更倾向于源 A，即更接近9.37。这种基于信任的加权平均法是卡尔曼滤波器的核心，也是它的数据组合能力所在。</p><p>但现在，我们遇到了一个新问题。哪个来源更可信，或者如何计算可信度？是应该优先考虑速度呢？还是应该优先考虑GPS测量结果？决定这一点的是偏差或方差指标。想想看，什么更值得信赖？是波动剧烈的信息源还是没有波动的信息源？试想一下，你收听10 个气象广播电台，其中 4 个告诉你会下雨，6个告诉你会是晴天。现在想象一下，你登录 10 个天气网站，其中 9个告诉你会下雨，1个告诉你会是晴天。哪个消息来源更可靠？你倾向于相信大多数气象广播电台告诉你的（晴天）？还是你倾向于相信天气网站告诉你的（下雨）？理性的做法是更倾向于网站的结论，因为许多网站的结论都是一致的，即它们的方差较小，而气象广播电台，至少在这个例子中，它们的结论似乎波动很大，所以也许不应该太相信。</p><p>这样，完整的更新步骤就变成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from statistics import variance</span><br><span class="line"></span><br><span class="line"># Find updated positions per passenger at t seconds</span><br><span class="line">def update(t, last):</span><br><span class="line"> velocity_updates = []</span><br><span class="line"> sensor_updates = []</span><br><span class="line"></span><br><span class="line"> for p in range(1000): # for each passenger</span><br><span class="line"> # new velocity update based on last known position</span><br><span class="line"> # for the passenger</span><br><span class="line"> velocity_updates.append(new_position(last[p]))</span><br><span class="line"> sensor_updates.append(sensor(t))</span><br><span class="line"> </span><br><span class="line"> # Calculate trust metrics for velocity and sensor measurements</span><br><span class="line"> # Remember that as fluctuation increases, trust decreases</span><br><span class="line"> # And vice-versa</span><br><span class="line"> fluctuation_velocity = variance(velocity_updates)</span><br><span class="line"> fluctuation_sensor = variance(sensor_updates)</span><br><span class="line"></span><br><span class="line"> # calculate trust</span><br><span class="line"> trust_velocity = 1/fluctuation_velocity</span><br><span class="line"> trust_sensor = 1/fluctuation_sensor</span><br><span class="line"></span><br><span class="line"> # combine these together for each passenger</span><br><span class="line"> combined = []</span><br><span class="line"> for p in range(1000):</span><br><span class="line"> combined.append(combine(A = velocity_updates[p],</span><br><span class="line"> B = sensor_updates[p],</span><br><span class="line"> trustA = trust_velocity,</span><br><span class="line"> trustB = trust_sensor))</span><br><span class="line"> # Sensor updates &amp; velocity updates returned for plotting purposes</span><br><span class="line"> return sensor_updates, velocity_updates, combined</span><br></pre></td></tr></table></figure><blockquote><p>注：有关方差函数的更多信息，请参阅附录。现在，只需将其视为数字列表波动的度量。</p></blockquote><p>这段代码相对简单。对于每位乘客，它都会进行基于速度的噪声测量和基于传感器的噪声测量。根据所有乘客的这些测量结果，计算出每个测量结果的信任度指标，作为方差的倒数（因为方差增加，信任度降低），然后调用包含相关信任度参数的组合方法。值得注意的是，这里的每位乘客都在为自己进行位置更新。在这些单个更新结束后，可以根据所有乘客位置的平均值推断出船只本身的实际位置。</p><p>我们使用以下代码来连接上述整个代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># We&#x27;ll do a final plot using this list</span><br><span class="line">plot_data = []</span><br><span class="line"></span><br><span class="line">def update_plot(t, sensor, velocity, combined_position):</span><br><span class="line"> # add true position at this time</span><br><span class="line"> plot_data.append(&#123;&#x27;passenger&#x27;: &#x27;true&#x27;, &#x27;type&#x27;: &#x27;true&#x27;, &#x27;time&#x27;: t,</span><br><span class="line"> &#x27;position&#x27;: true_position[t]&#125;)</span><br><span class="line"> # for each passengers</span><br><span class="line"> for p in range(1000):</span><br><span class="line"> plot_data.append(&#123;&#x27;passenger&#x27;: p, &#x27;type&#x27;: &#x27;sensor&#x27;, &#x27;time&#x27;: t,</span><br><span class="line"> &#x27;position&#x27;: sensor[p]&#125;)</span><br><span class="line"> plot_data.append(&#123;&#x27;passenger&#x27;: p, &#x27;type&#x27;: &#x27;velocity&#x27;, &#x27;time&#x27;: t,</span><br><span class="line"> &#x27;position&#x27;: velocity[p]&#125;)</span><br><span class="line"> plot_data.append(&#123;&#x27;passenger&#x27;: p, &#x27;type&#x27;: &#x27;combined&#x27;, &#x27;time&#x27;: t,</span><br><span class="line"> &#x27;position&#x27;: combined_position[p]&#125;)</span><br><span class="line"></span><br><span class="line">update_plot(0, [0]*1000, [0]*1000, [0]*1000)</span><br><span class="line">estimated_positions = [0]*1000 # all estimates start from 0</span><br><span class="line">for t in range(1, 10): # ten seconds</span><br><span class="line"> _sensor, _velocity, estimated_positions = update(t, estimated_positions)</span><br><span class="line"> update_plot(t, _sensor, _velocity, estimated_positions)</span><br></pre></td></tr></table></figure><p>update_plot函数只是做一些基本的簿记工作，以存储用于绘图的瞬时统计数据。这里的主要迭代只是最底层的for循环，它使用乘客当前的最佳估计值，在任何给定时间持续更新位置估计值。除此以外，代码基本上不言自明。</p><p>使用 seaborn 库绘制的结果如下：</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011025.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由于目前的比例尺，这有点难以解析。让我们放大这两个区域，特别是 t=0.75至 t=1，即传感器正常工作时，以及 t=2 至 t=4 出现故障时。</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011027.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://qiniu.hivan.me/picGo/20230803011030.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>注：包络线指的是不确定性。线中的包络线越宽，我们对数字的不确定性就越大。</p></blockquote><p>在第一种情况下，正如您所看到的，所有 1000名乘客的综合位置估计值比单独的速度估计值要好（绿色），虽然在第一种情况下，我们的估计值确实比我们的传感器读数要差，但在第二种情况下，我们的估计值实际上比单独的故障传感器读数要好得多！这是因为卡尔曼滤波器会自动调整不可预见的波动造成的剧烈变化，并始终为我们提供合理可靠的指标。如下图所示，一旦我们的传感器恢复正常（t=4到t=5），卡尔曼滤波器就会再次偏向于传感器（由于传感器读数和真实值重叠太多，所以有点难看）。</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011033.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我相信你至少对卡尔曼滤波器的工作原理有了一些直观的了解。卡尔曼滤波器的实际理论基础同样引人入胜，如果你的工作需要，我鼓励你继续深入研究。与此同时，我希望这篇文章能证明，代码作为一种形式语言，能在多大程度上帮助人们对那些乍看之下令人生畏的概念产生直觉。我也希望能够通过简单的代码，向大家传授一些我认为很有吸引力的话题的更多见解。</p><h3 id="高斯函数"><strong>高斯函数</strong></h3><p>这里唯一需要知道的特殊函数是正态分布函数，即 gauss(0, 0.1) 和gauss(0,2)。简单地说，它给你一个随机数，这个数通常在 0附近（技术上正确的说法是以 0 为中心），而得到离 0更远的数的几率由第二个参数控制，即 2 和 0.1。</p><p>因此，如果调用 gauss(0,0.1)，得到0.06、-0.07、-0.06、0.02、-0.23、-0.06、0.09等数字的可能性较大，顺序不分先后。</p><p>而如果调用 gauss(0,2)，则更有可能得到1.05、1.03、-1.06、0.32、1.29、-0.40、-1.72 等数字，同样不分先后。</p><p>直观地说，第二个参数也叫标准偏差，控制着测量值的波动程度。在上面的代码中，这意味着您通常会认为风的偏差过大（大风天？请注意下面直方图中偏差=2和偏差=0.1 所产生的数字的频率（特别注意 x轴）。虽然数字的范围有很大不同，但这两个直方图的形状看起来差不多。这种钟形分布被称为高斯分布、正态分布或钟形曲线分布，在自然界中经常出现。</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011036.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://qiniu.hivan.me/picGo/20230803011039.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="方差"><strong>方差</strong></h3><p>方差是衡量一致性的标准。也就是说，如果一致性好，方差就小，反之亦然。在上图中，由于x轴实际上是自动调整的，所以你无法完全看到方差。如果我们在相同的坐标轴限制内绘制上图中的直方图，就会得到如下结果：</p><figure><img src="https://qiniu.hivan.me/picGo/20230803011041.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://qiniu.hivan.me/picGo/20230803011044.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注意到第一张图片有多宽了吗？这是因为其中的数字变化很大。也就是说，你会发现其中有很多-2、2、0 和一些 4、-4。但在第二幅图中，你会发现很多 0、0.1、-0.1等，但你会发现-2、2等的数量会少很多。正确地说，第一个分布的方差（准确地说是4）大于第二个分布的方差（0.01）。有关方差的更多信息，请上网查阅。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果你想查看的话，本文的代码可以在我的&lt;a
href=&quot;https://github.com/hivandu/AI_Cheats/blob/main/Python/Kalman.ipynb&quot;&gt;Github&lt;/a&gt;上查看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;卡尔曼滤波器非常巧妙。如果你从未听说过卡尔曼滤波器，那么一种非常直观（也可以说是还原）的思考方式就是将其视为一个漏斗，在这里你可以从多个嘈杂的信息源中获取信息，并将其浓缩为一个更精确的统计数据。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
    <category term="Math" scheme="https://hivan.me/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>5. 模块化编程</title>
    <link href="https://hivan.me/Modular-programming/"/>
    <id>https://hivan.me/Modular-programming/</id>
    <published>2023-08-01T15:43:14.000Z</published>
    <updated>2023-08-02T19:17:30.416Z</updated>
    
    <content type="html"><![CDATA[<p>HI, 大家好。我是茶桁。</p><p>上一节中我们学习了Python基本的流程控制，并且预告了这一节的内容，就是将要学习「模块化编程」。那什么是模块化编程呢？按照维基百科的说法：</p><span id="more"></span><blockquote><p><strong>模块化编程</strong>（英语：modularprogramming），是强调将计算机程序的功能分离成独立的、可相互改变的“模块)”（module）的软件设计技术，它使得每个模块都包含着执行预期功能的一个唯一方面（aspect）所必需的所有东西。</p></blockquote><p>说的简单一点，就是把程序进行封装（函数封装、面向对象、文件...）</p><p>OK，话不多说，让我们开始吧。</p><h2 id="函数">函数</h2><h3 id="什么是函数">什么是函数？</h3><p>函数的英文单词为<code>function</code>,我们将其翻译过来，就是“函数，功能”。</p><p>其实，函数就是一个具有特定功能的代码块。</p><h3 id="函数的作用">函数的作用</h3><p>函数的目的是封装，将特定功能的代码块进行封装，其目的是提高代码的重用性，从而提高开发效率，并且降低了后期的维护成本。</p><h3 id="函数的定义和使用">函数的定义和使用</h3><p>函数的定义其实非常简单，我们用代码来写一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数[基本结构]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">[参数列表]</span>):</span><br><span class="line">    当前行数的具体功能的代码</span><br><span class="line">    当前行数的具体功能的代码</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>当然，函数在写完之后并不会自动执行，只是把函数定义了而已。如果想要使用定义完成的函数，需要用语法来进行函数的调用。</p><p>那么函数该如何调用呢？如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名()</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的定义格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;love&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的调用</span></span><br><span class="line">love()</span><br></pre></td></tr></table></figure><p>当前程序运行输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i</span><br><span class="line">love</span><br><span class="line">u</span><br></pre></td></tr></table></figure><p>以上代码可以得到函数的第一个特征：函数定义后，不调用不执行。还记得咱们上节课强调的流程控制吗？代码最基本流程顺序是自上而下的，所以，这个时候我们如果调用放在上方，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的调用</span></span><br><span class="line">love()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的定义格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;love&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时因为<code>love()</code>调用的时候函数还未被定义，所以会执行报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name &#x27;love&#x27; is not defined</span><br></pre></td></tr></table></figure><figure><img src="https://qiniu.hivan.me/picGo/20230802142847.png?imgNote"alt="image-20230802142829519" /><figcaption aria-hidden="true">image-20230802142829519</figcaption></figure><p>所以我们需要注意：<strong>不能在函数定义前调用函数。</strong></p><p>另外，我们需要注意，函数的调用不受次数的影响，比如，我们定义好函数后，这个时候在后面调用三次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">love()</span><br><span class="line">love()</span><br><span class="line">love()</span><br></pre></td></tr></table></figure><p>那执行后的结果应该是连着打印了三次结果。</p><p>和变量一样，函数的命名也是要遵守命名规范的：</p><ul><li>字母数字下划线，不能以数字开头</li><li>严格区分大小写，且不能使用关键字</li><li>命名最好有意义，且不要使用中文</li></ul><p>现在我们想想，在<code>love()</code>函数被定义后，我们再来定义一个同名的函数会怎么样？</p><p>我们尝试一下，在刚才定义好的函数下方重复写一个同名的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的定义格式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;love&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;don&#x27;t&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;love&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;me&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的调用</span></span><br><span class="line">love()</span><br></pre></td></tr></table></figure><p>直接结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u</span><br><span class="line">don&#x27;t</span><br><span class="line">love</span><br><span class="line">me</span><br></pre></td></tr></table></figure><p>那，我们得到了实验结果：同样的函数名被再次定义之后，冲突的函数会被覆盖。</p><p>所以，最后我们总结一下函数的特征及注意事项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 函数定义后，不调用不执行</span><br><span class="line">2. 不能在函数定义前调用函数</span><br><span class="line">3. 函数的调用不受次数影响</span><br><span class="line">4. 函数的命名要遵守命名规范</span><br><span class="line">   - 字母数字下划线，不能以数字开头</span><br><span class="line">   - 严格区分大小写，不能使用关键字</span><br><span class="line">   - 命名最好有意义，且不要使用中文</span><br><span class="line">5. 函数名不要冲突，冲突后会被覆盖</span><br></pre></td></tr></table></figure><h3 id="函数的参数">函数的参数</h3><p>在定义函数的时候，我们需要注意给函数的参数。可以在参数列表的位置进行定义，这个称为<code>形参</code>。如果一个函数有形参，那么在调用的时候必须传递参数（实参）。实参将值传递给实参的过程，本质上就是变量赋值操作。</p><h4 id="函数参数概念及分类">函数参数概念及分类</h4><p>带有参数的函数，该如何定义？</p><p>在定义函数时，在小括号内可以定义形参（形式上的参数）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>(<span class="params">w</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;i love <span class="subst">&#123;w&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用带有形参的函数时，需要传递参数（实参）</span></span><br><span class="line">love(<span class="string">&#x27;马户&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i love 马户</span><br></pre></td></tr></table></figure><p>在这整个函数中，小括号内的<code>w</code>就是形参，在调用的时候的<code>马户</code>就是实参，在调用过程中将值传给了形参<code>w</code>。</p><p>那么，如果我在调用的时候没有传递实参，就会直接报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">love()</span><br><span class="line"></span><br><span class="line">TypeError: love() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;w&#x27;</span></span><br></pre></td></tr></table></figure><p>形参可以是多个，这就是定义带有多个参数的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;m&#125;</span> love <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">love(<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i love u</span><br></pre></td></tr></table></figure><p>如果形参是多个的话，那么有多少个形参就必须传递几个实参。并且参数都是按照顺序进行传递的。</p><p>如果少传一个参数，则同样会被错。</p><p>那，能不能多传呢？也不行，如果多传了参数，一样会报错。</p><p>至此，我们可以做如下总结：</p><ul><li><p>函数参数：调用时需要传递的数据</p></li><li><p>函数参数的大类分为形参和实参</p><ul><li>形参意思：函数定义时的参数</li><li>实参意思：函数调用时的参数</li></ul></li><li><p>形实关系：函数调用时，形参和实参个数需要一一对应</p></li></ul><h4 id="函数中的参数类型">函数中的参数类型</h4><p>在确定了什么是形参和实参之后，我们来看看，这两种参数都有哪些类型。</p><p>函数参数在类型上，包括：</p><ul><li>普通参数</li><li>默认参数</li><li>收集参数</li><li>命名关键字参数</li><li>关键字参数收集</li></ul><h4 id="普通参数">普通参数</h4><p>先来说说普通参数，其实就是位置参数，也叫顺序参数，也是必须传递的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">love</span>(<span class="params">m, n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;m&#125;</span> love <span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">love(<span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;u&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码中，m, n就是普通参数，必须传递。</p><h4 id="默认参数">默认参数</h4><p>有些函数在定义的时候，行参上就已经定义了默认值，那么这种就叫做默认参数。</p><p>在调用函数的时候，默认参数是可以不传值的。当传值之后，默认值就会被改变：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y=<span class="number">20</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line"></span><br><span class="line">func(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这段代码中的行参<code>y</code>就是默认参数，我们在调用函数<code>func()</code>只写了一个实参，也就是只传了一个值给函数。这个时候执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 20</span><br></pre></td></tr></table></figure><p>我们修改一下，传两个值进去看看结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y=<span class="number">20</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line"></span><br><span class="line">func(<span class="number">2</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 100</span><br></pre></td></tr></table></figure><p>可以看到，本来我们定义的行参<code>y</code>的默认值被改变了。</p><p>在定义默认参数的时候需要注意，函数中的默认参数只能全部定义在普通参数的后面，否则在调用函数的时候就会报错，比如以下这些情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第1种错误情况</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x=<span class="number">100</span>, y=<span class="number">200</span>, z</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br><span class="line">func(<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2种错误情况</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x=<span class="number">100</span>, y, z=<span class="number">200</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br><span class="line">func(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3种错误情况</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y=<span class="number">100</span>, z</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, y, z)</span><br><span class="line"></span><br><span class="line">func(<span class="number">300</span>,<span class="number">200</span>,<span class="number">50</span>)</span><br></pre></td></tr></table></figure><h4 id="收集参数">收集参数</h4><p>收集参数就是专门收集在函数调用时传递的多余的实参，或者我们可以理解为，不确定需要传递多少个实参，直接用一个行参来接收。</p><p>比如，我们现在有个需求就是需要计算用户输入的数字总和，我们按前面那个函数的定义方式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y z=<span class="number">100</span></span>):</span><br><span class="line">  <span class="built_in">print</span>(x+y+z)</span><br><span class="line"></span><br><span class="line">func(<span class="number">20</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>这个函数中，我们输入2个值或者3个值都可以，但是当我们只输入一个值或者三个以上的时候，程序就会报错了。</p><p>那么有没有什么办法，不管用户输入多少个数字，我们都可以进行相加计算呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x=<span class="string">&quot;+&quot;</span>, *args</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;加法运算&#x27;</span>, args)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;减法运算&#x27;</span>, args)</span><br><span class="line"></span><br><span class="line">func(<span class="string">&quot;-&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>这段代码执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">减法运算 (2, 3, 4, 5, 6, 7, 8)</span><br></pre></td></tr></table></figure><p>虽然中间的运算代码我没有写，但是大家可以看到，已经可以接受不固定的多个参数了。</p><p>这个<code>*args</code>就是我们的收集参数。</p><p>在定义函数的时候，如果需要收集参数，那么这个形参前面需要加一个<code>*</code>号，例如<code>*args</code>。这里需要注意一点，<code>*args</code>并不是固定写法，你可以随意定义一个，只要前面有<code>*</code>号就可以了。比如下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x=<span class="string">&quot;+&quot;</span>, *y</span>):</span><br><span class="line">    <span class="keyword">if</span> x == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;加法运算&#x27;</span>, y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;减法运算&#x27;</span>, y)</span><br><span class="line"></span><br><span class="line">func(<span class="string">&quot;-&quot;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>一样可以执行并得到一样的结果，这个时候，我们的<code>*y</code>就是收集参数。</p><p>收集参数也有两类，一种是普通的收集参数：专门用于收集多余的普通参数，形成一个新的元组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法： 参数前面加*, 例如：*args</span><br></pre></td></tr></table></figure><p>还有一种是关键字收集参数：用于专门收集多余关键字实参，形成一个新的字典：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：参数前面加**, 例如：**kwargs</span><br></pre></td></tr></table></figure><p>现在我们已经理解了普通的收集参数，那么在学习关键字收集参数之前，我们先来学习一下<strong>命名关键字参数</strong></p><h4 id="命名关键字参数">命名关键字参数</h4><p>命名关键字是放在<code>*</code>号后面的参数，调用的时候强制必须传入制定参数名才能进行调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c=<span class="number">3</span>, *args, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, <span class="string">&quot;\n&quot;</span>, *args, <span class="string">&quot;\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, name=<span class="string">&#x27;茶桁&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line"> 4 5 6 7 8 </span><br><span class="line"> 茶桁</span><br></pre></td></tr></table></figure><p>我们特意在中间加了换行字符来清晰的辨别<code>*args</code>和<code>name</code>。</p><p>如果在这段代码中我稍微变一下，在执行函数的时候，实参里不标明<code>name</code>可以吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c=<span class="number">3</span>, *args, name</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, <span class="string">&quot;\n&quot;</span>, *args, <span class="string">&quot;\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;茶桁&#x27;</span>)</span><br></pre></td></tr></table></figure><p>执行之后我们收到了报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeError: func() missing 1 required keyword-only argument: &#x27;name&#x27;</span><br></pre></td></tr></table></figure><p>这段报错明显告诉我们，确实了一个<code>必须</code>的关键字参数<code>name</code>。</p><p>那为什么会出现这种报错呢？这是因为在关键字参数之前，我们使用了<code>*args</code>来进行收集参数，那么无论你写多少，这些值都会被<code>*args</code>接收变成元组，那么后面的<code>name</code>自然就无法接受到值了。</p><p>让我们再来做一个实验，给命名关键字参数加上一个默认值，那么我们就能明显的看出问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c=<span class="number">3</span>, *args, name=<span class="string">&#x27;_茶桁&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, <span class="string">&quot;\n&quot;</span>, *args, <span class="string">&quot;\n&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="string">&#x27;茶桁&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段代码执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line"> 4 5 6 7 8 茶桁 </span><br><span class="line"> _茶桁</span><br></pre></td></tr></table></figure><p>可以看到，<code>name</code>给了默认值之后不再出现报错，而我们的实参也并未传到<code>name</code>里，而是全部被<code>*args</code>接收了。最后打印出了<code>name</code>的默认值<code>_茶桁</code>。</p><p>利用命名参数的这种定义参数名称接收值的特点，我们就可以打乱之前普通参数传值的顺序性，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="built_in">print</span>(x, <span class="string">&quot;\t&quot;</span>, y)</span><br><span class="line"></span><br><span class="line">func(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">func(y = <span class="number">2</span>, x = <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2  3</span><br><span class="line">3  2</span><br></pre></td></tr></table></figure><p>还是最开始的普通参数的写法，但是最后执行函数的时候，我们给实参指定了名称，这样传参顺序就没那么重要了。</p><p>所以，我们总结一下：</p><ul><li><strong>关键字参数</strong>定义在<strong>收集参数</strong>后面</li><li>关键字参数必须通过形参的名字来进行传递</li></ul><h4 id="关键字参数收集">关键字参数收集</h4><p>前面我们在讲收集参数的结尾处提到了<strong>关键字参数收集</strong>，形式为<code>**kwargs</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def func(a, b, c=3, *args, name, age,  **kwargs):</span><br><span class="line">    print(a, b, c)</span><br><span class="line">    print(args) # 普通收集参数，会把多余的参数收集为元组</span><br><span class="line">    print(name, age)</span><br><span class="line">    print(kwargs) # 关键字参数收集，会把多余的关键字参数收集为字典</span><br><span class="line"></span><br><span class="line">func(1, 2, 4, 112, 123, 321, 541, 231, name=&quot;茶桁&quot;, age=18, sex=&#x27;male&#x27;, height=185, x=&#x27;x&#x27;, y=&#x27;y&#x27;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 2 4</span><br><span class="line">(112, 123, 321, 541, 231)</span><br><span class="line">茶桁 18</span><br><span class="line">&#123;&#x27;sex&#x27;: &#x27;male&#x27;, &#x27;height&#x27;: 185, &#x27;x&#x27;: &#x27;x&#x27;, &#x27;y&#x27;: &#x27;y&#x27;&#125;</span><br></pre></td></tr></table></figure><p>从执行结果上我们可以看到，在<code>name</code>和<code>age</code>之后的所有参数都被传递到了<code>**kwargs</code>里，然后作为字典打印了出来。</p><p>在声明这个函数和执行函数的时候需要注意，这些参数都是有顺序的，如果在执行函数的时候再多传一个非关键字参数，这个时候程序就会报错，如果是关键字参数，则照样会被<code>**kwargs</code>接收。</p><p>在我们介绍完这些参数之后，我们最后再说明一下：</p><ul><li><p>形参声明的位置顺序：普通参数 -&gt; 默认参数 -&gt; 收集参数 -&gt;命名关键字参数 -&gt; 关键字收集参数</p></li><li><p><code>def func(a, b, c=1, *args, d, **kw)</code>这段声明中，<code>a,b</code>为普通参数，<code>c</code>是默认参数，<code>args</code>是收集参数，<code>d</code>是命名关键字参数，<code>kw</code>是关键字收集参数</p></li><li><p>极少情况下会同时出现上面五种形参，一般情况下为：普通参数，收集参数，关键字收集参数</p></li><li><p>所有参数的摆放问题:</p><ul><li>实参：普通实参在前，关键字参数在后</li><li>形参：关键字收集参数一定在最后出现，收集参数推荐在普通参数之后使用。</li><li>推荐顺序：普通形参、收集参数、关键字收集参数</li></ul></li></ul><h3 id="函数的返回值">函数的返回值</h3><p>一个函数除了可以完成一定功能之外，还可以用来安需要返回一些内容。在函数中，使用<code>return</code>关键字来制定返回数据，可以返回任意类型的数据。</p><p>函数的返回值会把数据返回到调用的地方，可以使用变量进行接收，或者作其他处理。</p><p>函数可以分为两类：</p><ol type="1"><li>执行过程函数：函数体内完成一定的功能即可，没有返回值</li><li>具有返回值的函数：函数体内完成一定的功能，并且返回一个结果到函数调用处。</li></ol><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> love <span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以上函数就是一个没有返回值的函数，这个函数只是为了完成打印这句话的功能。</p><p>那么有返回值的函数是什么样子？</p><p>如果需要在函数中制定返回内容，我们需要使用<code>return</code>关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有返回值的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    res = <span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> love <span class="subst">&#123;b&#125;</span>&#x27;</span></span><br><span class="line">    <span class="comment"># 可以在函数体内，使用return返回内容</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">r = func(<span class="string">&#x27;老鼠&#x27;</span>, <span class="string">&#x27;布丁&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">老鼠 love 布丁</span><br></pre></td></tr></table></figure><p>在这段代码中，我们在<code>func()</code>的函数体内最后利用关键字<code>return</code>返回了任意内容，并且使用变量<code>r</code>接收了这个返回值，最后讲<code>r</code>打印了出来。</p><p>在调用<code>func()</code>这个函数的时候，函数中的返回值会返回到函数调用处。</p><p>我们再来研究一下<code>return</code>这个关键字，我们在<code>return</code>的前后都加上一段打印代码，看看会发生什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b</span>):</span><br><span class="line">    res = <span class="string">f&#x27;<span class="subst">&#123;a&#125;</span> love <span class="subst">&#123;b&#125;</span>&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是return前&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是return后&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r = func(<span class="string">&#x27;老鼠&#x27;</span>,<span class="string">&#x27;布丁&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是return前</span><br><span class="line">老鼠 love 布丁</span><br></pre></td></tr></table></figure><p>看到结果我们可以清楚，<code>return</code>之后的的代码并未继续执行，也就是说，我们如果要在函数体内执行其他任务，必须放在<code>return</code>之前执行，否则根本不会执行。那么我们可以得出结论：<code>return</code>必须放在一个定义函数的最后面。</p><blockquote><p>Tips:其实，即便没有return关键字或者returen之后没有任何内容，也有返回值，只是返回的是None值。</p><p>None是一个特殊的数据，表示什么都没有。查询类型可以看到返回 &lt;class‘NoneType’&gt;</p></blockquote><h3 id="变量的作用域">变量的作用域</h3><p>作用域就是当前起作用，可用的范围区域。也就是变量的有效范围。</p><p>变量按作用域可以分为：</p><ul><li>局部变量： 在函数内部可以使用的变量</li><li>全局变量：在函数内外都可以使用的变量</li></ul><h4 id="局部变量">局部变量</h4><p>让我们尝试下，如果函数内定义的变量在函数外使用会如何：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name &#x27;a&#x27; is not defined</span><br></pre></td></tr></table></figure><p>被告知<code>a</code>并未被定义。</p><p>可以看到，函数内定义的变量，在函数外连获取都做不到。这种在函数内定义的这个变量<code>a</code>，就是局部变量，它在函数外不能使用。</p><p>再让我们来看看将变量定义在函数外会是怎样的一种情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>在<code>func</code>函数内，我们获取到了变量<code>num</code>的值并打印。那说明，在函数内我们可以获取函数外部的变量。</p><p>我们继续在继续看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    num += <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>执行后报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;num&#x27; referenced before assignment</span><br></pre></td></tr></table></figure><p>这样我们可以看到，变量<code>num</code>在函数内虽然可以使用，但是无法进行更改。</p><p>那在函数外定义的所有变量都是如此吗？再让我们试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    items[<span class="number">0</span>] = <span class="number">20</span></span><br><span class="line">    <span class="built_in">print</span>(items)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[20, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>由此我们看出，并不是所有的变量都不可在函数内进行更改。</p><p>其实，变量是分为两种的：</p><ul><li>可变数据类型：在函数外定义的变量，在函数内可以使用并改变</li><li>不可变数据类型：在函数外定义的变量，在函数内只可以访问而无法改变</li></ul><p>可变数据类型有列表和字典，其他的都是不可变数据类型。</p><h4 id="全局变量">全局变量</h4><p>之前我们介绍的都是局部变量，那怎样定义全局变量呢？</p><p>在函数内使用<code>global</code>直接定义的变量，就是全局变量，函数内外都可以直接使用。</p><p>在函数外定义的变量，在函数内使用<code>global</code>关键字进行声明，那么也是全局变量。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> num</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>这个时候我们可以得到执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p>那有小伙伴就问了，如果我在函数外直接使用<code>global</code>定义全局变量可以吗？让我们来试试看就知道了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> num</span><br><span class="line">num = <span class="number">20</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>执行之后得到报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;num&#x27; referenced before assignment</span><br></pre></td></tr></table></figure><p>这样我们就得到了结果：不可以。</p><p>在整个程序中，我们可以使用两个函数方法来获取数据：</p><p><code>globals()</code>用来获取全局数据，<code>locals()</code>用来获取当前作用域的数据</p><p>讲到这里，我们再来多看一组代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的作用域</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is outer func...&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is inner func...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line">inner()</span><br></pre></td></tr></table></figure><p>这段代码执行结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this is outer func...</span><br><span class="line"></span><br><span class="line">NameError: name &#x27;inner&#x27; is not defined</span><br></pre></td></tr></table></figure><p>正常执行了<code>outer()</code>内的打印，然后又报了一个错误，提示<code>inner</code>函数未定义。</p><p>说明，不只是变量有作用域，函数一样也有作用域。要想<code>inner</code>函数内的打印也起作用，我们需要在函数内就调用执行<code>inner()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的作用域</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is outer func...&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is inner func...&#x27;</span>)</span><br><span class="line">inner() <span class="comment"># 在函数内执行</span></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>这样，我们执行的结果就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is outer func...</span><br><span class="line">this is inner func...</span><br></pre></td></tr></table></figure><p>如果我们在外层函数中定义一个局部变量，能在内层函数中使用吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数的作用域</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;this is outer func...&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;this is inner func...&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(a)</span><br><span class="line">    inner()</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>执行之后得到报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;a&#x27; referenced before assignment</span><br></pre></td></tr></table></figure><p>说明并不可以。</p><h4 id="nonlocal关键字">nonlocal关键字</h4><p>那么，到底有没有什么办法在内函数中使用上一层函数中的局部变量呢？答案是有办法。</p><p>在内函数中如果想要使用外层函数的变量，那么需要使用<code>nonlocal</code>关键字，可以引用上一层函数中定义的局部变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个外层函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    <span class="comment"># 外函数的局部变量</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 内函数, 局部函数, 在函数的内部定义的函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="comment"># nonlocal 关键字在局部函数中使用</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num <span class="comment"># 可以引用上一层函数中定义的局部变量</span></span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(num)</span><br><span class="line">    inner()</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>执行后返回结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p>至此，我们通过使用<code>nonlocal</code>关键字，成功拿到了外层函数定义的变量<code>num</code>并使用。最后打印出使用的结果。</p><p>这里我们要注意，<code>nonlocal</code>虽然可以引用上一层函数中定义的局部变量，但是这并不代表提升为了全局变量。</p><p>既然我们有了<code>global</code>关键字可以提升变量为全局变量，为什么还需要一个<code>nonlocal</code>关键字呢？是不是有点多此一举？</p><p>这两者的功能上并不相同。<code>global</code>关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而<code>nonlocal</code>关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，<code>nonlocal</code>位置会发生错误（最上层的函数使用<code>nonlocal</code>修饰变量必定会报错）。</p><h3 id="关于函数的文档">关于函数的文档</h3><p>我们在一个未定义任何变量和函数的空白文档中打印一下全局数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    &#x27;__name__&#x27;<span class="punctuation">:</span> &#x27;__main__&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;__doc__&#x27;<span class="punctuation">:</span> &#x27;Automatically created module for IPython interactive environment&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;__package__&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">    &#x27;__loader__&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">    &#x27;__spec__&#x27;<span class="punctuation">:</span> None<span class="punctuation">,</span></span><br><span class="line">    &#x27;__builtin__&#x27;<span class="punctuation">:</span> &lt;module &#x27;builtins&#x27; (built-in)&gt;<span class="punctuation">,</span></span><br><span class="line">    &#x27;__builtins__&#x27;<span class="punctuation">:</span> &lt;module &#x27;builtins&#x27; (built-in)&gt;<span class="punctuation">,</span></span><br><span class="line">    &#x27;_ih&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;print(globals())&#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;_oh&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;_dh&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span>PosixPath(&#x27;/Users/xx/git/AI_Cheats/Python&#x27;)<span class="punctuation">,</span></span><br><span class="line">    PosixPath(&#x27;/Users/xx/git/AI_Cheats/Python&#x27;)<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;In&#x27;<span class="punctuation">:</span> <span class="punctuation">[</span>&#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;print(globals())&#x27;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;Out&#x27;<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    &#x27;get_ipython&#x27;<span class="punctuation">:</span> &lt;bound method InteractiveShell.get_ipython of &lt;ipykernel.zmqshell.ZMQInteractiveShell object at <span class="number">0x105be29e0</span>&gt;&gt;<span class="punctuation">,</span></span><br><span class="line">    &#x27;exit&#x27;<span class="punctuation">:</span> &lt;IPython.core.autocall.ZMQExitAutocall object at <span class="number">0x105be3280</span>&gt;<span class="punctuation">,</span></span><br><span class="line">    &#x27;quit&#x27;<span class="punctuation">:</span> &lt;IPython.core.autocall.ZMQExitAutocall object at <span class="number">0x105be3280</span>&gt;<span class="punctuation">,</span></span><br><span class="line">    &#x27;open&#x27;<span class="punctuation">:</span> &lt;function open at <span class="number">0x10488e710</span>&gt;<span class="punctuation">,</span></span><br><span class="line">    &#x27;_&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;__&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;___&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;__vsc_ipynb_file__&#x27;<span class="punctuation">:</span> &#x27;/Users/xx/git/AI_Cheats/Python/globals.ipynb&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;_i&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;_ii&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;_iii&#x27;<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    &#x27;_i1&#x27;<span class="punctuation">:</span> &#x27;print(globals())&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们来看这个打印出来的json</p><p>类似于<code>__name__</code>这种前后有<code>__ __</code>的数据，称之为“魔术变量”。我们并未定义，但是已经存在了。</p><p>如果脚本作为主程序，那么<code>__name__</code>值是<code>__main__</code>，如果是当作一个模块在另外一个脚本中引用去使用，那么值就是当前文件的命名。</p><p><code>__doc__</code>当前脚本的文档说明，在当前脚本当中的第一个三引号注释就是当前脚本的说明文档。比如，我们在这个空白的文档中写一段三引号注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这里是整个文档的说明部分。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>然后我们直接将doc打印出来查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(__doc__)</span><br></pre></td></tr></table></figure><p>可以看到输出内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是整个文档的说明部分。</span><br></pre></td></tr></table></figure><p>这种文档其实不止适用于python文件，对于定义的函数依然适用。比如，我们执行定义了一个函数，并在函数内部用三引号进行注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    这里是让你写一写函数的文档说明的。</span></span><br><span class="line"><span class="string">    需要说明当前函数的作用，</span></span><br><span class="line"><span class="string">    如果当前函数还有形参，那么也需要对形参进行一一说明。</span></span><br><span class="line"><span class="string">    name: 这个是一个name参数，用于接收姓名</span></span><br><span class="line"><span class="string">    age: 这个参数是表示年龄</span></span><br><span class="line"><span class="string">    :return: 此处说明当前函数的返回值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这个时候，我们在下方执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(func.__doc__)</span><br></pre></td></tr></table></figure><p>可以看到我们在注释内定义的说明文档被打印出来了：</p><figure><img src="https://qiniu.hivan.me/picGo/20230803024716.png?imgNote"alt="image-20230803024715900" /><figcaption aria-hidden="true">image-20230803024715900</figcaption></figure><p>这样，我们不仅可以在自己写函数的时候在上方清晰的写明当前函数的作用及参数，我们还可以使用此方法，查找其他人所写的函数的一些说明。</p><p>在我们平时写代码的时候，养成一个好习惯是非常有必要的。</p><p>总结一下：</p><ul><li><code>print(__name__)</code>: 获取当前脚本的文件名</li><li><code>print(__doc__)</code>: 获取当前脚本的说明文档</li><li><code>print(func.__doc__)</code>： 获取当前函数的说明文档</li></ul><h2 id="练习函数封装">练习：函数封装</h2><p>我们上一讲中的练习中，我们打印了乘法表，矩形图形，还计算了12生肖。这里我们就将乘法表来封装成函数，实现我们上节课留的其中一道思考题：反向打印。</p><p>我们先将打印乘法表封装起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数，打印九九乘法表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply_table</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    当前函数的功能是打印出乘法表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>X<span class="subst">&#123;y&#125;</span>=<span class="subst">&#123;x*y&#125;</span>&#x27;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>这样，我们在其他地方执行<code>multiply_table()</code>函数的时候，就可以直接打印出乘法表。</p><p>现在让我们给这个函数多加一些功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数，打印九九乘法表</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply_table</span>(<span class="params">i=<span class="number">0</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    当前函数的功能是打印出乘法表</span></span><br><span class="line"><span class="string">    i=0; i 这个参数可以用来控制正向输出和方向输出，0的时候正向，1的时候反向,默认为0</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> i:</span><br><span class="line">        rs = <span class="built_in">range</span>(<span class="number">9</span>, <span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rs = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> rs:</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>X<span class="subst">&#123;y&#125;</span>=<span class="subst">&#123;x*y&#125;</span>&#x27;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>我们执行函数的时候，输入1来试试看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiply_table(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>X1=<span class="number">9</span> <span class="number">9</span>X2=<span class="number">18</span> <span class="number">9</span>X3=<span class="number">27</span> <span class="number">9</span>X4=<span class="number">36</span> <span class="number">9</span>X5=<span class="number">45</span> <span class="number">9</span>X6=<span class="number">54</span> <span class="number">9</span>X7=<span class="number">63</span> <span class="number">9</span>X8=<span class="number">72</span> <span class="number">9</span>X9=<span class="number">81</span> </span><br><span class="line"><span class="number">8</span>X1=<span class="number">8</span> <span class="number">8</span>X2=<span class="number">16</span> <span class="number">8</span>X3=<span class="number">24</span> <span class="number">8</span>X4=<span class="number">32</span> <span class="number">8</span>X5=<span class="number">40</span> <span class="number">8</span>X6=<span class="number">48</span> <span class="number">8</span>X7=<span class="number">56</span> <span class="number">8</span>X8=<span class="number">64</span> </span><br><span class="line"><span class="number">7</span>X1=<span class="number">7</span> <span class="number">7</span>X2=<span class="number">14</span> <span class="number">7</span>X3=<span class="number">21</span> <span class="number">7</span>X4=<span class="number">28</span> <span class="number">7</span>X5=<span class="number">35</span> <span class="number">7</span>X6=<span class="number">42</span> <span class="number">7</span>X7=<span class="number">49</span> </span><br><span class="line"><span class="number">6</span>X1=<span class="number">6</span> <span class="number">6</span>X2=<span class="number">12</span> <span class="number">6</span>X3=<span class="number">18</span> <span class="number">6</span>X4=<span class="number">24</span> <span class="number">6</span>X5=<span class="number">30</span> <span class="number">6</span>X6=<span class="number">36</span> </span><br><span class="line"><span class="number">5</span>X1=<span class="number">5</span> <span class="number">5</span>X2=<span class="number">10</span> <span class="number">5</span>X3=<span class="number">15</span> <span class="number">5</span>X4=<span class="number">20</span> <span class="number">5</span>X5=<span class="number">25</span> </span><br><span class="line"><span class="number">4</span>X1=<span class="number">4</span> <span class="number">4</span>X2=<span class="number">8</span> <span class="number">4</span>X3=<span class="number">12</span> <span class="number">4</span>X4=<span class="number">16</span> </span><br><span class="line"><span class="number">3</span>X1=<span class="number">3</span> <span class="number">3</span>X2=<span class="number">6</span> <span class="number">3</span>X3=<span class="number">9</span> </span><br><span class="line"><span class="number">2</span>X1=<span class="number">2</span> <span class="number">2</span>X2=<span class="number">4</span> </span><br><span class="line"><span class="number">1</span>X1=<span class="number">1</span> </span><br></pre></td></tr></table></figure><p>可以看到，我们的控制结果被成功打印出来。至此，这个有一些小功能的九九乘法表就封装完成了。</p><p>那么这一节课就不留思考题了，大家课后熟练掌握一下封装函数和变量的作用域，我们下节课来学习一些<strong>高阶函数</strong>，好，下课。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;HI, 大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;上一节中我们学习了Python基本的流程控制，并且预告了这一节的内容，就是将要学习「模块化编程」。那什么是模块化编程呢？按照维基百科的说法：&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>4. Python的流程控制</title>
    <link href="https://hivan.me/Python-process-control/"/>
    <id>https://hivan.me/Python-process-control/</id>
    <published>2023-08-01T08:15:43.000Z</published>
    <updated>2023-08-01T14:10:09.380Z</updated>
    
    <content type="html"><![CDATA[<p>Hi，大家好。我是茶桁。</p><p>在前面几节课的基础之上，我们今天开始尝试在Python中控制流程。这中间，让我们来做一些实际的练习。</p><span id="more"></span><h2 id="python语句的分类">Python语句的分类</h2><p>让我们先了解一下Python语句的分类。</p><p>在Python中，可分为<code>单行代码</code>和<code>代码块/组</code>,顾名思义，单行代码就是一行的Python代码，而代码块是以冒号作为开始，用缩进划分相同作用域，这样的结构称之为代码块，是一个整体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行代码</span></span><br><span class="line">a = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 代码块</span></span><br><span class="line"><span class="keyword">if</span> a == <span class="number">123</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;True&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;False&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以上代码中输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure><p>在输入代码块的时候，我们要注意使用缩进。在其他语言中代码块可能是<code>&#123;&#125;</code>，但是在Python中严格遵守的缩进规则就是代码块。缩进可以是一个Tab距离或者四个空格，可是注意绝对不能混合使用，必须自使用一种方式缩进。</p><h2 id="流程控制的分类">流程控制的分类</h2><p>什么是流程？流程就是计算机执行代码时候的顺序。</p><p>流程可以被分为以下几类：</p><ul><li>顺序结构</li><li>分支结构/选择结构</li><li>循环结构</li></ul><h3 id="顺序结构">顺序结构</h3><p>顺序结构是系统的默认程序结构，自上而下进行执行。</p><h3 id="分支结构">分支结构</h3><p>分支结构可以让代码走向不同的方向，不同的分支区间。</p><p>分支结构中又包含了单向分支，双分支和多分支以及巢状分支。</p><h4 id="单向分支">单向分支</h4><p>单向分支就是在条件满足之后，执行后续任务。条件不满足的情况下，则不执行。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式：</span><br><span class="line">一条python代码</span><br><span class="line">  </span><br><span class="line">a = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;True&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure><p>一个经典案例：</p><blockquote><p>程序员下班前女朋友打电话：下班路上买十个包子回来，如果看到卖西瓜的买一个</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baozi = <span class="number">10</span></span><br><span class="line">mxg = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> mxg:</span><br><span class="line">  baozi = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;买 %s 个包子&quot;</span> %(baozi))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">买 10 个包子</span><br></pre></td></tr></table></figure><p>正常情况下，我们是直接买了10个包子回家，那如果我们看到了卖西瓜的呢？那么这段代码中等于是我们重新赋值了<code>mxg</code>,就变成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">baozi = <span class="number">10</span></span><br><span class="line">mxg = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 走在路上看到了卖西瓜的，重新赋值</span></span><br><span class="line">mxg = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mxg:</span><br><span class="line">  baozi = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;买 %s 个包子&quot;</span> %(baozi))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">买 1 个包子</span><br></pre></td></tr></table></figure><h4 id="双分支">双分支</h4><p>双分支就是在单向分支的基础之上，又多了一个“否则”的选项，当条件不满足的时候执行其他操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式:</span><br><span class="line">一条python代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">另外一条python代码</span><br><span class="line"></span><br><span class="line">person = <span class="string">&#x27;girl&#x27;</span></span><br><span class="line"><span class="keyword">if</span> person == <span class="string">&#x27;girl&#x27;</span>:</span><br><span class="line">  <span class="comment"># 真区间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;上前搭讪：美女，能加个微信吗？&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 假区间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;直接走开。&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上前搭讪：美女，能加个微信吗？</span><br></pre></td></tr></table></figure><p>以上就是一个双向的流程控制，这里面的含义为：表达式成立则执行真区间，如果不成立则执行假区间。</p><h4 id="多分支">多分支</h4><p>多分支就是在双分支的基础之上再增加其他可能出现的判断条件，用于执行更多的其他操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式：</span><br><span class="line">    一条python代码</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">elif</span> 条件表达式：</span><br><span class="line">    一条python代码</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">elif</span> 条件表达式：</span><br><span class="line">    一条python代码</span><br><span class="line">    ...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    一条python代码</span><br><span class="line">            ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码中的<code>elif</code>就是可能出现的不同条件，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">59</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span> <span class="keyword">and</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;奖励一个手机&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;今晚吃一顿好的奖励一下&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span> <span class="keyword">and</span> score &lt; <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;鼓励：下次努力加油。&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span> <span class="keyword">and</span> score &lt; <span class="number">70</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;盯紧复习，争取下次进步。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;奖励一顿‘竹笋炒肉’&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奖励一顿‘竹笋炒肉’</span><br></pre></td></tr></table></figure><p>可以看到以上代码中，是从上到下依次进行判断条件，当所有条件都没有满足的时候，最后走到了<code>else</code>区间。</p><p>这就是多分支，需要判断多个表达式的结果，会自行其中符合条件的一个。</p><h4 id="巢状分支">巢状分支</h4><p>巢状分支，也就是嵌套分支。也就是if条件语句的嵌套：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件表达式：</span><br><span class="line">    代码语句</span><br><span class="line">    <span class="keyword">if</span> 条件表达式:</span><br><span class="line">        代码语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        代码语句</span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    代码语句</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">25</span></span><br><span class="line">height = <span class="number">177</span></span><br><span class="line">sex = <span class="string">&#x27;male&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sex == <span class="string">&#x27;male&#x27;</span>:</span><br><span class="line">    <span class="comment"># 可以往后判断</span></span><br><span class="line">    <span class="keyword">if</span> age &gt;= <span class="number">22</span> <span class="keyword">and</span> age &lt;= <span class="number">35</span>:</span><br><span class="line">        <span class="comment"># 年龄比较合适</span></span><br><span class="line">        <span class="keyword">if</span> height &gt;= <span class="number">175</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;处一下试试...&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;拉到...&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当闺蜜吧。&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处一下试试...</span><br></pre></td></tr></table></figure><blockquote><p>在嵌套分支中我们需要注意，3 ～5层嵌套就是极限了，不要再往后嵌套。如果这个层数无法解决你的问题，那么可以重新梳理一下逻辑。基本大部分时候都是逻辑上有问题了。</p></blockquote><h4 id="分支-练习十二生肖">分支 练习：十二生肖</h4><p>当用户输入一个四位数的年份，计算当前这个年份对应的生肖：</p><p><code>申猴 酉鸡 戌狗 亥猪 子鼠 丑牛 寅虎 卯兔 辰龙 已蛇 午马 未羊</code></p><p>我们先来做一个用户输入的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入的年份</span></span><br><span class="line">year = <span class="built_in">input</span>(<span class="string">&quot;请输入四位数的年份: &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(year, <span class="built_in">type</span>(year))</span><br></pre></td></tr></table></figure><p>添加一个<code>type()</code>函数是为了验证用户输入之后的数据类型，当我们输入<code>2023</code>之后，可以看到输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023 &lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><p>证明虽然我们输入的是数字，但是被转成了字符串，那这个时候，我们就需要处理一下了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入的年份</span></span><br><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入四位数的年份: &quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(year, <span class="built_in">type</span>(year))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023 &lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这下就对了。</p><p>原本我们是需要讲位数，以及范围都控制在合理的数据内的。因为时间关系，在这整个示例中，我就不再去做更多的验证判断了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入的年份</span></span><br><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入四位数的年份: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#print(year%12)</span></span><br><span class="line">num = year % <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">申猴 酉鸡 戌狗 亥猪 子鼠 丑牛 寅虎 卯兔 辰龙 巳蛇 午马 未羊</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 申猴&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 酉鸡&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 戌狗&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 亥猪&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">4</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 子鼠&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 丑牛&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 寅虎&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">7</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 卯兔&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">8</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 辰龙&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">9</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 巳蛇&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 午马&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">11</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是 ==&gt; 未羊&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;您为输入正常的年份&quot;</span>)</span><br></pre></td></tr></table></figure><p>当我输入<code>2023</code>的时候，程序输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023年是 ==&gt; 卯兔</span><br></pre></td></tr></table></figure><p>程序是正常运行了（排除我没做特殊处理可能会出现的BUG），但是我们看这段代码，已经不能用丑陋来形容了。</p><p>让我们再改动一下，还记得咱们<ahref="../Introduction-to-Python-scripting/">第二节课程</a>中所学的<code>list</code>吗？这段代码中我们去判断的<code>num</code>是不是和<code>list</code>的下标是一模一样？OK，让我们利用下标来重新写一下这段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入的年份</span></span><br><span class="line">year = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入四位数的年份：&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义十二生肖 列表</span></span><br><span class="line">items = [<span class="string">&#x27;申猴&#x27;</span>, <span class="string">&#x27;酉鸡&#x27;</span>, <span class="string">&#x27;戌狗&#x27;</span>, <span class="string">&#x27;亥猪&#x27;</span>, <span class="string">&#x27;子鼠&#x27;</span>, <span class="string">&#x27;丑牛&#x27;</span>, <span class="string">&#x27;寅虎&#x27;</span>, <span class="string">&#x27;卯兔&#x27;</span>, <span class="string">&#x27;辰龙&#x27;</span>, <span class="string">&#x27;巳蛇&#x27;</span>, <span class="string">&#x27;午马&#x27;</span>, <span class="string">&#x27;未羊&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;year&#125;</span>年是%s年&#x27;</span> %(items[year % <span class="number">12</span>]))</span><br></pre></td></tr></table></figure><p>这段代码输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2023年是卯兔年</span><br></pre></td></tr></table></figure><p>是不是比起第一段代码来优雅多了？</p><h3 id="循环结构">循环结构</h3><p>在完成了分支结构之后，我们来看一下循环结构。<strong>循环结构非常重要，必须熟练掌握。</strong></p><p>为什么我们需要循环呢？先来看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span>)</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>这段代码中，我们重复做了很多次打印的工作。这种事情，其实完全没必要重复去做，交给循环就可以了。</p><p>目前在Python中常用的循环有两个，<code>while</code>循环和<code>for...in</code>循环。</p><h4 id="while-循环">while 循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">  代码内容</span><br><span class="line">    代码内容</span><br><span class="line">    代码内容</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>在while循环中，我们通常都会写带有<strong>条件变化的循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num &lt;=<span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;num为<span class="subst">&#123;num&#125;</span>&#x27;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num为1</span><br><span class="line">num为2</span><br><span class="line">num为3</span><br><span class="line">num为4</span><br><span class="line">num为5</span><br><span class="line">num为6</span><br><span class="line">num为7</span><br><span class="line">num为8</span><br><span class="line">num为9</span><br><span class="line">num为10</span><br></pre></td></tr></table></figure><p>在这样一段代码中，在进入循环的时候，判断了一下当前条件是否成立。我们先设定了<code>num</code>的值为1，满足进入循环的条件，所以就进入了循环体，然后输出了<code>num</code>的值。</p><p>之后，每循环一次我们都对<code>num</code>做一次+1的处理.也就是更改了变量。当变量更改后，会重新走到循环体的开始去判断条件。在循环11次之后，<code>num</code>就变成了11，不符合进入循环的条件了，循环自然被终止。也可以说，更该变量也是在朝着循环结束的方向在前进。</p><p>那么如果我们没有设定这个<code>num</code>的条件变化呢，自然就是无限的循环下去，最终导致内存溢出。</p><h4 id="for循环">for循环</h4><p>通常来说，<code>for</code>循环是用来遍历一个容器类型的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 自定义变量 <span class="keyword">in</span> 容器数据:</span><br><span class="line">      代码内容,可以使用自定义变量</span><br><span class="line">      代码内容,可以使用自定义变量</span><br><span class="line">      代码内容,可以使用自定义变量</span><br></pre></td></tr></table></figure><p>使用<code>for...in</code>循环遍历容器类型数据，那么中间的自定义变量就是当前容器类型中的每一个元素。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>在整个<code>for...in</code>循环体内，我们经常使用<code>range()</code>函数来迭代输出一个范围，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>可以看到我们输出了从<code>0</code>开始，一直到<code>9</code>结束，一共输出了<code>10</code>个数字。</p><p>从结果中，我们大致可以猜到<code>range()</code>函数中<code>(a, b)</code>的含义为：<strong>从a开始循环输出，输出到b（不包含b）为止</strong>,比如，我们将刚才的数字改为<code>range(1,8)</code>，那么我们最后输出的内容就会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h4 id="其他流程控制语句">其他流程控制语句</h4><p>在循环体中，我们还经常应用一些其他的控制语句，用于程序的正常执行和中止。这其中包括</p><ul><li>continue语句， 用于跳过当前这一次循环</li><li>break语句，用于结束或者跳出</li><li>pass语句， 用于占位</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">10</span>:</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 判断当前的num是否为偶数</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># 跳过本次循环，执行下一次循环</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>可以从结果中看到，每次<code>num</code>为偶数的时候，打印并未执行，被跳过了。</p><p>让我们来更改一下这一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> num &lt;= <span class="number">10</span>:</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 判断当前的num是否为偶数</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment"># 跳过本次循环，执行下一次循环</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 跳出并结束循环，不再继续执行。</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>结果中我们可以看到，代码只输出到了5。我们来剖析一下整个代码，当代码为5的时候，<code>print()</code>函数还是正常执行了一次，然后再进来的时候，<code>num</code>在最前方+1变为了6，执行了<code>continue</code>，跳出了本次循环。再进入循环之后，<code>num</code>+1变成了7，这个时候进入了第二个<code>if</code>判断，直接执行了<code>break</code>语句，跳出并结束了整个循环。这样，<code>print()</code>函数这无法再继续执行下去了。</p><h4 id="特殊语句">特殊语句</h4><ul><li>exit()</li><li>quit()</li></ul><p>这两个特殊语句，均是用于结束程序的执行，<code>exit()</code>和<code>quit()</code>之后的代码不会执行。在单纯的循环结构中的作用与<code>break</code>很像，但是<strong>完全不能混为一谈</strong>。这两个语句是用于结束并退出当前python解释器的，而<code>break</code>仅用于结束当前的循环体。</p><h2 id="练习">练习</h2><h3 id="打印矩形">打印矩形</h3><p>让我们循环出十行十列 ★ ☆ ，隔一行换色，再做一个隔一列换色。</p><p>在最开始，我们先思考一下，十行十列，那就是完成100次打印。我们先把这部分实现一下：</p><blockquote><p>输出结果因为占篇幅，我就不写了，大家自行执行就可以了。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;☆&#x27;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在这之后，我们需要考虑一下，既然是十行十列，那说明我们每隔10个就需要一次换行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;☆&#x27;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断是否需要换行</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>现在打印出了十行<code>☆</code>,每一行十个。第一步我们已经实现了，那么现在，让我们来尝试一下隔一行打印一个不同的。思考一下，其实就是<strong>奇偶数</strong>的问题，想明白之后，接下来就好办了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隔列换色</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="comment"># 判断当前是基数还是偶数</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;☆&#x27;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;★&#x27;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断是否需要换行</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>隔列换色实现之后，我们再来考虑一下隔行换色，让我们从隔列换色上找一点灵感。既然隔列换色是奇偶数的问题，那么隔行换色，是不是就是每一行的奇偶数问题？</p><p>那么我们如何对行数做判断呢？其实很简单，我们只要对当前数字做取整数操作：<code>num // 10</code>，然后获取到的整数再来取余就行了。</p><p>那么我们就可以这样来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 隔行换色</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> num &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="comment"># 以当前行数为基数，对2取余，判断奇偶</span></span><br><span class="line">    <span class="keyword">if</span> num // <span class="number">10</span> % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;☆ &#x27;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;★&#x27;</span>, end = <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断是否需要换行</span></span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    num += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>大家可以执行去操作一下试试，建议使用JupyterNotebook，这种实验性的代码块，很方便得到结果。</p><figure><img src="https://qiniu.hivan.me/picGo/20230801220517.png?imgNote"alt="image-20230801220517578" /><figcaption aria-hidden="true">image-20230801220517578</figcaption></figure><h3 id="打印乘法口诀表">打印乘法口诀表</h3><p>这也是Python教学中经常被拿来进行教学的一个经典案例，和上一个练习一样，我们一边分析，便来完善代码。</p><p>整个代码中，我们用到了刚才学到的<code>for...in</code>循环以及<code>range()</code>函数。</p><p>首先我们利用<code>range()</code>函数，输出1到9，每输出一个换一次行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 乘法口诀表</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 换行</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>然后我们在每一行内再做一次循环，输出每一行的序列,当然还是从1开始。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 乘法口诀表</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 第二层循环，内循环</span></span><br><span class="line">    <span class="comment"># 内循环负责当前行的函数，第一行 1列 2行 2列....9行 9列</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>x<span class="subst">&#123;y&#125;</span>=<span class="subst">&#123;x*y&#125;</span>&#x27;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 换行</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>这里需要注意，就乘法表而言，我们最大列不能大于这一行的被乘数,那么我们<code>range()</code>需要调整一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 乘法口诀表</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 第二层循环，内循环</span></span><br><span class="line">    <span class="comment"># 内循环负责当前行的函数，第一行 1列 2行 2列....9行 9列</span></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, x+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;x&#125;</span>x<span class="subst">&#123;y&#125;</span>=<span class="subst">&#123;x*y&#125;</span>&#x27;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="comment"># 换行</span></span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列">斐波那契数列</h3><p>再来让我们多做一个练习，斐波那契数列。</p><p>在做这个练习之前，首先我们需要了解什么是斐波那契数列。我这里应用一下<ahref="https://zh.wikipedia.org/zh-cn/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0">维基百科的解释</a>：</p><blockquote><p><strong>斐波那契数</strong>所形成的数列称为斐波那契数列。这个数列是由意大利数学家斐波那契在他的《算盘书》中提出。在数学上，<strong>斐波那契数</strong>是以递归的方法来定义：</p><ul><li><span class="math inline">\(F_0=0\)</span></li><li><span class="math inline">\(F_1=1\)</span></li><li><spanclass="math inline">\(F_n=F_{n-1}+F_{n-2}(n&gt;=2)\)</span></li></ul><p>用文字来说，就是斐波那契数列由0和1开始，之后的斐波那契数就是由之前的两数相加而得出。首几个斐波那契数是：1、1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、987……</p></blockquote><p>了解之后，让我们来分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13...</span><br></pre></td></tr></table></figure><p>第0项如果是0，那么第一项是1， 第二项也是1，之后的第三项开始，每一项都是前面两个数的和。</p><p>因为这个数列是一个无限递归下去的数列，我们不能无限的计算下去，所以需要先知道自己计算多少项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取用户输入的数据</span></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;你需要计算多少项？&#x27;</span>))</span><br></pre></td></tr></table></figure><p>之前我们分析得到，第三项开始，每一项是前面两个数的和，那么，我们需要定义两个变量用来承载相加的两个数，再多定义一个初始值，用于判断是否执行循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;你需要计算多少项？&#x27;</span>))</span><br><span class="line">n1 = <span class="number">0</span></span><br><span class="line">n2 = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>然后，让我们开始进入正题，需要先判断用户输入的数字是否正整数，我们先不搞那么复杂，只需要简单判断一下是否大于等于0，然后再判断用户输入是否为1，因为如果是只输出1项，那么就不需要计算了，直接输出<code>n1</code>就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;你需要计算多少项？&#x27;</span>))</span><br><span class="line">n1 = <span class="number">0</span></span><br><span class="line">n2 = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line"><span class="comment"># 从之后的数字开始计算</span></span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入一个正整数。&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;斐波那契数列: <span class="subst">&#123;n1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># 占位</span></span><br></pre></td></tr></table></figure><p>然后，让我们正式进入循环计算,现在<code>n1</code>为第一项，<code>n2</code>就是第二项，直接输出就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;你需要计算多少项？&#x27;</span>))</span><br><span class="line">n1 = <span class="number">0</span></span><br><span class="line">n2 = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line"><span class="comment"># 从之后的数字开始计算</span></span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入一个正整数。&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;斐波那契数列: <span class="subst">&#123;n1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;斐波那契数列: <span class="subst">&#123;n1&#125;</span>, <span class="subst">&#123;n2&#125;</span>&#x27;</span>, end = <span class="string">&quot;, &quot;</span>)</span><br></pre></td></tr></table></figure><p>之后，我们去判断<code>count</code>是否小于用户输入的数字，如果小于，就进入循环。然后再循环内定义一个变量<code>n3</code>，用来承载相加之后得到的结果，作为当前项输出。再讲<code>n1, n2</code>重新赋值。不要忘了给<code>count</code>加值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;你需要计算多少项？&#x27;</span>))</span><br><span class="line">n1 = <span class="number">0</span></span><br><span class="line">n2 = <span class="number">1</span></span><br><span class="line">count = <span class="number">2</span></span><br><span class="line"><span class="comment"># 从之后的数字开始计算</span></span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入一个正整数。&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;斐波那契数列: <span class="subst">&#123;n1&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;斐波那契数列: <span class="subst">&#123;n1&#125;</span>, <span class="subst">&#123;n2&#125;</span>&#x27;</span>, end = <span class="string">&quot;, &quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> count &lt; num:</span><br><span class="line">        n3 = n1 + n2</span><br><span class="line">        <span class="built_in">print</span>(n3, end = <span class="string">&quot;, &quot;</span>)</span><br><span class="line">        <span class="comment"># 更新数据</span></span><br><span class="line">        n1, n2 = n2, n3</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>当我们输入9的时候，输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">斐波那契数列: 0, 1, 1, 2, 3, 5, 8, 13, 21, </span><br></pre></td></tr></table></figure><h3 id="百钱买百鸡">百钱买百鸡</h3><p>让我们先来说明一下这个题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一共有100块钱，需要买100只鸡</span><br><span class="line">公鸡 3元钱一只，母鸡1元钱一只，小鸡5毛钱一只。</span><br><span class="line">要求计算，100块钱买100只鸡，一共有多少种方案</span><br></pre></td></tr></table></figure><p>在这个题目里，我们可以计算如果只买一种，这公鸡可以有33只，母鸡有100只，小鸡这可以买200只。</p><p>这里面我们可以思考一下，这里我们一共需要3个变量和2个常量，变量为公鸡，母鸡以及小鸡；2个常量为100块钱和总共100只鸡。</p><p>先让我们从循环体来开始写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> gj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">34</span>):</span><br><span class="line">    <span class="keyword">for</span> mj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">        <span class="keyword">for</span> xj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">            <span class="comment"># 判断是否为100只，是否话费100元</span></span><br><span class="line">            <span class="keyword">if</span> gj + mj + xj == <span class="number">100</span> <span class="keyword">and</span> gj*<span class="number">3</span> + mj + xj*<span class="number">0.5</span> == <span class="number">100</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;公鸡<span class="subst">&#123;gj&#125;</span>只，母鸡<span class="subst">&#123;mj&#125;</span>只，小鸡<span class="subst">&#123;xj&#125;</span>只， 共花费<span class="subst">&#123;gj*<span class="number">3</span> + mj + xj*<span class="number">0.5</span>&#125;</span>元&#x27;</span>)</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>这里，我们是计算了三只都买的情况，那么其实还有一种额外的情况，就是我们一开始说的，100块钱都买母鸡的情况，也正好是100块钱100只鸡。所以，我们的<code>num</code>要从1开始计数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> gj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">34</span>):</span><br><span class="line">    <span class="keyword">for</span> mj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">        <span class="keyword">for</span> xj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">            <span class="comment"># 判断是否为100只，是否话费100元</span></span><br><span class="line">            <span class="keyword">if</span> gj + mj + xj == <span class="number">100</span> <span class="keyword">and</span> gj*<span class="number">3</span> + mj + xj*<span class="number">0.5</span> == <span class="number">100</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;公鸡<span class="subst">&#123;gj&#125;</span>只，母鸡<span class="subst">&#123;mj&#125;</span>只，小鸡<span class="subst">&#123;xj&#125;</span>只， 共花费<span class="subst">&#123;gj*<span class="number">3</span> + mj + xj*<span class="number">0.5</span>&#125;</span>元&#x27;</span>)</span><br><span class="line">                num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>输出结果（只看num）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><p>也就是说，我们目前一共有20种组合方案。具体有哪些方案，有兴趣的小伙伴可以执行我所写的代码，会打印出来。</p><p>虽然解决问题了，可是这并不是最好的写法。</p><p>看看这团垃圾的效率：第一层需要计算34次，第一层每次计算，第二层都要计算100次，第二层每跑一遍，第三层需要计算200次....这简直就是一堆米田共。当我们加上一个计数变量稍微统计一下到底计算了多少次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">for</span> xj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">201</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 判断是否为100只，是否话费100元</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure><p>可以得到最后结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">660000</span><br></pre></td></tr></table></figure><p>是不是很恐怖？让我们改动一下代码，优化性能：</p><p>让我们来思考一下，100只鸡这个总数是不是固定不变的？那么公鸡，母鸡的计算得到之后，是不是小鸡的数量就得到了。还有必要在进入一次循环吗？肯定没必要了对不对？所以我们这样改动：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> gj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">34</span>):</span><br><span class="line">    <span class="keyword">for</span> mj <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">        xj = <span class="number">100</span> - gj - mj</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 判断是否为100只，是否话费100元</span></span><br><span class="line">        <span class="keyword">if</span> gj + mj + xj == <span class="number">100</span> <span class="keyword">and</span> gj*<span class="number">3</span> + mj + xj*<span class="number">0.5</span> == <span class="number">100</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;公鸡<span class="subst">&#123;gj&#125;</span>只，母鸡<span class="subst">&#123;mj&#125;</span>只，小鸡<span class="subst">&#123;xj&#125;</span>只， 共花费<span class="subst">&#123;gj*<span class="number">3</span> + mj + xj*<span class="number">0.5</span>&#125;</span>元&#x27;</span>)</span><br><span class="line">            num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;一共有<span class="subst">&#123;num&#125;</span>种组合方式。&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;当前一共计算了<span class="subst">&#123;count&#125;</span>次&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后得到的计算结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一共有20种组合方式。</span><br><span class="line">当前一共计算了3300次</span><br></pre></td></tr></table></figure><p>从660000次一下下降到了3300次，这个性能的提示是很大的了。</p><p>所以，很多问题我们不要只追求解决，要善于多思考。</p><p>那么至此，我们这节课也就结束了。让我们最后放几个思考题：</p><h2 id="思考题">思考题</h2><ol type="1"><li>对于我们打印矩阵，完成了隔行上色和隔列上色的问题，我们思考一下该如何解决<code>三角形和菱形</code>；</li><li>对于乘法表，思考下我们如何完成反向打印。</li></ol><p>解决了思考题的小伙伴，可以在评论区留言。期待看到大家的想法。我是茶桁，咱们下次见，下一节课，我们进入「模块化编程」，开始学习函数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;在前面几节课的基础之上，我们今天开始尝试在Python中控制流程。这中间，让我们来做一些实际的练习。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>3. Python3 运算符</title>
    <link href="https://hivan.me/Python-operators/"/>
    <id>https://hivan.me/Python-operators/</id>
    <published>2023-07-31T10:10:12.000Z</published>
    <updated>2023-07-31T15:41:43.903Z</updated>
    
    <content type="html"><![CDATA[<p>Hi，大家好。我是茶桁。</p><p>前两节我们学习了基本的Python特性和语法，并且认识了一些基本的Python脚本。今天，我们来学习一下Python的运算符，而我们选择的版本为Python3。</p><span id="more"></span><h2 id="什么是运算符">什么是运算符</h2><p>为了能让我们的学习顺利进行下去，首先我们需要先弄明白：什么是<strong>运算符</strong>。</p><p>这里举一个简单的栗子：<span class="math inline">\(4 + 5 = 9\)</span>,在这个简单的数学计算栗子中，4和5倍称为操作数，<code>+</code>就被成为是运算符,最后9就是它的运算结果。</p><p>到这里，我们对于运算符应该有了一个基本的认知，那么Python语言都支持哪些运算符呢？如下列表：</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li><li>运算符优先级</li></ul><p>接下来，就让我们来一个个的学习Python的运算符</p><h2 id="算术运算符">算术运算符</h2><table><colgroup><col style="width: 7%" /><col style="width: 60%" /><col style="width: 32%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">+</td><td style="text-align: left;">加 - 两个对象相加</td><td style="text-align: left;">a + b 输出结果 31</td></tr><tr class="even"><td style="text-align: left;">-</td><td style="text-align: left;">减 - 得到负数或是一个数减去另一个数</td><td style="text-align: left;">a - b 输出结果 -11</td></tr><tr class="odd"><td style="text-align: left;">*</td><td style="text-align: left;">乘 -两个数相乘或是返回一个被重复若干次的字符串</td><td style="text-align: left;">a * b 输出结果 210</td></tr><tr class="even"><td style="text-align: left;">/</td><td style="text-align: left;">除 - x 除以 y</td><td style="text-align: left;">b / a 输出结果 2.1</td></tr><tr class="odd"><td style="text-align: left;">%</td><td style="text-align: left;">取模 - 返回除法的余数</td><td style="text-align: left;">b % a 输出结果 1</td></tr><tr class="even"><td style="text-align: left;">**</td><td style="text-align: left;">幂 - 返回x的y次幂</td><td style="text-align: left;">a**b 为10的21次方</td></tr><tr class="odd"><td style="text-align: left;">//</td><td style="text-align: left;">取整除 - 向下取接近除数的整数</td><tdstyle="text-align: left;"><code>&gt;&gt;&gt; 9//2 4 &gt;&gt;&gt; -9//2 -5</code></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 算术运算符</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">21</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a+b=&quot;</span>, a+b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a-b=&quot;</span>, a-b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a*b=&quot;</span>, a*b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b/a=&quot;</span>, b/a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b%a=&quot;</span>, b%a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a**b=&quot;</span>, a**b)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>//<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(-<span class="number">9</span>//<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a+b= 31</span><br><span class="line">a-b= -11</span><br><span class="line">a*b= 210</span><br><span class="line">b/a= 2.1</span><br><span class="line">b%a= 1</span><br><span class="line">a**b= 1000000000000000000000</span><br><span class="line">4</span><br><span class="line">-5</span><br></pre></td></tr></table></figure><h2 id="比较运算符">比较运算符</h2><table><colgroup><col style="width: 6%" /><col style="width: 68%" /><col style="width: 24%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">==</td><td style="text-align: left;">等于 - 比较对象是否相等</td><td style="text-align: left;">(a == b) 返回 False。</td></tr><tr class="even"><td style="text-align: left;">!=</td><td style="text-align: left;">不等于 - 比较两个对象是否不相等</td><td style="text-align: left;">(a != b) 返回 True。</td></tr><tr class="odd"><td style="text-align: left;">&gt;</td><td style="text-align: left;">大于 - 返回x是否大于y</td><td style="text-align: left;">(a &gt; b) 返回 False。</td></tr><tr class="even"><td style="text-align: left;">&lt;</td><td style="text-align: left;">小于 -返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td><td style="text-align: left;">(a &lt; b) 返回 True。</td></tr><tr class="odd"><td style="text-align: left;">&gt;=</td><td style="text-align: left;">大于等于 - 返回x是否大于等于y。</td><td style="text-align: left;">(a &gt;= b) 返回 False。</td></tr><tr class="even"><td style="text-align: left;">&lt;=</td><td style="text-align: left;">小于等于 - 返回x是否小于等于y。</td><td style="text-align: left;">(a &lt;= b) 返回 True。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a==b:&quot;</span>, a==b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a!=b:&quot;</span>, a!=b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&gt;b:&quot;</span>, a&gt;b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&lt;b:&quot;</span>, a&lt;b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&gt;=b:&quot;</span>, a&gt;=b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&lt;=b:&quot;</span>, a&lt;=b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a==b: False</span><br><span class="line">a!=b: True</span><br><span class="line">a&gt;b: False</span><br><span class="line">a&lt;b: True</span><br><span class="line">a&gt;=b: False</span><br><span class="line">a&lt;=b: True</span><br></pre></td></tr></table></figure><h2 id="赋值运算符">赋值运算符</h2><table><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">=</td><td style="text-align: left;">简单的赋值运算符</td><td style="text-align: left;">c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr class="even"><td style="text-align: left;">+=</td><td style="text-align: left;">加法赋值运算符</td><td style="text-align: left;">c += a 等效于 c = c + a</td></tr><tr class="odd"><td style="text-align: left;">-=</td><td style="text-align: left;">减法赋值运算符</td><td style="text-align: left;">c -= a 等效于 c = c - a</td></tr><tr class="even"><td style="text-align: left;">*=</td><td style="text-align: left;">乘法赋值运算符</td><td style="text-align: left;">c <em>= a 等效于 c = c </em> a</td></tr><tr class="odd"><td style="text-align: left;">/=</td><td style="text-align: left;">除法赋值运算符</td><td style="text-align: left;">c /= a 等效于 c = c / a</td></tr><tr class="even"><td style="text-align: left;">%=</td><td style="text-align: left;">取模赋值运算符</td><td style="text-align: left;">c %= a 等效于 c = c % a</td></tr><tr class="odd"><td style="text-align: left;">**=</td><td style="text-align: left;">幂赋值运算符</td><td style="text-align: left;">c <strong>= a 等效于 c = c </strong>a</td></tr><tr class="even"><td style="text-align: left;">//=</td><td style="text-align: left;">取整除赋值运算符</td><td style="text-align: left;">c //= a 等效于 c = c // a</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 赋值运算符</span></span><br><span class="line">c = a+b</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c+=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c-=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c*=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c/=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c%=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">c//=a</span><br><span class="line"><span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">31</span><br><span class="line">41</span><br><span class="line">31</span><br><span class="line">310</span><br><span class="line">31.0</span><br><span class="line">1.0</span><br><span class="line">10</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="位运算符">位运算符</h2><p>按位运算符是把数字看作二进制来进行计算的。<code>bin()</code>函数可以把数字转为二进制。</p><p>Python中的按位运算法则如下：</p><p>下表中变量 a 为 60，b 为 13二进制格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = 0011 <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">a&amp;b = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line"></span><br><span class="line">a|b = 0011 <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">a^b = 0011 0001</span><br><span class="line"></span><br><span class="line">~a  = <span class="number">1100</span> 0011</span><br></pre></td></tr></table></figure><table style="width:100%;"><colgroup><col style="width: 4%" /><col style="width: 47%" /><col style="width: 47%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">&amp;</td><tdstyle="text-align: left;">按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td style="text-align: left;">(a &amp; b) 输出结果 12 ，二进制解释：0000 1100</td></tr><tr class="even"><td style="text-align: left;">|</td><tdstyle="text-align: left;">按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td style="text-align: left;">(a | b) 输出结果 61 ，二进制解释： 00111101</td></tr><tr class="odd"><td style="text-align: left;">^</td><tdstyle="text-align: left;">按位异或运算符：当两对应的二进位相异时，结果为1</td><td style="text-align: left;">(a ^ b) 输出结果 49 ，二进制解释： 00110001</td></tr><tr class="even"><td style="text-align: left;">~</td><tdstyle="text-align: left;">按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。<strong>~x</strong>类似于 <strong>-x-1</strong></td><td style="text-align: left;">(~a ) 输出结果 -61 ，二进制解释： 11000011， 在一个有符号二进制数的补码形式。</td></tr><tr class="odd"><td style="text-align: left;">&lt;&lt;</td><tdstyle="text-align: left;">左移动运算符：运算数的各二进位全部左移若干位，由"&lt;&lt;"右边的数指定移动的位数，高位丢弃，低位补0。</td><td style="text-align: left;">a &lt;&lt; 2 输出结果 240 ，二进制解释：1111 0000</td></tr><tr class="even"><td style="text-align: left;">&gt;&gt;</td><tdstyle="text-align: left;">右移动运算符：把"&gt;&gt;"左边的运算数的各二进位全部右移若干位，"&gt;&gt;"右边的数指定移动的位数</td><td style="text-align: left;">a &gt;&gt; 2 输出结果 15 ，二进制解释：0000 1111</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">20</span>))</span><br><span class="line">a = <span class="number">60</span></span><br><span class="line">b = <span class="number">13</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a = &quot;</span>, <span class="built_in">bin</span>(a), <span class="string">&quot;, b = &quot;</span>, <span class="built_in">bin</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&amp;b =&quot;</span>,<span class="built_in">bin</span>(a&amp;b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a|b =&quot;</span>,<span class="built_in">bin</span>(a|b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a^b =&quot;</span>,<span class="built_in">bin</span>(a^b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;~a =&quot;</span>,<span class="built_in">bin</span>(~a))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&lt;&lt;2 = &quot;</span>,<span class="built_in">bin</span>(a&lt;&lt;<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a&gt;&gt;2 = &quot;</span>,<span class="built_in">bin</span>(a&gt;&gt;<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0b10100</span><br><span class="line">a =  0b111100 , b =  0b1101</span><br><span class="line">a&amp;b = 0b1100</span><br><span class="line">a|b = 0b111101</span><br><span class="line">a^b = 0b110001</span><br><span class="line">~a = -0b111101</span><br><span class="line">a&lt;&lt;2 =  0b11110000</span><br><span class="line">a&gt;&gt;2 =  0b1111</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符">逻辑运算符</h2><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><colgroup><col style="width: 6%" /><col style="width: 10%" /><col style="width: 60%" /><col style="width: 23%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">逻辑表达式</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">and</td><td style="text-align: left;">x and y</td><td style="text-align: left;">布尔"与" - 如果 x 为 False，x and y 返回False，否则它返回 y 的计算值。</td><td style="text-align: left;">(a and b) 返回 20。</td></tr><tr class="even"><td style="text-align: left;">or</td><td style="text-align: left;">x or y</td><td style="text-align: left;">布尔"或" - 如果 x 是 True，它返回 x的值，否则它返回 y 的计算值。</td><td style="text-align: left;">(a or b) 返回 10。</td></tr><tr class="odd"><td style="text-align: left;">not</td><td style="text-align: left;">not x</td><td style="text-align: left;">布尔"非" - 如果 x 为 True，返回 False。如果 x 为 False，它返回 True。</td><td style="text-align: left;">not(a and b) 返回 False</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 逻辑运算符</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a and b = &quot;</span>, a <span class="keyword">and</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a or b = &quot;</span>, a <span class="keyword">or</span> b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not(a and b) = &quot;</span>, <span class="keyword">not</span>(a <span class="keyword">and</span> b))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a and b =  20</span><br><span class="line">a or b =  10</span><br><span class="line">not(a and b) =  False</span><br></pre></td></tr></table></figure><h2 id="成员运算符">成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><colgroup><col style="width: 5%" /><col style="width: 50%" /><col style="width: 44%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">in</td><td style="text-align: left;">如果在指定的序列中找到值返回True，否则返回 False。</td><td style="text-align: left;">x 在 y 序列中 , 如果 x 在 y 序列中返回True。</td></tr><tr class="even"><td style="text-align: left;">not in</td><td style="text-align: left;">如果在指定的序列中没有找到值返回True，否则返回 False。</td><td style="text-align: left;">x 不在 y 序列中 , 如果 x 不在 y 序列中返回True。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 成员运算符</span></span><br><span class="line">x = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x in y :&quot;</span>, x <span class="keyword">in</span> y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x not in y :&quot;</span>, x <span class="keyword">not</span> <span class="keyword">in</span> y)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x in y : False</span><br><span class="line">x not in y : True</span><br></pre></td></tr></table></figure><h2 id="身份运算符">身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p><table><colgroup><col style="width: 5%" /><col style="width: 39%" /><col style="width: 55%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th><th style="text-align: left;">实例</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">is</td><td style="text-align: left;">is是判断两个标识符是不是引用自一个对象</td><td style="text-align: left;"><strong>x is y</strong>, 类似<strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回True，否则返回 False</td></tr><tr class="even"><td style="text-align: left;">is not</td><td style="text-align: left;">is not是判断两个标识符是不是引用自不同对象</td><td style="text-align: left;"><strong>x is not y</strong> ， 类似<strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果True，否则返回 False。</td></tr></tbody></table><p><strong>注：</strong> <ahref="https://www.runoob.com/python/python-func-id.html">id()</a>函数用于获取对象内存地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 身份运算符</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">y = x</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is y:&quot;</span>, x <span class="keyword">is</span> y)</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is y:&quot;</span>, x <span class="keyword">is</span> y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;id(x) == id(y)&quot;</span>, <span class="built_in">id</span>(x) == <span class="built_in">id</span>(y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is not y:&quot;</span>, x <span class="keyword">is</span> <span class="keyword">not</span> y)</span><br><span class="line"><span class="built_in">id</span>(x)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x is y: True</span><br><span class="line">x is y: True</span><br><span class="line">id(x) == id(y) True</span><br><span class="line">x is not y: False</span><br><span class="line"></span><br><span class="line">4312793616</span><br></pre></td></tr></table></figure><blockquote><p>is 与 == 区别：</p><p>is 用于判断两个变量引用对象是否为同一个， ==用于判断引用变量的值是否相等。</p></blockquote><h2 id="运算符优先级">运算符优先级</h2><p>以下表格列出了从最高到最低优先级的所有运算符：</p><table><colgroup><col style="width: 30%" /><col style="width: 69%" /></colgroup><thead><tr class="header"><th style="text-align: left;">运算符</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">**</td><td style="text-align: left;">指数 (最高优先级)</td></tr><tr class="even"><td style="text-align: left;">~ + -</td><td style="text-align: left;">按位翻转, 一元加号和减号(最后两个的方法名为 +@ 和 -@)</td></tr><tr class="odd"><td style="text-align: left;">* / % //</td><td style="text-align: left;">乘，除，取模和取整除</td></tr><tr class="even"><td style="text-align: left;">+ -</td><td style="text-align: left;">加法减法</td></tr><tr class="odd"><td style="text-align: left;">&gt;&gt; &lt;&lt;</td><td style="text-align: left;">右移，左移运算符</td></tr><tr class="even"><td style="text-align: left;">&amp;</td><td style="text-align: left;">位 'AND'</td></tr><tr class="odd"><td style="text-align: left;">^ |</td><td style="text-align: left;">位运算符</td></tr><tr class="even"><td style="text-align: left;">&lt;= &lt; &gt; &gt;=</td><td style="text-align: left;">比较运算符</td></tr><tr class="odd"><td style="text-align: left;">== !=</td><td style="text-align: left;">等于运算符</td></tr><tr class="even"><td style="text-align: left;">= %= /= //= -= += *= **=</td><td style="text-align: left;">赋值运算符</td></tr><tr class="odd"><td style="text-align: left;">is is not</td><td style="text-align: left;">身份运算符</td></tr><tr class="even"><td style="text-align: left;">in not in</td><td style="text-align: left;">成员运算符</td></tr><tr class="odd"><td style="text-align: left;">not and or</td><td style="text-align: left;">逻辑运算符</td></tr></tbody></table><blockquote><p>注意：Pyhton3 已不支持 &lt;&gt; 运算符，可以使用 != 代替</p></blockquote><p>本教程相关代码<ahref="https://github.com/hivandu/AI_Cheats">可在此查看</a></p><p>​</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi，大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;前两节我们学习了基本的Python特性和语法，并且认识了一些基本的Python脚本。今天，我们来学习一下Python的运算符，而我们选择的版本为Python3。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>21. 尝试制作你自己的数字人进行播报</title>
    <link href="https://hivan.me/Digital-human-broadcasting/"/>
    <id>https://hivan.me/Digital-human-broadcasting/</id>
    <published>2023-07-30T11:40:07.000Z</published>
    <updated>2023-07-31T10:20:40.706Z</updated>
    
    <content type="html"><![CDATA[<p>Hi， 大家好。我是茶桁。</p><p>在之前的课程中，我们接触了AI进行文字回复，语音合成。</p><span id="more"></span><p>那么将这两个组合在一起，我们基本就可以制作一个智能的语音聊天机器人了。看过电影《Her》的同学都应该清楚，AI因为用了女神斯嘉丽.约翰逊的配音，吸引到了不少的观众。</p><p>不过，我们怎么能就满足于此呢，从文字到音频，我们似乎还缺少了一点什么。是啊，谁不希望拥有一个特定的虚拟人来发出自己特定的语音。看着自己在镜头面前侃侃而谈的样子，是不是想想就兴奋？</p><p>把这些需求都结合在一起，那就是“数字人”了，我相信各位小伙伴或多或少都已经接触过，至少在抖音上看到过其他主播的“数字人”了。但是我们不得不说，那些都是一些商业公司的成熟方案，而咱们要实现的内容肯定比不了人家，但是作为概念演示，那是完全够用了。</p><p>好了，让我开始吧。首先呢，让我们先制作一个语音聊天机器人</p><h2 id="语音聊天机器人的制作">语音聊天机器人的制作</h2><h3 id="第一步文本聊天">第一步：文本聊天</h3><p>第一步是什么？当然是需要先做一个「文本聊天机器人」，还记得咱们<ahref="../Quickly-build-an-AI-application/">第六讲</a>的内容吗？接下来，咱们就需要用到第六讲中的代码逻辑，整个UI界面也还是使用Gradio来创建。</p><blockquote><p>由于本文在其他平台已经成为收费文章，为了避免损害付费会员权益，所以此处做删减处理。</p><p>希望继续观看的，请订阅我的公众号。</p><p><imgsrc="https://qiniu.hivan.me/picGo/20230727142457.png?imgNote" /></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi， 大家好。我是茶桁。&lt;/p&gt;
&lt;p&gt;在之前的课程中，我们接触了AI进行文字回复，语音合成。&lt;/p&gt;</summary>
    
    
    
    <category term="从零开始接触人工智能大模型" scheme="https://hivan.me/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>2. 初识Python脚本</title>
    <link href="https://hivan.me/Introduction-to-Python-scripting/"/>
    <id>https://hivan.me/Introduction-to-Python-scripting/</id>
    <published>2023-07-30T09:06:11.000Z</published>
    <updated>2023-07-30T09:09:39.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python的系列课程是写给零基础的小白看的，如果基础比较好的小伙伴可以暂时先不关注，等待后续课程。</p></blockquote><p>Hi， 大家好，我是茶桁。</p><p>之前的课程已经给大家讲解了Python相关特性和基本语法。那么这节课呢，我们尝试着从最简单的脚本来开始认识Python。</p><span id="more"></span><p>在开始这节课之前呢，我是默认大家已经安装好了VSCode，并且配置好了Jupyter环境和Python的基本环境。如果在这一步有疑问的小伙伴，可以留言私信我。</p><p>我们在终端里输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python -V</span><br><span class="line">Python 3.10.11</span><br></pre></td></tr></table></figure><p>可以看到自己的Python版本。</p><p>这个时候，我们其实已经可以在终端里进行Python的代码编辑了，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="string">&quot;Hello AI Cheats&quot;</span>)</span><br><span class="line">Hello AI Cheats</span><br></pre></td></tr></table></figure><p>如下图：</p><figure><img src="https://qiniu.hivan.me/picGo/20230730162816.png?imgNote"alt="image-20230730162816574" /><figcaption aria-hidden="true">image-20230730162816574</figcaption></figure><p>我们这里需要理解一下，编写python程序的文件，称为python的脚本或程序。要求我们当前的python脚本的文件后缀名必须是<code>.py</code>，如果是Jupyter的文件，后缀是<code>.ipynb</code></p><h3 id="print-输出函数">print() 输出函数</h3><p><code>print</code>可以在程序中输出一些内容，如字符串，数字等等。</p><p>函数就是为了完成一些功能，例如： print就是为了输出数据。</p><h2 id="变量">变量</h2><p>变量就是用一个英文字符串来记录或标记一些数据，并且这个被标记的数据是可以变化的。</p><p>比如<code>num = 10</code>，就是把数据10赋值给了变量<code>num</code>来使用，之后就可以使用<code>num</code>来代替这个10的数据。</p><h3 id="命名规范">命名规范</h3><p>这里我们强调一下Python的命名规范，所有在教授编程的教程中最初一定都会强调规范性。</p><p>变量的命名规范如下：</p><ul><li>变量名可以使用字母，数字，下划线_，</li><li>不能以数字开头</li><li>严格区分大小写</li><li>不要使用中文</li><li>不要使用关键字 if else True False print</li></ul><p>当然具体关键字并不仅仅是这些，这里列出了<ahref="https://www.w3school.com.cn/python/python_ref_keywords.asp">Python的关键字</a>，大家可以自行查看一下，命名的时候需要进行避免。</p><h3 id="变量的定义方式">变量的定义方式</h3><p>在遵循了变量命名规范之下，我们可以有以下几种定义方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种定义方式</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种定义方式</span></span><br><span class="line">a,b = <span class="number">30</span>, <span class="number">40</span></span><br></pre></td></tr></table></figure><p>这里我们来思考一个问题，如何实现两个变量的数据相互交换呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义两个变量</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交换两个变量的值</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果使用最普通的方式完成变量数据的交换，那么我们可以使用如下步骤：</p><ol type="1"><li>把a变量的值 赋值给c ，此时 c变量中 就是 10</li><li>把b变量的值 赋值给a ， 此时 a变量中 就是 20</li><li>把c变量的值 赋值给b ， 此时 b变量中 就是 10</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通方式交换数据</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20, 10</span><br></pre></td></tr></table></figure><p>我们还可以利用python定义比变量的语法来实现变量的数据交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义比变量的语法方式</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="built_in">print</span>(a, b)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20,10</span><br></pre></td></tr></table></figure><h2 id="python的数据类型">Python的数据类型</h2><p>数据类型就是数据的表现形式，比如 <code>“你好”</code>就是一个字符串，<code>200</code> 就是一个数字。</p><p>在程序当中除了这种常用的字符和数字外还有很多其它的数据表现形式。</p><p>在Python中，我们可以使用<code>type()</code>函数来返回当前数据的数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;ilovechaheng&#x27;</span></span><br><span class="line">res = <span class="built_in">type</span>(s)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure><h3 id="字符串类型">字符串类型</h3><ul><li>单双引号都可以定义字符串</li><li>三引号也可以定义字符串</li><li>单双引号定义的字符串不能随意换行，需要在换行时指明换行符</li><li>字符串中的引号可以互相嵌套，但是不能嵌套自己（例如不能在单引号中嵌套单引号，除非转义）</li><li>字符串中可以使用转义字符，如 ..</li><li>如果不想在字符串中实现转义字符可以在字符定义时 加<code>love = r'\nihao \shijie'</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号和双引号进行定义</span></span><br><span class="line">love = <span class="string">&#x27;iloveyou&#x27;</span></span><br><span class="line">hello = <span class="string">&quot;你好 世界&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用三引号实现大字符串的定义，一般用于大文本字符串的定义，并且大字符串，可以换行</span></span><br><span class="line">s = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">比如说这一个</span></span><br><span class="line"><span class="string">很长很长的文章内容。。。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="数字类型">数字类型</h3><ul><li>int 整型</li><li>float 浮点类型</li><li>complex 复数</li><li>bool 布尔类型（True，False）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字类型 Number</span></span><br><span class="line">varn = <span class="number">521</span></span><br><span class="line">varn = -<span class="number">1111</span></span><br><span class="line">varn = <span class="number">3.1415926</span></span><br><span class="line">varn = <span class="number">0x10</span>  <span class="comment"># 十六进制</span></span><br><span class="line">varn = <span class="string">b&#x27;001100111&#x27;</span> <span class="comment"># bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复数</span></span><br><span class="line">varn = <span class="number">5</span>+<span class="number">6j</span>  <span class="comment"># complex</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布尔类型  bool</span></span><br><span class="line">varn = <span class="literal">True</span></span><br><span class="line">varn = <span class="literal">False</span></span><br><span class="line"><span class="comment"># print(varn,type(varn))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数值类型可以参与运算</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(a+b) <span class="comment"># 输出结果 30</span></span><br></pre></td></tr></table></figure><h3 id="list列表类型">List列表类型</h3><ul><li>列表用来表示一系列数据，例如： 需要记录一组数字或其它数据</li><li>列表中存储的数据可以是任意类型的</li><li>在需要记录多个数据时，可以使用中括号进行定义 [],</li><li>并且每个数据之间使用逗号分隔 ,</li><li>例如以下数据，定义了几组数字</li><li>列表中存储的每一组数据，称为元素</li><li>列表中存储的数据，可以通过下标的方式进行获取</li><li>那么列表中元素的值可不可以存储一个列表,称为 二级列表（二维列表）或者 多级列表 （多维列表）</li></ul><p>关于列表中的下标，正读和反读的正负号是不一样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关于列表中的下标</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  0   1   2    3    4 </span></span><br><span class="line"><span class="string">[&#x27;a&#x27;,&#x27;b&#x27;,521,&#x27;pai&#x27;,3.1415926]</span></span><br><span class="line"><span class="string"> -5   -4   -3  -2   -1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">521</span>,<span class="string">&#x27;pai&#x27;</span>,<span class="number">3.1415926</span>]</span><br><span class="line"><span class="built_in">print</span>(a[-<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">521</span><br></pre></td></tr></table></figure><h3 id="tuple-元组类型的定义">tuple 元组类型的定义</h3><ul><li>在定义多个数据内容时，可以选择使用List列表类型</li><li>还可以使用元组类型来定义，</li><li>元组和列表非常像，都时用于存储多个数据时使用</li><li>元组使用小括号进行定义（），列表使用中括号进行定义</li><li><strong>元组的最大特点就是值不能被改变</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vart = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="comment"># 元组的其它定义方式</span></span><br><span class="line">vart = <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p>注意在定义元组时，如果元组中只有一个元素，那么需要加,不然就不是元组类型了</p></blockquote><h3 id="dict字典类型">Dict字典类型</h3><ul><li>字典也是用于存储一组或多组数据时使用，使用大括号 {}来定义</li><li>字典是 键值对 的存储方式 name ：admin</li><li>键和值之间使用冒号进行分隔，多组键值对之间使用逗号分隔</li><li>键必须是字符串或数字类型，值可以是任意类型</li><li>键名不能重复，值可以重复</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比如需要记录一本书的相关数据 书名，作者，价格，。。。</span></span><br><span class="line">vard = &#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;&lt;&lt;鬼谷子&gt;&gt;&#x27;</span>,<span class="string">&#x27;author&#x27;</span>:<span class="string">&#x27;鬼谷子&#x27;</span>,<span class="string">&#x27;price&#x27;</span>:<span class="string">&#x27;29.99&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># print(vard,type(vard))</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;&lt;&lt;鬼谷子&gt;&gt;&#x27;, &#x27;author&#x27;: &#x27;鬼谷子&#x27;, &#x27;price&#x27;: &#x27;29.99&#x27;&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典中的值</span></span><br><span class="line"><span class="built_in">print</span>(vard[<span class="string">&#x27;title&#x27;</span>])</span><br><span class="line"><span class="comment"># 字典中的键不能重复使用，否则会覆盖</span></span><br><span class="line">vard = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;aa&#x27;</span>,<span class="number">1</span>:<span class="string">&#x27;abcdef&#x27;</span>,<span class="string">&#x27;2&#x27;</span>:<span class="string">&#x27;2222&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(vard)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;鬼谷子&gt;&gt;</span><br><span class="line">&#123;&#x27;a&#x27;: &#x27;aa&#x27;, &#x27;b&#x27;: 10, &#x27;c&#x27;: 20, 1: &#x27;abcdef&#x27;, &#x27;2&#x27;: &#x27;2222&#x27;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在python之前的版本中，字典是无序的</p></blockquote><h3 id="set集合类型">set集合类型</h3><ul><li>set集合是一个 无序且元素不重复的 集合的数据类型</li><li>set集合使用 中括号或者set()方法来定义</li><li>如果需要定义一个空集合时 只能使用set()方法,因为大括号时定义的空字典</li><li>集合主要用于运算，交集，差集，并集，对称集合</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 给集合添加元素</span></span><br><span class="line"><span class="comment"># a.add(&#x27;b&#x27;)</span></span><br><span class="line"><span class="comment"># 无法获取集合中的单个元素，但是可以添加和删除</span></span><br><span class="line"><span class="comment"># a.discard(&#x27;a&#x27;)</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="comment"># 检查当前的元素是否在集合中</span></span><br><span class="line"><span class="comment"># print(1 in a)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合主要用于运算，交集，差集，并集，对称集合</span></span><br><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">22</span>,<span class="number">33</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b) <span class="comment"># 交集  &#123;1, &#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(a - b) <span class="comment"># 差集 &#123;&#x27;b&#x27;, 2, 3&#125;  a 集合有，b集合没有的</span></span><br><span class="line"><span class="built_in">print</span>(a | b) <span class="comment"># 并集 &#123;1, 2, 3, 33, &#x27;a&#x27;, &#x27;b&#x27;, 22&#125; 两个集合，放到一起，并且去重</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b) <span class="comment"># 对称差集 &#123;33, 2, 3, &#x27;b&#x27;, 22&#125; </span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;1, &#x27;a&#x27;&#125;</span><br><span class="line">&#123;2, 3, &#x27;b&#x27;&#125;</span><br><span class="line">&#123;1, 2, 3, &#x27;a&#x27;, 33, 22, &#x27;b&#x27;&#125;</span><br><span class="line">&#123;33, 2, 3, 22, &#x27;b&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>最后，让我们来进行总结一下，关于Python的数据类型可以查看如下列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">字符串 string</span><br><span class="line">数字类型 Number</span><br><span class="line">    整型 int</span><br><span class="line">    浮点 float</span><br><span class="line">    复数</span><br><span class="line">    布尔 bool</span><br><span class="line">列表  list</span><br><span class="line">元组  tuple</span><br><span class="line">字典  dict</span><br><span class="line">集合  set</span><br><span class="line"></span><br><span class="line">可变数据类型：列表，字典，集合</span><br><span class="line">不可不数据类型： 字符串，数字，元组</span><br><span class="line"></span><br><span class="line">容器类型数据 ： 字符串，列表，元组，集合，字典</span><br><span class="line">非容器类型数据： 数字，布尔类型</span><br></pre></td></tr></table></figure><h2 id="数据类型转换">数据类型转换</h2><p><strong>什么是数据类型转换？</strong></p><p>把一个数据类型转换为另一个数据类型，例如 字符串转为数字</p><p><strong>为什么需要数据类型转换？</strong></p><p>因为不同的数据类型之间不能运算</p><p><strong>数据类型转换的形式？</strong></p><ul><li>自动类型转换</li><li>强制类型转换</li></ul><h3 id="自动类型转换">自动类型转换</h3><p>当两个不同的值进行运算时，结果会向更高的精度进行计算：<code>True ==&gt; 整型 ==&gt; 浮点 ==&gt; 复数</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">b = <span class="literal">True</span>  <span class="comment"># 在和数字运算时 True转为数字1，False转为数字 0</span></span><br><span class="line"><span class="built_in">print</span>(a+b)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">12.5</span>+<span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span>+<span class="number">3.14</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">124</span><br><span class="line">34.5</span><br><span class="line">4.140000000000001</span><br></pre></td></tr></table></figure><h3 id="强制类型转换">强制类型转换</h3><p>python中的每个数据类型都有对应的方法，可以对数据类型进行转换</p><ul><li><code>str()</code>可以把所有的其它数据类型转换为字符串类型</li><li><code>int()</code>字符串转数字类型时，如果字符串中是纯数字，可以转换，其它容器类型不能转为数字int类型</li><li><code>float()</code>浮点类型的转换和int类型一样，不过转换的结果是浮点类型</li><li><code>bool()</code> 可以把其它类型转换布尔类型的True或False<ul><li>以下情况转bool的结果是 False:<code>'',0,0.0,False,[],&#123;&#125;,(),set()</code></li></ul></li><li><code>list()</code>列表<ul><li>数字类型是 非容器类型，不能转换为列表</li><li>字符串 转换为列表时 会把字符串中的每一个字符当做列表的元素</li><li>集合 可以转换为 list列表类型</li><li>元组 可以转换为 list列表类型</li><li>字典 可以转换为 list列表类型,只保留了字典中的键</li></ul></li><li><code>tuple()</code>元组<ul><li>数字类型 非容器类型，不能转换为元组</li><li>其它容器类型的数据进行转换时，和列表一样</li></ul></li><li><code>set()</code>集合<ul><li>数字类型 非容器类型，不能转换为 集合</li><li>字符串,列表，元组 可以转为 集合 结果是无序的</li><li>字典转换为集合时，只保留了字典的键 key</li></ul></li><li><code>dict()</code>字典<ul><li>数字类型 非容器类型，不能转换为 字典</li><li>字符串不能直接转换为 字典</li><li>列表可以转换为字典，要求是一个二级列表，并且每个二级元素只能有两个值</li><li>元组可以转换为字典，要求是一个二级元组，并且每个二级元素只能有两个值</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Python的系列课程是写给零基础的小白看的，如果基础比较好的小伙伴可以暂时先不关注，等待后续课程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Hi， 大家好，我是茶桁。&lt;/p&gt;
&lt;p&gt;之前的课程已经给大家讲解了Python相关特性和基本语法。那么这节课呢，我们尝试着从最简单的脚本来开始认识Python。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>新专辑《AI秘籍》，你所感兴趣的一切</title>
    <link href="https://hivan.me/AI-cheats-information/"/>
    <id>https://hivan.me/AI-cheats-information/</id>
    <published>2023-07-29T11:22:20.000Z</published>
    <updated>2023-07-30T09:11:26.312Z</updated>
    
    <content type="html"><![CDATA[<p>Hi，大家好。我时茶桁。</p><p>最近，我花了几天时间仔细思考了一下即将要开始写的专栏《AI秘籍》，再根据自己的能力大概规划了一下。目前大致已经理出了一些相关信息可以分享给大家。</p><span id="more"></span><h2 id="专栏形式">专栏形式</h2><p>本次专栏应该会以文章的形式先和大家见面，后续还会根据能力以原本的文章为准录制视频版本。</p><h2 id="专栏平台">专栏平台</h2><p>就如前一篇文章公布的内容一致，会优先发表在我的公众号上，当然目前我还在努力寻找其他的专栏平台。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727142457.png?imgNote"alt="欢迎订阅：坍缩的奇点ss" /><figcaption aria-hidden="true">欢迎订阅：坍缩的奇点ss</figcaption></figure><p>我的预想是尽量能够让大家一篇一篇的购买，不需要必须购买全部专辑，这样朋友们可以根据自己具体需求来进行购买。</p><p>而目前我的百家号收费专栏也在申请之中，不知道会不会顺利申请下来。有新的平台入驻之后，我会进行通知的。</p><h2 id="专栏内容">专栏内容</h2><p>在规划专栏的时候，大部分时间基本都放在了规划内容上。包括目录的编排，内容取舍等等。</p><p>目前规划中的专栏打算从基础开始，到Python开发，再到一些应用基础，比如AI数学，AI英语等。而由于这些内容都会是针对AI学习的，所以并不会是那种很全面的学习资料。</p><p>比如说Python，我们不会讲的很系统，重点会放在数据结构以及数据分析和开发方面。数学等基础当然也会是一致的。</p><p>当基础篇学完之后，接下来就是重点了，会根据三个不同的AI方向来进行讲解，分别包括：BI、NLP以及CV。</p><h3 id="基本目录如下">基本目录如下：</h3><h4 id="第一篇-python基础ai方向">第一篇： Python基础（AI方向）</h4><h4 id="第二篇核心基础能力">第二篇：核心基础能力</h4><h4 id="第三篇核心知识增强">第三篇：核心知识增强</h4><h4 id="第四篇bi-基础">第四篇：BI 基础</h4><h4 id="第五篇cv-基础">第五篇：CV 基础</h4><h4 id="第六篇nlp-基础">第六篇：NLP 基础</h4><h4 id="第七篇bi-进阶">第七篇：BI 进阶</h4><h4 id="第八篇cv-进阶">第八篇：CV 进阶</h4><h4 id="第九篇nlp-进阶">第九篇：NLP 进阶</h4><h4 id="拓展篇1-数学">拓展篇1: 数学</h4><h4 id="拓展篇2-英语">拓展篇2: 英语</h4><p>详细目录如下（<strong>进阶部分目录未完全展开</strong>）： <imgsrc="https://qiniu.hivan.me/picGo/20230729210903.png?imgNote"alt="AI秘籍目录" /></p><h2 id="一些说明和后续">一些说明和后续</h2><p>本专栏暂时价格上还未进行调研，反正第一篇Python部分应该会是全免费发放。毕竟Python课程网上太多了，而且同质化严重，收费感觉没太大必要。所以，咱们写的时候再慢慢想。小伙伴们也可以留言来说说大家期望是一个什么价格，我根据大家留言再结合自己的实际情况最后定价。</p><p>另外，除了Python部分之外，数学和英语部分也是免费的。说实话，我数学和英语并不是很好，这两部分我仅仅给大家一个总结和方向，反正也是独立内容，均可以去网上找相关替代的。</p><p>专栏在完成之后，会更新一些关于算法和数据库的内容，然后会考虑整篇投放到其他平台去进行完整售卖。</p><h2 id="结尾">结尾</h2><p>好了，结束语也无需说太多。让我们一起期待吧，希望在我的课程完成的那一天，各位小伙伴们能完全入门并掌握人工智能。</p><blockquote><p>本次课程的所有代码都会上传到Github上，地址：</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi，大家好。我时茶桁。&lt;/p&gt;
&lt;p&gt;最近，我花了几天时间仔细思考了一下即将要开始写的专栏《AI秘籍》，再根据自己的能力大概规划了一下。目前大致已经理出了一些相关信息可以分享给大家。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>1. Python的特性和语法</title>
    <link href="https://hivan.me/Python-features-and-syntax/"/>
    <id>https://hivan.me/Python-features-and-syntax/</id>
    <published>2023-07-29T09:07:28.000Z</published>
    <updated>2023-07-30T09:27:02.746Z</updated>
    
    <content type="html"><![CDATA[<p>千里之行始于足下。</p><p>大家好，我是茶桁，这里是我们《AI秘籍》的第一节，让我们先从Python来开始好好的打好基础。</p><p>第一堂课，我们先从最基础的Python特性开始，当然，还有一些基本语法。</p><span id="more"></span><p>上来就开始讲特性和语法，说明我们将会遗弃惯用的“环境搭建”等更基础的内容，那些内容网上已经很丰富了，一查一大堆，并且相对来说内容都比较独立，所以希望还不太会搭建开发环境的同学可以自己去搜索看看。或者，其实从我这篇<ahref="../Apple_M1_AI_environment_construction/">《AppleM1的AI环境搭建》</a>也能完全搭建起一个完整的Python开发环境。（Windows和Linux的同学就只能在网上搜索一下看看了。）</p><p>总体来说，Python语言的使用率越来越高，它不仅可以用于GUI开发、Web开发，还能进行数据预处理、数据探索性分析（EDA），更是进行数据挖掘、机器学习、深度学习等任务的首选语言。</p><p>基于Python的包也越来越丰富，各种优秀的库层出不穷。根据"Tiobe编程语言排行榜"的最新统计，Python结束了自己攀爬的势头，已经开始长期占据榜首。Python的发展势头让人们看到了它在各个领域都有着广阔的应用前景。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727185716.png?imgNote"alt="image-20230727185715840" /><figcaption aria-hidden="true">image-20230727185715840</figcaption></figure><p>得益于Python语言的简洁语法和高效开发能力，使得集成系统变得非常方便。</p><p>与此同时，Python相关的就业机会也非常丰富，待遇也相当优渥。</p><p>因此，无论从易用性、就业机会还是薪酬待遇来看，Python都是IT从业者必备的编程语言之一。</p><h2 id="课程说明">课程说明</h2><ol type="1"><li>本课程所使用语言为Python3</li><li>本课程将会有一些案例，用于辅助学习和理解知识点。</li><li>基本所有案例均使用Jupyter Notebook做演示</li><li>一些项目会用到软件工程和设计模式的思想。</li><li>本课程无任何文学色彩，重点在于简单通俗易懂。</li></ol><p><strong>接下来，让我们真实开始吧。</strong></p><h2 id="python的两大特性">Python的两大特性</h2><p>一句话总结，就是Python是一门动态的、强类型语言。</p><h3 id="动态语言">动态语言</h3><p>在了解“动态语言”之前，我们先来了解一下“类型检查”。</p><p>类型检查是验证变量或表达式的数据类型是否符合语言规定的类型约束的过程。它用于确保程序在运行时不会出现类型错误，例如将一个字符串与一个整数相加或将一个数字与一个布尔值进行比较。类型检查旨在捕捉潜在的类型不匹配错误，并在编译时或运行时提供相应的警告或错误信息。</p><p>如果类型检查发生在程序运行阶段（运行时），则称为"动态类型语言"（dynamicallytyped languages）。常见的动态语言包括：</p><ul><li>Python</li><li>JavaScript</li><li>Ruby</li><li>PHP</li><li>Lua</li><li>Perl</li><li>Shell脚本</li></ul><p>有动态语言，则必然会有其相对的“静态语言”，常见的“静态类语言”包含：</p><ul><li>C</li><li>C++</li><li>Java</li><li>C#</li><li>Swift</li><li>Kotlin</li><li>Rust</li><li>TypeScript</li></ul><p>当然，这些都只是一部分常见的动态语言和静态类型语言，还有许多其他编程语言也属于这两个类别。在实际开发中，选择使用动态语言还是静态类型语言取决于项目的需求、开发团队的喜好和项目的规模等因素。每种类型的语言都有其独特的特点和适用场景，因此选择合适的语言是非常重要的。</p><h3 id="强类型语言">强类型语言</h3><p>强类型语言（Strongly TypedLanguage）要求在编程过程中严格定义和遵守数据类型规则。在强类型语言中，变量必须明确地声明其数据类型，并且在运行时不能隐式地改变数据类型。这意味着变量在使用之前必须进行类型转换，以确保数据的一致性和安全性。</p><p>在强类型语言中，编译器或解释器会对数据类型进行严格的检查，如果发现不符合类型规则的操作，就会报错并拒绝执行。这样可以防止一些潜在的类型错误，确保程序的稳定性和正确性。</p><p>强类型语言的主要特点包括：</p><ol type="1"><li>静态类型检查：在编译时或解释时进行类型检查，检查数据类型是否匹配，避免类型不匹配的错误。</li><li>显式类型转换：在进行类型转换时，必须显式地指定转换的方式，例如强制类型转换。</li><li>不支持隐式类型转换：强类型语言不允许在不明确声明的情况下将一个数据类型隐式地转换为另一个数据类型。</li></ol><p>这么说可能并不直接，我们来拿个示例，我们输入两行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">a = a + <span class="string">&#x27;s&#x27;</span></span><br></pre></td></tr></table></figure><p>然后我们会看到程序抛出TypeError异常：</p><figure><img src="https://qiniu.hivan.me/picGo/20230727202716.png?imgNote"alt="image-20230727202715960" /><figcaption aria-hidden="true">image-20230727202715960</figcaption></figure><p>这个异常意思是不支持<code>int变量</code>和<code>str变量</code>相加。</p><p>常见的强类型语言包括：</p><ul><li>Java</li><li>C++</li><li>C#</li><li>Python</li><li>Swift</li><li>Kotlin</li><li>TypeScript</li><li>Rust</li><li>Pascal</li><li>Ada</li><li>Delphi</li></ul><p>一样的，对应的就是弱类型语言。弱类型语言容易与其他类型混合计算，其代表是JavaScript。（有一说一，我还挺喜欢JS的这个特性的）</p><figure><img src="https://qiniu.hivan.me/picGo/20230727203234.png?imgNote"alt="image-20230727203234464" /><figcaption aria-hidden="true">image-20230727203234464</figcaption></figure><p>弱类型语言包括：</p><ul><li>JavaScript</li><li>PHP</li><li>Perl</li><li>Ruby</li><li>Tcl</li><li>Bash</li><li>AWK</li><li>MATLAB (在一些操作上可以被视为弱类型)</li></ul><blockquote><p>当然，对于这个划分其实并不是所有人都一致的，有些人还是会把Python归结为弱类型语言，而通常意义上，大家会把C++划分到弱类型。这里我们不去争论，仅仅记住动态/静态、弱类型/强类型的区别就行了。</p></blockquote><h2 id="基本语法">基本语法</h2><p>基本语法里，我们介绍一下Python的命名规则、缩进原则、特殊关键字和特殊运算符四个方面。</p><h3 id="命名规则">命名规则</h3><p>Python的变量命名规则包括以下几条：</p><ol type="1"><li>允许包括英文、数字以及下划线（_），不能以数字开头。</li><li>名称区分大小写，例如"myVar"和"myvar"是两个不同的变量。</li><li>以单下划线（_）开头的变量通常用作受保护的变量，表示应该将其视为私有，不建议直接访问。虽然Python没有严格的访问控制，但这是一种约定俗成的做法。</li><li>以双下划线（__）开头和结尾的变量是Python中的特殊标识符，具有特殊的意义，如类的私有成员或专用标识符。</li></ol><p>Python的变量命名习惯一般遵守蛇形命名法（snake case）：</p><ol type="1"><li>一般变量命名使用小写字母，多个单词之间用下划线连接，例如：book_id、book_store_count。</li><li>类名首字母大写，如Python内置模块collections.abc中的Iterable类，我们自定义的Book类等。</li><li>类方法名也使用小写字母，多个单词之间用下划线连接，例如：get_store_count()。</li></ol><p>与Java的命名方法不同，Java通常使用驼峰命名法（camelcase）来命名变量和方法名，其中第一个单词首字母小写，后续单词首字母大写，例如：myVar、getStoreCount()。而Python则更倾向于使用蛇形命名法。这是因为Python社区普遍认可了蛇形命名法，使得代码在风格上更加一致和易读。</p><h3 id="缩进原则">缩进原则</h3><p>Python最具特色的特点之一是使用缩进来表示代码的逻辑层次，而不是像Java和C++中使用{}。Python的缩进层级结构非常重要，它代表着代码的逻辑结构。</p><p>通常情况下，Python的缩进为4个空格字符。例如，在定义一个Book类并重写__add__方法来计算两本书的库存量时，代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义类的参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, b_id, b_name, b_store_count</span>):</span><br><span class="line">        self.b_id = b_id</span><br><span class="line">        self.b_name = b_name</span><br><span class="line">        self.b_store_count = b_store_count</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重写加法操作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, book</span>):</span><br><span class="line">        <span class="keyword">return</span> self.b_store_count + book.b_store_count</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建两个Book类的实例</span></span><br><span class="line">python_intro_book = Book(<span class="number">1</span>, <span class="string">&#x27;金瓶梅&#x27;</span>, <span class="number">100</span>)</span><br><span class="line">ml_intro_book = Book(<span class="number">2</span>, <span class="string">&#x27;玉蒲团&#x27;</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求两本书的总销量</span></span><br><span class="line">sales_cnt = python_intro_book + ml_intro_book</span><br><span class="line"><span class="built_in">print</span>(sales_cnt) </span><br></pre></td></tr></table></figure><p>上述代码定义了一个Book类，包括初始化方法<code>__init__</code>和重写的加法操作<code>__add__</code>。通过这种缩进结构，我们可以清晰地看到代码的层次结构和逻辑。</p><p>在Python编码中，缩进格式、行间空行数、变量和等号之间的空格等都遵循PEP8（PythonEnhancement Proposal8）规范。可以使用<code>autopep8</code>包来自动实现PEP8规范，保持代码的规范和易读性。</p><h3 id="特殊关键字">特殊关键字</h3><p>Python有35个关键字，这些关键字具有特殊的含义，不能用于自定义变量名，否则会引起语法错误。以下是Python的关键字列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span>      <span class="keyword">await</span>      <span class="keyword">else</span>       <span class="keyword">import</span>     <span class="keyword">pass</span></span><br><span class="line"><span class="literal">None</span>       <span class="keyword">break</span>      <span class="keyword">except</span>     <span class="keyword">in</span>         <span class="keyword">raise</span></span><br><span class="line"><span class="literal">True</span>       <span class="keyword">class</span>      <span class="title class_">finally</span>    <span class="keyword">is</span>         <span class="keyword">return</span></span><br><span class="line"><span class="keyword">and</span>        <span class="keyword">continue</span>   <span class="keyword">for</span>        <span class="keyword">lambda</span>     <span class="keyword">try</span></span><br><span class="line"><span class="keyword">as</span>         <span class="keyword">def</span>        <span class="title function_">from</span>       <span class="keyword">nonlocal</span>   <span class="keyword">while</span></span><br><span class="line"><span class="keyword">assert</span>     <span class="keyword">del</span>        <span class="keyword">global</span>     <span class="keyword">not</span>        <span class="keyword">with</span></span><br><span class="line"><span class="keyword">async</span>      <span class="keyword">elif</span>       <span class="keyword">if</span>         <span class="keyword">or</span>         <span class="keyword">yield</span></span><br></pre></td></tr></table></figure><p>这些关键字在Python编程中扮演着重要的角色。其中，<code>True</code>和<code>False</code>用于表示布尔值的真和假，类似于Java中的<code>true</code>和<code>false</code>；<code>None</code>表示空值，类似于Java中的<code>null</code>；Python使用<code>not</code>表示逻辑反操作，而Java使用<code>!</code>；Python使用<code>and</code>表示两个条件同时满足，Java使用<code>&amp;&amp;</code>；Python使用<code>or</code>表示两个条件满足其一，Java使用<code>||</code>；Python使用<code>elif</code>，而Java使用<code>else if</code>。</p><p>还有一些比较特殊的关键字，例如：</p><ul><li><code>del</code>用于删除可迭代对象中的某个元素；</li><li><code>def</code>用于定义函数；</li><li>带有<code>yield</code>的关键字用于定义生成器（generator）函数；</li><li><code>global</code>和<code>nonlocal</code>是在Python函数式编程的闭包场景中使用的。</li></ul><p><code>pass</code>关键字用于占位，当你在定义函数或类时暂时不想添加具体的实现时，可以使用<code>pass</code>关键字。</p><p>这些关键字的具体用法将在后续文章中更详细地介绍。在此，先对它们有一个整体的认识即可。</p><h3 id="特殊运算符">特殊运算符</h3><p>Python的运算符包括：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+       -       *       **      /       //      %      @</span><br><span class="line">&lt;&lt;      &gt;&gt;      &amp;       |       ^       ~       :=</span><br><span class="line">&lt;       &gt;       &lt;=      &gt;=      ==      !=</span><br></pre></td></tr></table></figure><p>大部分运算符在其他编程语言中也是常见的，不过这里重点介绍三个比较特殊的运算符：<code>//</code>、<code>**</code>和<code>:=</code>。</p><p><code>//</code>运算符用于两个数值相除并向下取整，类似于Python的<code>math.floor()</code>功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">5</span> // <span class="number">2</span>)   <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> // <span class="number">4.5</span>) <span class="comment"># 输出: 1.0</span></span><br></pre></td></tr></table></figure><p><code>**</code>运算符用于进行幂运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">2</span> ** <span class="number">3</span>) <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><p><code>:=</code>运算符是在Python3.8版本中引入的，被形象地称为“海象运算符”。它可以在表达式中同时为变量赋值和比较：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n&#125;</span>大于10&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以用“海象运算符”简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n := <span class="built_in">len</span>(a)) &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;n&#125;</span>大于10&quot;</span>)</span><br></pre></td></tr></table></figure><p>Python的比较运算符还支持链式比较，使得编码更加方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> &lt; i &lt; <span class="number">3</span>)  <span class="comment"># 输出: False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> &lt; i &lt;= <span class="number">3</span>) <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure><p>此外，运算符<code>@</code>用于装饰器功能，本专栏会深入解释它的本质，并提供相关案例，帮助你学会使用装饰器。</p><h2 id="总结">总结</h2><p>在本文中，我们一起学习了Python这门功能强大的编程语言。Python的两大特性是动态语言和强类型语言。</p><p>动态语言意味着在运行时执行类型检查，而不是在编译时。这使得Python更加灵活和易于使用，允许我们在代码中动态创建和修改变量。Python的动态特性使其成为进行数据预处理、数据探索性分析、数据挖掘、机器学习和深度学习等任务的首选语言。</p><p>另一方面，强类型语言意味着变量的类型在声明时就已经确定，并且不能进行隐式类型转换。这确保了代码的稳定性和安全性，帮助我们避免一些常见的错误。</p><p>在Python的基本语法方面，我们学习了变量命名规则，缩进原则，特殊关键字和特殊运算符。Python的命名规则允许使用英文、数字和下划线，但不能以数字开头，并且区分大小写。特殊关键字包括Python的35个关键字，如if、else、for、while等等，它们有着特定的含义和用途。特殊运算符中，//用于整数除法，**用于幂运算，:=是在Python3.8版本中引入的“海象运算符”，使得在表达式中同时为变量赋值和比较变得更加方便。</p><p>通过学习Python的特性和基本语法，我们已经具备了编写简单到复杂的程序的基础知识。Python的易用性、丰富的库和社区支持，使其成为一个优秀的编程语言，适用于各种应用场景。无论是初学者还是有经验的开发者，Python都是一个值得深入学习和探索的语言。</p><p>希望本文能够为读者提供了一个对Python的初步认识，并激发了你继续学习和研究的兴趣。在接下来的学习过程中，我们可以更深入地了解Python的各种功能和应用领域，并用Python来解决更复杂的问题。</p><p>好了，我是茶桁，咱们下节见。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;千里之行始于足下。&lt;/p&gt;
&lt;p&gt;大家好，我是茶桁，这里是我们《AI秘籍》的第一节，让我们先从Python来开始好好的打好基础。&lt;/p&gt;
&lt;p&gt;第一堂课，我们先从最基础的Python特性开始，当然，还有一些基本语法。&lt;/p&gt;</summary>
    
    
    
    <category term="AI秘籍" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/"/>
    
    <category term="Python" scheme="https://hivan.me/categories/AI%E7%A7%98%E7%B1%8D/Python/"/>
    
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>《AI秘籍》预告</title>
    <link href="https://hivan.me/AI%20Cheats%20Trailer/"/>
    <id>https://hivan.me/AI%20Cheats%20Trailer/</id>
    <published>2023-07-27T06:13:06.000Z</published>
    <updated>2023-07-27T12:08:04.135Z</updated>
    
    <content type="html"><![CDATA[<p>Hi,大家好，我是茶桁，这里为自己做个广告，目前打算开始写一整个系列《AI秘籍》。</p><span id="more"></span><p>这一段时间内我写过一个系列<ahref="../categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/">《零基础学习大语言模型》</a>（目前还没写完）。</p><p>说实话，这个系列其实原出处并不是我，严谨的说来，有涉嫌擦边“洗稿”的嫌疑，所以最后放弃了收费的想法，仅仅对一些模型，资源以及计算结果进行了补偿性的收费。不过在写这个系列的同时，我开始有了自己的一些想法，打算真正写一个属于自己的系列文章。</p><p>因为我的个人博客并没有付费阅读的功能，所以还在看平台。第一选择自然是我的微信订阅号，有想过发到少数派里，但是并不清楚少数派对我文章的审核会是什么结果，能成为专栏发出来不太有信心。</p><p>说说这个专栏本身，参照我几个自媒体平台的数据来看，Python的基础知识还是更受欢迎一点，我想大概也是更多基础不太好的小伙伴希望能入行吧。所以这次我准备从基础开始写起，总的来说分成以下几个大的篇章：</p><ul><li>第一卷：Python</li><li>第二卷：核心知识</li><li>第三卷：核心能力培养</li><li>第四卷：NLP</li><li>第五卷：BI</li><li>第六卷：CV</li><li>第七卷：扩展 - 数学</li><li>第八卷：扩展 - 英语</li></ul><p>大致的算了一下，可能这个系列会耗费比较长的时间和精力，也希望小伙伴们能多多支持。</p><p>在这里，放上我的公众号订阅方式：</p><figure><img src="https://qiniu.hivan.me/picGo/20230727142457.png?imgNote"alt="欢迎订阅：坍缩的奇点ss" /><figcaption aria-hidden="true">欢迎订阅：坍缩的奇点ss</figcaption></figure><blockquote><p>最后，找到合适的订阅平台之后，本篇内容应该会有更新。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi,
大家好，我是茶桁，这里为自己做个广告，目前打算开始写一整个系列《AI秘籍》。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
    <category term="Python" scheme="https://hivan.me/tags/Python/"/>
    
    <category term="CV" scheme="https://hivan.me/tags/CV/"/>
    
    <category term="NLP" scheme="https://hivan.me/tags/NLP/"/>
    
    <category term="BI" scheme="https://hivan.me/tags/BI/"/>
    
    <category term="LLM" scheme="https://hivan.me/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>人工神经网络</title>
    <link href="https://hivan.me/Artificial-Neural-Network/"/>
    <id>https://hivan.me/Artificial-Neural-Network/</id>
    <published>2023-07-27T03:30:11.000Z</published>
    <updated>2023-07-27T04:01:44.217Z</updated>
    
    <content type="html"><![CDATA[<p>神经元、如何构建网络、高级神经网络</p><p>人工神经网络是人工智能（AI）中重要而有趣的一部分。</p><span id="more"></span><h2 id="什么是神经网络">什么是神经网络？</h2><p>神经网络是对大脑神经过程的复制。</p><ul><li>它是在计算机上构建的大脑模拟。</li></ul><figure><img src="https://qiniu.hivan.me/picGo/20230727113127.jpeg?imgNote"alt="神经网络结构" /><figcaption aria-hidden="true">神经网络结构</figcaption></figure><p>神经网络，无论是生物的还是人工的，都由大量的简单单元和神经元组成，它们相互接收和传输信号。</p><p>它由细胞体和连接神经元的导线组成。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727113152.jpeg?imgNote"alt="神经结构" /><figcaption aria-hidden="true">神经结构</figcaption></figure><p>用生物学语言来说 ：</p><ul><li>为神经元提供输入的电线称为树突。</li><li>在某些情况下，神经元会向另一个神经元发送信号，这些向外发送信号的导线被称为轴突。</li><li>轴突可能与一个或多个树突相连，这种交叉点称为突触。</li></ul><figure><img src="https://qiniu.hivan.me/picGo/20230727113215.jpeg?imgNote"alt="生物神经网络结构" /><figcaption aria-hidden="true">生物神经网络结构</figcaption></figure><p>这个过程会随着我们的成长而不断调整，这种 "调整"被称为记忆或学习。</p><h2 id="什么是深度学习">什么是深度学习？</h2><p>深度学习是一种机器学习技术，由相互连接的多层简单处理单元组成。</p><p>它的灵感来源于大脑处理视觉信息的方式。</p><h2 id="为什么要开发人工神经网络">为什么要开发人工神经网络？</h2><p>开发人工神经网络（ANN）的原因之一是为了帮助神经科学（研究大脑和神经系统）。</p><ul><li>人们相信，通过绘制人脑图谱，我们可以了解意识和智力背后的秘密。</li><li>我们已经能够识别异常功能，并帮助大脑避免异常功能。</li><li>例如--解决老年痴呆症、因受伤造成的损伤和发育障碍。</li></ul><p>开发人工神经网络（ANN）的另一个原因是为了建立更好的人工智能和机器学习技术。</p><ul><li>因为，大脑是一个极其复杂的信息处理系统。</li></ul><h2 id="人工神经网络的特点">人工神经网络的特点 ：</h2><ul><li><p>ANN由许多神经元组成，可以同时处理信息。这意味着，我们可以同时处理大量数据，从而提高了效率。</p></li><li><p>神经元可以同时存储（就像内存一样）和处理信息，因此从存储器中检索数据不会有任何延迟，因而速度很快。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727113344.jpeg?imgNote"alt="神经元 -&gt; 简单处理单元，也可以存储" /><figcaption aria-hidden="true">神经元 -&gt;简单处理单元，也可以存储</figcaption></figure></li></ul><p>是的，ANN 可以快速处理信息，但很难应用于"传统计算机"（单机处理），因为它一次只能完成一项任务。这就是 GPU的用武之地。</p><h2 id="听说过-gpu-吗">听说过 GPU 吗？</h2><p>GPU 是图形处理单元（Graphical ProcessingUnit）的缩写，它可以进行并行处理，而不是像传统计算机那样进行单一处理。因此，神经网络可以快速完成工作或处理信息。</p><h2 id="构建神经网络">构建神经网络 ：</h2><p>权重在神经网络中扮演着重要角色，它通过控制每个输入，让网络从这些数据中学习，从而做出准确的预测。</p><h2 id="但是什么是权重">但是，什么是权重？</h2><p>权重就像可调节的旋钮，决定着每个输入对最终输出的影响程度。</p><p>例如，为了找到适当的平衡（数据），我们要给输入值加上适当的权重。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727113429.jpeg?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>因此，通过将每个输入值（神经元）与权重相乘并相加，我们就能实现"线性组合"。</p><h2 id="线性组合公式">线性组合公式 ：</h2><p>考虑到我们有 4 个输入，因此我们也需要 4个权重来平衡它，而且还会有一个额外的固定值，称为截距（偏差）。</p><ul><li>截距值是一个偏置值，用作基准值，这样即使输入值为零，网络也能做出预测。</li></ul><p>计算公式：</p><p>线性组合 = [截距 + Weight 1 × Input 1 + Weight 2 × Input 2 + Weight 3× Input 3 + Weight 4 × Input 4］</p><figure><img src="https://qiniu.hivan.me/picGo/20230727113525.jpeg?imgNote"alt="线性组合" /><figcaption aria-hidden="true">线性组合</figcaption></figure><p><strong>问：请考虑以下表达式</strong></p><p>10.0 + 5.4 × 8 + (-10.2) × 5 + (-0.1) × 22 + 101.4 × (-5) + 0.0 × 2 +12.0 × (-3) = -543.0</p><p><strong>(i) 表达式中的截距（偏差）项是什么？</strong></p><p>"10.0 "是截距（偏差）数，因为它没有乘以任何变量。</p><p><strong>(ii) 这里的输入是什么？</strong></p><p>"8,5,22,-5,2,-3 "是输入值，因为它是乘法中的第二个数字。</p><p>实现线性组合后，再将其传递给 "激活函数"。</p><h2 id="激活功能">激活功能：</h2><p>激活函数就像一个开关，它决定信号是否应该通过，使神经网络能够有效地学习和解决不同的问题。</p><ul><li>为图像识别、自然语言处理等进行预测。</li></ul><figure><imgsrc="https://miro.medium.com/v2/resize:fit:700/1*VENgyOk30RPJ_BsN2tl84Q.jpeg"alt="将线性组合应用于激活函数" /><figcaption aria-hidden="true">将线性组合应用于激活函数</figcaption></figure><h2 id="激活函数示例">激活函数示例 ：</h2><p>激活函数的一些示例如下</p><ul><li>识别函数：什么也不做，只输出线性组合（与线性回归相同，不提供任何新信息，因此很少使用）</li></ul><figure><img src="https://qiniu.hivan.me/picGo/20230727114528.jpeg?imgNote"alt="确定功能" /><figcaption aria-hidden="true">确定功能</figcaption></figure><ul><li>步进功能：如果线性组合值大于 0，则通过信号，否则什么也不做</li></ul><figure><img src="https://qiniu.hivan.me/picGo/20230727114550.jpeg?imgNote"alt="步进功能" /><figcaption aria-hidden="true">步进功能</figcaption></figure><ul><li>Sigmoid 函数：阶跃函数的 "软 "版本</li></ul><figure><img src="https://qiniu.hivan.me/picGo/20230727114613.jpeg?imgNote"alt="Sigmoid 函数" /><figcaption aria-hidden="true">Sigmoid 函数</figcaption></figure><p>通过线性组合激活函数实现的神经元输出用于预测或决策。</p><h2id="感知器--人工神经网络ann之母">"感知器--人工神经网络（ANN）之母"：</h2><p>Perceptron 是一种使用阶跃激活函数的简单神经元模型。</p><ul><li>它被用作二元分类任务中的简单分类器。</li><li>由于它是第一个正式的神经网络模型，因此被称为 "ANN 之母"。</li></ul><h2id="现在让我们回到神经网络的构建上来">"现在，让我们回到神经网络的构建上来。</h2><p>网络架构由层级组成，例如 ：</p><ul><li>输入层：由作为输入数据的神经元组成。例如，用于图像识别的图像像素值。</li><li>隐藏层：接收输入层的输出，并将自己的输出传递给下一层。</li><li>输出层：产生网络的最终结果。例如，用于人脸识别的人的概率值。</li></ul><figure><img src="https://qiniu.hivan.me/picGo/20230727114708.jpeg?imgNote"alt="网络架构" /><figcaption aria-hidden="true">网络架构</figcaption></figure><p>为了在这些层中进行线性组合，我们应该能够找到合适的权重。</p><h2 id="反向传播---找到合适的权重">反向传播 - 找到合适的权重 ：</h2><figure><img src="https://qiniu.hivan.me/picGo/20230727114735.jpeg?imgNote"alt="反向传播" /><figcaption aria-hidden="true">反向传播</figcaption></figure><ul><li>在过去（20 世纪 80年代之前），人们曾使用过感知器算法，但寻找权重需要花费大量时间。</li><li>因此，人们引入了反向传播算法。它通过层层递进和递退来确定合适的权重，从而做出准确的预测。</li></ul><p>现在，让我们举个例子，来识别图像。</p><h2id="建立分类器对图像显示的是-x-还是-o-进行分类">建立分类器，对图像显示的是"X "还是 "O "进行分类</h2><figure><img src="https://qiniu.hivan.me/picGo/20230727114821.jpeg?imgNote"alt="X &amp; O 图像" /><figcaption aria-hidden="true">X &amp; O 图像</figcaption></figure><p>这里是一个 5 × 5 的网格，因此每幅图像由 25 个像素组成。阴影像素为1，其他空白像素为 0。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727114834.jpeg?imgNote"alt="X" /><figcaption aria-hidden="true">X</figcaption></figure><figure><img src="https://qiniu.hivan.me/picGo/20230727114843.jpeg?imgNote"alt="O" /><figcaption aria-hidden="true">O</figcaption></figure><p>现在，我们应该应用权重，其中在中心位置，权重假设为-1，而在近中心像素位置，权重假设为1：</p><figure><img src="https://qiniu.hivan.me/picGo/20230727114910.jpeg?imgNote"alt="权重" /><figcaption aria-hidden="true">权重</figcaption></figure><p>因此，在这里，如果线性组合为负数，即激活度为零，则为"X"；如果为正数，则为 "O"。</p><p><strong>对第一幅图像进行线性组合 ：</strong></p><figure><img src="https://qiniu.hivan.me/picGo/20230727114943.jpeg?imgNote"alt="负线性组合/零激活" /><figcaption aria-hidden="true">负线性组合/零激活</figcaption></figure><p><strong>(忽略 0 值权重，得到） -&gt; 1 × -1 = -1</strong></p><p>因此，我们得到 "X”</p><p><strong>对第二幅图像进行线性组合：</strong></p><figure><img src="https://qiniu.hivan.me/picGo/20230727115027.jpeg?imgNote"alt="正线性组合/正激活" /><figcaption aria-hidden="true">正线性组合/正激活</figcaption></figure><p><strong>(忽略 0 值权重，我们得到） -&gt; 1 × 1 + 1 × 1 + 1 × 1 + 1 ×1 = 4</strong> 因此我们得到 "O"</p><p>到目前为止，我们已经了解了 -&gt;多层网络（超过一层的神经网络）、非线性函数（阶跃激活函数和 Sigmoid激活函数）、学习规则（如反向传播）。</p><p>让我们进入高级神经网络。</p><h2 id="卷积神经网络">卷积神经网络 ：</h2><p>使用感知器或线性回归可以进行图像处理，但由于需要大量权值，而且无法有效检测图像特征，因此效果和效率都不高。</p><p>因此，为了解决这些局限性，人们引入了卷积神经网络。</p><ul><li>CNN或卷积神经网络由卷积层组成，可以自动学习和提取图像特征，如颜色、图案、边缘等。</li><li>例如，CNN 可用于动物检测、标志检测等。</li></ul><p>如果我们想使用传统方法检测图像或识别图像，它将使用图像中的像素位置来检测物体。因此，我们必须有一张相似的图像才能做到这一点，但对于卷积神经网络来说，这并非必要。</p><p>例如，我们有一张位于图像中心的停车标志的训练图像，然后我们会得到一张测试图像，该图像的右上角有一个停车标志。由于训练图像和测试图像的像素值和位置不同，因此无法使用感知器进行检测。不过，通过使用卷积神经网络，它可以成功检测出图像中任何位置的停车标志。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727115124.jpeg?imgNote"alt="停车标志" /><figcaption aria-hidden="true">停车标志</figcaption></figure><h2 id="生成式人工智能generative-ai">生成式人工智能（GenerativeAI）：</h2><p>生成式人工智能是人工智能的一种，可以生成文本、图像、音频和合成数据等各种类型的内容。</p><p>它可以是.....：</p><ul><li>监督学习法</li><li>无监督学习法</li><li>半监督学习法</li></ul><p><strong>判别模型用于通过标注数据的训练进行分类或预测。</strong></p><p><strong>生成模型用于生成新数据，如预测序列中的下一个单词。</strong></p><figure><img src="https://qiniu.hivan.me/picGo/20230727115157.jpeg?imgNote"alt="DM（直接法）和 GM（生成法）" /><figcaption aria-hidden="true">DM（直接法）和 GM（生成法）</figcaption></figure><h2 id="生成对抗网络gan">生成对抗网络（GAN）：</h2><p>其原理是让两个神经网络相互竞争。</p><ul><li>一个网络将生成与训练数据类似的图像。</li><li>另一个网络将对生成的图像和训练图像进行分类。</li></ul><p>这样做是为了生成逼真的图像。</p><figure><img src="https://qiniu.hivan.me/picGo/20230727115234.jpeg?imgNote"alt="伪造名人图像" /><figcaption aria-hidden="true">伪造名人图像</figcaption></figure><p><strong>上述图像由英伟达公司开发的 GAN 生成。</strong></p><p>将人工智能应用于现实问题比解决谜题和游戏更具挑战性。在现实世界的场景中，可能出现的状态数量之多令人目不暇接，使得穷举式搜索或巧妙的启发式方法无法奏效。此外，由于我们无法控制的因素，行动的结果并不总是可以预测的，这就引入了随机性。为了解决这些复杂问题，我们需要将不确定性和概率的概念纳入算法，同时利用先进的神经网络，使我们能够有效地解决现实世界中的人工智能问题。</p><p>康康康康恐龙康。最后，你已经掌握了基本的神经网络和高级神经网络的基本知识。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;神经元、如何构建网络、高级神经网络&lt;/p&gt;
&lt;p&gt;人工神经网络是人工智能（AI）中重要而有趣的一部分。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
    <category term="Neural Network" scheme="https://hivan.me/tags/Neural-Network/"/>
    
  </entry>
  
  <entry>
    <title>20. 尝试让机器拥有声音</title>
    <link href="https://hivan.me/%E5%B0%9D%E8%AF%95%E8%AE%A9%E6%9C%BA%E5%99%A8%E6%8B%A5%E6%9C%89%E5%A3%B0%E9%9F%B3/"/>
    <id>https://hivan.me/%E5%B0%9D%E8%AF%95%E8%AE%A9%E6%9C%BA%E5%99%A8%E6%8B%A5%E6%9C%89%E5%A3%B0%E9%9F%B3/</id>
    <published>2023-07-26T08:31:43.000Z</published>
    <updated>2023-07-31T10:20:03.972Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是Hivan。</p><p>好久不见了，今天我们来讨论下如何让机器拥有声音。</p><span id="more"></span><p>回顾一下我们<ahref="../%E5%BF%AB%E9%80%9F%E5%80%BE%E5%90%AC%E5%92%8C%E6%80%BB%E7%BB%93%E9%9F%B3%E9%A2%91%E5%86%85%E5%AE%B9/">上一讲</a>的内容，我们已经成功使用Whisper模型使得AI能够理解我们说的话。这为我们带来了很多应用，例如让AI代替我们收听播客并总结内容。然而，这只是单向的交流模式。现在，让我们探索更深入的可能性，让AI不仅仅能够“听懂”我们的话，而且通过ChatGPT回答我们的问题，并将所有内容合成语音，用声音与我们进行双向交互。</p><p>这就是我们本次探索的主题：让AI说话。我们将学习如何使用云端API进行语音合成（Text-To-Speech），同时也会介绍开源模型，使您能够在本地CPU上实现这一功能，让数据安全问题不再是困扰。</p><p>让我们一起，给机器赋予声音吧！</p><h2 id="使用-azure-云进行语音合成">使用 Azure 云进行语音合成</h2><p>语音合成技术早已迈入成熟阶段，你所听到的许多短视频配音都借助此技术实现。无论是<ahref="https://www.xfyun.cn/services/online_tts">科大讯飞</a>、<ahref="https://ai.aliyun.com/nls/tts">阿里云</a>、<ahref="https://ai.baidu.com/tech/speech/tts">百度</a>、<ahref="https://aws.amazon.com/cn/polly/">AWS Polly</a>还是<ahref="https://cloud.google.com/text-to-speech?hl=zh-cn">GoogleCloud</a>，国内外的大公司纷纷提供了类似的云服务。然而，今天我们将带您领略微软Azure云的语音合成API，主要是因为以下两个原因：</p><blockquote><p>由于本文在其他平台已经成为收费文章，为了避免损害付费会员权益，所以此处做删减处理。</p><p>希望继续观看的，请订阅我的公众号。</p><p><imgsrc="https://qiniu.hivan.me/picGo/20230727142457.png?imgNote" /></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是Hivan。&lt;/p&gt;
&lt;p&gt;好久不见了，今天我们来讨论下如何让机器拥有声音。&lt;/p&gt;</summary>
    
    
    
    <category term="从零开始接触人工智能大模型" scheme="https://hivan.me/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>将 Bard API 与 ChatGPT 集成：实时数据访问</title>
    <link href="https://hivan.me/BardAPI-ChatGPT/"/>
    <id>https://hivan.me/BardAPI-ChatGPT/</id>
    <published>2023-07-21T04:47:54.000Z</published>
    <updated>2023-07-21T04:48:39.691Z</updated>
    
    <content type="html"><![CDATA[<p>在人工智能领域，很少有创新能像 OpenAI 的 ChatGPT一样激发世界的想象力。这种非凡的对话式人工智能改变了我们看待人机交互的方式，展现出一定程度的复杂性、情境意识和创造力，而这些曾经被认为是人类智能的专属领域。</p><span id="more"></span><figure><imgsrc="https://miro.medium.com/v2/resize:fit:700/1*sBgoRLJEfkoRRl3BYrBV2g.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>ChatGPT 基于强大的 GPT-3模型构建，能够进行引人入胜、有意义且令人印象深刻的类人对话。它可以写诗、回答复杂的问题、辅导各种科目、翻译语言，甚至模仿著名作家的写作风格。从本质上讲，它重新定义了我们认为人工智能可能实现的界限。</p><p>然而，ChatGPT 的主要缺点是它缺乏实时互联网数据访问。这意味着，虽然ChatGPT可以生成高度智能且上下文准确的响应，但其知识基本上被及时冻结，截止日期为2021 年 9 月。</p><p>那么，当出现需要通过将 Google 的 Bard API 与 ChatGPT集成来获取超出此限制的信息的问题时，会发生什么情况呢？</p><p><strong>以下是使用Python</strong>将 Bard API 连接到 ChatGPT以检索实时数据的分步指南：</p><h2 id="第-1-步安装非官方-bard-python-库并检索-cookie-值api-密钥">第 1步：安装非官方 Bard Python 库并检索 Cookie 值（API 密钥）</h2><p>我正在使用<a href="https://github.com/dsdanielpark/Bard-API">DanielPark</a>使用逆向工程开发的非官方 Bard库。这个库是一个非常用户友好的Python包。其主要目的是通过 API 从 GoogleBard 获取响应。使用 Bard-API，用户可以方便地将 Bard的自然语言响应集成到他们的 Python 项目和各种应用程序中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install bardapi</span><br></pre></td></tr></table></figure><p>您还可以直接从 Github安装<ahref="https://github.com/dsdanielpark/Bard-API">最新版本：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/dsdanielpark/Bard-API.git</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bardapi <span class="keyword">import</span> Bard</span><br><span class="line"></span><br><span class="line">token = <span class="string">&#x27;xxxxxxx&#x27;</span></span><br><span class="line">bard = Bard(token=token)</span><br><span class="line">bard.get_answer(&lt;your query&gt;)[<span class="string">&#x27;content&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>设置您的 API 密钥</strong></p><p>安装 Bard-API 后，使用 Bard cookie 中的 Secure-1PSID进行身份验证。尽管非正式地称为 API KEY（Cookie值），但请记住对其保密以确保安全访问。</p><ol type="1"><li><p>访问https://bard.google.com/</p></li><li><p>按 F12 或右键单击并“检查”</p><figure><img src="https://qiniu.hivan.me/picGo/20230721124228.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure></li><li><p>转到应用程序 → Cookie，并将您的 __Secure-1PSID Cookie值复制到安全位置。</p></li></ol><h2 id="步骤-2从openai.com获取-openai-密钥并安装-openai-库"><ahref="http://openai.com/">步骤 2：从openai.com</a>获取 OpenAI 密钥并安装OpenAI 库</h2><figure><img src="https://qiniu.hivan.me/picGo/20230721124257.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>访问 OpenAI 网站并获取您的 OpenAI API 密钥。现在安装 OpenAI库并导入它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openai</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key = &lt;Your_API_Key&gt;</span><br></pre></td></tr></table></figure><h2id="步骤3将bard请求结果连接到gpt-3.5-turbo模型并设计提示">步骤3：将bard请求结果连接到gpt-3.5-turbo模型并设计提示</h2><p>这里的关键部分是设计将 Bard 结果集成到 ChatGPT API函数中所需的提示。因此，我为此制定了一个方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">query = <span class="built_in">input</span>(<span class="string">&quot;Your query&quot;</span>)</span><br><span class="line">bard_result = bard.get_answer(query)[<span class="string">&#x27;content&#x27;</span>]</span><br><span class="line">completion = openai.ChatCompletion.create(</span><br><span class="line">        model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">        messages=[</span><br><span class="line">                   &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Act as an AI chatbot with access to the internet.&quot;</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Provide a well structured and easily readable text by analyzing this: The first content below is the user&#x27;s query and the second content below is the result obtained by accessing the internet with the help of google&#x27;s search alogoritm. Provide the well structured and good mannered answer by processing the user&#x27;s query and the result from Google search algorithm. /n&quot;</span>+query+<span class="string">&#x27; /n &#x27;</span>+ bard_result&#125;</span><br><span class="line">       </span><br><span class="line">                 ]</span><br><span class="line">)</span><br><span class="line">final_response = completion[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;message&quot;</span>][<span class="string">&quot;content&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(final_response)</span><br></pre></td></tr></table></figure><p>将所有代码封装在一起，得出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bardapi <span class="keyword">import</span> Bard</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key = &lt;Your Key&gt;</span><br><span class="line">token = &lt;Your Key&gt;</span><br><span class="line">bard = Bard(token=token)</span><br><span class="line">query = <span class="built_in">input</span>(<span class="string">&quot;Your query: &quot;</span>)</span><br><span class="line">bard_result = bard.get_answer(query)[<span class="string">&#x27;content&#x27;</span>]</span><br><span class="line">completion = openai.ChatCompletion.create(</span><br><span class="line">        model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>,</span><br><span class="line">        messages=[</span><br><span class="line">                   &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;system&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Act as an AI chatbot with access to the internet.&quot;</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Provide a well structured and easily readable text by analyzing this: The first content below is the user&#x27;s query and the second content below is the result obtained by accessing the internet with the help of google&#x27;s search alogoritm. Provide the well structured and good mannered answer by processing the user&#x27;s query and the result from Google search algorithm. /n&quot;</span>+query+<span class="string">&#x27; /n &#x27;</span>+ bard_result&#125;</span><br><span class="line">       </span><br><span class="line">                 ]</span><br><span class="line">)</span><br><span class="line">final_response = completion[<span class="string">&quot;choices&quot;</span>][<span class="number">0</span>][<span class="string">&quot;message&quot;</span>][<span class="string">&quot;content&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(final_response)</span><br></pre></td></tr></table></figure><figure><img src="https://qiniu.hivan.me/picGo/20230721124414.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>与其使用 gpt-3.5-turbo 型号，不如试试 gpt-3.5-turbo-16k 和gpt-4-0314，效果会更好。</p><p>通过整合像谷歌的 Bard 这样的应用程序接口，ChatGPT可以超越目前的局限，为用户提供实时、准确的上下文信息。这将大大增强其协助、教育和与用户互动的能力，为人与人工智能的互动增添一个全新的维度。此外，这还将极大地扩展ChatGPT 的应用范围，为企业、教育工作者、研究人员和个人带来新的机遇。</p><p>我认为这是将互联网接入集成到 ChatGPT 并从 ChatGPT获得实时见解的最简单方法。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在人工智能领域，很少有创新能像 OpenAI 的 ChatGPT
一样激发世界的想象力。这种非凡的对话式人工智能改变了我们看待人机交互的方式，展现出一定程度的复杂性、情境意识和创造力，而这些曾经被认为是人类智能的专属领域。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>使用 Transformers 进行语音转文本的完整入门指南</title>
    <link href="https://hivan.me/%E4%BD%BF%E7%94%A8Transformers%E8%BF%9B%E8%A1%8C%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E6%9C%AC/"/>
    <id>https://hivan.me/%E4%BD%BF%E7%94%A8Transformers%E8%BF%9B%E8%A1%8C%E8%AF%AD%E9%9F%B3%E8%BD%AC%E6%96%87%E6%9C%AC/</id>
    <published>2023-07-15T07:18:39.000Z</published>
    <updated>2023-07-15T07:26:59.688Z</updated>
    
    <content type="html"><![CDATA[<p>我与音频数据打交道的次数比我意识到的要多得多。</p><span id="more"></span><p>世界上充满了音频数据和亟待解决的相关问题。我们可以使用机器学习来解决其中的许多问题。您可能对用于训练机器学习模型的图像、文本和表格数据以及用于解决这些领域问题的机器学习并不陌生。随着Transformer架构的出现，解决音频相关问题的准确性大大高于之前已知的方法。我们将学习音频ML的基础知识，使用变压器将语音转换为文本，并学习使用Huggingface库通过机器学习解决音频相关问题。</p><ul><li>了解音频机器学习的基础知识并获得相关背景知识。</li><li>了解如何为机器学习收集、存储和处理音频数据。</li><li>了解一项常见且有价值的任务：使用机器学习将语音转换为文本。</li><li>了解如何使用Huggingface工具和库来完成音频任务--从寻找数据集到训练模型，并使用它们利用HuggingfacePython库通过机器学习解决音频问题。</li></ul><p>本文作为<ahref="https://hivan.me/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/">AI系列文章</a>的附加部分，但是并不放入系列之内，以保证其整体性。</p><hr /><p>自 2010 年代初期深度学习革命发生以来，AlexNet在识别物体方面超越了人类的专业知识，Transformer架构可能是自那时以来最大的突破。Transformers使以前无法解决的任务成为可能，并简化了许多问题的解决方案。虽然它最初的目的是为了在自然语言翻译中获得更好的结果，但很快它不仅被应用于自然语言处理中的其他任务，而且还被跨领域应用——ViT或视觉变压器用于解决与图像相关的任务，决策变压器用于决策强化学习代理中的制作，最近一篇名为MagViT 的论文演示了 Transformer 在各种视频相关任务中的使用。</p><p>这一切都始于现在著名的论文《Attention is All YouNeed》，该论文介绍了导致Transformers诞生的注意力机制。本文并不假设您已经了解 Transformers架构的内部工作原理。</p><p>尽管在公共领域和普通开发人员领域，ChatGPT 和 GitHub Copilot是非常著名的名字，但深度学习已经在许多领域的许多实际用例中使用——视觉、强化学习、自然语言处理等。</p><p>近年来，我们了解了许多其他用例，例如药物发现和蛋白质折叠。音频是深度学习尚未完全解决的迷人领域之一；从某种意义上说，Imagenet数据集中的图像分类是通过卷积神经网络解决的。</p><ul><li>我假设您有使用 Python的经验。基本的Python知识是必要的。您应该了解库及其常见用法。</li><li>我还假设您了解机器学习和深度学习的基础知识。</li><li>不需要具备Transformers 知识，但会有所帮助。</li></ul><p><strong>关于音频数据的注意事项：该平台不支持插入音频，因此我创建了一个包含所有代码和音频数据的Colab 笔记本。你可以在这里找到它。在GoogleColaboratory中启动它，您可以从笔记本上播放浏览器中的所有音频。</strong></p><p>您可能已经见过音频 ML 的实际应用。说“Hi, Siri”或“Okay,Google”就会启动各自平台的助手——这就是与音频相关的机器学习的实际应用。这种特殊的应用被称为“关键字检测”。</p><p>但在这个领域中，使用 Transformer很有可能解决许多问题。但是，在开始使用 Transformer之前，让我快速告诉您在 Transformer 之前如何解决与音频相关的任务。</p><p>在《Transformers》出现之前，音频数据通常被转换为梅尔谱图——描述手头音频剪辑的图像，并将其视为一幅图像并输入卷积神经网络进行训练。在推理过程中，音频样本首先被转换为梅尔谱图表示，CNN架构将基于此进行推理。</p><p>现在我将快速向您介绍“librosa”Python包。这是一个处理音频数据非常有用的包。我将生成一个梅尔光谱图，让您了解它们的外观。您可以在网上找到<ahref="https://librosa.org/doc/latest/index.html">librosa 文档。</a></p><p>首先，通过从终端运行以下命令来安装 librosa 库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install librosa</span><br></pre></td></tr></table></figure><p>然后，在您的笔记本中，您必须像这样简单地导入它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> librosa</span><br></pre></td></tr></table></figure><p>我们将使用与库捆绑在一起的一些数据来探索该库的一些基本功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array, sampling_rate = librosa.load(librosa.ex(<span class="string">&quot;trumpet&quot;</span>))</span><br></pre></td></tr></table></figure><p>我们可以看到<strong>librosa.load()</strong>方法返回一个音频数组以及喇叭声音的采样率。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> librosa.display</span><br><span class="line"></span><br><span class="line">plt.figure().set_figwidth(<span class="number">12</span>)</span><br><span class="line">librosa.display.waveshow(array, sr=sampling_rate)</span><br></pre></td></tr></table></figure><p>这会将音频数据值绘制成如下图：</p><figure><img src="https://qiniu.hivan.me/picGo/20230715150518.webp?imgNote"alt="”" /><figcaption aria-hidden="true">”</figcaption></figure><p>在 X 轴上，我们看到时间，在 Y轴上，我们看到剪辑的幅度。通过以下方式收听：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Audio <span class="keyword">as</span> aud</span><br><span class="line"></span><br><span class="line">aud(array, rate=<span class="number">16_000</span>)</span><br></pre></td></tr></table></figure><p>您可以在我为此博文创建的<ahref="https://colab.research.google.com/drive/1iU57okU8Ti0_p1XoinHaExygJE-QDsxv?usp=sharing">Colab笔记本</a>中聆听声音。</p><p>使用 librosa 直接绘制梅尔谱图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">S = librosa.feature.melspectrogram(y=array, sr=sampling_rate,</span><br><span class="line"></span><br><span class="line">  n_mels=<span class="number">128</span>, fmax=<span class="number">8_000</span>)</span><br><span class="line"></span><br><span class="line">S_dB = librosa.power_to_db(S, ref=np.<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">plt.figure().set_figwidth(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">librosa.display.specshow(S_dB, x_axis=<span class="string">&quot;time&quot;</span>,</span><br><span class="line"></span><br><span class="line">     y_axis=<span class="string">&quot;mel&quot;</span>, sr=sampling_rate,</span><br><span class="line"></span><br><span class="line">     fmax=<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></table></figure><figure><img src="https://qiniu.hivan.me/picGo/20230715150548.webp?imgNote"alt="”" /><figcaption aria-hidden="true">”</figcaption></figure><p>我们使用梅尔谱图而不是其他表示形式，因为它比其他表示形式包含更多的信息——一条曲线中的频率和幅度。您可以访问有关Analytics Vidhya 的这篇精彩文章，了解有关频谱图的更多信息。</p><p>这正是 Transformer 之前的音频 ML中的大量输入数据的样子，用于训练卷积神经网络。</p><p>正如《Attention is All YouNeed》论文中介绍的那样，注意力机制成功地解决了与语言相关的任务，因为从高层次来看，注意力头在预测下一个序列时决定序列的哪一部分比其他部分更值得关注令牌。</p><p>现在，音频是序列数据的一个非常合适的例子。音频自然是由自然界或我们的语音器官（例如人类语音或动物声音）的振动产生的连续信号。但计算机既不能处理也不能存储连续数据。所有数据都是离散存储的。</p><p>音频的情况也是如此。仅存储特定时间间隔的值；这些功能足以听歌、看电影以及通过电话或互联网与我们自己交流。</p><p>变压器也处理这些数据。</p><p>就像NLP（自然语言处理）一样，我们可以根据不同的需求使用不同架构的Transformer。我们将使用编码器-解码器架构来完成我们的任务。</p><figure><img src="https://qiniu.hivan.me/picGo/20230715150555.webp?imgNote"alt="”" /><figcaption aria-hidden="true">”</figcaption></figure><p>如前所述，我们将在每个流程步骤中使用 Huggingface 库。您可以导航到Huggingface 数据集中心来查看音频数据集。我们将在这里计算的数据集是 MINDS数据集。它是来自不同语言的说话者的语音数据的数据集。数据集中的所有示例都带有完整注释。</p><p>让我们加载数据集并对其进行一些探索。</p><p>首先，安装 Huggingface 数据集库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install datasets</span><br></pre></td></tr></table></figure><p>pip install确保我们下载的<strong>数据集</strong>库增加了对音频相关功能的支持。</p><p>然后我们探索 MINDS 数据集。我强烈建议您浏览数据集的<ahref="https://huggingface.co/datasets/PolyAI/minds14">Huggingface页面</a>并阅读数据集卡。</p><figure><img src="https://qiniu.hivan.me/picGo/20230715151652.png?imgNote"alt="image-20230715151652853" /><figcaption aria-hidden="true">image-20230715151652853</figcaption></figure><p>在 Huggingface数据集页面上，您可以看到数据集具有非常相关的信息，例如任务、可用语言和使用数据集的许可证。</p><p>现在我们将加载数据并了解更多信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset, Audio</span><br><span class="line"></span><br><span class="line">minds = load_dataset(<span class="string">&quot;PolyAI/minds14&quot;</span>, name=<span class="string">&quot;en-AU&quot;</span>,</span><br><span class="line">                     split=<span class="string">&quot;train&quot;</span>)</span><br><span class="line"></span><br><span class="line">minds = minds.cast_column(<span class="string">&quot;audio&quot;</span>, Audio(sampling_rate=<span class="number">16_000</span>))</span><br></pre></td></tr></table></figure><p>请注意数据集的加载方式。名字在前，我们只对澳大利亚口音英语感兴趣，我们只对训练分组感兴趣。</p><p>在输入训练或推理任务之前，我们希望所有音频数据具有相同的采样率。这是通过代码中的“Audio”方法完成的。</p><p>我们可以研究个别例子，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">example = minds[<span class="number">0</span>]</span><br><span class="line">example</span><br></pre></td></tr></table></figure><p><em>{‘path’:‘/root/.cache/huggingface/datasets/downloads/extracted/a19fbc5032eacf25eab0097832db7b7f022b42104fbad6bd5765527704a428b9/en-AU~PAY_BILL/response_4.wav’,‘audio’:{‘path’:‘/root/.cache/huggingface/datasets/downloads/extracted/a19fbc5032eacf25eab0097832db7b7f022b42104fbad6bd5765527704a428b9/en-AU~PAY_BILL/response_4.wav’,‘array’:array([2.36119668e-05, 1.92324660e-04, 2.19284790e-04, …,9.40907281e-04,1.16613181e-03, 7.20883254e-04]),‘sampling_rate’:16000},‘transcription’: ‘I would like to pay my electricity bill usingmy card can you please assist’,‘english_transcription’: ‘I would like topay my electricity bill using my card can you pleaseassist’,‘intent_class’: 13,</em></p><p>‘lang_id’: 2}</p><p>这很容易理解。它是一个带有级别的 Python字典。我们已经存储了路径和采样率。查看字典中的<strong>转录键。</strong>当我们对自动语音识别感兴趣时，它包含标签。<code>[“audio”][“aray”]</code>包含我们将用于训练或推断的音频数据。</p><p>我们可以轻松收听任何我们想要的音频示例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> Audio <span class="keyword">as</span> aud</span><br><span class="line"></span><br><span class="line">aud(example[<span class="string">&quot;audio&quot;</span>][<span class="string">&quot;array&quot;</span>], rate=<span class="number">16_000</span>)</span><br></pre></td></tr></table></figure><p><ahref="https://colab.research.google.com/drive/1iU57okU8Ti0_p1XoinHaExygJE-QDsxv?usp=sharing">您可以在ColabNotebook</a>中收听音频。</p><p>现在，我们清楚地了解数据的外观及其结构。我们现在可以继续从自动语音识别的预训练模型中进行推断。</p><p>Huggingface hub有许多模型，可用于各种任务，如文本生成、摘要、情感分析、图像分类等。我们可以根据我们想要的任务对中心中的模型进行排序。我们的用例是语音到文本，我们将探索专门为此任务设计的模型。</p><p>为此，您应该导航到https://huggingface.co/models，然后在左侧边栏上单击您想要的任务。在这里，您可以找到可以立即使用的模型，或者找到一个很好的候选模型来微调您的特定任务。</p><figure><img src="https://qiniu.hivan.me/picGo/20230715151434.png?imgNote"alt="image-20230715151434564" /><figcaption aria-hidden="true">image-20230715151434564</figcaption></figure><p>在上图中，我已经选择了自动语音识别作为任务，并且我得到了右侧列出的所有相关模型。</p><p>注意不同的预训练模型。像 wav2vec2这样的一种架构可以有许多针对特定数据集进行微调的模型。</p><p>您需要进行一些搜索并记住可用于使用该模型或微调的资源。</p><p>我认为Facebook 的<ahref="https://huggingface.co/facebook/wav2vec2-base-960h">wav2vec2-base-960h</a>将适合我们的任务。我再次鼓励您访问模型页面并阅读模型卡。</p><p>Huggingface 有一个非常友好的 API，可以帮助完成各种与 Transformer相关的任务。</p><p>之前，我们找到了任务所需的模型，现在我们将其与上一节中看到的 Pipeline方法一起使用。</p><p>首先，安装 Huggingface 变压器库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install transformers</span><br></pre></td></tr></table></figure><p>然后，导入 Pipeline 类并选择任务和模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> pipeline</span><br><span class="line"></span><br><span class="line">asr = pipeline(<span class="string">&quot;automatic-speech-recognition&quot;</span>,</span><br><span class="line"></span><br><span class="line">   model=<span class="string">&quot;facebook/wav2vec2-base-960h&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(asr(example[<span class="string">&quot;audio&quot;</span>][<span class="string">&quot;example&quot;</span>])) <span class="comment"># example is one example from the dataset</span></span><br></pre></td></tr></table></figure><p>输出是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;text&#x27;: &#x27;I WOULD LIKE TO PAY MY ELECTRICITY BILL USING MY CAD CAN YOU PLEASE ASSIST&#x27;&#125;</span><br></pre></td></tr></table></figure><p>您可以看到这与我们上面看到的注释非常匹配。</p><p>这样，您就可以从任何其他示例中得到推论。</p><p>在本指南中，我介绍了音频数据处理和探索的基础知识以及音频机器学习的基础知识。在简要讨论用于音频机器学习的Transformer 架构之后，我向您展示了如何在 Huggingface中心使用音频数据集以及如何通过 Huggingface 模型中心使用预训练模型。</p><p>您可以使用此工作流程解决许多与音频相关的问题，并通过利用变压器架构来解决这些问题。</p><ul><li>音频机器学习涉及通过机器学习技术解决音频领域现实世界中出现的与音频相关的问题。</li><li>由于音频数据存储为数字序列，因此可以将其视为与序列相关的问题，并使用我们已有的用于解决其他序列相关问题的工具来解决。</li><li>由于 Transformer 成功解决了与序列相关的问题，我们可以使用Transformer 架构来解决音频问题。</li><li>由于语音数据和音频数据通常由于年龄、口音、说话习惯等因素而存在很大差异，因此针对特定数据集使用微调的解决方案总是更好。</li><li>Huggingface拥有许多与音频相关的解决方案，涉及数据集、训练模型以及使用和调整训练和微调的简单方法。</li><li>Huggingface Audio ML 课程，了解有关音频机器学习的更多信息</li><li>Allen Downey 的《Think DSP》深入研究数字信号处理</li></ul><p><strong>Q1. 什么是音频机器学习？</strong></p><p>答：音频机器学习是使用机器学习技术解决与音频数据相关的问题的领域。示例包括：通过关键字检测打开和关闭智能家居中的灯，通过语音转文本向语音助手询问当天的天气等。</p><p><strong>Q2。如何收集机器学习的音频数据？</strong></p><p>答：机器学习通常需要大量数据。要收集音频机器学习的数据，必须首先决定要解决什么问题。并收集相关资料。例如，如果您正在创建一个名为“Jarvis”的语音助手，并希望用“Goodday,Jarvis”这句话来激活它，那么您需要收集来自不同地区、不同年龄、属于不同国家的人说出的这句话。多种性别- 并使用适当的标签存储数据。在每个音频任务中，标记数据非常重要。</p><p><strong>Q3。什么是机器学习中的音频分类？</strong></p><p>答：音频分类是一项机器学习任务，旨在将音频样本分类为一定数量的预定类别。例如，如果在银行部署音频模型，则可以使用音频分类根据客户的意图对来电进行分类，以将呼叫转发到适当的部门（贷款、储蓄账户、支票和汇票、共同基金）， ETC。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;我与音频数据打交道的次数比我意识到的要多得多。&lt;/p&gt;</summary>
    
    
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>LLMs的实用介绍</title>
    <link href="https://hivan.me/LLMs%E7%9A%84%E5%AE%9E%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://hivan.me/LLMs%E7%9A%84%E5%AE%9E%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2023-07-14T06:30:00.000Z</published>
    <updated>2023-07-14T07:47:01.300Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在实践中使用llms的3个级别">在实践中使用LLMs的3个级别</h3><p>这是关于在实践中使用大型语言模型（LLMs）系列文章的第一篇。在这里，我将介绍LLMs并提出三个使用它们的级别。未来的文章将探讨LLMs的实际方面，例如如何使用OpenAI的公共API、HuggingFace Transformers Python库、如何微调LLMs以及如何从头构建LLMs</p><span id="more"></span><figure><img src="https://qiniu.hivan.me/picGo/20230714153129.jpeg?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="什么是llm"><strong>什么是LLM？</strong></h2><p><strong>LLM</strong> 是 <strong>Large Language Model</strong>的缩写，是人工智能和机器学习中的最新创新。这种强大的新型人工智能在2022年12月随着ChatGPT 的发布而迅速传播开来。</p><p>对于那些生活在人工智能热潮和技术新闻周期之外的人来说，<strong>ChatGPT</strong>是运行在名为 GPT-3 的 LLM 上的聊天界面（现在在撰写本文时已升级到 GPT-3.5或 GPT-4）。</p><p>如果你使用过 ChatGPT，显然这不是来自 [AOL InstantMessenger]（https://en.wikipedia.org/wiki/AIM_(software))或你的信用卡客服的传统聊天机器人。</p><p>这个聊天机器人感觉不同。</p><h2 id="什么使得llm大">什么使得LLM“大”？</h2><p>当我听到“大型语言模型”这个术语时，我的第一个问题是，这与“常规”语言模型有何不同？</p><p>语言模型比大型语言模型更通用。就像所有正方形都是矩形，但并非所有矩形都是正方形一样。所有LLM都是语言模型，但不是所有语言模型都是LLM。</p><figure><img src="https://qiniu.hivan.me/picGo/20230714153550.png?imgNote"alt="大型语言模型是一种特殊类型的语言模型" /><figcaptionaria-hidden="true">大型语言模型是一种特殊类型的语言模型</figcaption></figure><p>所以LLM是一种特殊的语言模型，<strong>但是什么使它们与众不同呢?</strong></p><p>有<strong>2个关键属性</strong>区分LLMs与其他语言模型。一个是数量上的，另一个则是质量上的。</p><ol type="1"><li><strong>数量上</strong>，LLM的区别在于模型中使用的参数数量。目前的LLM大约有<strong>10-1000亿个参数</strong>[1]。</li><li><strong>质量上</strong>，当语言模型变得“大”时，会发生一些非凡的事情。它会展示出所谓的***emergentproperties***例如零-shot学习[1]。这些是当语言模型达到足够大的规模时，似乎突然出现的特性。</li></ol><h2 id="零样本学习"><strong>零样本学习</strong></h2><p>GPT-3（以及其他LLM）的主要创新在于它能够在各种情境下进行<strong>零样本学习</strong>[2]。这意味着ChatGPT可以<strong>执行一个任务，即使它没有被明确训练过</strong>。</p><p>尽管这对我们这些高度进化的人类来说可能不是什么大不了的事情，但是这种零样本学习能力与之前的机器学习范例形成了鲜明对比。</p><p>以前，为了获得良好的性能，模型需要明确地在它所要完成的任务上进行<strong>明确的训练</strong>。这可能需要1k-1M个预标记的训练示例。</p><p>例如，如果你想让计算机进行语言翻译、情感分析和识别语法错误。每个任务都需要一个专门的模型，它需要在大量标记示例的基础上进行训练。然而，现在，<strong>LLM可以在没有明确训练的情况下完成所有这些任务</strong>。</p><h2 id="llm如何工作"><strong>LLM如何工作？</strong></h2><p>训练大多数最先进的LLM所使用的核心任务是<strong>单词预测</strong>。换句话说，给定一序列单词，<strong>下一个单词的概率分布是什么</strong>？</p><p>例如，给定序列<code>Listen to your ____</code>，最有可能的下一个单词可能是：heart，gut，body，parents，grandma等。这可能看起来像下面显示的概率分布。</p><figure><img src="https://qiniu.hivan.me/picGo/20230714154319.png?imgNote"alt="Toy 序列中下一个作品的概率分布 Listen to your ____" /><figcaption aria-hidden="true">Toy 序列中下一个作品的概率分布<code>Listen to your ____</code></figcaption></figure><p>有趣的是，这是许多（非大型）语言模型过去被训练的方式（例如GPT-1）[3]。然而，由于某种原因，当语言模型超过一定大小（例如~10B个参数）时，这些（新生的）能力，例如零-shot学习，开始出现[1]。</p><p>尽管目前还没有明确的答案，解释为什么会发生这种情况（只有推测），但明显LLM是一种强大的技术，具有无数的潜在用例。</p><h2 id="使用llm的3个层次"><strong>使用LLM的3个层次</strong></h2><p>现在我们来看看如何在实践中使用这种强大的技术。虽然有无数的LLM用例，但在这里，我将它们按所需的技术知识和计算资源排序为3个层次。我们从最容易使用的开始。</p><h3 id="一级提示工程"><strong>一级：提示工程</strong></h3><p>使用LLM的第一级别是“提示工程”，我将其定义为“任何使用LLM的开箱即用方式”，即不更改任何模型参数。虽然许多技术倾向的个人似乎对提示工程的想法不屑一顾，但这是实际中使用LLM（在技术和经济上）最可访问的方法。</p><p>有两种主要的提示工程方式： <strong>简单方式</strong> 和<strong>较不简单方式</strong>。</p><p><strong>简单方式：ChatGPT（或其他方便的LLM UI）</strong> -这种方法的关键好处是方便。像ChatGPT这样的工具提供了一种直观，免费且无代码的使用LLM的方法（没有比这更容易的方法了）。</p><p>然而，方便通常是有代价的。在这种情况下，这种方法有两个主要缺点。第一个是缺乏功能。例如，ChatGPT不容易使用户自定义模型输入参数（例如温度或最大响应长度），这些值调节LLM输出。第二，与ChatGPTUI的交互不能轻松地自动化，因此无法应用于大规模使用情况。</p><p>虽然这些缺点可能是某些用例的杀手级应用，但如果我们将提示工程向前推进一步，这两个缺点都可以得到改善。</p><p><strong>较不简单方式：直接与LLM交互</strong> -我们可以通过编程接口直接与LLM进行交互来克服ChatGPT的一些缺点。这可以通过公共API（例如OpenAI的API）或在本地运行LLM（使用像Transformers这样的库）来实现。</p><p>虽然这种提示工程方式不太方便（因为它需要编程知识和潜在的API成本），但它提供了一种可定制，灵活和可扩展的使用LLM的方法。本系列文章将讨论付费和免费的方法来进行此类提示工程。</p><p>尽管提示工程（如此定义）可以处理大多数潜在的LLM应用程序，但依赖通用模型可能会导致特定用例的次优性能。对于这些情况，我们可以进入使用LLM的下一个级别。</p><h3 id="等级-2模型微调"><strong>等级 2：模型微调</strong></h3><p>使用 LLM 的第二个等级是<strong>模型微调</strong>，我定义为对现有 LLM进行微调以用于特定用例，通过<strong>改变至少一个（内部）模型参数</strong>，即权重和偏差。在此类别中，我还将在此处将迁移学习即使用现有LLM 的某些部分来开发另一个模型。</p><p>微调通常包括两个步骤。<strong>步骤 1</strong>：获得预先训练的LLM。<strong>步骤2</strong>：基于给定的特定任务更新模型参数（通常是数千个）高质量标记的示例。</p><p>模型参数是定义 LLM对输入文本的内部表示的。因此，通过针对特定任务调整这些参数，内部表示变得针对微调任务进行了优化（或者至少是这样的想法）。</p><p>这是一种强大的模型开发方法，因为相对<strong>较少的示例</strong>和计算资源<strong>可以产生出色的模型性能</strong>。</p><p>然而，缺点是它需要比提示工程更多的技术专业知识和计算资源。在未来的一篇文章中，我将尝试通过审查微调技术并共享示例Python 代码来缓解这种缺点。</p><p>虽然提示工程和模型微调可能可以处理 LLM 应用程序的99％，但有时必须走得更远。</p><h3 id="等级-3构建自己的-llm"><strong>等级 3：构建自己的LLM</strong></h3><p>在实践中使用 LLM的第三种最终方法是<strong>构建自己的</strong>。在模型参数方面，这是您从头开始制定所有模型参数的地方。</p><p>LLM主要是其训练数据的产物。因此，对于某些应用程序，可能需要策划自定义的高质量文本语料库进行模型训练，例如医学研究语料库，用于开发临床应用程序。</p><p>这种方法最大的优点是您可以<strong>完全自定义 LLM以适用于您的特定用例</strong>。这是终极的灵活性。但是，通常情况下，灵活性的代价是方便性。</p><p>由于<strong>LLM 性能的关键是规模</strong>，因此从头开始构建 LLM需要巨大的计算资源和技术专业知识。换句话说，这不会是一个个人周末项目，而是一个完整的团队工作数月甚至数年，预算达到7-8F。</p><p>尽管如此，在我未来文章中，我希望探讨从头开始开发 LLM 的流行技术。</p><p><strong>最后让我们来总结一下：</strong></p><p>虽然LLM现在被吹得足够大，但它们是AI领域的一项强大创新。在这里，我提供了有关LLMs是什么以及如何在实践中使用它们的入门指南。日后我希望写一些文章提供初学者指南，帮助大家启动下一个LLM用例。</p><h2 id="资源">资源</h2><p>链接：「<a href="https://hivan.me">个人博客</a>」</p><p>社交：「<a href="https://twitter.com/hivan">推特</a>」|「<ahref="https://weibo.com/hivan">微博</a>」| 「<ahref="https://www.linkedin.com/in/hivandu/">领英</a>」|「<ahref="https://www.youtube.com/hivandu">油管</a>」</p><p>之后我会出一些AI相关的具体视频教程，目前还未找到合适的平台托管，敬请期待。关注我，我会第一时间通知到家。</p><p>在我的公众号内的文章大部分是免费阅读的（除非有实际成本支出），如果您觉得对您有帮助，可以给我赞赏一下以表支持。</p><h2 id="引用">引用</h2><p>[1] 大型语言模型调查。 <ahref="https://arxiv.org/abs/2303.18223">arXiv:2303.18223</a> <strong>[<ahref="http://cs.cl/">cs.CL</a>]</strong></p><p>[2] GPT-3论文。 <ahref="https://arxiv.org/abs/2005.14165">arXiv:2005.14165</a> <strong>[<ahref="http://cs.cl/">cs.CL</a>]</strong></p><p>[3] Radford，A.，&amp;Narasimhan，K。（2018）。通过生成式预训练改善语言理解。 （<ahref="https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">GPT-1论文</a>）</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;在实践中使用llms的3个级别&quot;&gt;在实践中使用LLMs的3个级别&lt;/h3&gt;
&lt;p&gt;这是关于在实践中使用大型语言模型（LLMs）系列文章的第一篇。在这里，我将介绍LLMs并提出三个使用它们的级别。未来的文章将探讨LLMs的实际方面，例如如何使用OpenAI的公共API、Hugging
Face Transformers Python库、如何微调LLMs以及如何从头构建LLMs&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>19. 快速倾听和总结音频内容</title>
    <link href="https://hivan.me/%E5%BF%AB%E9%80%9F%E5%80%BE%E5%90%AC%E5%92%8C%E6%80%BB%E7%BB%93%E9%9F%B3%E9%A2%91%E5%86%85%E5%AE%B9/"/>
    <id>https://hivan.me/%E5%BF%AB%E9%80%9F%E5%80%BE%E5%90%AC%E5%92%8C%E6%80%BB%E7%BB%93%E9%9F%B3%E9%A2%91%E5%86%85%E5%AE%B9/</id>
    <published>2023-07-10T14:52:54.000Z</published>
    <updated>2023-07-31T10:19:54.731Z</updated>
    
    <content type="html"><![CDATA[<p>Hi，大家好，我是茶桁。</p><p>其实到<ahref="../根据垂直需求微调模型">第18章</a>的时候，我们处理文本的内容就全部都结束了，从本节课开始，我们要开始学习如何处理音频和图像。</p><span id="more"></span><p>我不知道有没有人和我一样的习性，就是比起视频和音频文件来说，还是跟喜欢看文本文件。这其中最主要的一个原因就是因为文本内容我们可以准确定位，而对于文本内容的接收速度还取决于我们输入设备（眼睛和处理信息的脑部）速度。而音频或者视频则不然，我们必须听完讲述者所说的话，即便你开到2倍速，速度依然受限，而且无法准确定位。那有没有什么办法能快速完成对音频文件内信息的获取呢，自然就是将语音内容转换成文本的能力。</p><p>其实到这一步，类似于Premiere或者剪映等剪辑软件都可以完成，不仅如此，在AI大行其道的今天，市面上应该也有不少Audio2Text的服务或者应用。接下来，我们要讲的就是一个杀手级服务了。</p><blockquote><p>由于本文在其他平台已经成为收费文章，为了避免损害付费会员权益，所以此处做删减处理。</p><p>希望继续观看的，请订阅我的公众号。</p><p><imgsrc="https://qiniu.hivan.me/picGo/20230727142457.png?imgNote" /></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hi，大家好，我是茶桁。&lt;/p&gt;
&lt;p&gt;其实到&lt;a
href=&quot;../根据垂直需求微调模型&quot;&gt;第18章&lt;/a&gt;的时候，我们处理文本的内容就全部都结束了，从本节课开始，我们要开始学习如何处理音频和图像。&lt;/p&gt;</summary>
    
    
    
    <category term="从零开始接触人工智能大模型" scheme="https://hivan.me/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT代码解释器：如何为我节省数小时的工作</title>
    <link href="https://hivan.me/ChatGPT%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>https://hivan.me/ChatGPT%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A%E5%99%A8/</id>
    <published>2023-07-09T17:22:07.000Z</published>
    <updated>2023-07-09T17:29:36.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>创建一个交互式世界地图，显示国家人口数量，配以简短的句子描述。</strong></p><span id="more"></span><figure><img src="https://qiniu.hivan.me/picGo/20230710011251.jpeg?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>2023年7月6日，OpenAI宣布Code Interpreter将在接下来的一周内向ChatGPTPlus用户开放。它可能是增强ChatGPT的能力和功能的最佳插件之一。</p><p>CodeInterpreter可以运行代码，允许上传数据，这样您就可以用它来进行数据清理、分析、可视化等许多其他任务。它就像是您指尖上的数据分析师。</p><p>听起来很棒吧？接下来我们来看看。</p><p>我在一项任务中使用了它，这项任务可能需要我花费几个小时才能完成。根据您的任务和对Python库的熟悉程度，这项任务甚至可能需要更长时间。</p><p>在使用ChatGPT时，我只需要写几句话并上传两个CSV文件。</p><p>我将逐步介绍整个过程，以及CodeInterpreter在理解数据、清理和预处理数据以及创建数据可视化方面的印象深刻之处。</p><h2 id="您需要先启用它"><strong>您需要先启用它</strong></h2><p>如果您想在聊天中使用代码解释器，需要先通过设置启用它。</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011257.png?imgNote"alt="如何启用代码解释器" /><figcaption aria-hidden="true">如何启用代码解释器</figcaption></figure><p>如何启用代码解释器</p><p>开启之后，你在接下来开启新的聊天的时候就可以使用它了。</p><h2 id="来个具体任务">来个具体任务</h2><p>我打算创建一个世界地图可视化，其中点的大小与国家的人口成比例。</p><p>我有两个数据集，一个是国家人口，另一个是以纬度和经度表示的位置。</p><p>您可以轻松地在网上找到这些数据集。如果没有，文末我将提供数据集（以及源代码）。</p><h2 id="让我们继续吧">让我们继续吧</h2><p>由于这是一个简单的任务，我没有花费太多时间在提示工程上。这是我向ChatGPT请求的第一句话：</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011324.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>你可以在提示窗口左侧使用加号上传数据集。</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011303.png?imgNote"alt="使用+号上传数据集" /><figcaption aria-hidden="true">使用+号上传数据集</figcaption></figure><p>使用+号上传数据集</p><p>首先要做的是读取数据集，这是显而易见的事情。但这还不够令人印象深刻！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code Interpreter 生成的代码</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将CSV数据加载到pandas DataFrame中</span></span><br><span class="line">population_data = pd.read_csv(<span class="string">&#x27;/mnt/data/country_population_historic.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 DataFrame 的前几行</span></span><br><span class="line">population_data.head()</span><br></pre></td></tr></table></figure><p>然后，ChatGPT要求提供国家位置：</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011345.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由于我已经拥有相关数据了，所以我要做的就只是上传它：</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011400.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Code Interpreter 生成的代码</span><br><span class="line"># 加载国家坐标数据</span><br><span class="line">country_coordinates = pd.read_csv(&#x27;/mnt/data/country_coordinates.csv&#x27;)</span><br><span class="line"></span><br><span class="line"># 显示前几行</span><br><span class="line">country_coordinates.head()</span><br></pre></td></tr></table></figure><h2 id="数据清洗和预处理"><strong>数据清洗和预处理</strong></h2><p>读取数据后的下一步是清洗和预处理数据。我相信你已经听过很多次，这一步通常需要最多的时间。</p><p>在创建世界地图可视化之前，有一些问题需要处理。ChatGPT检测到它们并在不到一分钟的时间内提供了解决方案。相当令人印象深刻！</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011419.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上面代码段中的代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由代码解释器生成的代码</span></span><br><span class="line"><span class="comment"># 检查数据框中的国家名称是否一致</span></span><br><span class="line">population_countries = <span class="built_in">set</span>(population_data[<span class="string">&#x27;Country Name&#x27;</span>])</span><br><span class="line">coordinates_countries = <span class="built_in">set</span>(country_coordinates[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人口数据中的国家但不在坐标数据中</span></span><br><span class="line">missing_in_coordinates = population_countries - coordinates_countries</span><br><span class="line"></span><br><span class="line"><span class="comment"># 坐标数据中的国家但人口数据中没有</span></span><br><span class="line">missing_in_population = coordinates_countries - population_countries</span><br></pre></td></tr></table></figure><p>在坐标数据集和人口数据集中都有一些国家缺失。</p><p>ChatGPT在上面的代码片段中做了什么：</p><ul><li>创建了Python集合，包含两个数据集中的国家名称。</li><li>分别比较这些集合，找到它们之间的差异。</li></ul><p>ChatGPT在不到一分钟的时间内解决了这个问题：</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011441.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>以上片段中的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># Code Interpreter 生成的代码</span><br><span class="line"># 将人口数据集中的国家名称映射到坐标数据集中</span><br><span class="line">country_name_mapping = &#123;</span><br><span class="line">    &#x27;Bahamas, The&#x27;: &#x27;Bahamas&#x27;,</span><br><span class="line">    &#x27;Brunei Darussalam&#x27;: &#x27;Brunei&#x27;,</span><br><span class="line">    &#x27;Cabo Verde&#x27;: &#x27;Cape Verde&#x27;,</span><br><span class="line">    &#x27;Congo, Dem. Rep.&#x27;: &#x27;Congo [DRC]&#x27;,</span><br><span class="line">    &#x27;Congo, Rep.&#x27;: &#x27;Congo [Republic]&#x27;,</span><br><span class="line">    &quot;Cote d&#x27;Ivoire&quot;: &quot;Côte d&#x27;Ivoire&quot;,</span><br><span class="line">    &#x27;Czechia&#x27;: &#x27;Czech Republic&#x27;,</span><br><span class="line">    &#x27;Egypt, Arab Rep.&#x27;: &#x27;Egypt&#x27;,</span><br><span class="line">    &#x27;Gambia, The&#x27;: &#x27;Gambia&#x27;,</span><br><span class="line">    &#x27;Hong Kong SAR, China&#x27;: &#x27;Hong Kong&#x27;,</span><br><span class="line">    &#x27;Iran, Islamic Rep.&#x27;: &#x27;Iran&#x27;,</span><br><span class="line">    &quot;Korea, Dem. People&#x27;s Rep.&quot;: &#x27;North Korea&#x27;,</span><br><span class="line">    &#x27;Korea, Rep.&#x27;: &#x27;South Korea&#x27;,</span><br><span class="line">    &#x27;Kyrgyz Republic&#x27;: &#x27;Kyrgyzstan&#x27;,</span><br><span class="line">    &#x27;Lao PDR&#x27;: &#x27;Laos&#x27;,</span><br><span class="line">    &#x27;Macao SAR, China&#x27;: &#x27;Macau&#x27;,</span><br><span class="line">    &#x27;Micronesia, Fed. Sts.&#x27;: &#x27;Micronesia&#x27;,</span><br><span class="line">    &#x27;Myanmar&#x27;: &#x27;Myanmar [Burma]&#x27;,</span><br><span class="line">    &#x27;North Macedonia&#x27;: &#x27;Macedonia [FYROM]&#x27;,</span><br><span class="line">    &#x27;Russian Federation&#x27;: &#x27;Russia&#x27;,</span><br><span class="line">    &#x27;Sao Tome and Principe&#x27;: &#x27;São Tomé and Príncipe&#x27;,</span><br><span class="line">    &#x27;Slovak Republic&#x27;: &#x27;Slovakia&#x27;,</span><br><span class="line">    &#x27;Syrian Arab Republic&#x27;: &#x27;Syria&#x27;,</span><br><span class="line">    &#x27;Turkiye&#x27;: &#x27;Turkey&#x27;,</span><br><span class="line">    &#x27;Venezuela, RB&#x27;: &#x27;Venezuela&#x27;,</span><br><span class="line">    &#x27;Yemen, Rep.&#x27;: &#x27;Yemen&#x27;,</span><br><span class="line">    &#x27;Eswatini&#x27;: &#x27;Swaziland&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 清理人口数据集</span><br><span class="line">population_data_clean = population_data.replace(&#123;&quot;Country Name&quot;: country_name_mapping&#125;)</span><br><span class="line"></span><br><span class="line"># 删除在坐标数据集中不存在的行</span><br><span class="line">population_data_clean = population_data_clean[population_data_clean[&#x27;Country Name&#x27;].isin(coordinates_countries)]</span><br><span class="line"></span><br><span class="line"># 将人口数据与国家坐标数据合并</span><br><span class="line">merged_data = pd.merge(population_data_clean, country_coordinates, left_on=&#x27;Country Name&#x27;, right_on=&#x27;name&#x27;)</span><br><span class="line"></span><br><span class="line"># 只保留必要的列</span><br><span class="line">merged_data = merged_data[[&#x27;Country Name&#x27;, &#x27;2022&#x27;, &#x27;latitude&#x27;, &#x27;longitude&#x27;]]</span><br><span class="line"></span><br><span class="line"># 重命名列以增加清晰度</span><br><span class="line">merged_data.columns = [&#x27;Country&#x27;, &#x27;Population&#x27;, &#x27;Latitude&#x27;, &#x27;Longitude&#x27;]</span><br><span class="line"></span><br><span class="line">merged_data.head()</span><br></pre></td></tr></table></figure><figure><img src="https://qiniu.hivan.me/picGo/20230710011502.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>清理和预处理的数据</p><p>现在我们已经有了整洁和清晰的数据格式。这个步骤通常需要很多时间和人工。ChatGPT在大约一分钟内完成了这一步。</p><h2 id="创建可视化">创建可视化</h2><p>ChatGPT首先尝试使用Matplotlib库进行创建。然而，由于没有世界地图图像而失败：</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011516.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后，我只是要求它使用 Plotly，这就是我一开始想到的。</p><figure><img src="https://qiniu.hivan.me/picGo/20230710011535.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://qiniu.hivan.me/picGo/20230710011549.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>以上代码段中的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 代码由代码解释器生成</span><br><span class="line">import plotly.graph_objects as go</span><br><span class="line"></span><br><span class="line"># 创建散点地理图</span><br><span class="line">fig = go.Figure(data=go.Scattergeo(</span><br><span class="line">    lon = merged_data[&#x27;Longitude&#x27;],</span><br><span class="line">    lat = merged_data[&#x27;Latitude&#x27;],</span><br><span class="line">    text = merged_data[&#x27;Country&#x27;] + &#x27;: &#x27; + merged_data[&#x27;Population&#x27;].astype(str),</span><br><span class="line">    mode = &#x27;markers&#x27;,</span><br><span class="line">    marker = dict(</span><br><span class="line">        size = (merged_data[&#x27;Population&#x27;] / 1000000) ** 0.5,  # Take square root to better visualize differences</span><br><span class="line">        sizemode = &#x27;diameter&#x27;,</span><br><span class="line">        sizeref = 1,</span><br><span class="line">        sizemin = 4,</span><br><span class="line">        color = merged_data[&#x27;Population&#x27;],</span><br><span class="line">        colorscale = &#x27;Viridis&#x27;,</span><br><span class="line">        colorbar_title = &quot;Millions&quot;,</span><br><span class="line">    )</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"># 更新布局</span><br><span class="line">fig.update_layout(</span><br><span class="line">    title_text = &#x27;2022 World Population&#x27;,</span><br><span class="line">    geo = dict(</span><br><span class="line">        showframe = False,</span><br><span class="line">        showcoastlines = True,</span><br><span class="line">        projection_type = &#x27;equirectangular&#x27;</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure><p>它不能在浏览器中显示交互式世界地图，但成功编写了生成它的代码。我所要做的就是将代码复制粘贴到Jupyter笔记本中。</p><p>这是最终结果：</p><figure><imgsrc="https://www.notion.so/image/https%3A%2F%2Fmiro.medium.com%2Fv2%2Fresize%3Afit%3A700%2F1*muaYWUJQNpEt0Tpm_UaHzw.gif?id=20caa395-3ab2-4b2b-8a15-d6c4fe9a1ebf&amp;table=block&amp;spaceId=9a074068-2ca2-46e6-b231-935d54db43cd&amp;userId=4f93353d-181a-4410-94d6-f9f4b3a98955&amp;cache=v2"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>互动世界地图，显示国家人口</p><h2 id="最后的话"><strong>最后的话</strong></h2><p>我们所做的事情：</p><ul><li>读取数据集</li><li>清洗、预处理和合并它们</li><li>创建互动数据可视化</li></ul><p>我们所要做的只是写两个句子（并告诉 ChatGPT 使用Plotly）。我认为这非常令人印象深刻！</p><h2 id="数据">数据</h2><p>本文已经结束。</p><p>文章最后，我将提供数据以及一个jupyternotebook内容，和往常一样，数据将付费查看，以获取一些成本。有想要的朋友可以去我公众号内搜索本文购买：</p><figure><img src="https://qiniu.hivan.me/picGo/20230704000058.png?imgNote"alt="个人公众号：坍缩的奇点" /><figcaption aria-hidden="true">个人公众号：坍缩的奇点</figcaption></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;创建一个交互式世界地图，显示国家人口数量，配以简短的句子描述。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>使用Python库unstructured揭秘文本数据</title>
    <link href="https://hivan.me/%E4%BD%BF%E7%94%A8Python%E5%BA%93unstructured%E6%8F%AD%E7%A7%98%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/"/>
    <id>https://hivan.me/%E4%BD%BF%E7%94%A8Python%E5%BA%93unstructured%E6%8F%AD%E7%A7%98%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE/</id>
    <published>2023-07-06T18:23:02.000Z</published>
    <updated>2023-07-06T18:28:19.055Z</updated>
    
    <content type="html"><![CDATA[<p>在数据的世界里，文本数据是特别复杂的。它不像数字数据那样被分成整齐的行和列。作为一个副业，我正在开发自己的个人人工智能助手。其目的是利用我的笔记和文件中的数据来回答我的问题。重要的好处是，所有的数据处理都将在我的电脑上进行，确保没有文件被上传到云端，而且我的文件将保持隐私。</p><p>为了处理这种非结构化的数据，我发现<code>unstructured</code>的Python库非常有用。它是一个灵活的工具，可以处理各种文档格式，包括Markdown、、XML和HTML文档。</p><span id="more"></span><h2 id="从unstructured的开始">从<code>unstructured</code>的开始</h2><p>你可以通过以下方式轻松安装该库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install unstructured</span><br></pre></td></tr></table></figure><h2 id="装载和分割文件">装载和分割文件</h2><p>你想对你的文件做的第一件事是把它分割成更小的部分或章节。这个过程被称为分区，使其更容易分类和提取文本。</p><p>以下是你如何做的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unstructured.partition.auto <span class="keyword">import</span> partition</span><br><span class="line"></span><br><span class="line">elements = partition(filename=<span class="string">&quot;example-docs/note.md&quot;</span>)</span><br></pre></td></tr></table></figure><p>example-docs/note.md：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## My test title</span></span><br><span class="line"></span><br><span class="line">And here <span class="keyword">is</span> a sample text.</span><br></pre></td></tr></table></figure><p>当我们分割一个文档时，输出是一个文档元素对象的列表。这些元素对象代表了源文档的不同组成部分。<code>unstructured</code>库支持各种元素类型，包括<code>Title</code>,<code>NarrativeText</code>,和<code>ListItem</code>。要访问元素类型，你可以使用<code>category</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;element.category&#125;</span>:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Title</span><br><span class="line">My test title</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NarrativeText</span><br><span class="line">And here is a sample text.</span><br></pre></td></tr></table></figure><p>文档元素的列表可以用<code>convert_to_dict</code>函数转换为字典的列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unstructured.staging.base <span class="keyword">import</span> convert_to_dict</span><br><span class="line"></span><br><span class="line">dict_data = convert_to_dict(elements)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;Title&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;coordinates&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;coordinate_system&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;layout_width&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;layout_height&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;element_id&#x27;</span>: <span class="string">&#x27;a3114599252de55bea36c288aa9aa199&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;metadata&#x27;</span>: &#123;<span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;sample-doc.md&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;filetype&#x27;</span>: <span class="string">&#x27;text/markdown&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;page_number&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;My test title&#x27;</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;NarrativeText&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;coordinates&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;coordinate_system&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;layout_width&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;layout_height&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line">  <span class="string">&#x27;element_id&#x27;</span>: <span class="string">&#x27;6e78562ede477550604528df644630e8&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;metadata&#x27;</span>: &#123;<span class="string">&#x27;filename&#x27;</span>: <span class="string">&#x27;sample-doc.md&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;filetype&#x27;</span>: <span class="string">&#x27;text/markdown&#x27;</span>,</span><br><span class="line">   <span class="string">&#x27;page_number&#x27;</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;text&#x27;</span>: <span class="string">&#x27;And here is a sample text.&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure><p>但由于我想把这些文本块存储在数据库中，并对数据进行一些探索性分析，所以我用<code>convert_to_dataframe</code>函数把文本元素转换成pandas数据框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unstructured.staging.base <span class="keyword">import</span> convert_to_dataframe</span><br><span class="line"></span><br><span class="line">df = convert_to_dataframe(elements)</span><br></pre></td></tr></table></figure><figure><img src="https://qiniu.hivan.me/picGo/20230707021015.png?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="获取元数据">获取元数据</h2><p><code>unstructured</code>库的一个整洁的特点是它如何跟踪它从文档中提取的元素的各种元数据。例如，你可能想知道哪些元素来自哪个页码。你可以像这样提取某个文档元素的元数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doc_metadata = elements[<span class="number">0</span>].metadata.to_dict()</span><br><span class="line"><span class="built_in">print</span>(doc_metadata)</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;filename&#x27;: &#x27;note.md&#x27;, &#x27;filetype&#x27;: &#x27;text/markdown&#x27;, &#x27;page_number&#x27;: 1&#125;</span><br></pre></td></tr></table></figure><p>当源文件中的信息可用时，所有文件类型都会返回以下元数据字段：<code>filename</code>、<code>file_directory</code>、<code>date</code>、<code>filetype</code>和<code>page_number</code>。</p><h2 id="筹备transformers">筹备Transformers</h2><p>当你准备将你的文本送入转化器模型进行进一步处理时，你可以使用<code>stage_for_transformers</code>函数。这个函数通过将你的文本元素分割成适合模型注意力窗口的大块来准备。</p><p>在下面的例子中，我使用了一个叫做<code>SentenceTransformers</code>的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"><span class="keyword">from</span> unstructured.staging.huggingface <span class="keyword">import</span> stage_for_transformers</span><br><span class="line"></span><br><span class="line">model = SentenceTransformer(<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br><span class="line">chunked_elements = stage_for_transformers(elements, model.tokenizer)</span><br></pre></td></tr></table></figure><p>And now I can load all the notes in a specific directory, so I canconvert them to embedding vectors later:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all_elements = []</span><br><span class="line">root_dir = <span class="string">&#x27;/corpus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> directory, subdirectories, files <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        full_path = os.path.join(directory, file)</span><br><span class="line">        all_elements += partition(filename=full_path)</span><br></pre></td></tr></table></figure><h2 id="unstructured-的局限性"><code>unstructured</code> 的局限性</h2><p>这个库也有一些问题和限制。</p><p>当加载和解析docx文件时，它不能正确地将子弹头识别为<code>ListItem</code>，大多数情况下将它们标记为<code>NarrativeText</code>或<code>Title</code>。这使得标题识别也不可靠，因为当你查看输出时，你无法确定每个标题实际上是一个标题还是一个被错误地标记为标题的列表项。(<ahref="https://github.com/Unstructured-IO/unstructured/issues/768">issueon github</a>)当处理大型文档时，没有办法知道每个段落或标题的父类是什么。这可能是一个非常有用的功能，特别是在将数据反馈给LLM的时候。(<ahref="https://github.com/Unstructured-IO/unstructured/issues/889">issueon github</a>)</p><h2 id="替代品">替代品</h2><p>在玩了<code>unstructured</code>之后，我试图看看是否有更好的替代品可以用python来阅读文档。虽然我需要加载各种格式的文件，但我缩小了搜索范围，首先找到阅读docx文件的替代品（因为这是你从GoogleDrive下载一大文件夹的文件时得到的格式）。以下是我找到的东西：</p><h3 id="python-docx">python-docx</h3><ul><li>它看起来很强大，但操作起来很复杂。</li><li>我试着加载和解析了几个docx文件。我遇到的最大问题是加载任何包含超链接的文本。由于某种未知的原因，超链接的文本在最后的输出中被返回为空。这使得它不能用于我的目的，因为链接文本提供了文本中的宝贵信息。</li><li>优点：它能够为标题提供标题级别的信息（如Heading 1、Heading2等）。</li></ul><h3 id="docx2txt">docx2txt</h3><ul><li>它在hood下使用 python-docx。</li><li>只返回加载的文档的一个巨大的全文字符串。这就要求我把我的文档分割成有意义的小块，这可不是一件容易的事。</li><li>优点：它对超链接没有任何问题，而且输出的文本是可读的、有用的。</li><li>优点：它也非常容易使用。</li></ul><h3 id="simplify_docx">simplify_docx</h3><ul><li><p>它在 python-docx 的基础上工作。</p></li><li><p>这个库基本上将python-docx的复杂输出转换为更容易使用的json输出。</p></li><li><p>它对超链接也有同样的问题，当段落中有一个链接时，会返回空文本。</p></li></ul><p>所以我现在会继续使用<code>unstructured</code>。值得一提的是，使用<ahref="https://python.langchain.com/docs/get_started/introduction.html">LangChain</a>或其他类似的工具可以更容易地完成这一点。然而，我建立这个个人AI助手的部分动机是学习之旅。通过使用<code>unstructured</code>加载文档和其他类似工具进行嵌入等，我对底层流程有了更深的了解，而不是使用LangChain这样的一站式解决方案。</p><p>我将在未来的文章中分享更多关于我在构建个人人工智能助手方面取得的进展，敬请关注「坍缩的奇点」，或到外网关注「茶桁- MAMT」。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在数据的世界里，文本数据是特别复杂的。它不像数字数据那样被分成整齐的行和列。作为一个副业，我正在开发自己的个人人工智能助手。其目的是利用我的笔记和文件中的数据来回答我的问题。重要的好处是，所有的数据处理都将在我的电脑上进行，确保没有文件被上传到云端，而且我的文件将保持隐私。&lt;/p&gt;
&lt;p&gt;为了处理这种非结构化的数据，我发现&lt;code&gt;unstructured&lt;/code&gt;的Python库非常有用。它是一个灵活的工具，可以处理各种文档格式，包括Markdown、、XML和HTML文档。&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://hivan.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2023年薪酬最高的科技工作中产品经理赫然在列</title>
    <link href="https://hivan.me/2023%E5%B9%B4%E8%96%AA%E9%85%AC%E6%9C%80%E9%AB%98%E7%9A%84%E7%A7%91%E6%8A%80%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E8%B5%AB%E7%84%B6%E5%9C%A8%E5%88%97/"/>
    <id>https://hivan.me/2023%E5%B9%B4%E8%96%AA%E9%85%AC%E6%9C%80%E9%AB%98%E7%9A%84%E7%A7%91%E6%8A%80%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86%E8%B5%AB%E7%84%B6%E5%9C%A8%E5%88%97/</id>
    <published>2023-07-05T14:43:05.000Z</published>
    <updated>2023-07-05T15:15:48.268Z</updated>
    
    <content type="html"><![CDATA[<p>在最近一段时间内，互联网以及科技公司面临了很大的挑战，工作岗位迅速减少。这让我很大程度上看衰了互联网行业，并且认为目前只是开始，更大的裁员潮还没延伸到中小企业。让我们来看看数据：</p><span id="more"></span><p>就数据（美国的数据）来看，现实非常严峻，2023年迄今为止已有809家科技公司裁员211,400名员工（这个数据一直在变化，<ahref="https://layoffs.fyi/">最新数据可以看这里</a>），但是各组织仍然在快速招聘人才，以填补云技术、区块链和网络安全等新兴领域的滋味。</p><p>看出来了么？并不是互联网和技术行业不香了，而是技术正在进行一轮行业替换，岗位需求发生了大变化。虽然早几年前大家都知道这些岗位是日后的方向，可是这一下子发生了一个断层的变化，导致很大一部分人没有完成转变，科技公司也没进行缓慢的过渡，再加上整个大环境的经济压力，才导致了如今全世界范围内（中国并未逃脱）的大裁员。如果最近一连串的科技裁员让您感到惊慌，请放心，科技作为一个行业仍然健康发展。</p><figure><img src="https://qiniu.hivan.me/picGo/20230705231326.jpg?imgNote"alt="developers.GettyImages-1214543732.jpg?w=" /><figcaptionaria-hidden="true">developers.GettyImages-1214543732.jpg?w=</figcaption></figure><p>而事实上，<ahref="https://pages.shrm.org/wearework?utm_source=all&amp;utm_medium=tv&amp;utm_campaign=brand~wwway~commercial">83%的美国人力资源专业人士</a>表示，在过去 12个月里招聘候选人一直很困难，这导致了未来缺乏必要的技术专业人员的更大问题。</p><p>麦肯锡最近的一份报告发现，43%的<ahref="https://www.mckinsey.com/business-functions/people-and-organizational-performance/our-insights/beyond-hiring-how-companies-are-reskilling-to-address-talent-gaps">组织目前面临技能缺口</a>，而来自KornFerry的单独数据表明，到2030年可能会出现<ahref="https://www.kornferry.com/insights/this-week-in-leadership/talent-crunch-future-of-work">8500万人短缺</a>，导致同年潜在年收入<ahref="https://www.kornferry.com/insights/this-week-in-leadership/talent-crunch-future-of-work">总计损失8.5 万亿美元。</a></p><p>好消息是，对于那些寻找新工作的人来说，机会很多。但是坏消息是，对于35岁以上的求职者，这依然是一个难以跨过去的坎，我们不得不承认一点，对于在国内的求职者们，35岁这个节点比在国外更加明显。（为我自己默哀。）</p><p>好了，说了这么多，还是要有点干货的。接下来咱们根据国外的相关数据，详细介绍五个薪酬最高的技术职位，<ahref="https://www.shrm.org/pages/default.aspx">数据来源于Payscale</a>，可以在<ahref="https://jobs.venturebeat.com/?source=article">VentureBeat</a>上找到数千个职位，就算国内的求职者们碰不到这些职业，我们依然可以从这些岗位的数据来分析一下目前最吃香的相关职位，为自己的转型做个有力的参考（以下内容都是基于美国当前数据所做的分析）。</p><h2 id="云计算解决方案架构师">1. 云计算解决方案架构师</h2><p>预计2023年云计算应用将超过<ahref="https://www.gartner.com/en/newsroom/press-releases/2023-04-19-gartner-forecasts-worldwide-public-cloud-end-user-spending-to-reach-nearly-600-billion-in-2023?_its=JTdCJTIydmlkJTIyJTNBJTIyM2VlOTI1MjQtMjRhMC00OWM3LWI0OWItZGYxZGIwOTdkZjYwJTIyJTJDJTIyc3RhdGUlMjIlM0ElMjJybHR%2BMTY4ODA0NjI5NH5sYW5kfjJfMTY0NjVfc2VvXzlhY2IwMjk3ZDJmODkwNTZhOGEyMTc3ODg3MmZkOGM0JTIyJTJDJTIyc2l0ZUlkJTIyJTNBNDAxMzElN0Q%3D">6000亿美元</a>，并将推动人工智能和Web3等新兴技术。</p><p><strong>平均工资：</strong> 132,700 美元</p><p>如果您有云计算方面的经验，德勤正在招聘一名<ahref="https://jobs.venturebeat.com/job/cloud-solutions-architect-at-deloitte-4?source=article">云解决方案架构师</a>，负责核心业务运营（CBO）组合的工作，以帮助C-suite和项目负责人通过新兴和颠覆性技术改造他们的组织并加速任务执行。</p><p>此外，SAIC 正在聘请一名专门从事系统工程的<ahref="https://jobs.venturebeat.com/job/cloud-solutions-architect-8-at-saic-2?source=article">云解决方案架构师</a>，以协助确定技术解决方案，解决技术差距，如在其国家情报社区（NIC）业务部门、美国政府任务和信息技术部门内的蜂窝和云服务。</p><h2 id="产品经理软件">2. 产品经理（软件）</h2><p>产品经理负责根据数据制定策略，其角色不断发展，因此是任何销售产品或服务的组织不可或缺的一部分。</p><p>由于我本身就是一名数据产品经理，这里我不得不发表一些感慨。不过我们还是得认清一个事实，产品经理的门槛在不断变高，不要认为PRD和原型就可以胜任了，我们从数据中可以看到，数据产品、策略产品以及安全相关的产品经理更容易赢得心仪的工作。</p><p><strong>基于此，我觉得我还是的多写点数据产品经理的相关文章了。</strong></p><p><strong>平均工资：</strong> $102,866</p><p>如果您正在该领域寻找职位，西门子正在寻找一名<ahref="https://jobs.venturebeat.com/job/senior-product-manager-cyber-security-products-at-siemens-2?source=article">高级产品经理</a>来领导网络安全产品的产品策略的开发和执行，与保护和自动化产品/解决方案的产品管理人员密切合作，以确保无缝集成网络安全功能。</p><p>与此同时，苹果公司正在招聘一名<ahref="https://jobs.venturebeat.com/job/new-product-technology-project-manager-4-at-apple-2?source=article">新产品技术项目经理</a>。在此职位中，您将需要建立矩阵管理并监督材料预测、规划、分析和报告、物流准备、预算、采购和配置管理活动。</p><h2 id="网络安全工程师">3. 网络安全工程师</h2><p>由于数据泄露和网络威胁仍然是一个大问题——网络犯罪预计每年增长15%，到<ahref="https://www.prnewswire.com/news-releases/cybercrime-to-cost-the-world-10-5-trillion-annually-by-2025--301172786.html">2025年将达到每年 10.5万亿美元</a>——网络安全领域迫切需要拥有保护企业及其资产的技能和经验的专业人员来自恶意软件攻击。</p><p><strong>平均工资：</strong> $99,887</p><p>国土安全部特别投资于网络安全，因此政府和军事承包商 Booz AllenHamilton 正在美国各地招聘各种网络安全工程师职位，包括<ahref="https://jobs.venturebeat.com/job/cybersecurity-engineer-18-at-booz-allen-hamilton-2?source=article">华盛顿</a>、<ahref="https://jobs.venturebeat.com/job/cybersecurity-engineer-15-at-booz-allen-hamilton-2?source=article">圣安东尼奥</a>和<ahref="https://jobs.venturebeat.com/job/cybersecurity-engineer-junior-7-at-booz-allen-hamilton-2?source=article">埃尔塞贡多</a>。</p><p>在这些职位上，您将需要提供国家和国际层面的网络安全解决方案。</p><h2 id="软件工程师">4. 软件工程师</h2><p>美国劳工统计局预测，从 2021 年到 2031年，软件开发人员、质量保证分析师和测试人员的就业人数预计将增长 25%，新增411,400 个就业岗位。</p><p><strong>平均工资：</strong> $90,777</p><p>对于那些拥有丰富经验的人，诺斯罗普·格鲁曼公司正在招聘一名<ahref="https://jobs.venturebeat.com/job/software-engineerprincipal-software-engineer-27-at-northrop-grumman-2?source=article">软件工程师/首席软件工程师</a>，作为其企业范围数字化转型的一部分。在此职位上，您将支持工程应用和产品的生成，例如实验室电子战(EW) 以及靶场训练和模拟系统。</p><p>经验丰富的 Aces Incorporated 也正在招聘一名<ahref="https://jobs.venturebeat.com/job/software-engineer-16-at-aces-incorporated-1?source=article">软件工程师</a>来应对美国政府最困难的挑战。</p><p>对于金融服务行业的职位，摩根大通银行正在招聘一名<ahref="https://jobs.venturebeat.com/job/full-stack-lead-software-engineer-7-at-jpmorgan-chase-bank-na-2?source=article">全栈首席软件工程师</a>，以安全、稳定和可扩展的方式增强、构建和交付值得信赖的市场领先技术产品。</p><h2 id="区块链工程师">5. 区块链工程师</h2><p>虽然大多数人认为区块链的唯一功能是加密货币，但该技术目前已应用于医疗保健、房地产、抵押贷款处理和游戏等各个领域，并且是一个正在增长的领域。</p><p><strong>平均工资：</strong> 90,000美元</p><p>cyberThink Inc 正在寻找一名<ahref="https://jobs.venturebeat.com/job/blockchain-engineer-at-cyberthink-inc-2?source=article">区块链工程师</a>，带领技术开发人员和云工程师团队建立AWS 区块链集成环境并管理数据接口和链码开发。</p><p>在西海岸，Third Republic 正在与一个开发团队合作，该团队为财富 500强公司提供创新的软件开发解决方案，以聘请<ahref="https://jobs.venturebeat.com/job/blockchain-developer-1-at-third-republic-2?source=article">区块链开发人员</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在最近一段时间内，互联网以及科技公司面临了很大的挑战，工作岗位迅速减少。这让我很大程度上看衰了互联网行业，并且认为目前只是开始，更大的裁员潮还没延伸到中小企业。让我们来看看数据：&lt;/p&gt;</summary>
    
    
    
    
    <category term="产品经理" scheme="https://hivan.me/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>18. 根据垂直需求微调模型</title>
    <link href="https://hivan.me/%E6%A0%B9%E6%8D%AE%E5%9E%82%E7%9B%B4%E9%9C%80%E6%B1%82%E5%BE%AE%E8%B0%83%E6%A8%A1%E5%9E%8B/"/>
    <id>https://hivan.me/%E6%A0%B9%E6%8D%AE%E5%9E%82%E7%9B%B4%E9%9C%80%E6%B1%82%E5%BE%AE%E8%B0%83%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-07-03T15:38:49.000Z</published>
    <updated>2023-07-31T10:19:45.096Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是茶桁。</p><p>最近事情太多，这一节课更新的有些晚了。</p><p>首先我们先了解一下我们本节课讲要讲一些什么，我们之前介绍过llama-index 和LangChain，学习了将大语言模型和自己的知识库组合来解决问题的方法。这个方法中，我们不需要调整我们使用的模型，而是使用嵌入向量索引我们的数据，并在需要时查询索引来解决问题。</p><p>然而，我们也可以完全利用自己的数据，创建一个新的模型来解决问题。这种方法是OpenAI提供的微调模型功能。这也是我们要探讨的大语言模型的最后一个主题。</p><span id="more"></span><h2 id="如何微调模型">如何微调模型</h2><p>我们都知道，AI其实是建立在大语言模型之上的，而模型再如何补全，也没有办法全知全能。在很多时候，AI所回答的内容常常错漏百出，甚至于一些垂直领域可能完全词不达意。这些其实都是因为缺少了特定领域的训练数据，而我们要做的，就是要补全这一部分数据进行训练，为我们自己的需求微调出一个擅长本领域的模型。</p><blockquote><p>由于本文在其他平台已经成为收费文章，为了避免损害付费会员权益，所以此处做删减处理。</p><p>希望继续观看的，请订阅我的公众号。</p><p><imgsrc="https://qiniu.hivan.me/picGo/20230727142457.png?imgNote" /></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;大家好，我是茶桁。&lt;/p&gt;
&lt;p&gt;最近事情太多，这一节课更新的有些晚了。&lt;/p&gt;
&lt;p&gt;首先我们先了解一下我们本节课讲要讲一些什么，我们之前介绍过
llama-index 和
LangChain，学习了将大语言模型和自己的知识库组合来解决问题的方法。这个方法中，我们不需要调整我们使用的模型，而是使用嵌入向量索引我们的数据，并在需要时查询索引来解决问题。&lt;/p&gt;
&lt;p&gt;然而，我们也可以完全利用自己的数据，创建一个新的模型来解决问题。这种方法是OpenAI提供的微调模型功能。这也是我们要探讨的大语言模型的最后一个主题。&lt;/p&gt;</summary>
    
    
    
    <category term="从零开始接触人工智能大模型" scheme="https://hivan.me/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%8E%A5%E8%A7%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="AI" scheme="https://hivan.me/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>观点：我们无法通过改造自己摆脱气候危机</title>
    <link href="https://hivan.me/%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E6%94%B9%E9%80%A0%E8%87%AA%E5%B7%B1%E6%91%86%E8%84%B1%E6%B0%94%E5%80%99%E5%8D%B1%E6%9C%BA/"/>
    <id>https://hivan.me/%E6%88%91%E4%BB%AC%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87%E6%94%B9%E9%80%A0%E8%87%AA%E5%B7%B1%E6%91%86%E8%84%B1%E6%B0%94%E5%80%99%E5%8D%B1%E6%9C%BA/</id>
    <published>2023-06-30T11:48:02.000Z</published>
    <updated>2023-06-30T11:55:57.360Z</updated>
    
    <content type="html"><![CDATA[<p>让我们面对现实吧——气候变化是人类最大的失误。我们已经知道它近一个世纪了。科学是清楚的。然而，我们什么也没做。真是太尴尬了。</p><span id="more"></span><p>现在，全球领导人终于开始忙着收拾残局。但是，尽管我们需要的大多数气候解决方案已经存在，但我们似乎无法按照所需的速度和规模部署它们。</p><p>简而言之，世界正在变暖，而我们却无法让它降温。去年，人类向大气中排放的<spanclass="math inline">\(CO_2\)</span>比以往任何时候都多（呃……WTF？）。</p><figure><img src="https://qiniu.hivan.me/picGo/20230630195036.jpeg?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以理解的是，领导者们都害怕极了。这促使他们探索一些非常愚蠢且完全危险的想法。他们最糟糕的脑波之一是地球工程——也就是用地球的气候扮演上帝的角色。（这里使用的“地球工程”并不是指碳去除技术，据我们所知，碳去除技术是相当合法的。）</p><p>其中一些建议包括增亮云层、改变海洋的化学成分，或者向大气中发射粒子来使太阳的光线变暗——会出现什么问题呢？</p><p>虽然这些提议听起来像是反乌托邦科幻电影中的内容，但改变地球气候实际上非常容易且成本低廉。</p><p>太阳能地球工程是这些“解决方案”中最具争议性的一种。其最受欢迎的衍生产品是平流层气溶胶喷射，涉及将灰尘喷射到大气中，以减少照射到地球表面的阳光量。这项技术的灵感来自于火山云，众所周知，火山云在一次大喷发后可以使整个地球冷却多年。</p><figure><img src="https://qiniu.hivan.me/picGo/20230630195040.jpeg?imgNote"alt="图片来源：Woovii/Getty Image" /><figcaption aria-hidden="true">图片来源：Woovii/Getty Image</figcaption></figure><p>云增加了地球表面的反射率。平流层气溶胶喷射旨在通过将灰尘喷洒到高层大气中来复制这种效果，以期冷却气候。</p><p>虽然平流层气溶胶注入对于阻止全球变暖可能非常有效，但它可能会打开潘多拉魔盒的问题。根据联合国最近的一份报告，干扰全球自然气候可能会破坏臭氧层，改变全球降雨模式，并导致严重的地缘政治紧张局势。</p><p>尽管支持者称太阳能地球工程将是对抗变暖的短期措施，但《科学美国人》最近发表的一项研究表明，如果政客们确实决定向大气中发射尘埃，他们可能会在“几个世纪或更长时间”内危险地依赖它。</p><p>为了向大气中排放足够的灰尘来抑制变暖，每年可能需要数万次高空飞行。这一过程的突然停止可能会导致温度飙升，其速度可能快于生命的适应速度，这一概念被称为“终止休克”。</p><p>还有一个道德问题，即技术修复可以减轻政客和企业尽快脱碳的压力。</p><p>简而言之，太阳能地球工程相当于气候变化创可贴。</p><p>尽管存在风险，美国政府去年还是启动了一项为期五年的研究计划，探索将更多阳光反射回太空的方法，为进一步资助这项新兴技术奠定了基础。</p><p>比尔·盖茨、乔治·索罗斯和 Facebook联合创始人达斯汀·莫斯科维茨等亿万富翁都表达了兴趣，而 60名著名科学家则希望进行小规模太阳能地球工程现场实验。</p><p>甚至还有一家名为 Make Sunsets的初创公司，基于其向大气中释放二氧化硫以遏制变暖的承诺而预售碳信用额。</p><figure><img src="https://qiniu.hivan.me/picGo/20230630195043.jpeg?imgNote"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>美国初创公司 Make Sunsets因未经批准进行平流层气溶胶注入测试而被逐出墨西哥。《麻省理工科技评论》的几位研究人员谴责了“MakeSunsets”，称其努力“为时过早”。</p><p>预防原则——或者对普通人来说“如果有疑问，就不要考虑”——是健全环境决策的基本前提之一，也是我们今后应该注意的原则。</p><p>欧盟本周宣布，呼吁就气候地球工程可能使用带来的风险进行“最高国际级别”会谈，这可能是积极的一步。</p><p>欧盟官员在周三的联合通讯中表示：“这些技术给人类和生态系统带来了新的风险，同时也可能加剧国家之间的权力失衡，引发冲突并引发无数道德、法律、治理和政治问题。”</p><blockquote><p>“我们不能用造成问题的思维方式来解决问题。</p></blockquote><p>尽管欧盟正在采取预防措施，但它并不完全反对这些技术，而是寻求制定管理这些技术的“规则”。</p><p>其他人则采取更强硬的立场。</p><p>乌得勒支大学哥白尼可持续发展研究所的弗兰克·比尔曼在去年发表的一份声明中警告说，“人们对太阳能地球工程的风险知之甚少，而且永远无法完全了解。”</p><p>比尔曼是一群著名气候科学家的领导者，呼吁就太阳能地球工程达成不使用协议。换句话说，全球范围内禁止其开发。</p><p>“太阳能地球工程的研究并不是像其倡导者所说的那样，为预防气候灾难而准备B 计划。相反，它只会推迟和破坏当前的全球气候政策，”他说。</p><p>“此外，现有的国际机构体系无法有效监管这项技术在全球范围内的部署。太阳能地球工程不是解决方案。”</p><p>我完全同意，教授。通过扮演上帝的角色来操纵气候，我们不仅面临着使我们的困境恶化的风险，而且还发出了一个危险的信息——人类可以简单地通过设计方法来解决问题，而不是从根本上解决问题（想想广泛的文化、社会和政治）变换）。</p><p>正如爱因斯坦的一句名言：“我们不能用创造问题的思维方式来解决问题。”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;让我们面对现实吧——气候变化是人类最大的失误。我们已经知道它近一个世纪了。科学是清楚的。然而，我们什么也没做。真是太尴尬了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
